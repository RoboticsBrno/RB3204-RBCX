{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RB3204-RBCX","text":"<p>RBCX is a universal controller for hobby robots. It is a successor of RB3201-RBControl. It is used in our robot Robotka on Robo camp 2020.</p> <p></p>"},{"location":"#features","title":"Features","text":"<ul> <li>4 DC motors with encoders</li> <li>4 servos with feedback (via ADC)</li> <li>4 LEDs</li> <li>buttons with the gamepad interface</li> <li>Smart Servo connector</li> <li>piezo buzzer</li> <li>RTC</li> <li>ultra-sonic distance sensor connector</li> <li>I2C connectors</li> <li>OLED display connector</li> <li>accelerometer and gyroscope</li> <li>micro USB and USB-C connectors</li> <li>battery connector (without charging circuit)</li> </ul>"},{"location":"#hardware","title":"Hardware","text":"<p>Board is based on <code>STM32F103VC</code> microcontroller and <code>ESP32-DevKitC</code>.</p> <p>STM32 is used for motor control and other low-level tasks. ESP32 is used for high-level tasks like communication with mobile app and sending commands to STM32 via UART.</p>"},{"location":"#stm32f103vc","title":"STM32F103VC","text":"<ul> <li>72 MHz, 32bit ARM Cortex-M3</li> <li>48 KiB RAM, 256 KiB Flash</li> <li>5x UART, USB</li> <li>Debug support (with ST-Link)</li> <li>Programmable in C++, with FreeRTOS and stm32cube framework, in Platform.io</li> <li>Our bootloader based on sboot_stm32.</li> </ul>"},{"location":"#esp32-devkitc","title":"ESP32-DevKitC","text":""},{"location":"SW-development/","title":"Software development","text":"<p>Both microcontrollers are programmed using PlatformIO in VSCode using C++ language.</p> <p></p>"},{"location":"SW-development/#stm32","title":"STM32","text":"<p>The software for STM32 is located in <code>fw</code> directory. STM32 uses our bootloader, which is based on sboot_stm32.</p> <p>The Czech manuals are in these presentations: - RBCX - RBCX firmware</p>"},{"location":"SW-development/#bootloader-installation","title":"Bootloader installation","text":"<p>RBCX might work without bootloader, but it is not recommended. Thanls to the bootloader, you can program STM32 without STLink programmer and program ESP32 directly trough USB-C in RBCX.</p> <p></p> <ul> <li>you need STLink programmer</li> <li>connect STLink programmer to the board\u2192<ul> <li>C \u2192 SWCLK</li> <li>-\u2192 GND</li> <li>D \u2192 SWDIO</li> <li>R \u2192 RST</li> <li>+\u2192 3.3V (optional, if you want to power the board from STLink)</li> </ul> </li> <li>!! If STLink is not connected to the computer, STM32 is in a reset state !!</li> <li> <p></p> </li> <li> <p>clone <code>https://github.com/RoboticsBrno/sboot_stm32</code></p> </li> <li><code>apt-get install stlink-tools make gcc-arm-none-eabi git</code></li> <li>flash prebuilt bootloader <code>st-flash --reset --format ihex write prebuilt/rbcx_v11/firmware.hex</code></li> <li>compile and flash firmware <code>make prerequisites &amp;&amp; ./rbcx_build_v11.sh &amp;&amp; make program</code></li> </ul>"},{"location":"SW-development/#firmware-installation","title":"Firmware installation","text":"<p>Firmware for STM32 is located in <code>fw/rbcx-coprocessor</code> directory. RBCX might be programmed using STLink programmer or using USB-C connector.</p>"},{"location":"SW-development/#stlink-development","title":"STLink development","text":"<p>In VSCode - PlatformIO, you have to change the environment to <code>hw*_stlink</code>. This setup supports debugging. Just press <code>F5</code> or <code>Debug</code> button in VSCode.</p>"},{"location":"SW-development/#usb-c-development","title":"USB C development","text":"<p>If you want to use USB-C connector for programming STM32, you need to press <code>DOWN</code> button (B2) on the board during the boot. In default mode, USB-C connector is used for communication with ESP32.</p> <p>To enable Debug output from STM32, you have to press <code>LEFT</code> button (B3) on the board during the boot. This will add virtual debug serial port to the USB-C connector.</p> <p>STM32 will create two virtual COM ports (one for STM32 and one for ESP32). In VSCode - PlatformIO, you have to change the environment to <code>hw*_sboot</code>. This setup does not support debugging (use STLink programmer for debugging).</p>"},{"location":"SW-development/#esp32","title":"ESP32","text":"<p>The library for ESP32 is in RB3204-RBCX-library repository. Examples for the Robotka, which is a robot based on RBCX, are in robotka-examples repository.</p> <p></p>"},{"location":"SW-development/#programming-esp32","title":"Programming ESP32","text":"<p>STM32 behaves like \"FTDI\" on dev kit, so you can program ESP32 using USB-C connector.</p> <ul> <li>Controls boot pins on ESP32 according to RTS/DTR.</li> <li>It supports faster UART than ESP32 DevKit (faster programming)</li> <li>ESP32 DevKit cannot be programmed via its own USB while plugged into RBCX</li> </ul>"},{"location":"SW-development/#esp32-and-stm32-communication","title":"ESP32 and STM32 communication","text":"<p>ESP32 and STM32 communicate via UART (baud 921600)</p> <p>Microcontrollers are communicating using Protocol Buffers (Protobuf). Protobuf messages are defined in RB3204-RBCX-coproc-comm repository.</p>"},{"location":"SW-development/#commands","title":"Commands","text":"<p>\"Run motor at 50%\", \"Battery voltage is 6802mV\", \"Reset the board\"</p> <p>Protocol: Protobuf + COBS + small header</p> <ul> <li><code>0x00, &lt;length&gt;, &lt;data&gt;</code></li> </ul> <p>Keepalive - when ESP32 does not respond, it is reset, STM32 turns off peripherals</p>"},{"location":"SW-development/#installation-and-usage","title":"Installation and usage","text":"<ul> <li>clone <code>https://github.com/RoboticsBrno/RB3204-RBCX-coproc-comm</code></li> <li>install protobuf compiler <code>apt-get install protobuf-compiler</code></li> <li>install nanopb generator <code>pip3 install nanopb==0.4.4</code></li> <li>edit <code>rbcx.proto</code> file</li> <li>compile protobuf messages using <code>./generate.sh</code></li> <li>commit and push changes to GitHub</li> <li>change GIT hash in FW and RBCX library to the latest commit hash</li> </ul>"},{"location":"SW-development/#schematic","title":"Schematic","text":""},{"location":"api/","title":"API documentation","text":"<p>This is the API documentation for the ESP-32 and STM</p>"},{"location":"apiEsp32/","title":"API ESP-32","text":"<p>This is the API documentation for the ESP32-DevKitC microcontroller.</p>"},{"location":"apiEsp32/#firmware","title":"Firmware","text":"<p>More information about firmware can be found in SW Development section.</p>"},{"location":"apiStm/","title":"API STM32","text":"<p>This is the API documentation for the STM32F103VC microcontroller.</p>"},{"location":"apiStm/#firmware","title":"Firmware","text":"<p>More information about firmware can be found in SW Development section.</p>"},{"location":"apiStm/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>struct A_BLOCK_LINK </li> <li>class BasePriorityRaiser </li> <li>class ByteFifo </li> <li>struct CalibrationData </li> <li>class Esp32Manager </li> <li>struct EventGroupDef_t </li> <li>struct FontDef </li> <li>struct HeapRegion </li> <li>struct MPU6050_t </li> <li>class MessageBufferWrapper </li> <li>class Motor </li> <li>struct MpuMotion32 </li> <li>struct MpuMotion6 </li> <li>struct MpuVector </li> <li>struct MpuVector32 </li> <li>class MutexWrapper </li> <li>struct OLED_VERTEX </li> <li>struct OLED_t </li> <li>struct QueueDefinition </li> <li>struct QueuePointers </li> <li>class QueueWrapper </li> <li>struct Regulator </li> <li>struct SemaphoreData </li> <li>struct StreamBufferDef_t </li> <li>class StreamBufferWrapper </li> <li>class TaskWrapper </li> <li>class TickTimer </li> <li>class XorShift Fast deterministic PRNG - https://en.wikipedia.org/wiki/Xorshift . </li> <li>struct __debug_descriptors </li> <li>struct _usbd_device Represents a USB device data. </li> <li>struct cdc_config </li> <li>struct corCoRoutineControlBlock </li> <li>struct mpu_t </li> <li>struct tskTaskControlBlock </li> <li>struct usb_cdc_acm_desc Abstract Control Management Functional Descriptor. </li> <li>struct usb_cdc_call_mgmt_desc Call Management Functional Descriptor. </li> <li>struct usb_cdc_country_desc Country Selection Functional Descriptor. </li> <li>struct usb_cdc_header_desc Header Functional Descriptor. </li> <li>struct usb_cdc_line_coding Line Coding Structure. </li> <li>struct usb_cdc_notification Notification structure from CDC. </li> <li>struct usb_cdc_union_desc Union Functional Descriptor. </li> <li>struct usb_config_descriptor USB device configuration descriptor. </li> <li>struct usb_debug_descriptor USB debug descriptor. </li> <li>struct usb_device_descriptor Represents a USB device descriptor. </li> <li>struct usb_endpoint_descriptor USB endpoint descriptor. </li> <li>struct usb_header_descriptor common USB descriptor header </li> <li>struct usb_iad_descriptor USB interface association descriptor. </li> <li>struct usb_interface_descriptor USB interface descriptor. </li> <li>struct usb_qualifier_descriptor USB device qualifier descriptor. </li> <li>struct usb_string_descriptor USB string descriptor. </li> <li>struct usbd_ctlreq Represents generic USB control request. </li> <li>struct usbd_driver Represents a hardware USB driver call table. </li> <li>struct usbd_status </li> <li>struct xHeapStats </li> <li>struct xLIST </li> <li>struct xLIST_ITEM </li> <li>struct xMEMORY_REGION </li> <li>struct xMINI_LIST_ITEM </li> <li>struct xSTATIC_EVENT_GROUP </li> <li>struct xSTATIC_LIST </li> <li>struct xSTATIC_LIST_ITEM </li> <li>struct xSTATIC_MINI_LIST_ITEM </li> <li>struct xSTATIC_QUEUE </li> <li>struct xSTATIC_STREAM_BUFFER </li> <li>struct xSTATIC_TCB </li> <li>struct xSTATIC_TIMER </li> <li>struct xTASK_PARAMETERS </li> <li>struct xTASK_STATUS </li> <li>struct xTIME_OUT </li> </ul>"},{"location":"apiStm/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir fw </li> <li>dir rbcx-coprocessor <ul> <li>file .clang-format </li> <li>dir include </li> <li>file Bsp.hpp </li> <li>file ButtonController.hpp </li> <li>file BuzzerController.hpp </li> <li>file CdcUartTunnel.hpp </li> <li>file ControlLink.hpp </li> <li>file DebugLink.hpp </li> <li>file Dispatcher.hpp </li> <li>file Esp32Manager.hpp </li> <li>file FreeRTOSConfig.h </li> <li>file I2cController.hpp </li> <li>file Motor.hpp </li> <li>file MotorController.hpp </li> <li>file Mpu6050.hpp </li> <li>file MpuController.hpp </li> <li>file OledController.hpp </li> <li>file OledController_fonts.hpp </li> <li>file Power.hpp </li> <li>file SmartServoController.hpp </li> <li>file StupidServoController.hpp </li> <li>file UltrasoundController.hpp </li> <li>file UsbCdcLink.h </li> <li>dir utils <ul> <li>file BasePriorityRaiser.hpp </li> <li>file ByteFifo.hpp </li> <li>file Debug.hpp </li> <li>file Flash.hpp </li> <li>file HalDma.hpp </li> <li>file MessageBufferWrapper.hpp </li> <li>file MutexWrapper.hpp </li> <li>file QueueWrapper.hpp </li> <li>file Regulator.hpp </li> <li>file StreamBufferWrapper.hpp </li> <li>file TaskWrapper.hpp </li> <li>file TickTimer.hpp </li> <li>file XorShift.hpp </li> </ul> </li> <li>dir lib </li> <li>dir FreeRTOS <ul> <li>dir include </li> <li>file FreeRTOS.h </li> <li>file atomic.h FreeRTOS atomic operation support. </li> <li>file croutine.h </li> <li>file deprecated_definitions.h </li> <li>file event_groups.h </li> <li>file list.h </li> <li>file message_buffer.h </li> <li>file mpu_prototypes.h </li> <li>file mpu_wrappers.h </li> <li>file portable.h </li> <li>file projdefs.h </li> <li>file queue.h </li> <li>file semphr.h </li> <li>file stack_macros.h </li> <li>file stream_buffer.h </li> <li>file task.h </li> <li>file timers.h </li> <li>dir src </li> <li>file croutine.c </li> <li>file event_groups.c </li> <li>file heap_4.c </li> <li>file list.c </li> <li>file mpu_wrappers.c </li> <li>file port.c </li> <li>file portmacro.h </li> <li>file queue.c </li> <li>file stream_buffer.c </li> <li>file tasks.c </li> <li>file timers.c </li> </ul> </li> <li>dir libusb_stm32 <ul> <li>dir include </li> <li>file stm32.h </li> <li>file usb.h </li> <li>file usb_cdc.h </li> <li>file usb_std.h </li> <li>file usbd_core.h </li> <li>dir src </li> <li>file usbd_core.c </li> <li>file usbd_stm32f103_devfs.c </li> </ul> </li> <li>dir src </li> <li>file Bsp.cpp </li> <li>file ButtonController.cpp </li> <li>file CdcUartTunnel.cpp </li> <li>file ControlLink.cpp </li> <li>file DebugLink.cpp </li> <li>file Dispatcher.cpp </li> <li>file Esp32Manager.cpp </li> <li>file FreeRTOSCallbacks.cpp </li> <li>file I2cController.cpp </li> <li>file MotorController.cpp </li> <li>file MpuController.cpp </li> <li>file OledController.cpp </li> <li>file OledController_fonts.cpp </li> <li>file Power.cpp </li> <li>file SmartServoController.cpp </li> <li>file StupidServoController.cpp </li> <li>file UltrasoundController.cpp </li> <li>file UsbCdcDescriptors.c </li> <li>file UsbCdcLink.cpp </li> <li>dir utils <ul> <li>file Debug.cpp </li> </ul> </li> <li>file main.cpp </li> </ul> </li> </ul>"},{"location":"apiStm/structA__BLOCK__LINK/","title":"Struct A_BLOCK_LINK","text":"<p>ClassList &gt; A_BLOCK_LINK</p>"},{"location":"apiStm/structA__BLOCK__LINK/#public-attributes","title":"Public Attributes","text":"Type Name struct A_BLOCK_LINK * pxNextFreeBlock size_t xBlockSize"},{"location":"apiStm/structA__BLOCK__LINK/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structA__BLOCK__LINK/#variable-pxnextfreeblock","title":"variable pxNextFreeBlock","text":"<pre><code>struct A_BLOCK_LINK* A_BLOCK_LINK::pxNextFreeBlock;\n</code></pre>"},{"location":"apiStm/structA__BLOCK__LINK/#variable-xblocksize","title":"variable xBlockSize","text":"<pre><code>size_t A_BLOCK_LINK::xBlockSize;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/src/heap_4.c</code></p>"},{"location":"apiStm/classBasePriorityRaiser/","title":"Class BasePriorityRaiser","text":"<p>template &lt;uint32_t TargetIrqPriority&gt;</p> <p>ClassList &gt; BasePriorityRaiser</p>"},{"location":"apiStm/classBasePriorityRaiser/#public-functions","title":"Public Functions","text":"Type Name BasePriorityRaiser ()  void lock ()  void unlock ()  ~BasePriorityRaiser ()"},{"location":"apiStm/classBasePriorityRaiser/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/classBasePriorityRaiser/#function-basepriorityraiser-12","title":"function BasePriorityRaiser [1/2]","text":"<pre><code>inline BasePriorityRaiser::BasePriorityRaiser () </code></pre>"},{"location":"apiStm/classBasePriorityRaiser/#function-lock","title":"function lock","text":"<pre><code>inline void BasePriorityRaiser::lock () </code></pre>"},{"location":"apiStm/classBasePriorityRaiser/#function-unlock","title":"function unlock","text":"<pre><code>inline void BasePriorityRaiser::unlock () </code></pre>"},{"location":"apiStm/classBasePriorityRaiser/#function-basepriorityraiser","title":"function ~BasePriorityRaiser","text":"<pre><code>inline BasePriorityRaiser::~BasePriorityRaiser () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/utils/BasePriorityRaiser.hpp</code></p>"},{"location":"apiStm/classByteFifo/","title":"Class ByteFifo","text":"<p>template &lt;int Size&gt;</p> <p>ClassList &gt; ByteFifo</p> <p>More...</p> <ul> <li><code>#include &lt;ByteFifo.hpp&gt;</code></li> </ul>"},{"location":"apiStm/classByteFifo/#public-functions","title":"Public Functions","text":"Type Name ByteFifo ()  size_t available () constReadable bytes. void clear () Clears the buffer by setting m_tail = m_head;. uint8_t * data () constPointer to the beginning. bool hasData () constTrue if some data is ready for reading. void notifyRead (size_t len) Move the read index (tail), indicating len bytes have been read out. void notifyWritten (size_t len) Move the write index (head), indicating len bytes have been written. void peekSpan (uint8_t * data, size_t len) Read len bytes into buffer starting at data. uint8_t pop () Reads one byte, must be available. void push (uint8_t b) Writes one byte. std::pair&lt; uint8_t *, size_t &gt; readableSpan () const void setHead (int newHead) Override the write index aka. head. constexpr size_t size () constTotal capacity. void writeSpan (uint8_t * data, size_t len) Write len bytes into buffer starting at data. std::pair&lt; uint8_t *, size_t &gt; writeableSpan () const"},{"location":"apiStm/classByteFifo/#detailed-description","title":"Detailed Description","text":"<p>A DMA-ready byte ring buffer with contiguous I/O API Allows direct read/write access using: readableSpan() -&gt; read-out -&gt; notifyRead() writeableSpan() -&gt; write-in -&gt; notifyWritten() </p>"},{"location":"apiStm/classByteFifo/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/classByteFifo/#function-bytefifo","title":"function ByteFifo","text":"<pre><code>inline ByteFifo::ByteFifo () </code></pre>"},{"location":"apiStm/classByteFifo/#function-available","title":"function available","text":"<pre><code>inline size_t ByteFifo::available () const\n</code></pre>"},{"location":"apiStm/classByteFifo/#function-clear","title":"function clear","text":"<pre><code>inline void ByteFifo::clear () </code></pre>"},{"location":"apiStm/classByteFifo/#function-data","title":"function data","text":"<pre><code>inline uint8_t * ByteFifo::data () const\n</code></pre>"},{"location":"apiStm/classByteFifo/#function-hasdata","title":"function hasData","text":"<pre><code>inline bool ByteFifo::hasData () const\n</code></pre>"},{"location":"apiStm/classByteFifo/#function-notifyread","title":"function notifyRead","text":"<pre><code>inline void ByteFifo::notifyRead (\nsize_t len\n) </code></pre>"},{"location":"apiStm/classByteFifo/#function-notifywritten","title":"function notifyWritten","text":"<pre><code>inline void ByteFifo::notifyWritten (\nsize_t len\n) </code></pre>"},{"location":"apiStm/classByteFifo/#function-peekspan","title":"function peekSpan","text":"<pre><code>inline void ByteFifo::peekSpan (\nuint8_t * data,\nsize_t len\n) </code></pre>"},{"location":"apiStm/classByteFifo/#function-pop","title":"function pop","text":"<pre><code>inline uint8_t ByteFifo::pop () </code></pre>"},{"location":"apiStm/classByteFifo/#function-push","title":"function push","text":"<pre><code>inline void ByteFifo::push (\nuint8_t b\n) </code></pre>"},{"location":"apiStm/classByteFifo/#function-readablespan","title":"function readableSpan","text":"<pre><code>inline std::pair&lt; uint8_t *, size_t &gt; ByteFifo::readableSpan () const\n</code></pre> <p>Gets a contiguous range of bytes ready for reading. Doesn't represent all readable bytes if wrapped over the end. Zero size_t means FIFO is empty. </p>"},{"location":"apiStm/classByteFifo/#function-sethead","title":"function setHead","text":"<pre><code>inline void ByteFifo::setHead (\nint newHead\n) </code></pre>"},{"location":"apiStm/classByteFifo/#function-size","title":"function size","text":"<pre><code>inline constexpr size_t ByteFifo::size () const\n</code></pre>"},{"location":"apiStm/classByteFifo/#function-writespan","title":"function writeSpan","text":"<pre><code>inline void ByteFifo::writeSpan (\nuint8_t * data,\nsize_t len\n) </code></pre>"},{"location":"apiStm/classByteFifo/#function-writeablespan","title":"function writeableSpan","text":"<pre><code>inline std::pair&lt; uint8_t *, size_t &gt; ByteFifo::writeableSpan () const\n</code></pre> <p>Gets a contiguous range of bytes ready for writing. Doesn't represent all writeable bytes if wrapped over the end. Zero size_t means FIFO is full. </p> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/utils/ByteFifo.hpp</code></p>"},{"location":"apiStm/structCalibrationData/","title":"Struct CalibrationData","text":"<p>ClassList &gt; CalibrationData</p>"},{"location":"apiStm/structCalibrationData/#public-attributes","title":"Public Attributes","text":"Type Name float batteryCoef float batteryMidCoef uint16_t internalVrefMv uint32_t magic uint16_t tempTypicalAtC uint16_t tempTypicalMv"},{"location":"apiStm/structCalibrationData/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structCalibrationData/#variable-batterycoef","title":"variable batteryCoef","text":"<pre><code>float CalibrationData::batteryCoef;\n</code></pre>"},{"location":"apiStm/structCalibrationData/#variable-batterymidcoef","title":"variable batteryMidCoef","text":"<pre><code>float CalibrationData::batteryMidCoef;\n</code></pre>"},{"location":"apiStm/structCalibrationData/#variable-internalvrefmv","title":"variable internalVrefMv","text":"<pre><code>uint16_t CalibrationData::internalVrefMv;\n</code></pre>"},{"location":"apiStm/structCalibrationData/#variable-magic","title":"variable magic","text":"<pre><code>uint32_t CalibrationData::magic;\n</code></pre>"},{"location":"apiStm/structCalibrationData/#variable-temptypicalatc","title":"variable tempTypicalAtC","text":"<pre><code>uint16_t CalibrationData::tempTypicalAtC;\n</code></pre>"},{"location":"apiStm/structCalibrationData/#variable-temptypicalmv","title":"variable tempTypicalMv","text":"<pre><code>uint16_t CalibrationData::tempTypicalMv;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/Power.cpp</code></p>"},{"location":"apiStm/classEsp32Manager/","title":"Class Esp32Manager","text":"<p>ClassList &gt; Esp32Manager</p>"},{"location":"apiStm/classEsp32Manager/#public-functions","title":"Public Functions","text":"Type Name Esp32Manager ()  void handleSettings (const CoprocReq_EspWatchdogSettings &amp; settings)  void init ()  bool isInBootloader () const void onEnRisingInIrq ()  void onSerialBreakInIrq (bool dtr, bool rst)  void poll ()  void queueReset (bool bootloader=false)  void resetWatchdog ()  void setWatchdogInhibit (bool inhibit)  ~Esp32Manager ()"},{"location":"apiStm/classEsp32Manager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/classEsp32Manager/#function-esp32manager-22","title":"function Esp32Manager [2/2]","text":"<pre><code>Esp32Manager::Esp32Manager () </code></pre>"},{"location":"apiStm/classEsp32Manager/#function-handlesettings","title":"function handleSettings","text":"<pre><code>void Esp32Manager::handleSettings (\nconst CoprocReq_EspWatchdogSettings &amp; settings\n) </code></pre>"},{"location":"apiStm/classEsp32Manager/#function-init","title":"function init","text":"<pre><code>void Esp32Manager::init () </code></pre>"},{"location":"apiStm/classEsp32Manager/#function-isinbootloader","title":"function isInBootloader","text":"<pre><code>inline bool Esp32Manager::isInBootloader () const\n</code></pre>"},{"location":"apiStm/classEsp32Manager/#function-onenrisinginirq","title":"function onEnRisingInIrq","text":"<pre><code>void Esp32Manager::onEnRisingInIrq () </code></pre>"},{"location":"apiStm/classEsp32Manager/#function-onserialbreakinirq","title":"function onSerialBreakInIrq","text":"<pre><code>void Esp32Manager::onSerialBreakInIrq (\nbool dtr,\nbool rst\n) </code></pre>"},{"location":"apiStm/classEsp32Manager/#function-poll","title":"function poll","text":"<pre><code>void Esp32Manager::poll () </code></pre>"},{"location":"apiStm/classEsp32Manager/#function-queuereset","title":"function queueReset","text":"<pre><code>void Esp32Manager::queueReset (\nbool bootloader=false\n) </code></pre>"},{"location":"apiStm/classEsp32Manager/#function-resetwatchdog","title":"function resetWatchdog","text":"<pre><code>void Esp32Manager::resetWatchdog () </code></pre>"},{"location":"apiStm/classEsp32Manager/#function-setwatchdoginhibit","title":"function setWatchdogInhibit","text":"<pre><code>void Esp32Manager::setWatchdogInhibit (\nbool inhibit\n) </code></pre>"},{"location":"apiStm/classEsp32Manager/#function-esp32manager","title":"function ~Esp32Manager","text":"<pre><code>Esp32Manager::~Esp32Manager () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/Esp32Manager.hpp</code></p>"},{"location":"apiStm/structEventGroupDef__t/","title":"Struct EventGroupDef_t","text":"<p>ClassList &gt; EventGroupDef_t</p>"},{"location":"apiStm/structEventGroupDef__t/#public-attributes","title":"Public Attributes","text":"Type Name EventBits_t uxEventBits List_t xTasksWaitingForBits"},{"location":"apiStm/structEventGroupDef__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structEventGroupDef__t/#variable-uxeventbits","title":"variable uxEventBits","text":"<pre><code>EventBits_t EventGroupDef_t::uxEventBits;\n</code></pre>"},{"location":"apiStm/structEventGroupDef__t/#variable-xtaskswaitingforbits","title":"variable xTasksWaitingForBits","text":"<pre><code>List_t EventGroupDef_t::xTasksWaitingForBits;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/src/event_groups.c</code></p>"},{"location":"apiStm/structFontDef/","title":"Struct FontDef","text":"<p>ClassList &gt; FontDef</p>"},{"location":"apiStm/structFontDef/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t FontHeight const uint8_t FontWidth const uint16_t * data"},{"location":"apiStm/structFontDef/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structFontDef/#variable-fontheight","title":"variable FontHeight","text":"<pre><code>uint8_t FontDef::FontHeight;\n</code></pre> <p>Font height in pixels </p>"},{"location":"apiStm/structFontDef/#variable-fontwidth","title":"variable FontWidth","text":"<pre><code>const uint8_t FontDef::FontWidth;\n</code></pre> <p>Font width in pixels </p>"},{"location":"apiStm/structFontDef/#variable-data","title":"variable data","text":"<pre><code>const uint16_t* FontDef::data;\n</code></pre> <p>Pointer to data font data array </p> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/OledController_fonts.hpp</code></p>"},{"location":"apiStm/structHeapRegion/","title":"Struct HeapRegion","text":"<p>ClassList &gt; HeapRegion</p>"},{"location":"apiStm/structHeapRegion/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t * pucStartAddress size_t xSizeInBytes"},{"location":"apiStm/structHeapRegion/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structHeapRegion/#variable-pucstartaddress","title":"variable pucStartAddress","text":"<pre><code>uint8_t* HeapRegion::pucStartAddress;\n</code></pre>"},{"location":"apiStm/structHeapRegion/#variable-xsizeinbytes","title":"variable xSizeInBytes","text":"<pre><code>size_t HeapRegion::xSizeInBytes;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/portable.h</code></p>"},{"location":"apiStm/structMPU6050__t/","title":"Struct MPU6050_t","text":"<p>ClassList &gt; MPU6050_t</p>"},{"location":"apiStm/structMPU6050__t/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t buffer uint8_t devAddr"},{"location":"apiStm/structMPU6050__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structMPU6050__t/#variable-buffer","title":"variable buffer","text":"<pre><code>uint8_t MPU6050_t::buffer[14];\n</code></pre>"},{"location":"apiStm/structMPU6050__t/#variable-devaddr","title":"variable devAddr","text":"<pre><code>uint8_t MPU6050_t::devAddr;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/Mpu6050.hpp</code></p>"},{"location":"apiStm/classMessageBufferWrapper/","title":"Class MessageBufferWrapper","text":"<p>template &lt;size_t SizeInBytes&gt;</p> <p>ClassList &gt; MessageBufferWrapper</p>"},{"location":"apiStm/classMessageBufferWrapper/#public-functions","title":"Public Functions","text":"Type Name MessageBufferWrapper ()  void create ()  MessageBufferHandle_t handle () const size_t pop_front (uint8_t * dst, size_t maxLen, TickType_t ticks_to_wait, BaseType_t * pxHigherPriorityTaskWoken=nullptr)  bool pop_front (T &amp; dst, TickType_t ticks_to_wait, BaseType_t * pxHigherPriorityTaskWoken=nullptr)  bool push_back (uint8_t * data, size_t len, TickType_t ticks_to_wait, BaseType_t * pxHigherPriorityTaskWoken=nullptr)  bool push_back (const T &amp; val, TickType_t ticks_to_wait, BaseType_t * pxHigherPriorityTaskWoken=nullptr)  bool reset ()  ~MessageBufferWrapper ()"},{"location":"apiStm/classMessageBufferWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/classMessageBufferWrapper/#function-messagebufferwrapper","title":"function MessageBufferWrapper","text":"<pre><code>inline MessageBufferWrapper::MessageBufferWrapper () </code></pre>"},{"location":"apiStm/classMessageBufferWrapper/#function-create","title":"function create","text":"<pre><code>inline void MessageBufferWrapper::create () </code></pre>"},{"location":"apiStm/classMessageBufferWrapper/#function-handle","title":"function handle","text":"<pre><code>inline MessageBufferHandle_t MessageBufferWrapper::handle () const\n</code></pre>"},{"location":"apiStm/classMessageBufferWrapper/#function-pop_front-12","title":"function pop_front [1/2]","text":"<pre><code>inline size_t MessageBufferWrapper::pop_front (\nuint8_t * dst,\nsize_t maxLen,\nTickType_t ticks_to_wait,\nBaseType_t * pxHigherPriorityTaskWoken=nullptr\n) </code></pre>"},{"location":"apiStm/classMessageBufferWrapper/#function-pop_front-22","title":"function pop_front [2/2]","text":"<pre><code>template&lt;typename T typename T&gt;\ninline bool MessageBufferWrapper::pop_front (\nT &amp; dst,\nTickType_t ticks_to_wait,\nBaseType_t * pxHigherPriorityTaskWoken=nullptr\n) </code></pre>"},{"location":"apiStm/classMessageBufferWrapper/#function-push_back-12","title":"function push_back [1/2]","text":"<pre><code>inline bool MessageBufferWrapper::push_back (\nuint8_t * data,\nsize_t len,\nTickType_t ticks_to_wait,\nBaseType_t * pxHigherPriorityTaskWoken=nullptr\n) </code></pre>"},{"location":"apiStm/classMessageBufferWrapper/#function-push_back-22","title":"function push_back [2/2]","text":"<pre><code>template&lt;typename T typename T&gt;\ninline bool MessageBufferWrapper::push_back (\nconst T &amp; val,\nTickType_t ticks_to_wait,\nBaseType_t * pxHigherPriorityTaskWoken=nullptr\n) </code></pre>"},{"location":"apiStm/classMessageBufferWrapper/#function-reset","title":"function reset","text":"<pre><code>inline bool MessageBufferWrapper::reset () </code></pre>"},{"location":"apiStm/classMessageBufferWrapper/#function-messagebufferwrapper_1","title":"function ~MessageBufferWrapper","text":"<pre><code>inline MessageBufferWrapper::~MessageBufferWrapper () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/utils/MessageBufferWrapper.hpp</code></p>"},{"location":"apiStm/classMotor/","title":"Class Motor","text":"<p>ClassList &gt; Motor</p>"},{"location":"apiStm/classMotor/#public-functions","title":"Public Functions","text":"Type Name Motor ()  bool atStandstill () const bool atTargetPosition () const void homePosition (int32_t homedTicks)  MotorMode mode () const void modeChange (MotorMode newMode)  int16_t poll (uint16_t encTicks)  void reportStat (CoprocStat_MotorStat &amp; stat)  void reset ()  void setConfig (const MotorConfig &amp; config)  void setPositionPid (const RegCoefs &amp; coefs)  void setTargetBrakingPower (int16_t brakingPower)  void setTargetPosition (const CoprocReq_MotorReq_SetPosition &amp; req, bool additive)  void setTargetPower (int16_t power)  void setTargetVelocity (int16_t ticksPerSec)  void setVelocityPid (const RegCoefs &amp; coefs)"},{"location":"apiStm/classMotor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/classMotor/#function-motor","title":"function Motor","text":"<pre><code>inline Motor::Motor () </code></pre>"},{"location":"apiStm/classMotor/#function-atstandstill","title":"function atStandstill","text":"<pre><code>inline bool Motor::atStandstill () const\n</code></pre>"},{"location":"apiStm/classMotor/#function-attargetposition","title":"function atTargetPosition","text":"<pre><code>inline bool Motor::atTargetPosition () const\n</code></pre>"},{"location":"apiStm/classMotor/#function-homeposition","title":"function homePosition","text":"<pre><code>inline void Motor::homePosition (\nint32_t homedTicks\n) </code></pre>"},{"location":"apiStm/classMotor/#function-mode","title":"function mode","text":"<pre><code>inline MotorMode Motor::mode () const\n</code></pre>"},{"location":"apiStm/classMotor/#function-modechange","title":"function modeChange","text":"<pre><code>inline void Motor::modeChange (\nMotorMode newMode\n) </code></pre>"},{"location":"apiStm/classMotor/#function-poll","title":"function poll","text":"<pre><code>inline int16_t Motor::poll (\nuint16_t encTicks\n) </code></pre>"},{"location":"apiStm/classMotor/#function-reportstat","title":"function reportStat","text":"<pre><code>inline void Motor::reportStat (\nCoprocStat_MotorStat &amp; stat\n) </code></pre>"},{"location":"apiStm/classMotor/#function-reset","title":"function reset","text":"<pre><code>inline void Motor::reset () </code></pre>"},{"location":"apiStm/classMotor/#function-setconfig","title":"function setConfig","text":"<pre><code>inline void Motor::setConfig (\nconst MotorConfig &amp; config\n) </code></pre>"},{"location":"apiStm/classMotor/#function-setpositionpid","title":"function setPositionPid","text":"<pre><code>inline void Motor::setPositionPid (\nconst RegCoefs &amp; coefs\n) </code></pre>"},{"location":"apiStm/classMotor/#function-settargetbrakingpower","title":"function setTargetBrakingPower","text":"<pre><code>inline void Motor::setTargetBrakingPower (\nint16_t brakingPower\n) </code></pre>"},{"location":"apiStm/classMotor/#function-settargetposition","title":"function setTargetPosition","text":"<pre><code>inline void Motor::setTargetPosition (\nconst CoprocReq_MotorReq_SetPosition &amp; req,\nbool additive\n) </code></pre>"},{"location":"apiStm/classMotor/#function-settargetpower","title":"function setTargetPower","text":"<pre><code>inline void Motor::setTargetPower (\nint16_t power\n) </code></pre>"},{"location":"apiStm/classMotor/#function-settargetvelocity","title":"function setTargetVelocity","text":"<pre><code>inline void Motor::setTargetVelocity (\nint16_t ticksPerSec\n) </code></pre>"},{"location":"apiStm/classMotor/#function-setvelocitypid","title":"function setVelocityPid","text":"<pre><code>inline void Motor::setVelocityPid (\nconst RegCoefs &amp; coefs\n) </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/Motor.hpp</code></p>"},{"location":"apiStm/structMpuMotion32/","title":"Struct MpuMotion32","text":"<p>ClassList &gt; MpuMotion32</p>"},{"location":"apiStm/structMpuMotion32/#public-attributes","title":"Public Attributes","text":"Type Name MpuVector32 accel MpuVector32 gyro"},{"location":"apiStm/structMpuMotion32/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structMpuMotion32/#variable-accel","title":"variable accel","text":"<pre><code>MpuVector32 MpuMotion32::accel;\n</code></pre>"},{"location":"apiStm/structMpuMotion32/#variable-gyro","title":"variable gyro","text":"<pre><code>MpuVector32 MpuMotion32::gyro;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/MpuController.cpp</code></p>"},{"location":"apiStm/structMpuMotion6/","title":"Struct MpuMotion6","text":"<p>ClassList &gt; MpuMotion6</p>"},{"location":"apiStm/structMpuMotion6/#public-attributes","title":"Public Attributes","text":"Type Name MpuVector accel MpuVector gyro"},{"location":"apiStm/structMpuMotion6/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structMpuMotion6/#variable-accel","title":"variable accel","text":"<pre><code>MpuVector MpuMotion6::accel;\n</code></pre>"},{"location":"apiStm/structMpuMotion6/#variable-gyro","title":"variable gyro","text":"<pre><code>MpuVector MpuMotion6::gyro;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/MpuController.cpp</code></p>"},{"location":"apiStm/structMpuVector/","title":"Struct MpuVector","text":"<p>ClassList &gt; MpuVector</p>"},{"location":"apiStm/structMpuVector/#public-attributes","title":"Public Attributes","text":"Type Name int16_t x int16_t y int16_t z"},{"location":"apiStm/structMpuVector/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structMpuVector/#variable-x","title":"variable x","text":"<pre><code>int16_t MpuVector::x;\n</code></pre>"},{"location":"apiStm/structMpuVector/#variable-y","title":"variable y","text":"<pre><code>int16_t MpuVector::y;\n</code></pre>"},{"location":"apiStm/structMpuVector/#variable-z","title":"variable z","text":"<pre><code>int16_t MpuVector::z;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/MpuController.cpp</code></p>"},{"location":"apiStm/structMpuVector32/","title":"Struct MpuVector32","text":"<p>ClassList &gt; MpuVector32</p>"},{"location":"apiStm/structMpuVector32/#public-attributes","title":"Public Attributes","text":"Type Name int32_t x int32_t y int32_t z"},{"location":"apiStm/structMpuVector32/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structMpuVector32/#variable-x","title":"variable x","text":"<pre><code>int32_t MpuVector32::x;\n</code></pre>"},{"location":"apiStm/structMpuVector32/#variable-y","title":"variable y","text":"<pre><code>int32_t MpuVector32::y;\n</code></pre>"},{"location":"apiStm/structMpuVector32/#variable-z","title":"variable z","text":"<pre><code>int32_t MpuVector32::z;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/MpuController.cpp</code></p>"},{"location":"apiStm/classMutexWrapper/","title":"Class MutexWrapper","text":"<p>ClassList &gt; MutexWrapper</p>"},{"location":"apiStm/classMutexWrapper/#public-functions","title":"Public Functions","text":"Type Name MutexWrapper ()  void create ()  void lock ()  SemaphoreHandle_t native_handle () const void unlock ()  ~MutexWrapper ()"},{"location":"apiStm/classMutexWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/classMutexWrapper/#function-mutexwrapper","title":"function MutexWrapper","text":"<pre><code>inline MutexWrapper::MutexWrapper () </code></pre>"},{"location":"apiStm/classMutexWrapper/#function-create","title":"function create","text":"<pre><code>inline void MutexWrapper::create () </code></pre>"},{"location":"apiStm/classMutexWrapper/#function-lock","title":"function lock","text":"<pre><code>inline void MutexWrapper::lock () </code></pre>"},{"location":"apiStm/classMutexWrapper/#function-native_handle","title":"function native_handle","text":"<pre><code>inline SemaphoreHandle_t MutexWrapper::native_handle () const\n</code></pre>"},{"location":"apiStm/classMutexWrapper/#function-unlock","title":"function unlock","text":"<pre><code>inline void MutexWrapper::unlock () </code></pre>"},{"location":"apiStm/classMutexWrapper/#function-mutexwrapper_1","title":"function ~MutexWrapper","text":"<pre><code>inline MutexWrapper::~MutexWrapper () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/utils/MutexWrapper.hpp</code></p>"},{"location":"apiStm/structOLED__VERTEX/","title":"Struct OLED_VERTEX","text":"<p>ClassList &gt; OLED_VERTEX</p>"},{"location":"apiStm/structOLED__VERTEX/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t x uint8_t y"},{"location":"apiStm/structOLED__VERTEX/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structOLED__VERTEX/#variable-x","title":"variable x","text":"<pre><code>uint8_t OLED_VERTEX::x;\n</code></pre>"},{"location":"apiStm/structOLED__VERTEX/#variable-y","title":"variable y","text":"<pre><code>uint8_t OLED_VERTEX::y;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/OledController.hpp</code></p>"},{"location":"apiStm/structOLED__t/","title":"Struct OLED_t","text":"<p>ClassList &gt; OLED_t</p>"},{"location":"apiStm/structOLED__t/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t CurrentX uint16_t CurrentY bool DisplayOn uint8_t Inverted"},{"location":"apiStm/structOLED__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structOLED__t/#variable-currentx","title":"variable CurrentX","text":"<pre><code>uint16_t OLED_t::CurrentX;\n</code></pre>"},{"location":"apiStm/structOLED__t/#variable-currenty","title":"variable CurrentY","text":"<pre><code>uint16_t OLED_t::CurrentY;\n</code></pre>"},{"location":"apiStm/structOLED__t/#variable-displayon","title":"variable DisplayOn","text":"<pre><code>bool OLED_t::DisplayOn;\n</code></pre>"},{"location":"apiStm/structOLED__t/#variable-inverted","title":"variable Inverted","text":"<pre><code>uint8_t OLED_t::Inverted;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/OledController.hpp</code></p>"},{"location":"apiStm/structQueueDefinition/","title":"Struct QueueDefinition","text":"<p>ClassList &gt; QueueDefinition</p>"},{"location":"apiStm/structQueueDefinition/#public-attributes","title":"Public Attributes","text":"Type Name int8_t cRxLock int8_t cTxLock int8_t * pcHead int8_t * pcWriteTo union QueueDefinition::@1 u UBaseType_t uxItemSize UBaseType_t uxLength UBaseType_t uxMessagesWaiting QueuePointers_t xQueue SemaphoreData_t xSemaphore List_t xTasksWaitingToReceive List_t xTasksWaitingToSend"},{"location":"apiStm/structQueueDefinition/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structQueueDefinition/#variable-crxlock","title":"variable cRxLock","text":"<pre><code>volatile int8_t QueueDefinition::cRxLock;\n</code></pre>"},{"location":"apiStm/structQueueDefinition/#variable-ctxlock","title":"variable cTxLock","text":"<pre><code>volatile int8_t QueueDefinition::cTxLock;\n</code></pre>"},{"location":"apiStm/structQueueDefinition/#variable-pchead","title":"variable pcHead","text":"<pre><code>int8_t* QueueDefinition::pcHead;\n</code></pre>"},{"location":"apiStm/structQueueDefinition/#variable-pcwriteto","title":"variable pcWriteTo","text":"<pre><code>int8_t* QueueDefinition::pcWriteTo;\n</code></pre>"},{"location":"apiStm/structQueueDefinition/#variable-u","title":"variable u","text":"<pre><code>union QueueDefinition::@1 QueueDefinition::u;\n</code></pre>"},{"location":"apiStm/structQueueDefinition/#variable-uxitemsize","title":"variable uxItemSize","text":"<pre><code>UBaseType_t QueueDefinition::uxItemSize;\n</code></pre>"},{"location":"apiStm/structQueueDefinition/#variable-uxlength","title":"variable uxLength","text":"<pre><code>UBaseType_t QueueDefinition::uxLength;\n</code></pre>"},{"location":"apiStm/structQueueDefinition/#variable-uxmessageswaiting","title":"variable uxMessagesWaiting","text":"<pre><code>volatile UBaseType_t QueueDefinition::uxMessagesWaiting;\n</code></pre>"},{"location":"apiStm/structQueueDefinition/#variable-xqueue","title":"variable xQueue","text":"<pre><code>QueuePointers_t QueueDefinition::xQueue;\n</code></pre>"},{"location":"apiStm/structQueueDefinition/#variable-xsemaphore","title":"variable xSemaphore","text":"<pre><code>SemaphoreData_t QueueDefinition::xSemaphore;\n</code></pre>"},{"location":"apiStm/structQueueDefinition/#variable-xtaskswaitingtoreceive","title":"variable xTasksWaitingToReceive","text":"<pre><code>List_t QueueDefinition::xTasksWaitingToReceive;\n</code></pre>"},{"location":"apiStm/structQueueDefinition/#variable-xtaskswaitingtosend","title":"variable xTasksWaitingToSend","text":"<pre><code>List_t QueueDefinition::xTasksWaitingToSend;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/src/queue.c</code></p>"},{"location":"apiStm/structQueuePointers/","title":"Struct QueuePointers","text":"<p>ClassList &gt; QueuePointers</p>"},{"location":"apiStm/structQueuePointers/#public-attributes","title":"Public Attributes","text":"Type Name int8_t * pcReadFrom int8_t * pcTail"},{"location":"apiStm/structQueuePointers/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structQueuePointers/#variable-pcreadfrom","title":"variable pcReadFrom","text":"<pre><code>int8_t* QueuePointers::pcReadFrom;\n</code></pre>"},{"location":"apiStm/structQueuePointers/#variable-pctail","title":"variable pcTail","text":"<pre><code>int8_t* QueuePointers::pcTail;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/src/queue.c</code></p>"},{"location":"apiStm/classQueueWrapper/","title":"Class QueueWrapper","text":"<p>template &lt;typename T typename T, UBaseType_t Length&gt;</p> <p>ClassList &gt; QueueWrapper</p>"},{"location":"apiStm/classQueueWrapper/#public-functions","title":"Public Functions","text":"Type Name QueueWrapper ()  void create ()  QueueHandle_t handle () const bool overwrite (const T &amp; val, BaseType_t * pxHigherPriorityTaskWoken=nullptr)  bool pop_front (T &amp; result, TickType_t ticks_to_wait=portMAX_DELAY, BaseType_t * pxHigherPriorityTaskWoken=nullptr)  bool push_back (const T &amp; val, TickType_t ticks_to_wait=portMAX_DELAY, BaseType_t * pxHigherPriorityTaskWoken=nullptr)  bool push_front (const T &amp; val, TickType_t ticks_to_wait=portMAX_DELAY, BaseType_t * pxHigherPriorityTaskWoken=nullptr)  void reset ()  ~QueueWrapper ()"},{"location":"apiStm/classQueueWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/classQueueWrapper/#function-queuewrapper-12","title":"function QueueWrapper [1/2]","text":"<pre><code>inline QueueWrapper::QueueWrapper () </code></pre>"},{"location":"apiStm/classQueueWrapper/#function-create","title":"function create","text":"<pre><code>inline void QueueWrapper::create () </code></pre>"},{"location":"apiStm/classQueueWrapper/#function-handle","title":"function handle","text":"<pre><code>inline QueueHandle_t QueueWrapper::handle () const\n</code></pre>"},{"location":"apiStm/classQueueWrapper/#function-overwrite","title":"function overwrite","text":"<pre><code>inline bool QueueWrapper::overwrite (\nconst T &amp; val,\nBaseType_t * pxHigherPriorityTaskWoken=nullptr\n) </code></pre>"},{"location":"apiStm/classQueueWrapper/#function-pop_front","title":"function pop_front","text":"<pre><code>inline bool QueueWrapper::pop_front (\nT &amp; result,\nTickType_t ticks_to_wait=portMAX_DELAY,\nBaseType_t * pxHigherPriorityTaskWoken=nullptr\n) </code></pre>"},{"location":"apiStm/classQueueWrapper/#function-push_back","title":"function push_back","text":"<pre><code>inline bool QueueWrapper::push_back (\nconst T &amp; val,\nTickType_t ticks_to_wait=portMAX_DELAY,\nBaseType_t * pxHigherPriorityTaskWoken=nullptr\n) </code></pre>"},{"location":"apiStm/classQueueWrapper/#function-push_front","title":"function push_front","text":"<pre><code>inline bool QueueWrapper::push_front (\nconst T &amp; val,\nTickType_t ticks_to_wait=portMAX_DELAY,\nBaseType_t * pxHigherPriorityTaskWoken=nullptr\n) </code></pre>"},{"location":"apiStm/classQueueWrapper/#function-reset","title":"function reset","text":"<pre><code>inline void QueueWrapper::reset () </code></pre>"},{"location":"apiStm/classQueueWrapper/#function-queuewrapper","title":"function ~QueueWrapper","text":"<pre><code>inline QueueWrapper::~QueueWrapper () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/utils/QueueWrapper.hpp</code></p>"},{"location":"apiStm/structRegulator/","title":"Struct Regulator","text":"<p>ClassList &gt; Regulator</p>"},{"location":"apiStm/structRegulator/#public-types","title":"Public Types","text":"Type Name typedef uint32_t coef_type typedef int32_t value_type"},{"location":"apiStm/structRegulator/#public-functions","title":"Public Functions","text":"Type Name coef_type D () const coef_type I () const coef_type P () const Regulator () = default Regulator (value_type max_output, coef_type p, coef_type i, coef_type d)  void clear ()  value_type de () const value_type e () const value_type integrator () const value_type maxOutput ()  constexpr Regulator &amp; operator= (Regulator &amp;&amp; other) = default value_type output () const value_type process (value_type target, value_type actual)  void setD (const coef_type &amp; v)  void setI (const coef_type &amp; v)  void setMaxOutput (value_type max_output)  void setP (const coef_type &amp; v)  void stop (bool s=true)"},{"location":"apiStm/structRegulator/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/structRegulator/#typedef-coef_type","title":"typedef coef_type","text":"<pre><code>typedef uint32_t Regulator::coef_type;\n</code></pre>"},{"location":"apiStm/structRegulator/#typedef-value_type","title":"typedef value_type","text":"<pre><code>typedef int32_t Regulator::value_type;\n</code></pre>"},{"location":"apiStm/structRegulator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/structRegulator/#function-d","title":"function D","text":"<pre><code>inline coef_type Regulator::D () const\n</code></pre>"},{"location":"apiStm/structRegulator/#function-i","title":"function I","text":"<pre><code>inline coef_type Regulator::I () const\n</code></pre>"},{"location":"apiStm/structRegulator/#function-p","title":"function P","text":"<pre><code>inline coef_type Regulator::P () const\n</code></pre>"},{"location":"apiStm/structRegulator/#function-regulator-12","title":"function Regulator [1/2]","text":"<pre><code>Regulator::Regulator () = default\n</code></pre>"},{"location":"apiStm/structRegulator/#function-regulator-22","title":"function Regulator [2/2]","text":"<pre><code>inline Regulator::Regulator (\nvalue_type max_output,\ncoef_type p,\ncoef_type i,\ncoef_type d\n) </code></pre>"},{"location":"apiStm/structRegulator/#function-clear","title":"function clear","text":"<pre><code>inline void Regulator::clear () </code></pre>"},{"location":"apiStm/structRegulator/#function-de","title":"function de","text":"<pre><code>inline value_type Regulator::de () const\n</code></pre>"},{"location":"apiStm/structRegulator/#function-e","title":"function e","text":"<pre><code>inline value_type Regulator::e () const\n</code></pre>"},{"location":"apiStm/structRegulator/#function-integrator","title":"function integrator","text":"<pre><code>inline value_type Regulator::integrator () const\n</code></pre>"},{"location":"apiStm/structRegulator/#function-maxoutput","title":"function maxOutput","text":"<pre><code>inline value_type Regulator::maxOutput () </code></pre>"},{"location":"apiStm/structRegulator/#function-operator","title":"function operator=","text":"<pre><code>constexpr Regulator &amp; Regulator::operator= (\nRegulator &amp;&amp; other\n) = default\n</code></pre>"},{"location":"apiStm/structRegulator/#function-output","title":"function output","text":"<pre><code>inline value_type Regulator::output () const\n</code></pre>"},{"location":"apiStm/structRegulator/#function-process","title":"function process","text":"<pre><code>inline value_type Regulator::process (\nvalue_type target,\nvalue_type actual\n) </code></pre>"},{"location":"apiStm/structRegulator/#function-setd","title":"function setD","text":"<pre><code>inline void Regulator::setD (\nconst coef_type &amp; v\n) </code></pre>"},{"location":"apiStm/structRegulator/#function-seti","title":"function setI","text":"<pre><code>inline void Regulator::setI (\nconst coef_type &amp; v\n) </code></pre>"},{"location":"apiStm/structRegulator/#function-setmaxoutput","title":"function setMaxOutput","text":"<pre><code>inline void Regulator::setMaxOutput (\nvalue_type max_output\n) </code></pre>"},{"location":"apiStm/structRegulator/#function-setp","title":"function setP","text":"<pre><code>inline void Regulator::setP (\nconst coef_type &amp; v\n) </code></pre>"},{"location":"apiStm/structRegulator/#function-stop","title":"function stop","text":"<pre><code>inline void Regulator::stop (\nbool s=true\n) </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/utils/Regulator.hpp</code></p>"},{"location":"apiStm/structSemaphoreData/","title":"Struct SemaphoreData","text":"<p>ClassList &gt; SemaphoreData</p>"},{"location":"apiStm/structSemaphoreData/#public-attributes","title":"Public Attributes","text":"Type Name UBaseType_t uxRecursiveCallCount TaskHandle_t xMutexHolder"},{"location":"apiStm/structSemaphoreData/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structSemaphoreData/#variable-uxrecursivecallcount","title":"variable uxRecursiveCallCount","text":"<pre><code>UBaseType_t SemaphoreData::uxRecursiveCallCount;\n</code></pre>"},{"location":"apiStm/structSemaphoreData/#variable-xmutexholder","title":"variable xMutexHolder","text":"<pre><code>TaskHandle_t SemaphoreData::xMutexHolder;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/src/queue.c</code></p>"},{"location":"apiStm/structStreamBufferDef__t/","title":"Struct StreamBufferDef_t","text":"<p>ClassList &gt; StreamBufferDef_t</p>"},{"location":"apiStm/structStreamBufferDef__t/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t * pucBuffer uint8_t ucFlags size_t xHead size_t xLength size_t xTail TaskHandle_t xTaskWaitingToReceive TaskHandle_t xTaskWaitingToSend size_t xTriggerLevelBytes"},{"location":"apiStm/structStreamBufferDef__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structStreamBufferDef__t/#variable-pucbuffer","title":"variable pucBuffer","text":"<pre><code>uint8_t* StreamBufferDef_t::pucBuffer;\n</code></pre>"},{"location":"apiStm/structStreamBufferDef__t/#variable-ucflags","title":"variable ucFlags","text":"<pre><code>uint8_t StreamBufferDef_t::ucFlags;\n</code></pre>"},{"location":"apiStm/structStreamBufferDef__t/#variable-xhead","title":"variable xHead","text":"<pre><code>volatile size_t StreamBufferDef_t::xHead;\n</code></pre>"},{"location":"apiStm/structStreamBufferDef__t/#variable-xlength","title":"variable xLength","text":"<pre><code>size_t StreamBufferDef_t::xLength;\n</code></pre>"},{"location":"apiStm/structStreamBufferDef__t/#variable-xtail","title":"variable xTail","text":"<pre><code>volatile size_t StreamBufferDef_t::xTail;\n</code></pre>"},{"location":"apiStm/structStreamBufferDef__t/#variable-xtaskwaitingtoreceive","title":"variable xTaskWaitingToReceive","text":"<pre><code>volatile TaskHandle_t StreamBufferDef_t::xTaskWaitingToReceive;\n</code></pre>"},{"location":"apiStm/structStreamBufferDef__t/#variable-xtaskwaitingtosend","title":"variable xTaskWaitingToSend","text":"<pre><code>volatile TaskHandle_t StreamBufferDef_t::xTaskWaitingToSend;\n</code></pre>"},{"location":"apiStm/structStreamBufferDef__t/#variable-xtriggerlevelbytes","title":"variable xTriggerLevelBytes","text":"<pre><code>size_t StreamBufferDef_t::xTriggerLevelBytes;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/src/stream_buffer.c</code></p>"},{"location":"apiStm/classStreamBufferWrapper/","title":"Class StreamBufferWrapper","text":"<p>template &lt;size_t SizeInBytes&gt;</p> <p>ClassList &gt; StreamBufferWrapper</p>"},{"location":"apiStm/classStreamBufferWrapper/#public-functions","title":"Public Functions","text":"Type Name StreamBufferWrapper ()  size_t available () const void create (size_t xTriggerLevelBytes=1)  size_t freeSpace () const StreamBufferHandle_t handle () const size_t read (uint8_t * dst, size_t maxLen, TickType_t ticks_to_wait, BaseType_t * pxHigherPriorityTaskWoken=nullptr)  bool reset ()  size_t write (const uint8_t *const data, size_t len, TickType_t ticks_to_wait, BaseType_t * pxHigherPriorityTaskWoken=nullptr)  ~StreamBufferWrapper ()"},{"location":"apiStm/classStreamBufferWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/classStreamBufferWrapper/#function-streambufferwrapper","title":"function StreamBufferWrapper","text":"<pre><code>inline StreamBufferWrapper::StreamBufferWrapper () </code></pre>"},{"location":"apiStm/classStreamBufferWrapper/#function-available","title":"function available","text":"<pre><code>inline size_t StreamBufferWrapper::available () const\n</code></pre>"},{"location":"apiStm/classStreamBufferWrapper/#function-create","title":"function create","text":"<pre><code>inline void StreamBufferWrapper::create (\nsize_t xTriggerLevelBytes=1\n) </code></pre>"},{"location":"apiStm/classStreamBufferWrapper/#function-freespace","title":"function freeSpace","text":"<pre><code>inline size_t StreamBufferWrapper::freeSpace () const\n</code></pre>"},{"location":"apiStm/classStreamBufferWrapper/#function-handle","title":"function handle","text":"<pre><code>inline StreamBufferHandle_t StreamBufferWrapper::handle () const\n</code></pre>"},{"location":"apiStm/classStreamBufferWrapper/#function-read","title":"function read","text":"<pre><code>inline size_t StreamBufferWrapper::read (\nuint8_t * dst,\nsize_t maxLen,\nTickType_t ticks_to_wait,\nBaseType_t * pxHigherPriorityTaskWoken=nullptr\n) </code></pre>"},{"location":"apiStm/classStreamBufferWrapper/#function-reset","title":"function reset","text":"<pre><code>inline bool StreamBufferWrapper::reset () </code></pre>"},{"location":"apiStm/classStreamBufferWrapper/#function-write","title":"function write","text":"<pre><code>inline size_t StreamBufferWrapper::write (\nconst uint8_t *const data,\nsize_t len,\nTickType_t ticks_to_wait,\nBaseType_t * pxHigherPriorityTaskWoken=nullptr\n) </code></pre>"},{"location":"apiStm/classStreamBufferWrapper/#function-streambufferwrapper_1","title":"function ~StreamBufferWrapper","text":"<pre><code>inline StreamBufferWrapper::~StreamBufferWrapper () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/utils/StreamBufferWrapper.hpp</code></p>"},{"location":"apiStm/classTaskWrapper/","title":"Class TaskWrapper","text":"<p>template &lt;int StackSizeBytes&gt;</p> <p>ClassList &gt; TaskWrapper</p>"},{"location":"apiStm/classTaskWrapper/#public-functions","title":"Public Functions","text":"Type Name TaskWrapper ()  TaskHandle_t handle () const bool start (const char * name, UBaseType_t priority, std::function&lt; void()&gt; &amp;&amp; func)  ~TaskWrapper ()"},{"location":"apiStm/classTaskWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/classTaskWrapper/#function-taskwrapper-12","title":"function TaskWrapper [1/2]","text":"<pre><code>inline TaskWrapper::TaskWrapper () </code></pre>"},{"location":"apiStm/classTaskWrapper/#function-handle","title":"function handle","text":"<pre><code>inline TaskHandle_t TaskWrapper::handle () const\n</code></pre>"},{"location":"apiStm/classTaskWrapper/#function-start","title":"function start","text":"<pre><code>inline bool TaskWrapper::start (\nconst char * name,\nUBaseType_t priority,\nstd::function&lt; void()&gt; &amp;&amp; func\n) </code></pre>"},{"location":"apiStm/classTaskWrapper/#function-taskwrapper","title":"function ~TaskWrapper","text":"<pre><code>inline TaskWrapper::~TaskWrapper () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/utils/TaskWrapper.hpp</code></p>"},{"location":"apiStm/classTickTimer/","title":"Class TickTimer","text":"<p>ClassList &gt; TickTimer</p>"},{"location":"apiStm/classTickTimer/#public-functions","title":"Public Functions","text":"Type Name TickTimer ()  bool isActive () const bool poll ()  void restart (uint32_t delayMs)  void stop ()  ~TickTimer ()"},{"location":"apiStm/classTickTimer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/classTickTimer/#function-ticktimer","title":"function TickTimer","text":"<pre><code>inline TickTimer::TickTimer () </code></pre>"},{"location":"apiStm/classTickTimer/#function-isactive","title":"function isActive","text":"<pre><code>inline bool TickTimer::isActive () const\n</code></pre>"},{"location":"apiStm/classTickTimer/#function-poll","title":"function poll","text":"<pre><code>inline bool TickTimer::poll () </code></pre>"},{"location":"apiStm/classTickTimer/#function-restart","title":"function restart","text":"<pre><code>inline void TickTimer::restart (\nuint32_t delayMs\n) </code></pre>"},{"location":"apiStm/classTickTimer/#function-stop","title":"function stop","text":"<pre><code>inline void TickTimer::stop () </code></pre>"},{"location":"apiStm/classTickTimer/#function-ticktimer_1","title":"function ~TickTimer","text":"<pre><code>inline TickTimer::~TickTimer () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/utils/TickTimer.hpp</code></p>"},{"location":"apiStm/classXorShift/","title":"Class XorShift","text":"<p>ClassList &gt; XorShift</p> <p>Fast deterministic PRNG - https://en.wikipedia.org/wiki/Xorshift .</p> <ul> <li><code>#include &lt;XorShift.hpp&gt;</code></li> </ul>"},{"location":"apiStm/classXorShift/#public-functions","title":"Public Functions","text":"Type Name XorShift (uint32_t seed=0xb45d9453)  uint32_t next ()"},{"location":"apiStm/classXorShift/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/classXorShift/#function-xorshift","title":"function XorShift","text":"<pre><code>inline XorShift::XorShift (\nuint32_t seed=0xb45d9453\n) </code></pre>"},{"location":"apiStm/classXorShift/#function-next","title":"function next","text":"<pre><code>inline uint32_t XorShift::next () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/utils/XorShift.hpp</code></p>"},{"location":"apiStm/struct____debug__descriptors/","title":"Struct __debug_descriptors","text":"<p>ClassList &gt; __debug_descriptors</p> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/UsbCdcLink.cpp</code></p>"},{"location":"apiStm/struct__usbd__device/","title":"Struct _usbd_device","text":"<p>ClassList &gt; _usbd_device</p> <p>Represents a USB device data. </p> <ul> <li><code>#include &lt;usbd_core.h&gt;</code></li> </ul>"},{"location":"apiStm/struct__usbd__device/#public-attributes","title":"Public Attributes","text":"Type Name usbd_rqc_callback complete_callback USB control transfer completed callback function. usbd_cfg_callback config_callback USB set configuration callback function. usbd_ctl_callback control_callback USB control callback function. usbd_dsc_callback descriptor_callback USB get descriptor callback function. const struct usbd_driver * driver Represents a hardware USB driver call table. usbd_evt_callback endpoint array of the endpoint callbacks. usbd_evt_callback events array of the event callbacks. usbd_status status"},{"location":"apiStm/struct__usbd__device/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/struct__usbd__device/#variable-complete_callback","title":"variable complete_callback","text":"<pre><code>usbd_rqc_callback _usbd_device::complete_callback;\n</code></pre>"},{"location":"apiStm/struct__usbd__device/#variable-config_callback","title":"variable config_callback","text":"<pre><code>usbd_cfg_callback _usbd_device::config_callback;\n</code></pre>"},{"location":"apiStm/struct__usbd__device/#variable-control_callback","title":"variable control_callback","text":"<pre><code>usbd_ctl_callback _usbd_device::control_callback;\n</code></pre>"},{"location":"apiStm/struct__usbd__device/#variable-descriptor_callback","title":"variable descriptor_callback","text":"<pre><code>usbd_dsc_callback _usbd_device::descriptor_callback;\n</code></pre>"},{"location":"apiStm/struct__usbd__device/#variable-driver","title":"variable driver","text":"<pre><code>const struct usbd_driver* _usbd_device::driver;\n</code></pre>"},{"location":"apiStm/struct__usbd__device/#variable-endpoint","title":"variable endpoint","text":"<pre><code>usbd_evt_callback _usbd_device::endpoint[8];\n</code></pre>"},{"location":"apiStm/struct__usbd__device/#variable-events","title":"variable events","text":"<pre><code>usbd_evt_callback _usbd_device::events[usbd_evt_count];\n</code></pre>"},{"location":"apiStm/struct__usbd__device/#variable-status","title":"variable status","text":"<pre><code>usbd_status _usbd_device::status;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usbd_core.h</code></p>"},{"location":"apiStm/structcdc__config/","title":"Struct cdc_config","text":"<p>ClassList &gt; cdc_config</p>"},{"location":"apiStm/structcdc__config/#public-attributes","title":"Public Attributes","text":"Type Name struct usb_config_descriptor config struct usb_cdc_acm_desc tunnel_cdc_acm struct usb_cdc_header_desc tunnel_cdc_hdr struct usb_cdc_call_mgmt_desc tunnel_cdc_mgmt struct usb_cdc_union_desc tunnel_cdc_union struct usb_interface_descriptor tunnel_comm struct usb_endpoint_descriptor tunnel_comm_ep struct usb_iad_descriptor tunnel_comm_iad struct usb_interface_descriptor tunnel_data struct usb_endpoint_descriptor tunnel_data_eprx struct usb_endpoint_descriptor tunnel_data_eptx"},{"location":"apiStm/structcdc__config/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structcdc__config/#variable-config","title":"variable config","text":"<pre><code>struct usb_config_descriptor cdc_config::config;\n</code></pre>"},{"location":"apiStm/structcdc__config/#variable-tunnel_cdc_acm","title":"variable tunnel_cdc_acm","text":"<pre><code>struct usb_cdc_acm_desc cdc_config::tunnel_cdc_acm;\n</code></pre>"},{"location":"apiStm/structcdc__config/#variable-tunnel_cdc_hdr","title":"variable tunnel_cdc_hdr","text":"<pre><code>struct usb_cdc_header_desc cdc_config::tunnel_cdc_hdr;\n</code></pre>"},{"location":"apiStm/structcdc__config/#variable-tunnel_cdc_mgmt","title":"variable tunnel_cdc_mgmt","text":"<pre><code>struct usb_cdc_call_mgmt_desc cdc_config::tunnel_cdc_mgmt;\n</code></pre>"},{"location":"apiStm/structcdc__config/#variable-tunnel_cdc_union","title":"variable tunnel_cdc_union","text":"<pre><code>struct usb_cdc_union_desc cdc_config::tunnel_cdc_union;\n</code></pre>"},{"location":"apiStm/structcdc__config/#variable-tunnel_comm","title":"variable tunnel_comm","text":"<pre><code>struct usb_interface_descriptor cdc_config::tunnel_comm;\n</code></pre>"},{"location":"apiStm/structcdc__config/#variable-tunnel_comm_ep","title":"variable tunnel_comm_ep","text":"<pre><code>struct usb_endpoint_descriptor cdc_config::tunnel_comm_ep;\n</code></pre>"},{"location":"apiStm/structcdc__config/#variable-tunnel_comm_iad","title":"variable tunnel_comm_iad","text":"<pre><code>struct usb_iad_descriptor cdc_config::tunnel_comm_iad;\n</code></pre>"},{"location":"apiStm/structcdc__config/#variable-tunnel_data","title":"variable tunnel_data","text":"<pre><code>struct usb_interface_descriptor cdc_config::tunnel_data;\n</code></pre>"},{"location":"apiStm/structcdc__config/#variable-tunnel_data_eprx","title":"variable tunnel_data_eprx","text":"<pre><code>struct usb_endpoint_descriptor cdc_config::tunnel_data_eprx;\n</code></pre>"},{"location":"apiStm/structcdc__config/#variable-tunnel_data_eptx","title":"variable tunnel_data_eptx","text":"<pre><code>struct usb_endpoint_descriptor cdc_config::tunnel_data_eptx;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/UsbCdcLink.cpp</code></p>"},{"location":"apiStm/structcorCoRoutineControlBlock/","title":"Struct corCoRoutineControlBlock","text":"<p>ClassList &gt; corCoRoutineControlBlock</p>"},{"location":"apiStm/structcorCoRoutineControlBlock/#public-attributes","title":"Public Attributes","text":"Type Name crCOROUTINE_CODE pxCoRoutineFunction UBaseType_t uxIndex UBaseType_t uxPriority uint16_t uxState ListItem_t xEventListItem ListItem_t xGenericListItem"},{"location":"apiStm/structcorCoRoutineControlBlock/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structcorCoRoutineControlBlock/#variable-pxcoroutinefunction","title":"variable pxCoRoutineFunction","text":"<pre><code>crCOROUTINE_CODE corCoRoutineControlBlock::pxCoRoutineFunction;\n</code></pre>"},{"location":"apiStm/structcorCoRoutineControlBlock/#variable-uxindex","title":"variable uxIndex","text":"<pre><code>UBaseType_t corCoRoutineControlBlock::uxIndex;\n</code></pre>"},{"location":"apiStm/structcorCoRoutineControlBlock/#variable-uxpriority","title":"variable uxPriority","text":"<pre><code>UBaseType_t corCoRoutineControlBlock::uxPriority;\n</code></pre>"},{"location":"apiStm/structcorCoRoutineControlBlock/#variable-uxstate","title":"variable uxState","text":"<pre><code>uint16_t corCoRoutineControlBlock::uxState;\n</code></pre>"},{"location":"apiStm/structcorCoRoutineControlBlock/#variable-xeventlistitem","title":"variable xEventListItem","text":"<pre><code>ListItem_t corCoRoutineControlBlock::xEventListItem;\n</code></pre>"},{"location":"apiStm/structcorCoRoutineControlBlock/#variable-xgenericlistitem","title":"variable xGenericListItem","text":"<pre><code>ListItem_t corCoRoutineControlBlock::xGenericListItem;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/croutine.h</code></p>"},{"location":"apiStm/structmpu__t/","title":"Struct mpu_t","text":"<p>ClassList &gt; mpu_t</p>"},{"location":"apiStm/structmpu__t/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t buffer uint8_t devAddr"},{"location":"apiStm/structmpu__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structmpu__t/#variable-buffer","title":"variable buffer","text":"<pre><code>uint8_t mpu_t::buffer[14];\n</code></pre>"},{"location":"apiStm/structmpu__t/#variable-devaddr","title":"variable devAddr","text":"<pre><code>uint8_t mpu_t::devAddr;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/MpuController.hpp</code></p>"},{"location":"apiStm/structtskTaskControlBlock/","title":"Struct tskTaskControlBlock","text":"<p>ClassList &gt; tskTaskControlBlock</p>"},{"location":"apiStm/structtskTaskControlBlock/#public-attributes","title":"Public Attributes","text":"Type Name char pcTaskName StackType_t * pxStack StackType_t * pxTopOfStack UBaseType_t uxPriority ListItem_t xEventListItem ListItem_t xStateListItem"},{"location":"apiStm/structtskTaskControlBlock/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structtskTaskControlBlock/#variable-pctaskname","title":"variable pcTaskName","text":"<pre><code>char tskTaskControlBlock::pcTaskName[configMAX_TASK_NAME_LEN];\n</code></pre>"},{"location":"apiStm/structtskTaskControlBlock/#variable-pxstack","title":"variable pxStack","text":"<pre><code>StackType_t* tskTaskControlBlock::pxStack;\n</code></pre>"},{"location":"apiStm/structtskTaskControlBlock/#variable-pxtopofstack","title":"variable pxTopOfStack","text":"<pre><code>volatile StackType_t* tskTaskControlBlock::pxTopOfStack;\n</code></pre>"},{"location":"apiStm/structtskTaskControlBlock/#variable-uxpriority","title":"variable uxPriority","text":"<pre><code>UBaseType_t tskTaskControlBlock::uxPriority;\n</code></pre>"},{"location":"apiStm/structtskTaskControlBlock/#variable-xeventlistitem","title":"variable xEventListItem","text":"<pre><code>ListItem_t tskTaskControlBlock::xEventListItem;\n</code></pre>"},{"location":"apiStm/structtskTaskControlBlock/#variable-xstatelistitem","title":"variable xStateListItem","text":"<pre><code>ListItem_t tskTaskControlBlock::xStateListItem;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/src/tasks.c</code></p>"},{"location":"apiStm/structusb__cdc__acm__desc/","title":"Struct usb_cdc_acm_desc","text":"<p>ClassList &gt; usb_cdc_acm_desc</p> <p>Abstract Control Management Functional Descriptor. More...</p> <ul> <li><code>#include &lt;usb_cdc.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__cdc__acm__desc/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bDescriptorSubType Abstract Control Management functional descriptor subtype. uint8_t bDescriptorType CS_INTERFACE descriptor type. uint8_t bFunctionLength Size of this functional descriptor, in bytes. uint8_t bmCapabilities The capabilities that this configuration supports."},{"location":"apiStm/structusb__cdc__acm__desc/#detailed-description","title":"Detailed Description","text":"<p>The Abstract Control Management functional descriptor describes the commands supported by the Communication Class interface, as defined in Section 3.6.2, with the SubClass code of Abstract Control Model. It can only occur within the class-specific portion of an Interface descriptor. </p>"},{"location":"apiStm/structusb__cdc__acm__desc/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__cdc__acm__desc/#variable-bdescriptorsubtype","title":"variable bDescriptorSubType","text":"<pre><code>uint8_t usb_cdc_acm_desc::bDescriptorSubType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__acm__desc/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_cdc_acm_desc::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__acm__desc/#variable-bfunctionlength","title":"variable bFunctionLength","text":"<pre><code>uint8_t usb_cdc_acm_desc::bFunctionLength;\n</code></pre>"},{"location":"apiStm/structusb__cdc__acm__desc/#variable-bmcapabilities","title":"variable bmCapabilities","text":"<pre><code>uint8_t usb_cdc_acm_desc::bmCapabilities;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_cdc.h</code></p>"},{"location":"apiStm/structusb__cdc__call__mgmt__desc/","title":"Struct usb_cdc_call_mgmt_desc","text":"<p>ClassList &gt; usb_cdc_call_mgmt_desc</p> <p>Call Management Functional Descriptor. More...</p> <ul> <li><code>#include &lt;usb_cdc.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__cdc__call__mgmt__desc/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bDataInterface Interface number of Data Class interface optionally used for call management. uint8_t bDescriptorSubType Call Management functional descriptor subtype. uint8_t bDescriptorType CS_INTERFACE descriptor type. uint8_t bFunctionLength Size of this functional descriptor, in bytes. uint8_t bmCapabilities The call management capabilities that this configuration supports."},{"location":"apiStm/structusb__cdc__call__mgmt__desc/#detailed-description","title":"Detailed Description","text":"<p>The Call Management functional descriptor describes the processing of calls for the Communication Class interface. It can only occur within the class-specific portion of an Interface descriptor. </p>"},{"location":"apiStm/structusb__cdc__call__mgmt__desc/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__cdc__call__mgmt__desc/#variable-bdatainterface","title":"variable bDataInterface","text":"<pre><code>uint8_t usb_cdc_call_mgmt_desc::bDataInterface;\n</code></pre>"},{"location":"apiStm/structusb__cdc__call__mgmt__desc/#variable-bdescriptorsubtype","title":"variable bDescriptorSubType","text":"<pre><code>uint8_t usb_cdc_call_mgmt_desc::bDescriptorSubType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__call__mgmt__desc/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_cdc_call_mgmt_desc::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__call__mgmt__desc/#variable-bfunctionlength","title":"variable bFunctionLength","text":"<pre><code>uint8_t usb_cdc_call_mgmt_desc::bFunctionLength;\n</code></pre>"},{"location":"apiStm/structusb__cdc__call__mgmt__desc/#variable-bmcapabilities","title":"variable bmCapabilities","text":"<pre><code>uint8_t usb_cdc_call_mgmt_desc::bmCapabilities;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_cdc.h</code></p>"},{"location":"apiStm/structusb__cdc__country__desc/","title":"Struct usb_cdc_country_desc","text":"<p>ClassList &gt; usb_cdc_country_desc</p> <p>Country Selection Functional Descriptor. More...</p> <ul> <li><code>#include &lt;usb_cdc.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__cdc__country__desc/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bDescriptorSubType Country Selection Functional Descriptor. uint8_t bDescriptorType CS_INTERFACE descriptor type. uint8_t bFunctionLength Size of this functional descriptor, in bytes. uint8_t iCountryCodeRelDate Index of a string giving the release date for the implemented ISO 3166 Country Codes. uint8_t wCountyCode0 Country code in hexadecimal format."},{"location":"apiStm/structusb__cdc__country__desc/#detailed-description","title":"Detailed Description","text":"<p>The Country Selection functional descriptor identifies the countries in which the communication device is qualified to operate. The parameters of the network connection often vary from one country to another, especially in Europe. Also legal requirements impose certain restrictions on devices because of different regulations by the governing body of the network to which the device must adhere. This descriptor can only occur within the class-specific portion of an Interface descriptor and should only be provided to a master Communication Class interface of a union. The country codes used in the Country Selection Functional Descriptor are not the same as the country codes used in dialing international telephone calls. Implementers should refer to the ISO 3166 specification for more information. </p>"},{"location":"apiStm/structusb__cdc__country__desc/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__cdc__country__desc/#variable-bdescriptorsubtype","title":"variable bDescriptorSubType","text":"<pre><code>uint8_t usb_cdc_country_desc::bDescriptorSubType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__country__desc/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_cdc_country_desc::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__country__desc/#variable-bfunctionlength","title":"variable bFunctionLength","text":"<pre><code>uint8_t usb_cdc_country_desc::bFunctionLength;\n</code></pre>"},{"location":"apiStm/structusb__cdc__country__desc/#variable-icountrycodereldate","title":"variable iCountryCodeRelDate","text":"<pre><code>uint8_t usb_cdc_country_desc::iCountryCodeRelDate;\n</code></pre>"},{"location":"apiStm/structusb__cdc__country__desc/#variable-wcountycode0","title":"variable wCountyCode0","text":"<p>Country code in hexadecimal format. <pre><code>uint8_t usb_cdc_country_desc::wCountyCode0;\n</code></pre></p> <p>As defined in ISO 3166, release date as specified in iCountryCodeRelDate for the first supported country. </p> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_cdc.h</code></p>"},{"location":"apiStm/structusb__cdc__header__desc/","title":"Struct usb_cdc_header_desc","text":"<p>ClassList &gt; usb_cdc_header_desc</p> <p>Header Functional Descriptor. More...</p> <ul> <li><code>#include &lt;usb_cdc.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__cdc__header__desc/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bDescriptorSubType Header functional descriptor subtype. uint8_t bDescriptorType CS_INTERFACE descriptor type. uint8_t bFunctionLength Size of this descriptor in bytes. uint16_t bcdCDC USB CDC Specification release number in BCD."},{"location":"apiStm/structusb__cdc__header__desc/#detailed-description","title":"Detailed Description","text":"<p>Header Functional Descriptor marks the beginning of the concatenated set of functional descriptors for the interface. </p>"},{"location":"apiStm/structusb__cdc__header__desc/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__cdc__header__desc/#variable-bdescriptorsubtype","title":"variable bDescriptorSubType","text":"<pre><code>uint8_t usb_cdc_header_desc::bDescriptorSubType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__header__desc/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_cdc_header_desc::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__header__desc/#variable-bfunctionlength","title":"variable bFunctionLength","text":"<pre><code>uint8_t usb_cdc_header_desc::bFunctionLength;\n</code></pre>"},{"location":"apiStm/structusb__cdc__header__desc/#variable-bcdcdc","title":"variable bcdCDC","text":"<pre><code>uint16_t usb_cdc_header_desc::bcdCDC;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_cdc.h</code></p>"},{"location":"apiStm/structusb__cdc__line__coding/","title":"Struct usb_cdc_line_coding","text":"<p>ClassList &gt; usb_cdc_line_coding</p> <p>Line Coding Structure. </p> <ul> <li><code>#include &lt;usb_cdc.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__cdc__line__coding/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bCharFormat Stop bits. uint8_t bDataBits Data bits (5,6,7,8 or 16). uint8_t bParityType Parity. uint32_t dwDTERate Data terminal rate, in bits per second."},{"location":"apiStm/structusb__cdc__line__coding/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__cdc__line__coding/#variable-bcharformat","title":"variable bCharFormat","text":"<pre><code>uint8_t usb_cdc_line_coding::bCharFormat;\n</code></pre>"},{"location":"apiStm/structusb__cdc__line__coding/#variable-bdatabits","title":"variable bDataBits","text":"<pre><code>uint8_t usb_cdc_line_coding::bDataBits;\n</code></pre>"},{"location":"apiStm/structusb__cdc__line__coding/#variable-bparitytype","title":"variable bParityType","text":"<pre><code>uint8_t usb_cdc_line_coding::bParityType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__line__coding/#variable-dwdterate","title":"variable dwDTERate","text":"<pre><code>uint32_t usb_cdc_line_coding::dwDTERate;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_cdc.h</code></p>"},{"location":"apiStm/structusb__cdc__notification/","title":"Struct usb_cdc_notification","text":"<p>ClassList &gt; usb_cdc_notification</p> <p>Notification structure from CDC. </p> <ul> <li><code>#include &lt;usb_cdc.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__cdc__notification/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t Data Data payload. uint8_t bNotificationType Notification type. uint8_t bmRequestType This bitmapped field identifies the characteristics of the specific request. uint16_t wIndex Interface. uint16_t wLength Data payload length in bytes. uint16_t wValue Notification value."},{"location":"apiStm/structusb__cdc__notification/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__cdc__notification/#variable-data","title":"variable Data","text":"<pre><code>uint8_t usb_cdc_notification::Data[];\n</code></pre>"},{"location":"apiStm/structusb__cdc__notification/#variable-bnotificationtype","title":"variable bNotificationType","text":"<pre><code>uint8_t usb_cdc_notification::bNotificationType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__notification/#variable-bmrequesttype","title":"variable bmRequestType","text":"<pre><code>uint8_t usb_cdc_notification::bmRequestType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__notification/#variable-windex","title":"variable wIndex","text":"<pre><code>uint16_t usb_cdc_notification::wIndex;\n</code></pre>"},{"location":"apiStm/structusb__cdc__notification/#variable-wlength","title":"variable wLength","text":"<pre><code>uint16_t usb_cdc_notification::wLength;\n</code></pre>"},{"location":"apiStm/structusb__cdc__notification/#variable-wvalue","title":"variable wValue","text":"<pre><code>uint16_t usb_cdc_notification::wValue;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_cdc.h</code></p>"},{"location":"apiStm/structusb__cdc__union__desc/","title":"Struct usb_cdc_union_desc","text":"<p>ClassList &gt; usb_cdc_union_desc</p> <p>Union Functional Descriptor. More...</p> <ul> <li><code>#include &lt;usb_cdc.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__cdc__union__desc/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bDescriptorSubType Union Functional Descriptor. uint8_t bDescriptorType CS_INTERFACE descriptor type. uint8_t bFunctionLength Size of this functional descriptor, in bytes. uint8_t bMasterInterface0 The interface number of the CDC interface designated as the master or controlling interface for the union. uint8_t bSlaveInterface0 Interface number of first slave or associated interface in the union."},{"location":"apiStm/structusb__cdc__union__desc/#detailed-description","title":"Detailed Description","text":"<p>The Union functional descriptor describes the relationship between a group of interfaces that can be considered to form a functional unit. It can only occur within the class-specific portion of an Interface descriptor. One of the interfaces in the group is designated as a master or controlling interface for the group, and certain class-specific messages can be sent to this interface to act upon the group as a whole. </p>"},{"location":"apiStm/structusb__cdc__union__desc/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__cdc__union__desc/#variable-bdescriptorsubtype","title":"variable bDescriptorSubType","text":"<pre><code>uint8_t usb_cdc_union_desc::bDescriptorSubType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__union__desc/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_cdc_union_desc::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__union__desc/#variable-bfunctionlength","title":"variable bFunctionLength","text":"<pre><code>uint8_t usb_cdc_union_desc::bFunctionLength;\n</code></pre>"},{"location":"apiStm/structusb__cdc__union__desc/#variable-bmasterinterface0","title":"variable bMasterInterface0","text":"<pre><code>uint8_t usb_cdc_union_desc::bMasterInterface0;\n</code></pre>"},{"location":"apiStm/structusb__cdc__union__desc/#variable-bslaveinterface0","title":"variable bSlaveInterface0","text":"<pre><code>uint8_t usb_cdc_union_desc::bSlaveInterface0;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_cdc.h</code></p>"},{"location":"apiStm/structusb__config__descriptor/","title":"Struct usb_config_descriptor","text":"<p>ClassList &gt; usb_config_descriptor</p> <p>USB device configuration descriptor. More...</p> <ul> <li><code>#include &lt;usb_std.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__config__descriptor/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bConfigurationValue Configuration index of the current configuration. uint8_t bDescriptorType Configuration descriptor. uint8_t bLength Size of the descriptor, in bytes. uint8_t bMaxPower Maximum power consumption of the device. USB_CFG_POWER_MA() macro. uint8_t bNumInterfaces Total number of interfaces in the configuration. uint8_t bmAttributes Configuration attributes. uint8_t iConfiguration Index of a string descriptor describing the configuration. uint16_t wTotalLength Size of the configuration descriptor header, and all sub descriptors inside the configuration."},{"location":"apiStm/structusb__config__descriptor/#detailed-description","title":"Detailed Description","text":"<p>The configuration descriptor describes information about a specific device configuration. The descriptor contains a bConfigurationValue field with a value that, when used as a parameter to the SetConfiguration() request, causes the device to assume the described configuration. </p>"},{"location":"apiStm/structusb__config__descriptor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__config__descriptor/#variable-bconfigurationvalue","title":"variable bConfigurationValue","text":"<pre><code>uint8_t usb_config_descriptor::bConfigurationValue;\n</code></pre>"},{"location":"apiStm/structusb__config__descriptor/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_config_descriptor::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__config__descriptor/#variable-blength","title":"variable bLength","text":"<pre><code>uint8_t usb_config_descriptor::bLength;\n</code></pre>"},{"location":"apiStm/structusb__config__descriptor/#variable-bmaxpower","title":"variable bMaxPower","text":"<pre><code>uint8_t usb_config_descriptor::bMaxPower;\n</code></pre>"},{"location":"apiStm/structusb__config__descriptor/#variable-bnuminterfaces","title":"variable bNumInterfaces","text":"<pre><code>uint8_t usb_config_descriptor::bNumInterfaces;\n</code></pre>"},{"location":"apiStm/structusb__config__descriptor/#variable-bmattributes","title":"variable bmAttributes","text":"<p>Configuration attributes. <pre><code>uint8_t usb_config_descriptor::bmAttributes;\n</code></pre></p> <p>Comprised of a mask of <code>USB_CONFIG_ATTR_</code> masks. On all devices, this should include USB_CONFIG_ATTR_RESERVED at a minimum. </p>"},{"location":"apiStm/structusb__config__descriptor/#variable-iconfiguration","title":"variable iConfiguration","text":"<pre><code>uint8_t usb_config_descriptor::iConfiguration;\n</code></pre>"},{"location":"apiStm/structusb__config__descriptor/#variable-wtotallength","title":"variable wTotalLength","text":"<pre><code>uint16_t usb_config_descriptor::wTotalLength;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_std.h</code></p>"},{"location":"apiStm/structusb__debug__descriptor/","title":"Struct usb_debug_descriptor","text":"<p>ClassList &gt; usb_debug_descriptor</p> <p>USB debug descriptor. More...</p> <ul> <li><code>#include &lt;usb_std.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__debug__descriptor/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bDebugInEndpoint Endpoint number of the Debug Data IN endpoint. uint8_t bDebugOutEndpoint Endpoint number of the Debug Data OUTendpoint. uint8_t bDescriptorType Debug descriptor type. uint8_t bLength Size of the descriptor, in bytes."},{"location":"apiStm/structusb__debug__descriptor/#detailed-description","title":"Detailed Description","text":"<p>This descriptor is used to describe certain characteristics of the device that the host debug port driver needs to know to communicate with the device. Specifically, the debug descriptor lists the addresses of the endpoints that comprise the Debug Pipe. The endpoints are identified by endpoint number. </p>"},{"location":"apiStm/structusb__debug__descriptor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__debug__descriptor/#variable-bdebuginendpoint","title":"variable bDebugInEndpoint","text":"<pre><code>uint8_t usb_debug_descriptor::bDebugInEndpoint;\n</code></pre>"},{"location":"apiStm/structusb__debug__descriptor/#variable-bdebugoutendpoint","title":"variable bDebugOutEndpoint","text":"<pre><code>uint8_t usb_debug_descriptor::bDebugOutEndpoint;\n</code></pre>"},{"location":"apiStm/structusb__debug__descriptor/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_debug_descriptor::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__debug__descriptor/#variable-blength","title":"variable bLength","text":"<pre><code>uint8_t usb_debug_descriptor::bLength;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_std.h</code></p>"},{"location":"apiStm/structusb__device__descriptor/","title":"Struct usb_device_descriptor","text":"<p>ClassList &gt; usb_device_descriptor</p> <p>Represents a USB device descriptor. More...</p> <ul> <li><code>#include &lt;usb_std.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__device__descriptor/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bDescriptorType USB_DTYPE_DEVICE Device descriptor. uint8_t bDeviceClass USB device class. uint8_t bDeviceProtocol USB device protocol. uint8_t bDeviceSubClass USB device subclass. uint8_t bLength Size of the descriptor, in bytes. uint8_t bMaxPacketSize0 Size of the control endpoint's bank in bytes. uint8_t bNumConfigurations Total number of configurations supported by the device. uint16_t bcdDevice Product release (version) number. uint16_t bcdUSB BCD of the supported USB specification. uint8_t iManufacturer String index for the manufacturer's name. uint8_t iProduct String index for the product name/details. uint8_t iSerialNumber String index for the product serial number. uint16_t idProduct Unique product ID for the USB product. uint16_t idVendor Vendor ID for the USB product."},{"location":"apiStm/structusb__device__descriptor/#detailed-description","title":"Detailed Description","text":"<p>A device descriptor describes general information about a USB device. It includes information that applies globally to the device and all of the device\u2019s configurations. A USB device has only one device descriptor. A high-speed capable device that has different device information for full-speed and high-speed must also have a usb_qualifier_descriptor. </p>"},{"location":"apiStm/structusb__device__descriptor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__device__descriptor/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_device_descriptor::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-bdeviceclass","title":"variable bDeviceClass","text":"<pre><code>uint8_t usb_device_descriptor::bDeviceClass;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-bdeviceprotocol","title":"variable bDeviceProtocol","text":"<pre><code>uint8_t usb_device_descriptor::bDeviceProtocol;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-bdevicesubclass","title":"variable bDeviceSubClass","text":"<pre><code>uint8_t usb_device_descriptor::bDeviceSubClass;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-blength","title":"variable bLength","text":"<pre><code>uint8_t usb_device_descriptor::bLength;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-bmaxpacketsize0","title":"variable bMaxPacketSize0","text":"<pre><code>uint8_t usb_device_descriptor::bMaxPacketSize0;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-bnumconfigurations","title":"variable bNumConfigurations","text":"<pre><code>uint8_t usb_device_descriptor::bNumConfigurations;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-bcddevice","title":"variable bcdDevice","text":"<pre><code>uint16_t usb_device_descriptor::bcdDevice;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-bcdusb","title":"variable bcdUSB","text":"<pre><code>uint16_t usb_device_descriptor::bcdUSB;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-imanufacturer","title":"variable iManufacturer","text":"<pre><code>uint8_t usb_device_descriptor::iManufacturer;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-iproduct","title":"variable iProduct","text":"<pre><code>uint8_t usb_device_descriptor::iProduct;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-iserialnumber","title":"variable iSerialNumber","text":"<pre><code>uint8_t usb_device_descriptor::iSerialNumber;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-idproduct","title":"variable idProduct","text":"<pre><code>uint16_t usb_device_descriptor::idProduct;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-idvendor","title":"variable idVendor","text":"<pre><code>uint16_t usb_device_descriptor::idVendor;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_std.h</code></p>"},{"location":"apiStm/structusb__endpoint__descriptor/","title":"Struct usb_endpoint_descriptor","text":"<p>ClassList &gt; usb_endpoint_descriptor</p> <p>USB endpoint descriptor. More...</p> <ul> <li><code>#include &lt;usb_std.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__endpoint__descriptor/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bDescriptorType Endpoint descriptor. uint8_t bEndpointAddress Logical address of the endpoint within the device for the current configuration, including direction mask. uint8_t bInterval Polling interval in milliseconds for the endpoint if it is an INTERRUPT or ISOCHRONOUS type. uint8_t bLength Size of the descriptor, in bytes. uint8_t bmAttributes Endpoint attributes, USB_ENDPOINT_DEF . uint16_t wMaxPacketSize Size of the endpoint bank, in bytes. This indicates the maximum packet size that the endpoint can receive at a time."},{"location":"apiStm/structusb__endpoint__descriptor/#detailed-description","title":"Detailed Description","text":"<p>This descriptor contains the information required by the host to determine the bandwidth requirements of each endpoint. </p>"},{"location":"apiStm/structusb__endpoint__descriptor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__endpoint__descriptor/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_endpoint_descriptor::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__endpoint__descriptor/#variable-bendpointaddress","title":"variable bEndpointAddress","text":"<pre><code>uint8_t usb_endpoint_descriptor::bEndpointAddress;\n</code></pre>"},{"location":"apiStm/structusb__endpoint__descriptor/#variable-binterval","title":"variable bInterval","text":"<pre><code>uint8_t usb_endpoint_descriptor::bInterval;\n</code></pre>"},{"location":"apiStm/structusb__endpoint__descriptor/#variable-blength","title":"variable bLength","text":"<pre><code>uint8_t usb_endpoint_descriptor::bLength;\n</code></pre>"},{"location":"apiStm/structusb__endpoint__descriptor/#variable-bmattributes","title":"variable bmAttributes","text":"<pre><code>uint8_t usb_endpoint_descriptor::bmAttributes;\n</code></pre>"},{"location":"apiStm/structusb__endpoint__descriptor/#variable-wmaxpacketsize","title":"variable wMaxPacketSize","text":"<pre><code>uint16_t usb_endpoint_descriptor::wMaxPacketSize;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_std.h</code></p>"},{"location":"apiStm/structusb__header__descriptor/","title":"Struct usb_header_descriptor","text":"<p>ClassList &gt; usb_header_descriptor</p> <p>common USB descriptor header </p> <ul> <li><code>#include &lt;usb_std.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__header__descriptor/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bDescriptorType Type of the descriptor. uint8_t bLength Size of the descriptor, in bytes."},{"location":"apiStm/structusb__header__descriptor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__header__descriptor/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_header_descriptor::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__header__descriptor/#variable-blength","title":"variable bLength","text":"<pre><code>uint8_t usb_header_descriptor::bLength;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_std.h</code></p>"},{"location":"apiStm/structusb__iad__descriptor/","title":"Struct usb_iad_descriptor","text":"<p>ClassList &gt; usb_iad_descriptor</p> <p>USB interface association descriptor. More...</p> <ul> <li><code>#include &lt;usb_std.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__iad__descriptor/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bDescriptorType IAD descriptor. uint8_t bFirstInterface Index of the first associated interface. uint8_t bFunctionClass Function class ID. uint8_t bFunctionProtocol Function protocol ID. uint8_t bFunctionSubClass Function subclass ID. uint8_t bInterfaceCount Total number of associated interfaces. uint8_t bLength Size of the descriptor, in bytes. uint8_t iFunction Index of the string descriptor describing the interface association."},{"location":"apiStm/structusb__iad__descriptor/#detailed-description","title":"Detailed Description","text":"<p>USB interface association descriptor (IAD) allows the device to group interfaces that belong to a function. </p>"},{"location":"apiStm/structusb__iad__descriptor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__iad__descriptor/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_iad_descriptor::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__iad__descriptor/#variable-bfirstinterface","title":"variable bFirstInterface","text":"<pre><code>uint8_t usb_iad_descriptor::bFirstInterface;\n</code></pre>"},{"location":"apiStm/structusb__iad__descriptor/#variable-bfunctionclass","title":"variable bFunctionClass","text":"<pre><code>uint8_t usb_iad_descriptor::bFunctionClass;\n</code></pre>"},{"location":"apiStm/structusb__iad__descriptor/#variable-bfunctionprotocol","title":"variable bFunctionProtocol","text":"<pre><code>uint8_t usb_iad_descriptor::bFunctionProtocol;\n</code></pre>"},{"location":"apiStm/structusb__iad__descriptor/#variable-bfunctionsubclass","title":"variable bFunctionSubClass","text":"<pre><code>uint8_t usb_iad_descriptor::bFunctionSubClass;\n</code></pre>"},{"location":"apiStm/structusb__iad__descriptor/#variable-binterfacecount","title":"variable bInterfaceCount","text":"<pre><code>uint8_t usb_iad_descriptor::bInterfaceCount;\n</code></pre>"},{"location":"apiStm/structusb__iad__descriptor/#variable-blength","title":"variable bLength","text":"<pre><code>uint8_t usb_iad_descriptor::bLength;\n</code></pre>"},{"location":"apiStm/structusb__iad__descriptor/#variable-ifunction","title":"variable iFunction","text":"<pre><code>uint8_t usb_iad_descriptor::iFunction;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_std.h</code></p>"},{"location":"apiStm/structusb__interface__descriptor/","title":"Struct usb_interface_descriptor","text":"<p>ClassList &gt; usb_interface_descriptor</p> <p>USB interface descriptor. More...</p> <ul> <li><code>#include &lt;usb_std.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__interface__descriptor/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bAlternateSetting Alternate setting for the interface number. uint8_t bDescriptorType Interface descriptor. uint8_t bInterfaceClass Interface class ID. uint8_t bInterfaceNumber Index of the interface in the current configuration. uint8_t bInterfaceProtocol Interface protocol ID. uint8_t bInterfaceSubClass Interface subclass ID. uint8_t bLength Size of the descriptor, in bytes. uint8_t bNumEndpoints Total number of endpoints in the interface. uint8_t iInterface Index of the string descriptor describing the interface."},{"location":"apiStm/structusb__interface__descriptor/#detailed-description","title":"Detailed Description","text":"<p>The interface descriptor describes a specific interface within a configuration. A configuration provides one or more interfaces, each with zero or more endpoint descriptors describing a unique set of endpoints within the configuration. </p>"},{"location":"apiStm/structusb__interface__descriptor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__interface__descriptor/#variable-balternatesetting","title":"variable bAlternateSetting","text":"<pre><code>uint8_t usb_interface_descriptor::bAlternateSetting;\n</code></pre>"},{"location":"apiStm/structusb__interface__descriptor/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_interface_descriptor::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__interface__descriptor/#variable-binterfaceclass","title":"variable bInterfaceClass","text":"<pre><code>uint8_t usb_interface_descriptor::bInterfaceClass;\n</code></pre>"},{"location":"apiStm/structusb__interface__descriptor/#variable-binterfacenumber","title":"variable bInterfaceNumber","text":"<pre><code>uint8_t usb_interface_descriptor::bInterfaceNumber;\n</code></pre>"},{"location":"apiStm/structusb__interface__descriptor/#variable-binterfaceprotocol","title":"variable bInterfaceProtocol","text":"<pre><code>uint8_t usb_interface_descriptor::bInterfaceProtocol;\n</code></pre>"},{"location":"apiStm/structusb__interface__descriptor/#variable-binterfacesubclass","title":"variable bInterfaceSubClass","text":"<pre><code>uint8_t usb_interface_descriptor::bInterfaceSubClass;\n</code></pre>"},{"location":"apiStm/structusb__interface__descriptor/#variable-blength","title":"variable bLength","text":"<pre><code>uint8_t usb_interface_descriptor::bLength;\n</code></pre>"},{"location":"apiStm/structusb__interface__descriptor/#variable-bnumendpoints","title":"variable bNumEndpoints","text":"<pre><code>uint8_t usb_interface_descriptor::bNumEndpoints;\n</code></pre>"},{"location":"apiStm/structusb__interface__descriptor/#variable-iinterface","title":"variable iInterface","text":"<pre><code>uint8_t usb_interface_descriptor::iInterface;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_std.h</code></p>"},{"location":"apiStm/structusb__qualifier__descriptor/","title":"Struct usb_qualifier_descriptor","text":"<p>ClassList &gt; usb_qualifier_descriptor</p> <p>USB device qualifier descriptor. More...</p> <ul> <li><code>#include &lt;usb_std.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__qualifier__descriptor/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bDescriptorType Qualifier descriptor. uint8_t bDeviceClass USB device class. uint8_t bDeviceProtocol USB device protocol. uint8_t bDeviceSubClass USB device subclass. uint8_t bLength Size of the descriptor, in bytes. uint8_t bMaxPacketSize0 Size of the control endpoint's bank in bytes. uint8_t bNumConfigurations Total number of configurations supported by the device. uint8_t bReserved Reserved for future use, must be 0. uint16_t bcdUSB BCD of the supported USB specification."},{"location":"apiStm/structusb__qualifier__descriptor/#detailed-description","title":"Detailed Description","text":"<p>The device_qualifier descriptor describes information about a high-speed capable device that would change if the device were operating at the other speed. For example, if the device is currently operating at full-speed, the device qualifier returns information about how it would operate at high-speed and vice-versa. </p>"},{"location":"apiStm/structusb__qualifier__descriptor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__qualifier__descriptor/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_qualifier_descriptor::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__qualifier__descriptor/#variable-bdeviceclass","title":"variable bDeviceClass","text":"<pre><code>uint8_t usb_qualifier_descriptor::bDeviceClass;\n</code></pre>"},{"location":"apiStm/structusb__qualifier__descriptor/#variable-bdeviceprotocol","title":"variable bDeviceProtocol","text":"<pre><code>uint8_t usb_qualifier_descriptor::bDeviceProtocol;\n</code></pre>"},{"location":"apiStm/structusb__qualifier__descriptor/#variable-bdevicesubclass","title":"variable bDeviceSubClass","text":"<pre><code>uint8_t usb_qualifier_descriptor::bDeviceSubClass;\n</code></pre>"},{"location":"apiStm/structusb__qualifier__descriptor/#variable-blength","title":"variable bLength","text":"<pre><code>uint8_t usb_qualifier_descriptor::bLength;\n</code></pre>"},{"location":"apiStm/structusb__qualifier__descriptor/#variable-bmaxpacketsize0","title":"variable bMaxPacketSize0","text":"<pre><code>uint8_t usb_qualifier_descriptor::bMaxPacketSize0;\n</code></pre>"},{"location":"apiStm/structusb__qualifier__descriptor/#variable-bnumconfigurations","title":"variable bNumConfigurations","text":"<pre><code>uint8_t usb_qualifier_descriptor::bNumConfigurations;\n</code></pre>"},{"location":"apiStm/structusb__qualifier__descriptor/#variable-breserved","title":"variable bReserved","text":"<pre><code>uint8_t usb_qualifier_descriptor::bReserved;\n</code></pre>"},{"location":"apiStm/structusb__qualifier__descriptor/#variable-bcdusb","title":"variable bcdUSB","text":"<pre><code>uint16_t usb_qualifier_descriptor::bcdUSB;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_std.h</code></p>"},{"location":"apiStm/structusb__string__descriptor/","title":"Struct usb_string_descriptor","text":"<p>ClassList &gt; usb_string_descriptor</p> <p>USB string descriptor. More...</p> <ul> <li><code>#include &lt;usb_std.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__string__descriptor/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bDescriptorType String descriptor type. uint8_t bLength Size of the descriptor, in bytes. uint16_t wString String data, as unicode characters or array of USB standard LANGID codes codes."},{"location":"apiStm/structusb__string__descriptor/#detailed-description","title":"Detailed Description","text":"<p>String descriptors are referenced by their one-based index number. A string descriptor contains one or more not NULL-terminated Unicode strings. </p> <p>Note:</p> <p>String descriptors are optional. if a device does not support string descriptors, all references to string descriptors within device, configuration, and interface descriptors must be reset to zero. </p>"},{"location":"apiStm/structusb__string__descriptor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__string__descriptor/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_string_descriptor::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__string__descriptor/#variable-blength","title":"variable bLength","text":"<pre><code>uint8_t usb_string_descriptor::bLength;\n</code></pre>"},{"location":"apiStm/structusb__string__descriptor/#variable-wstring","title":"variable wString","text":"<pre><code>uint16_t usb_string_descriptor::wString[];\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_std.h</code></p>"},{"location":"apiStm/structusbd__ctlreq/","title":"Struct usbd_ctlreq","text":"<p>ClassList &gt; usbd_ctlreq</p> <p>Represents generic USB control request. </p> <ul> <li><code>#include &lt;usbd_core.h&gt;</code></li> </ul>"},{"location":"apiStm/structusbd__ctlreq/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bRequest This field specifies the particular request. uint8_t bmRequestType This bitmapped field identifies the characteristics of the specific request. uint8_t data Data payload. uint16_t wIndex It is used to pass a parameter to the device, specific to the request. uint16_t wLength This field specifies the length of the data transferred during the second phase of the control transfer. uint16_t wValue It is used to pass a parameter to the device, specific to the request."},{"location":"apiStm/structusbd__ctlreq/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusbd__ctlreq/#variable-brequest","title":"variable bRequest","text":"<pre><code>uint8_t usbd_ctlreq::bRequest;\n</code></pre>"},{"location":"apiStm/structusbd__ctlreq/#variable-bmrequesttype","title":"variable bmRequestType","text":"<pre><code>uint8_t usbd_ctlreq::bmRequestType;\n</code></pre>"},{"location":"apiStm/structusbd__ctlreq/#variable-data","title":"variable data","text":"<pre><code>uint8_t usbd_ctlreq::data[];\n</code></pre>"},{"location":"apiStm/structusbd__ctlreq/#variable-windex","title":"variable wIndex","text":"<pre><code>uint16_t usbd_ctlreq::wIndex;\n</code></pre>"},{"location":"apiStm/structusbd__ctlreq/#variable-wlength","title":"variable wLength","text":"<pre><code>uint16_t usbd_ctlreq::wLength;\n</code></pre>"},{"location":"apiStm/structusbd__ctlreq/#variable-wvalue","title":"variable wValue","text":"<pre><code>uint16_t usbd_ctlreq::wValue;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usbd_core.h</code></p>"},{"location":"apiStm/structusbd__driver/","title":"Struct usbd_driver","text":"<p>ClassList &gt; usbd_driver</p> <p>Represents a hardware USB driver call table. </p> <ul> <li><code>#include &lt;usbd_core.h&gt;</code></li> </ul>"},{"location":"apiStm/structusbd__driver/#public-attributes","title":"Public Attributes","text":"Type Name usbd_hw_connect connect usbd_hw_enable enable Enables or disables USB hardware. usbd_hw_ep_config ep_config Configures endpoint. usbd_hw_ep_deconfig ep_deconfig De-configures, cleans and disables endpoint. usbd_hw_ep_isstalled ep_isstalled Checks endpoint for stalled state. usbd_hw_ep_read ep_read Reads data from OUT or control endpoint. usbd_hw_ep_setstall ep_setstall usbd_hw_ep_write ep_write Writes data to IN or control endpoint. usbd_hw_get_frameno frame_no Gets frame number from usb hardware. usbd_hw_get_serialno get_serialno_desc Makes a string descriptor contains unique serial number from hardware ID's. usbd_hw_getinfo getinfo Get USB device status and capabilities. usbd_hw_poll poll Polls USB hardware for the events. usbd_hw_setaddr setaddr Sets USB hardware address."},{"location":"apiStm/structusbd__driver/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusbd__driver/#variable-connect","title":"variable connect","text":"<pre><code>usbd_hw_connect usbd_driver::connect;\n</code></pre>"},{"location":"apiStm/structusbd__driver/#variable-enable","title":"variable enable","text":"<pre><code>usbd_hw_enable usbd_driver::enable;\n</code></pre>"},{"location":"apiStm/structusbd__driver/#variable-ep_config","title":"variable ep_config","text":"<pre><code>usbd_hw_ep_config usbd_driver::ep_config;\n</code></pre>"},{"location":"apiStm/structusbd__driver/#variable-ep_deconfig","title":"variable ep_deconfig","text":"<pre><code>usbd_hw_ep_deconfig usbd_driver::ep_deconfig;\n</code></pre>"},{"location":"apiStm/structusbd__driver/#variable-ep_isstalled","title":"variable ep_isstalled","text":"<pre><code>usbd_hw_ep_isstalled usbd_driver::ep_isstalled;\n</code></pre>"},{"location":"apiStm/structusbd__driver/#variable-ep_read","title":"variable ep_read","text":"<pre><code>usbd_hw_ep_read usbd_driver::ep_read;\n</code></pre>"},{"location":"apiStm/structusbd__driver/#variable-ep_setstall","title":"variable ep_setstall","text":"<pre><code>usbd_hw_ep_setstall usbd_driver::ep_setstall;\n</code></pre>"},{"location":"apiStm/structusbd__driver/#variable-ep_write","title":"variable ep_write","text":"<pre><code>usbd_hw_ep_write usbd_driver::ep_write;\n</code></pre>"},{"location":"apiStm/structusbd__driver/#variable-frame_no","title":"variable frame_no","text":"<pre><code>usbd_hw_get_frameno usbd_driver::frame_no;\n</code></pre>"},{"location":"apiStm/structusbd__driver/#variable-get_serialno_desc","title":"variable get_serialno_desc","text":"<pre><code>usbd_hw_get_serialno usbd_driver::get_serialno_desc;\n</code></pre>"},{"location":"apiStm/structusbd__driver/#variable-getinfo","title":"variable getinfo","text":"<pre><code>usbd_hw_getinfo usbd_driver::getinfo;\n</code></pre>"},{"location":"apiStm/structusbd__driver/#variable-poll","title":"variable poll","text":"<pre><code>usbd_hw_poll usbd_driver::poll;\n</code></pre>"},{"location":"apiStm/structusbd__driver/#variable-setaddr","title":"variable setaddr","text":"<pre><code>usbd_hw_setaddr usbd_driver::setaddr;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usbd_core.h</code></p>"},{"location":"apiStm/structusbd__status/","title":"Struct usbd_status","text":"<p>ClassList &gt; usbd_status</p> <p>More...</p> <ul> <li><code>#include &lt;usbd_core.h&gt;</code></li> </ul>"},{"location":"apiStm/structusbd__status/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t control_state Current usbd_ctl_state . void * data_buf Pointer to data buffer used for control requests. uint16_t data_count Count remained data for control request. uint16_t data_maxsize Size of the data buffer for control requests. void * data_ptr Pointer to current data for control request. uint8_t device_cfg Current device configuration number. uint8_t device_state Current usbd_machine_state . uint8_t ep0size Size of the control endpoint."},{"location":"apiStm/structusbd__status/#detailed-description","title":"Detailed Description","text":"<p>USB device status data. </p>"},{"location":"apiStm/structusbd__status/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusbd__status/#variable-control_state","title":"variable control_state","text":"<pre><code>uint8_t usbd_status::control_state;\n</code></pre>"},{"location":"apiStm/structusbd__status/#variable-data_buf","title":"variable data_buf","text":"<pre><code>void* usbd_status::data_buf;\n</code></pre>"},{"location":"apiStm/structusbd__status/#variable-data_count","title":"variable data_count","text":"<pre><code>uint16_t usbd_status::data_count;\n</code></pre>"},{"location":"apiStm/structusbd__status/#variable-data_maxsize","title":"variable data_maxsize","text":"<pre><code>uint16_t usbd_status::data_maxsize;\n</code></pre>"},{"location":"apiStm/structusbd__status/#variable-data_ptr","title":"variable data_ptr","text":"<pre><code>void* usbd_status::data_ptr;\n</code></pre>"},{"location":"apiStm/structusbd__status/#variable-device_cfg","title":"variable device_cfg","text":"<pre><code>uint8_t usbd_status::device_cfg;\n</code></pre>"},{"location":"apiStm/structusbd__status/#variable-device_state","title":"variable device_state","text":"<pre><code>uint8_t usbd_status::device_state;\n</code></pre>"},{"location":"apiStm/structusbd__status/#variable-ep0size","title":"variable ep0size","text":"<pre><code>uint8_t usbd_status::ep0size;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usbd_core.h</code></p>"},{"location":"apiStm/structxHeapStats/","title":"Struct xHeapStats","text":"<p>ClassList &gt; xHeapStats</p>"},{"location":"apiStm/structxHeapStats/#public-attributes","title":"Public Attributes","text":"Type Name size_t xAvailableHeapSpaceInBytes size_t xMinimumEverFreeBytesRemaining size_t xNumberOfFreeBlocks size_t xNumberOfSuccessfulAllocations size_t xNumberOfSuccessfulFrees size_t xSizeOfLargestFreeBlockInBytes size_t xSizeOfSmallestFreeBlockInBytes"},{"location":"apiStm/structxHeapStats/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structxHeapStats/#variable-xavailableheapspaceinbytes","title":"variable xAvailableHeapSpaceInBytes","text":"<pre><code>size_t xHeapStats::xAvailableHeapSpaceInBytes;\n</code></pre>"},{"location":"apiStm/structxHeapStats/#variable-xminimumeverfreebytesremaining","title":"variable xMinimumEverFreeBytesRemaining","text":"<pre><code>size_t xHeapStats::xMinimumEverFreeBytesRemaining;\n</code></pre>"},{"location":"apiStm/structxHeapStats/#variable-xnumberoffreeblocks","title":"variable xNumberOfFreeBlocks","text":"<pre><code>size_t xHeapStats::xNumberOfFreeBlocks;\n</code></pre>"},{"location":"apiStm/structxHeapStats/#variable-xnumberofsuccessfulallocations","title":"variable xNumberOfSuccessfulAllocations","text":"<pre><code>size_t xHeapStats::xNumberOfSuccessfulAllocations;\n</code></pre>"},{"location":"apiStm/structxHeapStats/#variable-xnumberofsuccessfulfrees","title":"variable xNumberOfSuccessfulFrees","text":"<pre><code>size_t xHeapStats::xNumberOfSuccessfulFrees;\n</code></pre>"},{"location":"apiStm/structxHeapStats/#variable-xsizeoflargestfreeblockinbytes","title":"variable xSizeOfLargestFreeBlockInBytes","text":"<pre><code>size_t xHeapStats::xSizeOfLargestFreeBlockInBytes;\n</code></pre>"},{"location":"apiStm/structxHeapStats/#variable-xsizeofsmallestfreeblockinbytes","title":"variable xSizeOfSmallestFreeBlockInBytes","text":"<pre><code>size_t xHeapStats::xSizeOfSmallestFreeBlockInBytes;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/portable.h</code></p>"},{"location":"apiStm/structxLIST/","title":"Struct xLIST","text":"<p>ClassList &gt; xLIST</p>"},{"location":"apiStm/structxLIST/#public-attributes","title":"Public Attributes","text":"Type Name ListItem_t *configLIST_VOLATILE pxIndex listFIRST_LIST_INTEGRITY_CHECK_VALUE volatile UBaseType_t uxNumberOfItems MiniListItem_t xListEnd"},{"location":"apiStm/structxLIST/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structxLIST/#variable-pxindex","title":"variable pxIndex","text":"<pre><code>ListItem_t* configLIST_VOLATILE xLIST::pxIndex;\n</code></pre>"},{"location":"apiStm/structxLIST/#variable-uxnumberofitems","title":"variable uxNumberOfItems","text":"<pre><code>listFIRST_LIST_INTEGRITY_CHECK_VALUE volatile UBaseType_t xLIST::uxNumberOfItems;\n</code></pre>"},{"location":"apiStm/structxLIST/#variable-xlistend","title":"variable xListEnd","text":"<pre><code>MiniListItem_t xLIST::xListEnd;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/list.h</code></p>"},{"location":"apiStm/structxLIST__ITEM/","title":"Struct xLIST_ITEM","text":"<p>ClassList &gt; xLIST_ITEM</p>"},{"location":"apiStm/structxLIST__ITEM/#public-attributes","title":"Public Attributes","text":"Type Name void * pvOwner struct xLIST *configLIST_VOLATILE pxContainer struct xLIST_ITEM *configLIST_VOLATILE pxNext struct xLIST_ITEM *configLIST_VOLATILE pxPrevious listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE configLIST_VOLATILE TickType_t xItemValue"},{"location":"apiStm/structxLIST__ITEM/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structxLIST__ITEM/#variable-pvowner","title":"variable pvOwner","text":"<pre><code>void* xLIST_ITEM::pvOwner;\n</code></pre>"},{"location":"apiStm/structxLIST__ITEM/#variable-pxcontainer","title":"variable pxContainer","text":"<pre><code>struct xLIST* configLIST_VOLATILE xLIST_ITEM::pxContainer;\n</code></pre>"},{"location":"apiStm/structxLIST__ITEM/#variable-pxnext","title":"variable pxNext","text":"<pre><code>struct xLIST_ITEM* configLIST_VOLATILE xLIST_ITEM::pxNext;\n</code></pre>"},{"location":"apiStm/structxLIST__ITEM/#variable-pxprevious","title":"variable pxPrevious","text":"<pre><code>struct xLIST_ITEM* configLIST_VOLATILE xLIST_ITEM::pxPrevious;\n</code></pre>"},{"location":"apiStm/structxLIST__ITEM/#variable-xitemvalue","title":"variable xItemValue","text":"<pre><code>listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE configLIST_VOLATILE TickType_t xLIST_ITEM::xItemValue;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/list.h</code></p>"},{"location":"apiStm/structxMEMORY__REGION/","title":"Struct xMEMORY_REGION","text":"<p>ClassList &gt; xMEMORY_REGION</p>"},{"location":"apiStm/structxMEMORY__REGION/#public-attributes","title":"Public Attributes","text":"Type Name void * pvBaseAddress uint32_t ulLengthInBytes uint32_t ulParameters"},{"location":"apiStm/structxMEMORY__REGION/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structxMEMORY__REGION/#variable-pvbaseaddress","title":"variable pvBaseAddress","text":"<pre><code>void* xMEMORY_REGION::pvBaseAddress;\n</code></pre>"},{"location":"apiStm/structxMEMORY__REGION/#variable-ullengthinbytes","title":"variable ulLengthInBytes","text":"<pre><code>uint32_t xMEMORY_REGION::ulLengthInBytes;\n</code></pre>"},{"location":"apiStm/structxMEMORY__REGION/#variable-ulparameters","title":"variable ulParameters","text":"<pre><code>uint32_t xMEMORY_REGION::ulParameters;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/task.h</code></p>"},{"location":"apiStm/structxMINI__LIST__ITEM/","title":"Struct xMINI_LIST_ITEM","text":"<p>ClassList &gt; xMINI_LIST_ITEM</p>"},{"location":"apiStm/structxMINI__LIST__ITEM/#public-attributes","title":"Public Attributes","text":"Type Name struct xLIST_ITEM *configLIST_VOLATILE pxNext struct xLIST_ITEM *configLIST_VOLATILE pxPrevious listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE configLIST_VOLATILE TickType_t xItemValue"},{"location":"apiStm/structxMINI__LIST__ITEM/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structxMINI__LIST__ITEM/#variable-pxnext","title":"variable pxNext","text":"<pre><code>struct xLIST_ITEM* configLIST_VOLATILE xMINI_LIST_ITEM::pxNext;\n</code></pre>"},{"location":"apiStm/structxMINI__LIST__ITEM/#variable-pxprevious","title":"variable pxPrevious","text":"<pre><code>struct xLIST_ITEM* configLIST_VOLATILE xMINI_LIST_ITEM::pxPrevious;\n</code></pre>"},{"location":"apiStm/structxMINI__LIST__ITEM/#variable-xitemvalue","title":"variable xItemValue","text":"<pre><code>listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE configLIST_VOLATILE TickType_t xMINI_LIST_ITEM::xItemValue;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/list.h</code></p>"},{"location":"apiStm/structxSTATIC__EVENT__GROUP/","title":"Struct xSTATIC_EVENT_GROUP","text":"<p>ClassList &gt; xSTATIC_EVENT_GROUP</p>"},{"location":"apiStm/structxSTATIC__EVENT__GROUP/#public-attributes","title":"Public Attributes","text":"Type Name TickType_t xDummy1 StaticList_t xDummy2"},{"location":"apiStm/structxSTATIC__EVENT__GROUP/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structxSTATIC__EVENT__GROUP/#variable-xdummy1","title":"variable xDummy1","text":"<pre><code>TickType_t xSTATIC_EVENT_GROUP::xDummy1;\n</code></pre>"},{"location":"apiStm/structxSTATIC__EVENT__GROUP/#variable-xdummy2","title":"variable xDummy2","text":"<pre><code>StaticList_t xSTATIC_EVENT_GROUP::xDummy2;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/FreeRTOS.h</code></p>"},{"location":"apiStm/structxSTATIC__LIST/","title":"Struct xSTATIC_LIST","text":"<p>ClassList &gt; xSTATIC_LIST</p>"},{"location":"apiStm/structxSTATIC__LIST/#public-attributes","title":"Public Attributes","text":"Type Name void * pvDummy3 UBaseType_t uxDummy2 StaticMiniListItem_t xDummy4"},{"location":"apiStm/structxSTATIC__LIST/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structxSTATIC__LIST/#variable-pvdummy3","title":"variable pvDummy3","text":"<pre><code>void* xSTATIC_LIST::pvDummy3;\n</code></pre>"},{"location":"apiStm/structxSTATIC__LIST/#variable-uxdummy2","title":"variable uxDummy2","text":"<pre><code>UBaseType_t xSTATIC_LIST::uxDummy2;\n</code></pre>"},{"location":"apiStm/structxSTATIC__LIST/#variable-xdummy4","title":"variable xDummy4","text":"<pre><code>StaticMiniListItem_t xSTATIC_LIST::xDummy4;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/FreeRTOS.h</code></p>"},{"location":"apiStm/structxSTATIC__LIST__ITEM/","title":"Struct xSTATIC_LIST_ITEM","text":"<p>ClassList &gt; xSTATIC_LIST_ITEM</p>"},{"location":"apiStm/structxSTATIC__LIST__ITEM/#public-attributes","title":"Public Attributes","text":"Type Name void * pvDummy3 TickType_t xDummy2"},{"location":"apiStm/structxSTATIC__LIST__ITEM/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structxSTATIC__LIST__ITEM/#variable-pvdummy3","title":"variable pvDummy3","text":"<pre><code>void* xSTATIC_LIST_ITEM::pvDummy3[4];\n</code></pre>"},{"location":"apiStm/structxSTATIC__LIST__ITEM/#variable-xdummy2","title":"variable xDummy2","text":"<pre><code>TickType_t xSTATIC_LIST_ITEM::xDummy2;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/FreeRTOS.h</code></p>"},{"location":"apiStm/structxSTATIC__MINI__LIST__ITEM/","title":"Struct xSTATIC_MINI_LIST_ITEM","text":"<p>ClassList &gt; xSTATIC_MINI_LIST_ITEM</p>"},{"location":"apiStm/structxSTATIC__MINI__LIST__ITEM/#public-attributes","title":"Public Attributes","text":"Type Name void * pvDummy3 TickType_t xDummy2"},{"location":"apiStm/structxSTATIC__MINI__LIST__ITEM/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structxSTATIC__MINI__LIST__ITEM/#variable-pvdummy3","title":"variable pvDummy3","text":"<pre><code>void* xSTATIC_MINI_LIST_ITEM::pvDummy3[2];\n</code></pre>"},{"location":"apiStm/structxSTATIC__MINI__LIST__ITEM/#variable-xdummy2","title":"variable xDummy2","text":"<pre><code>TickType_t xSTATIC_MINI_LIST_ITEM::xDummy2;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/FreeRTOS.h</code></p>"},{"location":"apiStm/structxSTATIC__QUEUE/","title":"Struct xSTATIC_QUEUE","text":"<p>ClassList &gt; xSTATIC_QUEUE</p>"},{"location":"apiStm/structxSTATIC__QUEUE/#public-attributes","title":"Public Attributes","text":"Type Name void * pvDummy1 void * pvDummy2 union xSTATIC_QUEUE::@0 u uint8_t ucDummy5 UBaseType_t uxDummy2 UBaseType_t uxDummy4 StaticList_t xDummy3"},{"location":"apiStm/structxSTATIC__QUEUE/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structxSTATIC__QUEUE/#variable-pvdummy1","title":"variable pvDummy1","text":"<pre><code>void* xSTATIC_QUEUE::pvDummy1[3];\n</code></pre>"},{"location":"apiStm/structxSTATIC__QUEUE/#variable-pvdummy2","title":"variable pvDummy2","text":"<pre><code>void* xSTATIC_QUEUE::pvDummy2;\n</code></pre>"},{"location":"apiStm/structxSTATIC__QUEUE/#variable-u","title":"variable u","text":"<pre><code>union xSTATIC_QUEUE::@0 xSTATIC_QUEUE::u;\n</code></pre>"},{"location":"apiStm/structxSTATIC__QUEUE/#variable-ucdummy5","title":"variable ucDummy5","text":"<pre><code>uint8_t xSTATIC_QUEUE::ucDummy5[2];\n</code></pre>"},{"location":"apiStm/structxSTATIC__QUEUE/#variable-uxdummy2","title":"variable uxDummy2","text":"<pre><code>UBaseType_t xSTATIC_QUEUE::uxDummy2;\n</code></pre>"},{"location":"apiStm/structxSTATIC__QUEUE/#variable-uxdummy4","title":"variable uxDummy4","text":"<pre><code>UBaseType_t xSTATIC_QUEUE::uxDummy4[3];\n</code></pre>"},{"location":"apiStm/structxSTATIC__QUEUE/#variable-xdummy3","title":"variable xDummy3","text":"<pre><code>StaticList_t xSTATIC_QUEUE::xDummy3[2];\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/FreeRTOS.h</code></p>"},{"location":"apiStm/structxSTATIC__STREAM__BUFFER/","title":"Struct xSTATIC_STREAM_BUFFER","text":"<p>ClassList &gt; xSTATIC_STREAM_BUFFER</p>"},{"location":"apiStm/structxSTATIC__STREAM__BUFFER/#public-attributes","title":"Public Attributes","text":"Type Name void * pvDummy2 uint8_t ucDummy3 size_t uxDummy1"},{"location":"apiStm/structxSTATIC__STREAM__BUFFER/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structxSTATIC__STREAM__BUFFER/#variable-pvdummy2","title":"variable pvDummy2","text":"<pre><code>void* xSTATIC_STREAM_BUFFER::pvDummy2[3];\n</code></pre>"},{"location":"apiStm/structxSTATIC__STREAM__BUFFER/#variable-ucdummy3","title":"variable ucDummy3","text":"<pre><code>uint8_t xSTATIC_STREAM_BUFFER::ucDummy3;\n</code></pre>"},{"location":"apiStm/structxSTATIC__STREAM__BUFFER/#variable-uxdummy1","title":"variable uxDummy1","text":"<pre><code>size_t xSTATIC_STREAM_BUFFER::uxDummy1[4];\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/FreeRTOS.h</code></p>"},{"location":"apiStm/structxSTATIC__TCB/","title":"Struct xSTATIC_TCB","text":"<p>ClassList &gt; xSTATIC_TCB</p>"},{"location":"apiStm/structxSTATIC__TCB/#public-attributes","title":"Public Attributes","text":"Type Name void * pxDummy1 void * pxDummy6 uint8_t ucDummy19 uint8_t ucDummy7 uint32_t ulDummy18 UBaseType_t uxDummy5 StaticListItem_t xDummy3"},{"location":"apiStm/structxSTATIC__TCB/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structxSTATIC__TCB/#variable-pxdummy1","title":"variable pxDummy1","text":"<pre><code>void* xSTATIC_TCB::pxDummy1;\n</code></pre>"},{"location":"apiStm/structxSTATIC__TCB/#variable-pxdummy6","title":"variable pxDummy6","text":"<pre><code>void* xSTATIC_TCB::pxDummy6;\n</code></pre>"},{"location":"apiStm/structxSTATIC__TCB/#variable-ucdummy19","title":"variable ucDummy19","text":"<pre><code>uint8_t xSTATIC_TCB::ucDummy19;\n</code></pre>"},{"location":"apiStm/structxSTATIC__TCB/#variable-ucdummy7","title":"variable ucDummy7","text":"<pre><code>uint8_t xSTATIC_TCB::ucDummy7[configMAX_TASK_NAME_LEN];\n</code></pre>"},{"location":"apiStm/structxSTATIC__TCB/#variable-uldummy18","title":"variable ulDummy18","text":"<pre><code>uint32_t xSTATIC_TCB::ulDummy18;\n</code></pre>"},{"location":"apiStm/structxSTATIC__TCB/#variable-uxdummy5","title":"variable uxDummy5","text":"<pre><code>UBaseType_t xSTATIC_TCB::uxDummy5;\n</code></pre>"},{"location":"apiStm/structxSTATIC__TCB/#variable-xdummy3","title":"variable xDummy3","text":"<pre><code>StaticListItem_t xSTATIC_TCB::xDummy3[2];\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/FreeRTOS.h</code></p>"},{"location":"apiStm/structxSTATIC__TIMER/","title":"Struct xSTATIC_TIMER","text":"<p>ClassList &gt; xSTATIC_TIMER</p>"},{"location":"apiStm/structxSTATIC__TIMER/#public-attributes","title":"Public Attributes","text":"Type Name void * pvDummy1 void * pvDummy5 TaskFunction_t pvDummy6 uint8_t ucDummy8 StaticListItem_t xDummy2 TickType_t xDummy3"},{"location":"apiStm/structxSTATIC__TIMER/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structxSTATIC__TIMER/#variable-pvdummy1","title":"variable pvDummy1","text":"<pre><code>void* xSTATIC_TIMER::pvDummy1;\n</code></pre>"},{"location":"apiStm/structxSTATIC__TIMER/#variable-pvdummy5","title":"variable pvDummy5","text":"<pre><code>void* xSTATIC_TIMER::pvDummy5;\n</code></pre>"},{"location":"apiStm/structxSTATIC__TIMER/#variable-pvdummy6","title":"variable pvDummy6","text":"<pre><code>TaskFunction_t xSTATIC_TIMER::pvDummy6;\n</code></pre>"},{"location":"apiStm/structxSTATIC__TIMER/#variable-ucdummy8","title":"variable ucDummy8","text":"<pre><code>uint8_t xSTATIC_TIMER::ucDummy8;\n</code></pre>"},{"location":"apiStm/structxSTATIC__TIMER/#variable-xdummy2","title":"variable xDummy2","text":"<pre><code>StaticListItem_t xSTATIC_TIMER::xDummy2;\n</code></pre>"},{"location":"apiStm/structxSTATIC__TIMER/#variable-xdummy3","title":"variable xDummy3","text":"<pre><code>TickType_t xSTATIC_TIMER::xDummy3;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/FreeRTOS.h</code></p>"},{"location":"apiStm/structxTASK__PARAMETERS/","title":"Struct xTASK_PARAMETERS","text":"<p>ClassList &gt; xTASK_PARAMETERS</p>"},{"location":"apiStm/structxTASK__PARAMETERS/#public-attributes","title":"Public Attributes","text":"Type Name const char *const pcName StackType_t * puxStackBuffer void * pvParameters TaskFunction_t pvTaskCode configSTACK_DEPTH_TYPE usStackDepth UBaseType_t uxPriority MemoryRegion_t xRegions"},{"location":"apiStm/structxTASK__PARAMETERS/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structxTASK__PARAMETERS/#variable-pcname","title":"variable pcName","text":"<pre><code>const char* const xTASK_PARAMETERS::pcName;\n</code></pre>"},{"location":"apiStm/structxTASK__PARAMETERS/#variable-puxstackbuffer","title":"variable puxStackBuffer","text":"<pre><code>StackType_t* xTASK_PARAMETERS::puxStackBuffer;\n</code></pre>"},{"location":"apiStm/structxTASK__PARAMETERS/#variable-pvparameters","title":"variable pvParameters","text":"<pre><code>void* xTASK_PARAMETERS::pvParameters;\n</code></pre>"},{"location":"apiStm/structxTASK__PARAMETERS/#variable-pvtaskcode","title":"variable pvTaskCode","text":"<pre><code>TaskFunction_t xTASK_PARAMETERS::pvTaskCode;\n</code></pre>"},{"location":"apiStm/structxTASK__PARAMETERS/#variable-usstackdepth","title":"variable usStackDepth","text":"<pre><code>configSTACK_DEPTH_TYPE xTASK_PARAMETERS::usStackDepth;\n</code></pre>"},{"location":"apiStm/structxTASK__PARAMETERS/#variable-uxpriority","title":"variable uxPriority","text":"<pre><code>UBaseType_t xTASK_PARAMETERS::uxPriority;\n</code></pre>"},{"location":"apiStm/structxTASK__PARAMETERS/#variable-xregions","title":"variable xRegions","text":"<pre><code>MemoryRegion_t xTASK_PARAMETERS::xRegions[portNUM_CONFIGURABLE_REGIONS];\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/task.h</code></p>"},{"location":"apiStm/structxTASK__STATUS/","title":"Struct xTASK_STATUS","text":"<p>ClassList &gt; xTASK_STATUS</p>"},{"location":"apiStm/structxTASK__STATUS/#public-attributes","title":"Public Attributes","text":"Type Name eTaskState eCurrentState const char * pcTaskName StackType_t * pxStackBase uint32_t ulRunTimeCounter configSTACK_DEPTH_TYPE usStackHighWaterMark UBaseType_t uxBasePriority UBaseType_t uxCurrentPriority TaskHandle_t xHandle UBaseType_t xTaskNumber"},{"location":"apiStm/structxTASK__STATUS/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structxTASK__STATUS/#variable-ecurrentstate","title":"variable eCurrentState","text":"<pre><code>eTaskState xTASK_STATUS::eCurrentState;\n</code></pre>"},{"location":"apiStm/structxTASK__STATUS/#variable-pctaskname","title":"variable pcTaskName","text":"<pre><code>const char* xTASK_STATUS::pcTaskName;\n</code></pre>"},{"location":"apiStm/structxTASK__STATUS/#variable-pxstackbase","title":"variable pxStackBase","text":"<pre><code>StackType_t* xTASK_STATUS::pxStackBase;\n</code></pre>"},{"location":"apiStm/structxTASK__STATUS/#variable-ulruntimecounter","title":"variable ulRunTimeCounter","text":"<pre><code>uint32_t xTASK_STATUS::ulRunTimeCounter;\n</code></pre>"},{"location":"apiStm/structxTASK__STATUS/#variable-usstackhighwatermark","title":"variable usStackHighWaterMark","text":"<pre><code>configSTACK_DEPTH_TYPE xTASK_STATUS::usStackHighWaterMark;\n</code></pre>"},{"location":"apiStm/structxTASK__STATUS/#variable-uxbasepriority","title":"variable uxBasePriority","text":"<pre><code>UBaseType_t xTASK_STATUS::uxBasePriority;\n</code></pre>"},{"location":"apiStm/structxTASK__STATUS/#variable-uxcurrentpriority","title":"variable uxCurrentPriority","text":"<pre><code>UBaseType_t xTASK_STATUS::uxCurrentPriority;\n</code></pre>"},{"location":"apiStm/structxTASK__STATUS/#variable-xhandle","title":"variable xHandle","text":"<pre><code>TaskHandle_t xTASK_STATUS::xHandle;\n</code></pre>"},{"location":"apiStm/structxTASK__STATUS/#variable-xtasknumber","title":"variable xTaskNumber","text":"<pre><code>UBaseType_t xTASK_STATUS::xTaskNumber;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/task.h</code></p>"},{"location":"apiStm/structxTIME__OUT/","title":"Struct xTIME_OUT","text":"<p>ClassList &gt; xTIME_OUT</p>"},{"location":"apiStm/structxTIME__OUT/#public-attributes","title":"Public Attributes","text":"Type Name BaseType_t xOverflowCount TickType_t xTimeOnEntering"},{"location":"apiStm/structxTIME__OUT/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structxTIME__OUT/#variable-xoverflowcount","title":"variable xOverflowCount","text":"<pre><code>BaseType_t xTIME_OUT::xOverflowCount;\n</code></pre>"},{"location":"apiStm/structxTIME__OUT/#variable-xtimeonentering","title":"variable xTimeOnEntering","text":"<pre><code>TickType_t xTIME_OUT::xTimeOnEntering;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/task.h</code></p>"},{"location":"apiStm/group__EventGroup/","title":"Group EventGroup","text":"<p>Modules &gt; EventGroup</p> <p>More...</p>"},{"location":"apiStm/group__EventGroup/#modules","title":"Modules","text":"Type Name module EventGroupHandle_t module xEventGroupClearBits module xEventGroupClearBitsFromISR module xEventGroupCreate module xEventGroupGetBits module xEventGroupGetBitsFromISR module xEventGroupSetBits module xEventGroupSetBitsFromISR module xEventGroupSync module xEventGroupWaitBits"},{"location":"apiStm/group__EventGroup/#detailed-description","title":"Detailed Description","text":"<p>An event group is a collection of bits to which an application can assign a meaning. For example, an application may create an event group to convey the status of various CAN bus related events in which bit 0 might mean \"A CAN message has been received and is ready for processing\", bit 1 might mean \"The application has queued a message that is ready for sending onto the CAN network\", and bit 2 might mean \"It is time to send a SYNC message onto the CAN network\" etc. A task can then test the bit values to see which events are active, and optionally enter the Blocked state to wait for a specified bit or a group of specified bits to be active. To continue the CAN bus example, a CAN controlling task can enter the Blocked state (and therefore not consume any processing time) until either bit 0, bit 1 or bit 2 are active, at which time the bit that was actually active would inform the task which action it had to take (process a received message, send a message, or send a SYNC).</p> <p>The event groups implementation contains intelligence to avoid race conditions that would otherwise occur were an application to use a simple variable for the same purpose. This is particularly important with respect to when a bit within an event group is to be cleared, and when bits have to be set and then tested atomically - as is the case where event groups are used to create a synchronisation point between multiple tasks (a 'rendezvous'). </p>"},{"location":"apiStm/group__EventGroupHandle__t/","title":"Group EventGroupHandle_t","text":"<p>Modules &gt; EventGroupHandle_t</p> <p>More...</p>"},{"location":"apiStm/group__EventGroupHandle__t/#detailed-description","title":"Detailed Description","text":"<p>event_groups.h</p> <p>Type by which event groups are referenced. For example, a call to xEventGroupCreate() returns an EventGroupHandle_t variable that can then be used as a parameter to other event group functions. </p>"},{"location":"apiStm/group__xEventGroupClearBits/","title":"Group xEventGroupClearBits","text":"<p>Modules &gt; xEventGroupClearBits</p> <p>More...</p>"},{"location":"apiStm/group__xEventGroupClearBits/#detailed-description","title":"Detailed Description","text":"<p>event_groups.h </p> <p>Clear bits within an event group. This function cannot be called from an interrupt.</p> <p>Parameters:</p> <ul> <li><code>xEventGroup</code> The event group in which the bits are to be cleared.</li> <li><code>uxBitsToClear</code> A bitwise value that indicates the bit or bits to clear in the event group. For example, to clear bit 3 only, set uxBitsToClear to 0x08. To clear bit 3 and bit 0 set uxBitsToClear to 0x09.</li> </ul> <p>Returns:</p> <p>The value of the event group before the specified bits were cleared.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xEventGroupClearBitsFromISR/","title":"Group xEventGroupClearBitsFromISR","text":"<p>Modules &gt; xEventGroupClearBitsFromISR</p> <p>More...</p>"},{"location":"apiStm/group__xEventGroupClearBitsFromISR/#detailed-description","title":"Detailed Description","text":"<p>event_groups.h </p> <p>A version of xEventGroupClearBits() that can be called from an interrupt.</p> <p>Setting bits in an event group is not a deterministic operation because there are an unknown number of tasks that may be waiting for the bit or bits being set. FreeRTOS does not allow nondeterministic operations to be performed while interrupts are disabled, so protects event groups that are accessed from tasks by suspending the scheduler rather than disabling interrupts. As a result event groups cannot be accessed directly from an interrupt service routine. Therefore xEventGroupClearBitsFromISR() sends a message to the timer task to have the clear operation performed in the context of the timer task.</p> <p>Parameters:</p> <ul> <li><code>xEventGroup</code> The event group in which the bits are to be cleared.</li> <li><code>uxBitsToClear</code> A bitwise value that indicates the bit or bits to clear. For example, to clear bit 3 only, set uxBitsToClear to 0x08. To clear bit 3 and bit 0 set uxBitsToClear to 0x09.</li> </ul> <p>Returns:</p> <p>If the request to execute the function was posted successfully then pdPASS is returned, otherwise pdFALSE is returned. pdFALSE will be returned if the timer service queue was full.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xEventGroupCreate/","title":"Group xEventGroupCreate","text":"<p>Modules &gt; xEventGroupCreate</p> <p>More...</p>"},{"location":"apiStm/group__xEventGroupCreate/#detailed-description","title":"Detailed Description","text":"<p>event_groups.h </p> <p>Create a new event group.</p> <p>Internally, within the FreeRTOS implementation, event groups use a [small] block of memory, in which the event group's structure is stored. If an event groups is created using xEventGropuCreate() then the required memory is automatically dynamically allocated inside the xEventGroupCreate() function. (see http://www.freertos.org/a00111.html). If an event group is created using xEventGropuCreateStatic() then the application writer must instead provide the memory that will get used by the event group. xEventGroupCreateStatic() therefore allows an event group to be created without using any dynamic memory allocation.</p> <p>Although event groups are not related to ticks, for internal implementation reasons the number of bits available for use in an event group is dependent on the configUSE_16_BIT_TICKS setting in FreeRTOSConfig.h. If configUSE_16_BIT_TICKS is 1 then each event group contains 8 usable bits (bit 0 to bit 7). If configUSE_16_BIT_TICKS is set to 0 then each event group has 24 usable bits (bit 0 to bit 23). The EventBits_t type is used to store event bits within an event group.</p> <p>Returns:</p> <p>If the event group was created then a handle to the event group is returned. If there was insufficient FreeRTOS heap available to create the event group then NULL is returned. See http://www.freertos.org/a00111.html</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xEventGroupGetBits/","title":"Group xEventGroupGetBits","text":"<p>Modules &gt; xEventGroupGetBits</p> <p>More...</p>"},{"location":"apiStm/group__xEventGroupGetBits/#detailed-description","title":"Detailed Description","text":"<p>event_groups.h </p> <p>Returns the current value of the bits in an event group. This function cannot be used from an interrupt.</p> <p>Parameters:</p> <ul> <li><code>xEventGroup</code> The event group being queried.</li> </ul> <p>Returns:</p> <p>The event group bits at the time xEventGroupGetBits() was called. </p>"},{"location":"apiStm/group__xEventGroupGetBitsFromISR/","title":"Group xEventGroupGetBitsFromISR","text":"<p>Modules &gt; xEventGroupGetBitsFromISR</p> <p>More...</p>"},{"location":"apiStm/group__xEventGroupGetBitsFromISR/#detailed-description","title":"Detailed Description","text":"<p>event_groups.h </p> <p>A version of xEventGroupGetBits() that can be called from an ISR.</p> <p>Parameters:</p> <ul> <li><code>xEventGroup</code> The event group being queried.</li> </ul> <p>Returns:</p> <p>The event group bits at the time xEventGroupGetBitsFromISR() was called. </p>"},{"location":"apiStm/group__xEventGroupSetBits/","title":"Group xEventGroupSetBits","text":"<p>Modules &gt; xEventGroupSetBits</p> <p>More...</p>"},{"location":"apiStm/group__xEventGroupSetBits/#detailed-description","title":"Detailed Description","text":"<p>event_groups.h </p> <p>Set bits within an event group. This function cannot be called from an interrupt. xEventGroupSetBitsFromISR() is a version that can be called from an interrupt.</p> <p>Setting bits in an event group will automatically unblock tasks that are blocked waiting for the bits.</p> <p>Parameters:</p> <ul> <li><code>xEventGroup</code> The event group in which the bits are to be set.</li> <li><code>uxBitsToSet</code> A bitwise value that indicates the bit or bits to set. For example, to set bit 3 only, set uxBitsToSet to 0x08. To set bit 3 and bit 0 set uxBitsToSet to 0x09.</li> </ul> <p>Returns:</p> <p>The value of the event group at the time the call to xEventGroupSetBits() returns. There are two reasons why the returned value might have the bits specified by the uxBitsToSet parameter cleared. First, if setting a bit results in a task that was waiting for the bit leaving the blocked state then it is possible the bit will be cleared automatically (see the xClearBitOnExit parameter of xEventGroupWaitBits()). Second, any unblocked (or otherwise Ready state) task that has a priority above that of the task that called xEventGroupSetBits() will execute and may change the event group value before the call to xEventGroupSetBits() returns.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xEventGroupSetBitsFromISR/","title":"Group xEventGroupSetBitsFromISR","text":"<p>Modules &gt; xEventGroupSetBitsFromISR</p> <p>More...</p>"},{"location":"apiStm/group__xEventGroupSetBitsFromISR/#detailed-description","title":"Detailed Description","text":"<p>event_groups.h </p> <p>A version of xEventGroupSetBits() that can be called from an interrupt.</p> <p>Setting bits in an event group is not a deterministic operation because there are an unknown number of tasks that may be waiting for the bit or bits being set. FreeRTOS does not allow nondeterministic operations to be performed in interrupts or from critical sections. Therefore xEventGroupSetBitsFromISR() sends a message to the timer task to have the set operation performed in the context of the timer task - where a scheduler lock is used in place of a critical section.</p> <p>Parameters:</p> <ul> <li><code>xEventGroup</code> The event group in which the bits are to be set.</li> <li><code>uxBitsToSet</code> A bitwise value that indicates the bit or bits to set. For example, to set bit 3 only, set uxBitsToSet to 0x08. To set bit 3 and bit 0 set uxBitsToSet to 0x09.</li> <li><code>pxHigherPriorityTaskWoken</code> As mentioned above, calling this function will result in a message being sent to the timer daemon task. If the priority of the timer daemon task is higher than the priority of the currently running task (the task the interrupt interrupted) then *pxHigherPriorityTaskWoken will be set to pdTRUE by xEventGroupSetBitsFromISR(), indicating that a context switch should be requested before the interrupt exits. For that reason *pxHigherPriorityTaskWoken must be initialised to pdFALSE. See the example code below.</li> </ul> <p>Returns:</p> <p>If the request to execute the function was posted successfully then pdPASS is returned, otherwise pdFALSE is returned. pdFALSE will be returned if the timer service queue was full.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xEventGroupSync/","title":"Group xEventGroupSync","text":"<p>Modules &gt; xEventGroupSync</p> <p>More...</p>"},{"location":"apiStm/group__xEventGroupSync/#detailed-description","title":"Detailed Description","text":"<p>event_groups.h </p> <p>Atomically set bits within an event group, then wait for a combination of bits to be set within the same event group. This functionality is typically used to synchronise multiple tasks, where each task has to wait for the other tasks to reach a synchronisation point before proceeding.</p> <p>This function cannot be used from an interrupt.</p> <p>The function will return before its block time expires if the bits specified by the uxBitsToWait parameter are set, or become set within that time. In this case all the bits specified by uxBitsToWait will be automatically cleared before the function returns.</p> <p>Parameters:</p> <ul> <li><code>xEventGroup</code> The event group in which the bits are being tested. The event group must have previously been created using a call to xEventGroupCreate().</li> <li><code>uxBitsToSet</code> The bits to set in the event group before determining if, and possibly waiting for, all the bits specified by the uxBitsToWait parameter are set.</li> <li><code>uxBitsToWaitFor</code> A bitwise value that indicates the bit or bits to test inside the event group. For example, to wait for bit 0 and bit 2 set uxBitsToWaitFor to 0x05. To wait for bits 0 and bit 1 and bit 2 set uxBitsToWaitFor to 0x07. Etc.</li> <li><code>xTicksToWait</code> The maximum amount of time (specified in 'ticks') to wait for all of the bits specified by uxBitsToWaitFor to become set.</li> </ul> <p>Returns:</p> <p>The value of the event group at the time either the bits being waited for became set, or the block time expired. Test the return value to know which bits were set. If xEventGroupSync() returned because its timeout expired then not all the bits being waited for will be set. If xEventGroupSync() returned because all the bits it was waiting for were set then the returned value is the event group value before any bits were automatically cleared.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xEventGroupWaitBits/","title":"Group xEventGroupWaitBits","text":"<p>Modules &gt; xEventGroupWaitBits</p> <p>More...</p>"},{"location":"apiStm/group__xEventGroupWaitBits/#detailed-description","title":"Detailed Description","text":"<p>event_groups.h </p> <p>Create a new event group.</p> <p>Internally, within the FreeRTOS implementation, event groups use a [small] block of memory, in which the event group's structure is stored. If an event groups is created using xEventGropuCreate() then the required memory is automatically dynamically allocated inside the xEventGroupCreate() function. (see http://www.freertos.org/a00111.html). If an event group is created using xEventGropuCreateStatic() then the application writer must instead provide the memory that will get used by the event group. xEventGroupCreateStatic() therefore allows an event group to be created without using any dynamic memory allocation.</p> <p>Although event groups are not related to ticks, for internal implementation reasons the number of bits available for use in an event group is dependent on the configUSE_16_BIT_TICKS setting in FreeRTOSConfig.h. If configUSE_16_BIT_TICKS is 1 then each event group contains 8 usable bits (bit 0 to bit 7). If configUSE_16_BIT_TICKS is set to 0 then each event group has 24 usable bits (bit 0 to bit 23). The EventBits_t type is used to store event bits within an event group.</p> <p>Parameters:</p> <ul> <li><code>pxEventGroupBuffer</code> pxEventGroupBuffer must point to a variable of type StaticEventGroup_t, which will be then be used to hold the event group's data structures, removing the need for the memory to be allocated dynamically.</li> </ul> <p>Returns:</p> <p>If the event group was created then a handle to the event group is returned. If pxEventGroupBuffer was NULL then NULL is returned.</p> <p>Example usage:  event_groups.h </p> <p>[Potentially] block to wait for one or more bits to be set within a previously created event group.</p> <p>This function cannot be called from an interrupt.</p> <p>Parameters:</p> <ul> <li><code>xEventGroup</code> The event group in which the bits are being tested. The event group must have previously been created using a call to xEventGroupCreate().</li> <li><code>uxBitsToWaitFor</code> A bitwise value that indicates the bit or bits to test inside the event group. For example, to wait for bit 0 and/or bit 2 set uxBitsToWaitFor to 0x05. To wait for bits 0 and/or bit 1 and/or bit 2 set uxBitsToWaitFor to 0x07. Etc.</li> <li><code>xClearOnExit</code> If xClearOnExit is set to pdTRUE then any bits within uxBitsToWaitFor that are set within the event group will be cleared before xEventGroupWaitBits() returns if the wait condition was met (if the function returns for a reason other than a timeout). If xClearOnExit is set to pdFALSE then the bits set in the event group are not altered when the call to xEventGroupWaitBits() returns.</li> <li><code>xWaitForAllBits</code> If xWaitForAllBits is set to pdTRUE then xEventGroupWaitBits() will return when either all the bits in uxBitsToWaitFor are set or the specified block time expires. If xWaitForAllBits is set to pdFALSE then xEventGroupWaitBits() will return when any one of the bits set in uxBitsToWaitFor is set or the specified block time expires. The block time is specified by the xTicksToWait parameter.</li> <li><code>xTicksToWait</code> The maximum amount of time (specified in 'ticks') to wait for one/all (depending on the xWaitForAllBits value) of the bits specified by uxBitsToWaitFor to become set.</li> </ul> <p>Returns:</p> <p>The value of the event group at the time either the bits being waited for became set, or the block time expired. Test the return value to know which bits were set. If xEventGroupWaitBits() returned because its timeout expired then not all the bits being waited for will be set. If xEventGroupWaitBits() returned because the bits it was waiting for were set then the returned value is the event group value before any bits were automatically cleared in the case that xClearOnExit parameter was set to pdTRUE.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__TaskHandle__t/","title":"Group TaskHandle_t","text":"<p>Modules &gt; TaskHandle_t</p> <p>More...</p>"},{"location":"apiStm/group__TaskHandle__t/#detailed-description","title":"Detailed Description","text":"<p>task. h</p> <p>Type by which tasks are referenced. For example, a call to xTaskCreate returns (via a pointer parameter) an TaskHandle_t variable that can then be used as a parameter to vTaskDelete to delete the task. </p>"},{"location":"apiStm/group__USBD__HW__CORE/","title":"Group USBD_HW_CORE","text":"<p>Modules &gt; USBD_HW_CORE</p>"},{"location":"apiStm/group__USBD__HW__CORE/#modules","title":"Modules","text":"Type Name module USB device core Contains core API. module USB hardware driver Contains HW driver API."},{"location":"apiStm/group__USBD__CORE/","title":"Group USBD_CORE","text":"<p>Modules &gt; USBD_CORE</p> <p>Contains core API. </p>"},{"location":"apiStm/group__USBD__CORE/#classes","title":"Classes","text":"Type Name struct _usbd_device Represents a USB device data. struct usbd_ctlreq Represents generic USB control request. struct usbd_status"},{"location":"apiStm/group__USBD__CORE/#public-types","title":"Public Types","text":"Type Name enum _usbd_respond Reporting status results. typedef usbd_respond(* usbd_cfg_callback USB set configuration callback function. typedef usbd_respond(* usbd_ctl_callback USB control callback function. enum usbd_ctl_state USB device control endpoint machine state. typedef struct _usbd_device usbd_device typedef usbd_respond(* usbd_dsc_callback USB get descriptor callback function. typedef void(* usbd_evt_callback Generic USB device event callback for events and endpoints processing. enum usbd_machine_state USB device machine states. typedef enum _usbd_respond usbd_respond Reporting status results. typedef void(* usbd_rqc_callback USB control transfer completed callback function."},{"location":"apiStm/group__USBD__CORE/#public-functions","title":"Public Functions","text":"Type Name void usbd_poll (usbd_device * dev) Polls USB for events."},{"location":"apiStm/group__USBD__CORE/#public-static-functions","title":"Public Static Functions","text":"Type Name uint8_t usbd_connect (usbd_device * dev, bool connect) Connects or disconnects USB hardware to/from usb host. void usbd_enable (usbd_device * dev, bool enable) Enables or disables USB hardware. bool usbd_ep_config (usbd_device * dev, uint8_t ep, uint8_t eptype, uint16_t epsize) Configure endpoint. void usbd_ep_deconfig (usbd_device * dev, uint8_t ep) Deconfigure endpoint. int32_t usbd_ep_read (usbd_device * dev, uint8_t ep, void * buf, uint16_t blen) Read data from endpoint. void usbd_ep_stall (usbd_device * dev, uint8_t ep) Stall endpoint. void usbd_ep_unstall (usbd_device * dev, uint8_t ep) Unstall endpoint. int32_t usbd_ep_write (usbd_device * dev, uint8_t ep, void * buf, uint16_t blen) Write data to endpoint. uint32_t usbd_getinfo (usbd_device * dev) Retrieves status and capabilities. void usbd_init (usbd_device * dev, const struct usbd_driver * drv, const uint8_t ep0size, uint32_t * buffer, const uint16_t bsize) Initializes device structure. void usbd_reg_config (usbd_device * dev, usbd_cfg_callback callback) Register callback for SET_CONFIG control request. void usbd_reg_control (usbd_device * dev, usbd_ctl_callback callback) Register callback for all control requests. void usbd_reg_descr (usbd_device * dev, usbd_dsc_callback callback) Register callback for GET_DESCRIPTOR control request. void usbd_reg_endpoint (usbd_device * dev, uint8_t ep, usbd_evt_callback callback) Register endpoint callback. void usbd_reg_event (usbd_device * dev, uint8_t evt, usbd_evt_callback callback) Registers event callback."},{"location":"apiStm/group__USBD__CORE/#macros","title":"Macros","text":"Type Name define USB_EPTYPE_DBLBUF  0x04Doublebuffered endpoint (bulk endpoint only). define USB_REQ_CLASS  (1 &lt;&lt; 5)Class specified request. define USB_REQ_DEVICE  (0 &lt;&lt; 0)Request to device. define USB_REQ_DEVTOHOST  (1 &lt;&lt; 7)Request direction is DEVICE to HOST. define USB_REQ_DIRECTION  (1 &lt;&lt; 7)Request direction mask. define USB_REQ_ENDPOINT  (2 &lt;&lt; 0)Request to endpoint. define USB_REQ_HOSTTODEV  (0 &lt;&lt; 7)Request direction is HOST to DEVICE. define USB_REQ_INTERFACE  (1 &lt;&lt; 0)Request to interface. define USB_REQ_OTHER  (3 &lt;&lt; 0)Other request. define USB_REQ_RECIPIENT  (3 &lt;&lt; 0)Request recipient mask. define USB_REQ_STANDARD  (0 &lt;&lt; 5)Standard request. define USB_REQ_TYPE  (3 &lt;&lt; 5)Request type mask. define USB_REQ_VENDOR  (2 &lt;&lt; 5)Vendor specified request."},{"location":"apiStm/group__USBD__CORE/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/group__USBD__CORE/#enum-_usbd_respond","title":"enum _usbd_respond","text":"<pre><code>enum _usbd_respond {\nusbd_fail,\nusbd_ack,\nusbd_nak\n};\n</code></pre>"},{"location":"apiStm/group__USBD__CORE/#typedef-usbd_cfg_callback","title":"typedef usbd_cfg_callback","text":"<p>USB set configuration callback function. <pre><code>typedef usbd_respond(* usbd_cfg_callback) (usbd_device *dev, uint8_t cfg);\n</code></pre></p> <p>called when SET_CONFIGURATION request issued </p> <p>Parameters:</p> <ul> <li><code>dev</code> pointer to USB device </li> <li><code>cfg</code> configuration number. </li> </ul> <p>Note:</p> <p>if config is 0 device endpoints should be de-configured </p> <p>Returns:</p> <p>TRUE if success </p>"},{"location":"apiStm/group__USBD__CORE/#typedef-usbd_ctl_callback","title":"typedef usbd_ctl_callback","text":"<p>USB control callback function. <pre><code>typedef usbd_respond(* usbd_ctl_callback) (usbd_device *dev, usbd_ctlreq *req, usbd_rqc_callback *callback);\n</code></pre></p> <p>Uses for the control request processing. Some requests will be handled by core if callback don't process it (returns FALSE). If request was not processed STALL PID will be issued. * GET_CONFIGURATION * SET_CONFIGURATION (passes to usbd_cfg_callback) * GET_DESCRIPTOR (passes to usbd_dsc_callback) * GET_STATUS * SET_FEATURE, CLEAR_FEATURE (endpoints only) * SET_ADDRESS </p> <p>Parameters:</p> <ul> <li><code>dev</code> points to USB device </li> <li><code>req</code> points to usb control request </li> <li><code>*callback</code> USB control transfer completion callback, default is NULL (no callback) </li> </ul> <p>Returns:</p> <p>usbd_respond status. </p>"},{"location":"apiStm/group__USBD__CORE/#enum-usbd_ctl_state","title":"enum usbd_ctl_state","text":"<pre><code>enum usbd_ctl_state {\nusbd_ctl_idle,\nusbd_ctl_rxdata,\nusbd_ctl_txdata,\nusbd_ctl_ztxdata,\nusbd_ctl_lastdata,\nusbd_ctl_statusin,\nusbd_ctl_statusout\n};\n</code></pre>"},{"location":"apiStm/group__USBD__CORE/#typedef-usbd_device","title":"typedef usbd_device","text":"<pre><code>typedef struct _usbd_device usbd_device;\n</code></pre>"},{"location":"apiStm/group__USBD__CORE/#typedef-usbd_dsc_callback","title":"typedef usbd_dsc_callback","text":"<p>USB get descriptor callback function. <pre><code>typedef usbd_respond(* usbd_dsc_callback) (usbd_ctlreq *req, void **address, uint16_t *dsize);\n</code></pre></p> <p>Called when GET_DESCRIPTOR request issued </p> <p>Parameters:</p> <ul> <li><code>req</code> pointer to usb control request structure </li> <li><code>address</code> pointer to the descriptor in memory. Points to req-&gt;data by default. You can use this buffer. </li> <li><code>dsize</code> descriptor size. maximum buffer size by default. </li> </ul> <p>Returns:</p> <p>usbd_ack if you passed the correct descriptor, usbd_fail otherwise. </p>"},{"location":"apiStm/group__USBD__CORE/#typedef-usbd_evt_callback","title":"typedef usbd_evt_callback","text":"<p>Generic USB device event callback for events and endpoints processing. <pre><code>typedef void(* usbd_evt_callback) (usbd_device *dev, uint8_t event, uint8_t ep);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> pointer to USB device </li> <li><code>event</code> USB event </li> <li><code>ep</code> active endpoint number </li> </ul> <p>Note:</p> <p>endpoints with same indexes i.e. 0x01 and 0x81 shares same callback. </p>"},{"location":"apiStm/group__USBD__CORE/#enum-usbd_machine_state","title":"enum usbd_machine_state","text":"<pre><code>enum usbd_machine_state {\nusbd_state_disabled,\nusbd_state_disconnected,\nusbd_state_default,\nusbd_state_addressed,\nusbd_state_configured\n};\n</code></pre>"},{"location":"apiStm/group__USBD__CORE/#typedef-usbd_respond","title":"typedef usbd_respond","text":"<pre><code>typedef enum _usbd_respond usbd_respond;\n</code></pre>"},{"location":"apiStm/group__USBD__CORE/#typedef-usbd_rqc_callback","title":"typedef usbd_rqc_callback","text":"<p>USB control transfer completed callback function. <pre><code>typedef void(* usbd_rqc_callback) (usbd_device *dev, usbd_ctlreq *req);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> pointer to USB device </li> <li><code>req</code> pointer to usb request structure </li> </ul> <p>Note:</p> <p>usbd_device-&gt;complete_callback will be set to NULL after this callback completion. </p>"},{"location":"apiStm/group__USBD__CORE/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/group__USBD__CORE/#function-usbd_poll","title":"function usbd_poll","text":"<p>Polls USB for events. <pre><code>void usbd_poll (\nusbd_device * dev\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> Pointer to device structure </li> </ul> <p>Note:</p> <p>can be called as from main routine as from USB interrupt </p>"},{"location":"apiStm/group__USBD__CORE/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"apiStm/group__USBD__CORE/#function-usbd_connect","title":"function usbd_connect","text":"<p>Connects or disconnects USB hardware to/from usb host. <pre><code>static inline uint8_t usbd_connect (\nusbd_device * dev,\nbool connect\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> dev usb device _usbd_device </li> <li><code>connect</code> Connects USB to host if TRUE, disconnects otherwise </li> </ul> <p>Returns:</p> <p>lanes connection status. USB_LANES_STATUS </p>"},{"location":"apiStm/group__USBD__CORE/#function-usbd_enable","title":"function usbd_enable","text":"<p>Enables or disables USB hardware. <pre><code>static inline void usbd_enable (\nusbd_device * dev,\nbool enable\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> dev usb device _usbd_device </li> <li><code>enable</code> Enables USB when TRUE disables otherwise </li> </ul>"},{"location":"apiStm/group__USBD__CORE/#function-usbd_ep_config","title":"function usbd_ep_config","text":"<p>Configure endpoint. <pre><code>static inline bool usbd_ep_config (\nusbd_device * dev,\nuint8_t ep,\nuint8_t eptype,\nuint16_t epsize\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> dev usb device _usbd_device </li> <li><code>ep</code> endpoint address. Use USB_EPDIR_ macros to set endpoint direction </li> <li><code>eptype</code> endpoint type. Use USB_EPTYPE_* macros. </li> <li><code>epsize</code> endpoint size in bytes </li> </ul> <p>Returns:</p> <p>TRUE if success </p>"},{"location":"apiStm/group__USBD__CORE/#function-usbd_ep_deconfig","title":"function usbd_ep_deconfig","text":"<p>Deconfigure endpoint. <pre><code>static inline void usbd_ep_deconfig (\nusbd_device * dev,\nuint8_t ep\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> dev usb device _usbd_device </li> <li><code>ep</code> endpoint index </li> </ul> <p>Note:</p> <p>if you have two one-direction single-buffered endpoints with same index (i.e. 0x02 and 0x82) both will be deconfigured. </p>"},{"location":"apiStm/group__USBD__CORE/#function-usbd_ep_read","title":"function usbd_ep_read","text":"<p>Read data from endpoint. <pre><code>static inline int32_t usbd_ep_read (\nusbd_device * dev,\nuint8_t ep,\nvoid * buf,\nuint16_t blen\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> dev usb device _usbd_device </li> <li><code>ep</code> endpoint index, should belong to OUT or CONTROL endpoint. </li> <li><code>buf</code> pointer to read buffer </li> <li><code>blen</code> size of the read buffer in bytes </li> </ul> <p>Returns:</p> <p>size of the actually received data, -1 on error. </p>"},{"location":"apiStm/group__USBD__CORE/#function-usbd_ep_stall","title":"function usbd_ep_stall","text":"<p>Stall endpoint. <pre><code>static inline void usbd_ep_stall (\nusbd_device * dev,\nuint8_t ep\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> dev usb device _usbd_device </li> <li><code>ep</code> endpoint address </li> </ul>"},{"location":"apiStm/group__USBD__CORE/#function-usbd_ep_unstall","title":"function usbd_ep_unstall","text":"<p>Unstall endpoint. <pre><code>static inline void usbd_ep_unstall (\nusbd_device * dev,\nuint8_t ep\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> dev usb device _usbd_device </li> <li><code>ep</code> endpoint address </li> </ul>"},{"location":"apiStm/group__USBD__CORE/#function-usbd_ep_write","title":"function usbd_ep_write","text":"<p>Write data to endpoint. <pre><code>static inline int32_t usbd_ep_write (\nusbd_device * dev,\nuint8_t ep,\nvoid * buf,\nuint16_t blen\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> dev usb device _usbd_device </li> <li><code>ep</code> endpoint index, hould belong to IN or CONTROL endpoint </li> <li><code>buf</code> pointer to data buffer </li> <li><code>blen</code> size of data will be written </li> </ul> <p>Returns:</p> <p>number of written bytes </p>"},{"location":"apiStm/group__USBD__CORE/#function-usbd_getinfo","title":"function usbd_getinfo","text":"<p>Retrieves status and capabilities. <pre><code>static inline uint32_t usbd_getinfo (\nusbd_device * dev\n) </code></pre></p> <p>Returns:</p> <p>current HW status, enumeration speed and capabilities USBD_HW_CAPS </p>"},{"location":"apiStm/group__USBD__CORE/#function-usbd_init","title":"function usbd_init","text":"<p>Initializes device structure. <pre><code>static inline void usbd_init (\nusbd_device * dev,\nconst struct usbd_driver * drv,\nconst uint8_t ep0size,\nuint32_t * buffer,\nconst uint16_t bsize\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> USB device that will be initialized </li> <li><code>drv</code> Pointer to hardware driver </li> <li><code>ep0size</code> Control endpoint 0 size </li> <li><code>buffer</code> Pointer to control request data buffer (32-bit aligned) </li> <li><code>bsize</code> Size of the data buffer </li> </ul>"},{"location":"apiStm/group__USBD__CORE/#function-usbd_reg_config","title":"function usbd_reg_config","text":"<p>Register callback for SET_CONFIG control request. <pre><code>static inline void usbd_reg_config (\nusbd_device * dev,\nusbd_cfg_callback callback\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> dev usb device _usbd_device </li> <li><code>callback</code> pointer to user usbd_cfg_callback </li> </ul>"},{"location":"apiStm/group__USBD__CORE/#function-usbd_reg_control","title":"function usbd_reg_control","text":"<p>Register callback for all control requests. <pre><code>static inline void usbd_reg_control (\nusbd_device * dev,\nusbd_ctl_callback callback\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> usb device _usbd_device </li> <li><code>callback</code> user control callback usbd_ctl_callback </li> </ul>"},{"location":"apiStm/group__USBD__CORE/#function-usbd_reg_descr","title":"function usbd_reg_descr","text":"<p>Register callback for GET_DESCRIPTOR control request. <pre><code>static inline void usbd_reg_descr (\nusbd_device * dev,\nusbd_dsc_callback callback\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> dev usb device _usbd_device </li> <li><code>callback</code> pointer to user usbd_ctl_callback </li> </ul>"},{"location":"apiStm/group__USBD__CORE/#function-usbd_reg_endpoint","title":"function usbd_reg_endpoint","text":"<p>Register endpoint callback. <pre><code>static inline void usbd_reg_endpoint (\nusbd_device * dev,\nuint8_t ep,\nusbd_evt_callback callback\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> dev usb device _usbd_device </li> <li><code>ep</code> endpoint index </li> <li><code>callback</code> pointer to user usbd_evt_callback callback for endpoint events </li> </ul>"},{"location":"apiStm/group__USBD__CORE/#function-usbd_reg_event","title":"function usbd_reg_event","text":"<p>Registers event callback. <pre><code>static inline void usbd_reg_event (\nusbd_device * dev,\nuint8_t evt,\nusbd_evt_callback callback\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> dev usb device _usbd_device </li> <li><code>evt</code> device event wants to be registered </li> <li><code>callback</code> pointer to user usbd_evt_callback for this event </li> </ul>"},{"location":"apiStm/group__USBD__CORE/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/group__USBD__CORE/#define-usb_eptype_dblbuf","title":"define USB_EPTYPE_DBLBUF","text":"<pre><code>#define USB_EPTYPE_DBLBUF 0x04\n</code></pre>"},{"location":"apiStm/group__USBD__CORE/#define-usb_req_class","title":"define USB_REQ_CLASS","text":"<pre><code>#define USB_REQ_CLASS (1 &lt;&lt; 5)\n</code></pre>"},{"location":"apiStm/group__USBD__CORE/#define-usb_req_device","title":"define USB_REQ_DEVICE","text":"<pre><code>#define USB_REQ_DEVICE (0 &lt;&lt; 0)\n</code></pre>"},{"location":"apiStm/group__USBD__CORE/#define-usb_req_devtohost","title":"define USB_REQ_DEVTOHOST","text":"<pre><code>#define USB_REQ_DEVTOHOST (1 &lt;&lt; 7)\n</code></pre>"},{"location":"apiStm/group__USBD__CORE/#define-usb_req_direction","title":"define USB_REQ_DIRECTION","text":"<pre><code>#define USB_REQ_DIRECTION (1 &lt;&lt; 7)\n</code></pre>"},{"location":"apiStm/group__USBD__CORE/#define-usb_req_endpoint","title":"define USB_REQ_ENDPOINT","text":"<pre><code>#define USB_REQ_ENDPOINT (2 &lt;&lt; 0)\n</code></pre>"},{"location":"apiStm/group__USBD__CORE/#define-usb_req_hosttodev","title":"define USB_REQ_HOSTTODEV","text":"<pre><code>#define USB_REQ_HOSTTODEV (0 &lt;&lt; 7)\n</code></pre>"},{"location":"apiStm/group__USBD__CORE/#define-usb_req_interface","title":"define USB_REQ_INTERFACE","text":"<pre><code>#define USB_REQ_INTERFACE (1 &lt;&lt; 0)\n</code></pre>"},{"location":"apiStm/group__USBD__CORE/#define-usb_req_other","title":"define USB_REQ_OTHER","text":"<pre><code>#define USB_REQ_OTHER (3 &lt;&lt; 0)\n</code></pre>"},{"location":"apiStm/group__USBD__CORE/#define-usb_req_recipient","title":"define USB_REQ_RECIPIENT","text":"<pre><code>#define USB_REQ_RECIPIENT (3 &lt;&lt; 0)\n</code></pre>"},{"location":"apiStm/group__USBD__CORE/#define-usb_req_standard","title":"define USB_REQ_STANDARD","text":"<pre><code>#define USB_REQ_STANDARD (0 &lt;&lt; 5)\n</code></pre>"},{"location":"apiStm/group__USBD__CORE/#define-usb_req_type","title":"define USB_REQ_TYPE","text":"<pre><code>#define USB_REQ_TYPE (3 &lt;&lt; 5)\n</code></pre>"},{"location":"apiStm/group__USBD__CORE/#define-usb_req_vendor","title":"define USB_REQ_VENDOR","text":"<pre><code>#define USB_REQ_VENDOR (2 &lt;&lt; 5)\n</code></pre>"},{"location":"apiStm/struct__usbd__device/","title":"Struct _usbd_device","text":"<p>ClassList &gt; _usbd_device</p> <p>Represents a USB device data. </p> <ul> <li><code>#include &lt;usbd_core.h&gt;</code></li> </ul>"},{"location":"apiStm/struct__usbd__device/#public-attributes","title":"Public Attributes","text":"Type Name usbd_rqc_callback complete_callback USB control transfer completed callback function. usbd_cfg_callback config_callback USB set configuration callback function. usbd_ctl_callback control_callback USB control callback function. usbd_dsc_callback descriptor_callback USB get descriptor callback function. const struct usbd_driver * driver Represents a hardware USB driver call table. usbd_evt_callback endpoint array of the endpoint callbacks. usbd_evt_callback events array of the event callbacks. usbd_status status"},{"location":"apiStm/struct__usbd__device/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/struct__usbd__device/#variable-complete_callback","title":"variable complete_callback","text":"<pre><code>usbd_rqc_callback _usbd_device::complete_callback;\n</code></pre>"},{"location":"apiStm/struct__usbd__device/#variable-config_callback","title":"variable config_callback","text":"<pre><code>usbd_cfg_callback _usbd_device::config_callback;\n</code></pre>"},{"location":"apiStm/struct__usbd__device/#variable-control_callback","title":"variable control_callback","text":"<pre><code>usbd_ctl_callback _usbd_device::control_callback;\n</code></pre>"},{"location":"apiStm/struct__usbd__device/#variable-descriptor_callback","title":"variable descriptor_callback","text":"<pre><code>usbd_dsc_callback _usbd_device::descriptor_callback;\n</code></pre>"},{"location":"apiStm/struct__usbd__device/#variable-driver","title":"variable driver","text":"<pre><code>const struct usbd_driver* _usbd_device::driver;\n</code></pre>"},{"location":"apiStm/struct__usbd__device/#variable-endpoint","title":"variable endpoint","text":"<pre><code>usbd_evt_callback _usbd_device::endpoint[8];\n</code></pre>"},{"location":"apiStm/struct__usbd__device/#variable-events","title":"variable events","text":"<pre><code>usbd_evt_callback _usbd_device::events[usbd_evt_count];\n</code></pre>"},{"location":"apiStm/struct__usbd__device/#variable-status","title":"variable status","text":"<pre><code>usbd_status _usbd_device::status;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usbd_core.h</code></p>"},{"location":"apiStm/structusbd__ctlreq/","title":"Struct usbd_ctlreq","text":"<p>ClassList &gt; usbd_ctlreq</p> <p>Represents generic USB control request. </p> <ul> <li><code>#include &lt;usbd_core.h&gt;</code></li> </ul>"},{"location":"apiStm/structusbd__ctlreq/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bRequest This field specifies the particular request. uint8_t bmRequestType This bitmapped field identifies the characteristics of the specific request. uint8_t data Data payload. uint16_t wIndex It is used to pass a parameter to the device, specific to the request. uint16_t wLength This field specifies the length of the data transferred during the second phase of the control transfer. uint16_t wValue It is used to pass a parameter to the device, specific to the request."},{"location":"apiStm/structusbd__ctlreq/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusbd__ctlreq/#variable-brequest","title":"variable bRequest","text":"<pre><code>uint8_t usbd_ctlreq::bRequest;\n</code></pre>"},{"location":"apiStm/structusbd__ctlreq/#variable-bmrequesttype","title":"variable bmRequestType","text":"<pre><code>uint8_t usbd_ctlreq::bmRequestType;\n</code></pre>"},{"location":"apiStm/structusbd__ctlreq/#variable-data","title":"variable data","text":"<pre><code>uint8_t usbd_ctlreq::data[];\n</code></pre>"},{"location":"apiStm/structusbd__ctlreq/#variable-windex","title":"variable wIndex","text":"<pre><code>uint16_t usbd_ctlreq::wIndex;\n</code></pre>"},{"location":"apiStm/structusbd__ctlreq/#variable-wlength","title":"variable wLength","text":"<pre><code>uint16_t usbd_ctlreq::wLength;\n</code></pre>"},{"location":"apiStm/structusbd__ctlreq/#variable-wvalue","title":"variable wValue","text":"<pre><code>uint16_t usbd_ctlreq::wValue;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usbd_core.h</code></p>"},{"location":"apiStm/structusbd__status/","title":"Struct usbd_status","text":"<p>ClassList &gt; usbd_status</p> <p>More...</p> <ul> <li><code>#include &lt;usbd_core.h&gt;</code></li> </ul>"},{"location":"apiStm/structusbd__status/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t control_state Current usbd_ctl_state . void * data_buf Pointer to data buffer used for control requests. uint16_t data_count Count remained data for control request. uint16_t data_maxsize Size of the data buffer for control requests. void * data_ptr Pointer to current data for control request. uint8_t device_cfg Current device configuration number. uint8_t device_state Current usbd_machine_state . uint8_t ep0size Size of the control endpoint."},{"location":"apiStm/structusbd__status/#detailed-description","title":"Detailed Description","text":"<p>USB device status data. </p>"},{"location":"apiStm/structusbd__status/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusbd__status/#variable-control_state","title":"variable control_state","text":"<pre><code>uint8_t usbd_status::control_state;\n</code></pre>"},{"location":"apiStm/structusbd__status/#variable-data_buf","title":"variable data_buf","text":"<pre><code>void* usbd_status::data_buf;\n</code></pre>"},{"location":"apiStm/structusbd__status/#variable-data_count","title":"variable data_count","text":"<pre><code>uint16_t usbd_status::data_count;\n</code></pre>"},{"location":"apiStm/structusbd__status/#variable-data_maxsize","title":"variable data_maxsize","text":"<pre><code>uint16_t usbd_status::data_maxsize;\n</code></pre>"},{"location":"apiStm/structusbd__status/#variable-data_ptr","title":"variable data_ptr","text":"<pre><code>void* usbd_status::data_ptr;\n</code></pre>"},{"location":"apiStm/structusbd__status/#variable-device_cfg","title":"variable device_cfg","text":"<pre><code>uint8_t usbd_status::device_cfg;\n</code></pre>"},{"location":"apiStm/structusbd__status/#variable-device_state","title":"variable device_state","text":"<pre><code>uint8_t usbd_status::device_state;\n</code></pre>"},{"location":"apiStm/structusbd__status/#variable-ep0size","title":"variable ep0size","text":"<pre><code>uint8_t usbd_status::ep0size;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usbd_core.h</code></p>"},{"location":"apiStm/group__USBD__HW/","title":"Group USBD_HW","text":"<p>Modules &gt; USBD_HW</p> <p>Contains HW driver API. </p>"},{"location":"apiStm/group__USBD__HW/#classes","title":"Classes","text":"Type Name struct usbd_driver Represents a hardware USB driver call table."},{"location":"apiStm/group__USBD__HW/#public-types","title":"Public Types","text":"Type Name typedef uint8_t(* usbd_hw_connect typedef void(* usbd_hw_enable Enables or disables USB hardware. typedef bool(* usbd_hw_ep_config Configures endpoint. typedef void(* usbd_hw_ep_deconfig De-configures, cleans and disables endpoint. typedef bool(* usbd_hw_ep_isstalled Checks endpoint for stalled state. typedef int32_t(* usbd_hw_ep_read Reads data from OUT or control endpoint. typedef void(* usbd_hw_ep_setstall typedef int32_t(* usbd_hw_ep_write Writes data to IN or control endpoint. typedef uint16_t(* usbd_hw_get_frameno Gets frame number from usb hardware. typedef uint16_t(* usbd_hw_get_serialno Makes a string descriptor contains unique serial number from hardware ID's. typedef uint32_t(* usbd_hw_getinfo Get USB device status and capabilities. typedef void(* usbd_hw_poll Polls USB hardware for the events. typedef void(* usbd_hw_setaddr Sets USB hardware address."},{"location":"apiStm/group__USBD__HW/#macros","title":"Macros","text":"Type Name define USBD_HW_ADDRFST  (1 &lt;&lt; 0)Set address before STATUS_OUT. define USBD_HW_BC  (1 &lt;&lt; 1)Battery charging detection supported. define USBD_HW_ENABLED  (1 &lt;&lt; 3)USB device enabled. define USBD_HW_ENUMSPEED  (2 &lt;&lt; 4)USB device enumeration speed mask. define USBD_HW_SPEED_FS  (2 &lt;&lt; 4)Full speed. define USBD_HW_SPEED_HS  (3 &lt;&lt; 4)High speed. define USBD_HW_SPEED_LS  (1 &lt;&lt; 4)Low speed. define USBD_HW_SPEED_NC  (0 &lt;&lt; 4)Not connected. define USND_HW_HS  (1 &lt;&lt; 2)High speed supported. define usbd_evt_count  8 define usbd_evt_eprx  5Data packet received. define usbd_evt_epsetup  6Setup packet received. define usbd_evt_eptx  4Data packet transmitted. define usbd_evt_error  7Data error. define usbd_evt_reset  0Reset. define usbd_evt_sof  1Start of frame. define usbd_evt_susp  2Suspend. define usbd_evt_wkup  3Wakeup. define usbd_lane_cdp  3Lanes connected to charging downstream port. define usbd_lane_dcp  4Lanes connected to dedicated charging port. define usbd_lane_dsc  1Lanes disconnected. define usbd_lane_sdp  2Lanes connected to standard downstream port. define usbd_lane_unk  0Unknown or proprietary charger."},{"location":"apiStm/group__USBD__HW/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/group__USBD__HW/#typedef-usbd_hw_connect","title":"typedef usbd_hw_connect","text":"<pre><code>typedef uint8_t(* usbd_hw_connect) (bool connect);\n</code></pre> <p>Connects or disconnects USB hardware to/from usb host </p> <p>Parameters:</p> <ul> <li><code>connect</code> Connects USB to host if TRUE, disconnects otherwise </li> </ul> <p>Returns:</p> <p>lanes connection status. </p>"},{"location":"apiStm/group__USBD__HW/#typedef-usbd_hw_enable","title":"typedef usbd_hw_enable","text":"<p>Enables or disables USB hardware. <pre><code>typedef void(* usbd_hw_enable) (bool enable);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>enable</code> Enables USB when TRUE disables otherwise. </li> </ul>"},{"location":"apiStm/group__USBD__HW/#typedef-usbd_hw_ep_config","title":"typedef usbd_hw_ep_config","text":"<p>Configures endpoint. <pre><code>typedef bool(* usbd_hw_ep_config) (uint8_t ep, uint8_t eptype, uint16_t epsize);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ep</code> endpoint address. Use USB_EPDIR_ macros to set endpoint direction </li> <li><code>eptype</code> endpoint type. Use USB_EPTYPE_* macros. </li> <li><code>epsize</code> endpoint size in bytes </li> </ul> <p>Returns:</p> <p>TRUE if success </p>"},{"location":"apiStm/group__USBD__HW/#typedef-usbd_hw_ep_deconfig","title":"typedef usbd_hw_ep_deconfig","text":"<p>De-configures, cleans and disables endpoint. <pre><code>typedef void(* usbd_hw_ep_deconfig) (uint8_t ep);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ep</code> endpoint index </li> </ul> <p>Note:</p> <p>if you have two one-direction single-buffered endpoints with same index (i.e. 0x02 and 0x82) both will be deconfigured. </p>"},{"location":"apiStm/group__USBD__HW/#typedef-usbd_hw_ep_isstalled","title":"typedef usbd_hw_ep_isstalled","text":"<p>Checks endpoint for stalled state. <pre><code>typedef bool(* usbd_hw_ep_isstalled) (uint8_t ep);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ep</code> endpoint address </li> </ul> <p>Returns:</p> <p>TRUE if endpoint is stalled </p>"},{"location":"apiStm/group__USBD__HW/#typedef-usbd_hw_ep_read","title":"typedef usbd_hw_ep_read","text":"<p>Reads data from OUT or control endpoint. <pre><code>typedef int32_t(* usbd_hw_ep_read) (uint8_t ep, void *buf, uint16_t blen);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ep</code> endpoint index, should belong to OUT or CONTROL endpoint. </li> <li><code>buf</code> pointer to read buffer </li> <li><code>blen</code> size of the read buffer in bytes </li> </ul> <p>Returns:</p> <p>size of the actually received data, -1 on error. </p>"},{"location":"apiStm/group__USBD__HW/#typedef-usbd_hw_ep_setstall","title":"typedef usbd_hw_ep_setstall","text":"<pre><code>typedef void(* usbd_hw_ep_setstall) (uint8_t ep, bool stall);\n</code></pre> <p>Stalls and unstalls endpoint </p> <p>Parameters:</p> <ul> <li><code>ep</code> endpoint address </li> <li><code>stall</code> endpoint will be stalled if TRUE and unstalled otherwise. </li> </ul> <p>Note:</p> <p>Has no effect on inactive endpoints. </p>"},{"location":"apiStm/group__USBD__HW/#typedef-usbd_hw_ep_write","title":"typedef usbd_hw_ep_write","text":"<p>Writes data to IN or control endpoint. <pre><code>typedef int32_t(* usbd_hw_ep_write) (uint8_t ep, void *buf, uint16_t blen);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ep</code> endpoint index, hould belong to IN or CONTROL endpoint </li> <li><code>buf</code> pointer to data buffer </li> <li><code>blen</code> size of data will be written </li> </ul> <p>Returns:</p> <p>number of written bytes </p>"},{"location":"apiStm/group__USBD__HW/#typedef-usbd_hw_get_frameno","title":"typedef usbd_hw_get_frameno","text":"<pre><code>typedef uint16_t(* usbd_hw_get_frameno) (void);\n</code></pre>"},{"location":"apiStm/group__USBD__HW/#typedef-usbd_hw_get_serialno","title":"typedef usbd_hw_get_serialno","text":"<p>Makes a string descriptor contains unique serial number from hardware ID's. <pre><code>typedef uint16_t(* usbd_hw_get_serialno) (void *buffer);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buffer</code> pointer to buffer for the descriptor </li> </ul> <p>Returns:</p> <p>of the descriptor in bytes </p>"},{"location":"apiStm/group__USBD__HW/#typedef-usbd_hw_getinfo","title":"typedef usbd_hw_getinfo","text":"<p>Get USB device status and capabilities. <pre><code>typedef uint32_t(* usbd_hw_getinfo) (void);\n</code></pre></p> <p>Returns:</p> <p>Hardware status and capabilities USBD_HW_CAPS </p>"},{"location":"apiStm/group__USBD__HW/#typedef-usbd_hw_poll","title":"typedef usbd_hw_poll","text":"<p>Polls USB hardware for the events. <pre><code>typedef void(* usbd_hw_poll) (usbd_device *dev, usbd_evt_callback callback);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> pointer to usb device structure </li> <li><code>callback</code> callback to event processing subroutine </li> </ul>"},{"location":"apiStm/group__USBD__HW/#typedef-usbd_hw_setaddr","title":"typedef usbd_hw_setaddr","text":"<p>Sets USB hardware address. <pre><code>typedef void(* usbd_hw_setaddr) (uint8_t address);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>address</code> USB address </li> </ul>"},{"location":"apiStm/group__USBD__HW/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/group__USBD__HW/#define-usbd_hw_addrfst","title":"define USBD_HW_ADDRFST","text":"<pre><code>#define USBD_HW_ADDRFST (1 &lt;&lt; 0)\n</code></pre>"},{"location":"apiStm/group__USBD__HW/#define-usbd_hw_bc","title":"define USBD_HW_BC","text":"<pre><code>#define USBD_HW_BC (1 &lt;&lt; 1)\n</code></pre>"},{"location":"apiStm/group__USBD__HW/#define-usbd_hw_enabled","title":"define USBD_HW_ENABLED","text":"<pre><code>#define USBD_HW_ENABLED (1 &lt;&lt; 3)\n</code></pre>"},{"location":"apiStm/group__USBD__HW/#define-usbd_hw_enumspeed","title":"define USBD_HW_ENUMSPEED","text":"<pre><code>#define USBD_HW_ENUMSPEED (2 &lt;&lt; 4)\n</code></pre>"},{"location":"apiStm/group__USBD__HW/#define-usbd_hw_speed_fs","title":"define USBD_HW_SPEED_FS","text":"<pre><code>#define USBD_HW_SPEED_FS (2 &lt;&lt; 4)\n</code></pre>"},{"location":"apiStm/group__USBD__HW/#define-usbd_hw_speed_hs","title":"define USBD_HW_SPEED_HS","text":"<pre><code>#define USBD_HW_SPEED_HS (3 &lt;&lt; 4)\n</code></pre>"},{"location":"apiStm/group__USBD__HW/#define-usbd_hw_speed_ls","title":"define USBD_HW_SPEED_LS","text":"<pre><code>#define USBD_HW_SPEED_LS (1 &lt;&lt; 4)\n</code></pre>"},{"location":"apiStm/group__USBD__HW/#define-usbd_hw_speed_nc","title":"define USBD_HW_SPEED_NC","text":"<pre><code>#define USBD_HW_SPEED_NC (0 &lt;&lt; 4)\n</code></pre>"},{"location":"apiStm/group__USBD__HW/#define-usnd_hw_hs","title":"define USND_HW_HS","text":"<pre><code>#define USND_HW_HS (1 &lt;&lt; 2)\n</code></pre>"},{"location":"apiStm/group__USBD__HW/#define-usbd_evt_count","title":"define usbd_evt_count","text":"<pre><code>#define usbd_evt_count 8\n</code></pre>"},{"location":"apiStm/group__USBD__HW/#define-usbd_evt_eprx","title":"define usbd_evt_eprx","text":"<pre><code>#define usbd_evt_eprx 5\n</code></pre>"},{"location":"apiStm/group__USBD__HW/#define-usbd_evt_epsetup","title":"define usbd_evt_epsetup","text":"<pre><code>#define usbd_evt_epsetup 6\n</code></pre>"},{"location":"apiStm/group__USBD__HW/#define-usbd_evt_eptx","title":"define usbd_evt_eptx","text":"<pre><code>#define usbd_evt_eptx 4\n</code></pre>"},{"location":"apiStm/group__USBD__HW/#define-usbd_evt_error","title":"define usbd_evt_error","text":"<pre><code>#define usbd_evt_error 7\n</code></pre>"},{"location":"apiStm/group__USBD__HW/#define-usbd_evt_reset","title":"define usbd_evt_reset","text":"<pre><code>#define usbd_evt_reset 0\n</code></pre>"},{"location":"apiStm/group__USBD__HW/#define-usbd_evt_sof","title":"define usbd_evt_sof","text":"<pre><code>#define usbd_evt_sof 1\n</code></pre>"},{"location":"apiStm/group__USBD__HW/#define-usbd_evt_susp","title":"define usbd_evt_susp","text":"<pre><code>#define usbd_evt_susp 2\n</code></pre>"},{"location":"apiStm/group__USBD__HW/#define-usbd_evt_wkup","title":"define usbd_evt_wkup","text":"<pre><code>#define usbd_evt_wkup 3\n</code></pre>"},{"location":"apiStm/group__USBD__HW/#define-usbd_lane_cdp","title":"define usbd_lane_cdp","text":"<pre><code>#define usbd_lane_cdp 3\n</code></pre>"},{"location":"apiStm/group__USBD__HW/#define-usbd_lane_dcp","title":"define usbd_lane_dcp","text":"<pre><code>#define usbd_lane_dcp 4\n</code></pre>"},{"location":"apiStm/group__USBD__HW/#define-usbd_lane_dsc","title":"define usbd_lane_dsc","text":"<pre><code>#define usbd_lane_dsc 1\n</code></pre>"},{"location":"apiStm/group__USBD__HW/#define-usbd_lane_sdp","title":"define usbd_lane_sdp","text":"<pre><code>#define usbd_lane_sdp 2\n</code></pre>"},{"location":"apiStm/group__USBD__HW/#define-usbd_lane_unk","title":"define usbd_lane_unk","text":"<pre><code>#define usbd_lane_unk 0\n</code></pre>"},{"location":"apiStm/structusbd__driver/","title":"Struct usbd_driver","text":"<p>ClassList &gt; usbd_driver</p> <p>Represents a hardware USB driver call table. </p> <ul> <li><code>#include &lt;usbd_core.h&gt;</code></li> </ul>"},{"location":"apiStm/structusbd__driver/#public-attributes","title":"Public Attributes","text":"Type Name usbd_hw_connect connect usbd_hw_enable enable Enables or disables USB hardware. usbd_hw_ep_config ep_config Configures endpoint. usbd_hw_ep_deconfig ep_deconfig De-configures, cleans and disables endpoint. usbd_hw_ep_isstalled ep_isstalled Checks endpoint for stalled state. usbd_hw_ep_read ep_read Reads data from OUT or control endpoint. usbd_hw_ep_setstall ep_setstall usbd_hw_ep_write ep_write Writes data to IN or control endpoint. usbd_hw_get_frameno frame_no Gets frame number from usb hardware. usbd_hw_get_serialno get_serialno_desc Makes a string descriptor contains unique serial number from hardware ID's. usbd_hw_getinfo getinfo Get USB device status and capabilities. usbd_hw_poll poll Polls USB hardware for the events. usbd_hw_setaddr setaddr Sets USB hardware address."},{"location":"apiStm/structusbd__driver/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusbd__driver/#variable-connect","title":"variable connect","text":"<pre><code>usbd_hw_connect usbd_driver::connect;\n</code></pre>"},{"location":"apiStm/structusbd__driver/#variable-enable","title":"variable enable","text":"<pre><code>usbd_hw_enable usbd_driver::enable;\n</code></pre>"},{"location":"apiStm/structusbd__driver/#variable-ep_config","title":"variable ep_config","text":"<pre><code>usbd_hw_ep_config usbd_driver::ep_config;\n</code></pre>"},{"location":"apiStm/structusbd__driver/#variable-ep_deconfig","title":"variable ep_deconfig","text":"<pre><code>usbd_hw_ep_deconfig usbd_driver::ep_deconfig;\n</code></pre>"},{"location":"apiStm/structusbd__driver/#variable-ep_isstalled","title":"variable ep_isstalled","text":"<pre><code>usbd_hw_ep_isstalled usbd_driver::ep_isstalled;\n</code></pre>"},{"location":"apiStm/structusbd__driver/#variable-ep_read","title":"variable ep_read","text":"<pre><code>usbd_hw_ep_read usbd_driver::ep_read;\n</code></pre>"},{"location":"apiStm/structusbd__driver/#variable-ep_setstall","title":"variable ep_setstall","text":"<pre><code>usbd_hw_ep_setstall usbd_driver::ep_setstall;\n</code></pre>"},{"location":"apiStm/structusbd__driver/#variable-ep_write","title":"variable ep_write","text":"<pre><code>usbd_hw_ep_write usbd_driver::ep_write;\n</code></pre>"},{"location":"apiStm/structusbd__driver/#variable-frame_no","title":"variable frame_no","text":"<pre><code>usbd_hw_get_frameno usbd_driver::frame_no;\n</code></pre>"},{"location":"apiStm/structusbd__driver/#variable-get_serialno_desc","title":"variable get_serialno_desc","text":"<pre><code>usbd_hw_get_serialno usbd_driver::get_serialno_desc;\n</code></pre>"},{"location":"apiStm/structusbd__driver/#variable-getinfo","title":"variable getinfo","text":"<pre><code>usbd_hw_getinfo usbd_driver::getinfo;\n</code></pre>"},{"location":"apiStm/structusbd__driver/#variable-poll","title":"variable poll","text":"<pre><code>usbd_hw_poll usbd_driver::poll;\n</code></pre>"},{"location":"apiStm/structusbd__driver/#variable-setaddr","title":"variable setaddr","text":"<pre><code>usbd_hw_setaddr usbd_driver::setaddr;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usbd_core.h</code></p>"},{"location":"apiStm/group__USB__CDC/","title":"Group USB_CDC","text":"<p>Modules &gt; USB_CDC</p> <p>Generic USB CDC class definitions. More...</p>"},{"location":"apiStm/group__USB__CDC/#classes","title":"Classes","text":"Type Name struct usb_cdc_acm_desc Abstract Control Management Functional Descriptor. struct usb_cdc_call_mgmt_desc Call Management Functional Descriptor. struct usb_cdc_country_desc Country Selection Functional Descriptor. struct usb_cdc_header_desc Header Functional Descriptor. struct usb_cdc_line_coding Line Coding Structure. struct usb_cdc_notification Notification structure from CDC. struct usb_cdc_union_desc Union Functional Descriptor."},{"location":"apiStm/group__USB__CDC/#public-functions","title":"Public Functions","text":"Type Name struct usb_cdc_header_desc __attribute__ ((packed))"},{"location":"apiStm/group__USB__CDC/#macros","title":"Macros","text":"Type Name define USB_CDC_1_5_STOP_BITS  0x011.5 stop bits. define USB_CDC_1_STOP_BITS  0x001 stop bit. define USB_CDC_2_STOP_BITS  0x022 stop bits. define USB_CDC_CALL_MGMT_CAP_CALL_MGMT  0x01Device handles call management itself. define USB_CDC_CALL_MGMT_CAP_DATA_INTF  0x02Device can send/receive call management information over a Data Class interface. define USB_CDC_CAP_BRK  0x04Supports the request Send_Break. define USB_CDC_CAP_LINE  0x02Supports the request combination of Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State. define USB_CDC_CAP_NOTIFY  0x08Supports notification Network_Connection. define USB_CDC_CLEAR_COMM_FEATURE  0x04Controls the settings for a particular communication feature of a particular target, setting the selected feature to its default state. define USB_CDC_COMM_FEATURE  0x01Supports the request combination of Set_Comm_Feature, Clear_Comm_Feature, Get_Comm_Feature. define USB_CDC_EVEN_PARITY  0x02EVEN parity bit. define USB_CDC_GET_COMM_FEATURE  0x03Returns the current settings for the communication feature as selected. define USB_CDC_GET_ENCAPSULATED_RESP  0x01Used to request a response in the format of the supported control protocol of the Communication Class interface. define USB_CDC_GET_LINE_CODING  0x21Allows the host to find out the currently configured line coding. define USB_CDC_MARK_PARITY  0x03patity is MARK. define USB_CDC_NO_PARITY  0x00NO parity bit. define USB_CDC_NTF_NETWORK_CONNECTION  0x00Allows the device to notify the host about network connection status. define USB_CDC_NTF_RESPONSE_AVAILABLE  0x01Allows the device to notify the host that a response is available. define USB_CDC_NTF_SERIAL_STATE  0x20Sends asynchronous notification of UART status. define USB_CDC_NTF_SPEED_CHANGE  0x2AAllows the device to inform the host-networking driver that a change in either the uplink or the downlink bit rate of the connection has occurred. define USB_CDC_ODD_PARITY  0x01ODD parity bit. define USB_CDC_PROTO_CDCSPEC  0xFECDC specified. define USB_CDC_PROTO_HOST  0xFDHost based driver. define USB_CDC_PROTO_NONE  0x00No class specific protocol required. define USB_CDC_PROTO_NTB  0x01Network Transfer Block. define USB_CDC_PROTO_V25TER  0x01AT Commands: V.250 etc. define USB_CDC_SEND_BREAK  0x23Sends special carrier modulation that generates an RS-232 style break. define USB_CDC_SEND_ENCAPSULATED_CMD  0x00Used to issue a command in the format of the supported control protocol of the Communication Class interface. define USB_CDC_SET_COMM_FEATURE  0x02Controls the settings for a particular communication feature of a particular target. define USB_CDC_SET_CONTROL_LINE_STATE  0x22Generates RS-232/V.24 style control signals. define USB_CDC_SET_LINE_CODING  0x20Allows the host to specify typical asynchronous line-character formatting properties. define USB_CDC_SPACE_PARITY  0x04patity is SPACE. define USB_CDC_STATE_BREAK  0x0004State of break detection mechanism of the device. define USB_CDC_STATE_FRAMING  0x0010A framing error has occurred. define USB_CDC_STATE_OVERRUN  0x0040Received data has been discarded due to overrun in the device. define USB_CDC_STATE_PARITY  0x0020A parity error has occurred. define USB_CDC_STATE_RING  0x0008State of ring signal detection of the device. define USB_CDC_STATE_RX_CARRIER  0x0001State of receiver carrier detection mechanism. define USB_CDC_STATE_TX_CARRIER  0x0002State of transmission carrier. define USB_CDC_SUBCLASS_ACM  0x02Abstract Control Model. define USB_CLASS_CDC  0x02Communicational Device class. define USB_CLASS_CDC_DATA  0x0AData Interface class. define USB_DTYPE_CDC_ACM  0x02Abstract Control Management Functional Descriptor. define USB_DTYPE_CDC_CALL_MANAGEMENT  0x01Call Management Functional Descriptor. define USB_DTYPE_CDC_COUNTRY  0x07Country Selection Functional Descriptor. define USB_DTYPE_CDC_HEADER  0x00Header Functional Descriptor. define USB_DTYPE_CDC_UNION  0x06Union Functional Descriptor."},{"location":"apiStm/group__USB__CDC/#detailed-description","title":"Detailed Description","text":"<p>This module based on * Universal Serial Bus Class Definitions for Communications Devices Revision 1.2 (Errata 1) </p>"},{"location":"apiStm/group__USB__CDC/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/group__USB__CDC/#function-__attribute__","title":"function __attribute__","text":"<pre><code>struct usb_cdc_header_desc __attribute__ (\n(packed)\n) </code></pre>"},{"location":"apiStm/group__USB__CDC/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_1_5_stop_bits","title":"define USB_CDC_1_5_STOP_BITS","text":"<pre><code>#define USB_CDC_1_5_STOP_BITS 0x01\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_1_stop_bits","title":"define USB_CDC_1_STOP_BITS","text":"<pre><code>#define USB_CDC_1_STOP_BITS 0x00\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_2_stop_bits","title":"define USB_CDC_2_STOP_BITS","text":"<pre><code>#define USB_CDC_2_STOP_BITS 0x02\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_call_mgmt_cap_call_mgmt","title":"define USB_CDC_CALL_MGMT_CAP_CALL_MGMT","text":"<pre><code>#define USB_CDC_CALL_MGMT_CAP_CALL_MGMT 0x01\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_call_mgmt_cap_data_intf","title":"define USB_CDC_CALL_MGMT_CAP_DATA_INTF","text":"<pre><code>#define USB_CDC_CALL_MGMT_CAP_DATA_INTF 0x02\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_cap_brk","title":"define USB_CDC_CAP_BRK","text":"<pre><code>#define USB_CDC_CAP_BRK 0x04\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_cap_line","title":"define USB_CDC_CAP_LINE","text":"<pre><code>#define USB_CDC_CAP_LINE 0x02\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_cap_notify","title":"define USB_CDC_CAP_NOTIFY","text":"<pre><code>#define USB_CDC_CAP_NOTIFY 0x08\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_clear_comm_feature","title":"define USB_CDC_CLEAR_COMM_FEATURE","text":"<pre><code>#define USB_CDC_CLEAR_COMM_FEATURE 0x04\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_comm_feature","title":"define USB_CDC_COMM_FEATURE","text":"<pre><code>#define USB_CDC_COMM_FEATURE 0x01\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_even_parity","title":"define USB_CDC_EVEN_PARITY","text":"<pre><code>#define USB_CDC_EVEN_PARITY 0x02\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_get_comm_feature","title":"define USB_CDC_GET_COMM_FEATURE","text":"<pre><code>#define USB_CDC_GET_COMM_FEATURE 0x03\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_get_encapsulated_resp","title":"define USB_CDC_GET_ENCAPSULATED_RESP","text":"<pre><code>#define USB_CDC_GET_ENCAPSULATED_RESP 0x01\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_get_line_coding","title":"define USB_CDC_GET_LINE_CODING","text":"<pre><code>#define USB_CDC_GET_LINE_CODING 0x21\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_mark_parity","title":"define USB_CDC_MARK_PARITY","text":"<pre><code>#define USB_CDC_MARK_PARITY 0x03\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_no_parity","title":"define USB_CDC_NO_PARITY","text":"<pre><code>#define USB_CDC_NO_PARITY 0x00\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_ntf_network_connection","title":"define USB_CDC_NTF_NETWORK_CONNECTION","text":"<pre><code>#define USB_CDC_NTF_NETWORK_CONNECTION 0x00\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_ntf_response_available","title":"define USB_CDC_NTF_RESPONSE_AVAILABLE","text":"<pre><code>#define USB_CDC_NTF_RESPONSE_AVAILABLE 0x01\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_ntf_serial_state","title":"define USB_CDC_NTF_SERIAL_STATE","text":"<pre><code>#define USB_CDC_NTF_SERIAL_STATE 0x20\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_ntf_speed_change","title":"define USB_CDC_NTF_SPEED_CHANGE","text":"<pre><code>#define USB_CDC_NTF_SPEED_CHANGE 0x2A\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_odd_parity","title":"define USB_CDC_ODD_PARITY","text":"<pre><code>#define USB_CDC_ODD_PARITY 0x01\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_proto_cdcspec","title":"define USB_CDC_PROTO_CDCSPEC","text":"<p>CDC specified. <pre><code>#define USB_CDC_PROTO_CDCSPEC 0xFE\n</code></pre></p> <p>The protocol(s) are described using a Protocol Unit Functional Descriptors on Communication Class Interface. </p>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_proto_host","title":"define USB_CDC_PROTO_HOST","text":"<p>Host based driver. <pre><code>#define USB_CDC_PROTO_HOST 0xFD\n</code></pre></p> <p>This protocol code should only be used in messages between host and device to identify the host driver portion of a protocol stack. </p>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_proto_none","title":"define USB_CDC_PROTO_NONE","text":"<pre><code>#define USB_CDC_PROTO_NONE 0x00\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_proto_ntb","title":"define USB_CDC_PROTO_NTB","text":"<pre><code>#define USB_CDC_PROTO_NTB 0x01\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_proto_v25ter","title":"define USB_CDC_PROTO_V25TER","text":"<pre><code>#define USB_CDC_PROTO_V25TER 0x01\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_send_break","title":"define USB_CDC_SEND_BREAK","text":"<pre><code>#define USB_CDC_SEND_BREAK 0x23\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_send_encapsulated_cmd","title":"define USB_CDC_SEND_ENCAPSULATED_CMD","text":"<pre><code>#define USB_CDC_SEND_ENCAPSULATED_CMD 0x00\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_set_comm_feature","title":"define USB_CDC_SET_COMM_FEATURE","text":"<pre><code>#define USB_CDC_SET_COMM_FEATURE 0x02\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_set_control_line_state","title":"define USB_CDC_SET_CONTROL_LINE_STATE","text":"<pre><code>#define USB_CDC_SET_CONTROL_LINE_STATE 0x22\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_set_line_coding","title":"define USB_CDC_SET_LINE_CODING","text":"<pre><code>#define USB_CDC_SET_LINE_CODING 0x20\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_space_parity","title":"define USB_CDC_SPACE_PARITY","text":"<pre><code>#define USB_CDC_SPACE_PARITY 0x04\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_state_break","title":"define USB_CDC_STATE_BREAK","text":"<pre><code>#define USB_CDC_STATE_BREAK 0x0004\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_state_framing","title":"define USB_CDC_STATE_FRAMING","text":"<pre><code>#define USB_CDC_STATE_FRAMING 0x0010\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_state_overrun","title":"define USB_CDC_STATE_OVERRUN","text":"<pre><code>#define USB_CDC_STATE_OVERRUN 0x0040\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_state_parity","title":"define USB_CDC_STATE_PARITY","text":"<pre><code>#define USB_CDC_STATE_PARITY 0x0020\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_state_ring","title":"define USB_CDC_STATE_RING","text":"<pre><code>#define USB_CDC_STATE_RING 0x0008\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_state_rx_carrier","title":"define USB_CDC_STATE_RX_CARRIER","text":"<p>State of receiver carrier detection mechanism. <pre><code>#define USB_CDC_STATE_RX_CARRIER 0x0001\n</code></pre></p> <p>This signal corresponds to V.24 signal 109 and RS-232 DCD. </p>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_state_tx_carrier","title":"define USB_CDC_STATE_TX_CARRIER","text":"<p>State of transmission carrier. <pre><code>#define USB_CDC_STATE_TX_CARRIER 0x0002\n</code></pre></p> <p>This signal corresponds to V.24 signal 106 and RS-232 DSR. </p>"},{"location":"apiStm/group__USB__CDC/#define-usb_cdc_subclass_acm","title":"define USB_CDC_SUBCLASS_ACM","text":"<pre><code>#define USB_CDC_SUBCLASS_ACM 0x02\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_class_cdc","title":"define USB_CLASS_CDC","text":"<pre><code>#define USB_CLASS_CDC 0x02\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_class_cdc_data","title":"define USB_CLASS_CDC_DATA","text":"<pre><code>#define USB_CLASS_CDC_DATA 0x0A\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_dtype_cdc_acm","title":"define USB_DTYPE_CDC_ACM","text":"<pre><code>#define USB_DTYPE_CDC_ACM 0x02\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_dtype_cdc_call_management","title":"define USB_DTYPE_CDC_CALL_MANAGEMENT","text":"<pre><code>#define USB_DTYPE_CDC_CALL_MANAGEMENT 0x01\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_dtype_cdc_country","title":"define USB_DTYPE_CDC_COUNTRY","text":"<pre><code>#define USB_DTYPE_CDC_COUNTRY 0x07\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_dtype_cdc_header","title":"define USB_DTYPE_CDC_HEADER","text":"<pre><code>#define USB_DTYPE_CDC_HEADER 0x00\n</code></pre>"},{"location":"apiStm/group__USB__CDC/#define-usb_dtype_cdc_union","title":"define USB_DTYPE_CDC_UNION","text":"<pre><code>#define USB_DTYPE_CDC_UNION 0x06\n</code></pre>"},{"location":"apiStm/structusb__cdc__acm__desc/","title":"Struct usb_cdc_acm_desc","text":"<p>ClassList &gt; usb_cdc_acm_desc</p> <p>Abstract Control Management Functional Descriptor. More...</p> <ul> <li><code>#include &lt;usb_cdc.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__cdc__acm__desc/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bDescriptorSubType Abstract Control Management functional descriptor subtype. uint8_t bDescriptorType CS_INTERFACE descriptor type. uint8_t bFunctionLength Size of this functional descriptor, in bytes. uint8_t bmCapabilities The capabilities that this configuration supports."},{"location":"apiStm/structusb__cdc__acm__desc/#detailed-description","title":"Detailed Description","text":"<p>The Abstract Control Management functional descriptor describes the commands supported by the Communication Class interface, as defined in Section 3.6.2, with the SubClass code of Abstract Control Model. It can only occur within the class-specific portion of an Interface descriptor. </p>"},{"location":"apiStm/structusb__cdc__acm__desc/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__cdc__acm__desc/#variable-bdescriptorsubtype","title":"variable bDescriptorSubType","text":"<pre><code>uint8_t usb_cdc_acm_desc::bDescriptorSubType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__acm__desc/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_cdc_acm_desc::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__acm__desc/#variable-bfunctionlength","title":"variable bFunctionLength","text":"<pre><code>uint8_t usb_cdc_acm_desc::bFunctionLength;\n</code></pre>"},{"location":"apiStm/structusb__cdc__acm__desc/#variable-bmcapabilities","title":"variable bmCapabilities","text":"<pre><code>uint8_t usb_cdc_acm_desc::bmCapabilities;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_cdc.h</code></p>"},{"location":"apiStm/structusb__cdc__call__mgmt__desc/","title":"Struct usb_cdc_call_mgmt_desc","text":"<p>ClassList &gt; usb_cdc_call_mgmt_desc</p> <p>Call Management Functional Descriptor. More...</p> <ul> <li><code>#include &lt;usb_cdc.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__cdc__call__mgmt__desc/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bDataInterface Interface number of Data Class interface optionally used for call management. uint8_t bDescriptorSubType Call Management functional descriptor subtype. uint8_t bDescriptorType CS_INTERFACE descriptor type. uint8_t bFunctionLength Size of this functional descriptor, in bytes. uint8_t bmCapabilities The call management capabilities that this configuration supports."},{"location":"apiStm/structusb__cdc__call__mgmt__desc/#detailed-description","title":"Detailed Description","text":"<p>The Call Management functional descriptor describes the processing of calls for the Communication Class interface. It can only occur within the class-specific portion of an Interface descriptor. </p>"},{"location":"apiStm/structusb__cdc__call__mgmt__desc/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__cdc__call__mgmt__desc/#variable-bdatainterface","title":"variable bDataInterface","text":"<pre><code>uint8_t usb_cdc_call_mgmt_desc::bDataInterface;\n</code></pre>"},{"location":"apiStm/structusb__cdc__call__mgmt__desc/#variable-bdescriptorsubtype","title":"variable bDescriptorSubType","text":"<pre><code>uint8_t usb_cdc_call_mgmt_desc::bDescriptorSubType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__call__mgmt__desc/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_cdc_call_mgmt_desc::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__call__mgmt__desc/#variable-bfunctionlength","title":"variable bFunctionLength","text":"<pre><code>uint8_t usb_cdc_call_mgmt_desc::bFunctionLength;\n</code></pre>"},{"location":"apiStm/structusb__cdc__call__mgmt__desc/#variable-bmcapabilities","title":"variable bmCapabilities","text":"<pre><code>uint8_t usb_cdc_call_mgmt_desc::bmCapabilities;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_cdc.h</code></p>"},{"location":"apiStm/structusb__cdc__country__desc/","title":"Struct usb_cdc_country_desc","text":"<p>ClassList &gt; usb_cdc_country_desc</p> <p>Country Selection Functional Descriptor. More...</p> <ul> <li><code>#include &lt;usb_cdc.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__cdc__country__desc/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bDescriptorSubType Country Selection Functional Descriptor. uint8_t bDescriptorType CS_INTERFACE descriptor type. uint8_t bFunctionLength Size of this functional descriptor, in bytes. uint8_t iCountryCodeRelDate Index of a string giving the release date for the implemented ISO 3166 Country Codes. uint8_t wCountyCode0 Country code in hexadecimal format."},{"location":"apiStm/structusb__cdc__country__desc/#detailed-description","title":"Detailed Description","text":"<p>The Country Selection functional descriptor identifies the countries in which the communication device is qualified to operate. The parameters of the network connection often vary from one country to another, especially in Europe. Also legal requirements impose certain restrictions on devices because of different regulations by the governing body of the network to which the device must adhere. This descriptor can only occur within the class-specific portion of an Interface descriptor and should only be provided to a master Communication Class interface of a union. The country codes used in the Country Selection Functional Descriptor are not the same as the country codes used in dialing international telephone calls. Implementers should refer to the ISO 3166 specification for more information. </p>"},{"location":"apiStm/structusb__cdc__country__desc/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__cdc__country__desc/#variable-bdescriptorsubtype","title":"variable bDescriptorSubType","text":"<pre><code>uint8_t usb_cdc_country_desc::bDescriptorSubType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__country__desc/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_cdc_country_desc::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__country__desc/#variable-bfunctionlength","title":"variable bFunctionLength","text":"<pre><code>uint8_t usb_cdc_country_desc::bFunctionLength;\n</code></pre>"},{"location":"apiStm/structusb__cdc__country__desc/#variable-icountrycodereldate","title":"variable iCountryCodeRelDate","text":"<pre><code>uint8_t usb_cdc_country_desc::iCountryCodeRelDate;\n</code></pre>"},{"location":"apiStm/structusb__cdc__country__desc/#variable-wcountycode0","title":"variable wCountyCode0","text":"<p>Country code in hexadecimal format. <pre><code>uint8_t usb_cdc_country_desc::wCountyCode0;\n</code></pre></p> <p>As defined in ISO 3166, release date as specified in iCountryCodeRelDate for the first supported country. </p> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_cdc.h</code></p>"},{"location":"apiStm/structusb__cdc__header__desc/","title":"Struct usb_cdc_header_desc","text":"<p>ClassList &gt; usb_cdc_header_desc</p> <p>Header Functional Descriptor. More...</p> <ul> <li><code>#include &lt;usb_cdc.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__cdc__header__desc/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bDescriptorSubType Header functional descriptor subtype. uint8_t bDescriptorType CS_INTERFACE descriptor type. uint8_t bFunctionLength Size of this descriptor in bytes. uint16_t bcdCDC USB CDC Specification release number in BCD."},{"location":"apiStm/structusb__cdc__header__desc/#detailed-description","title":"Detailed Description","text":"<p>Header Functional Descriptor marks the beginning of the concatenated set of functional descriptors for the interface. </p>"},{"location":"apiStm/structusb__cdc__header__desc/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__cdc__header__desc/#variable-bdescriptorsubtype","title":"variable bDescriptorSubType","text":"<pre><code>uint8_t usb_cdc_header_desc::bDescriptorSubType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__header__desc/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_cdc_header_desc::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__header__desc/#variable-bfunctionlength","title":"variable bFunctionLength","text":"<pre><code>uint8_t usb_cdc_header_desc::bFunctionLength;\n</code></pre>"},{"location":"apiStm/structusb__cdc__header__desc/#variable-bcdcdc","title":"variable bcdCDC","text":"<pre><code>uint16_t usb_cdc_header_desc::bcdCDC;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_cdc.h</code></p>"},{"location":"apiStm/structusb__cdc__line__coding/","title":"Struct usb_cdc_line_coding","text":"<p>ClassList &gt; usb_cdc_line_coding</p> <p>Line Coding Structure. </p> <ul> <li><code>#include &lt;usb_cdc.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__cdc__line__coding/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bCharFormat Stop bits. uint8_t bDataBits Data bits (5,6,7,8 or 16). uint8_t bParityType Parity. uint32_t dwDTERate Data terminal rate, in bits per second."},{"location":"apiStm/structusb__cdc__line__coding/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__cdc__line__coding/#variable-bcharformat","title":"variable bCharFormat","text":"<pre><code>uint8_t usb_cdc_line_coding::bCharFormat;\n</code></pre>"},{"location":"apiStm/structusb__cdc__line__coding/#variable-bdatabits","title":"variable bDataBits","text":"<pre><code>uint8_t usb_cdc_line_coding::bDataBits;\n</code></pre>"},{"location":"apiStm/structusb__cdc__line__coding/#variable-bparitytype","title":"variable bParityType","text":"<pre><code>uint8_t usb_cdc_line_coding::bParityType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__line__coding/#variable-dwdterate","title":"variable dwDTERate","text":"<pre><code>uint32_t usb_cdc_line_coding::dwDTERate;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_cdc.h</code></p>"},{"location":"apiStm/structusb__cdc__notification/","title":"Struct usb_cdc_notification","text":"<p>ClassList &gt; usb_cdc_notification</p> <p>Notification structure from CDC. </p> <ul> <li><code>#include &lt;usb_cdc.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__cdc__notification/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t Data Data payload. uint8_t bNotificationType Notification type. uint8_t bmRequestType This bitmapped field identifies the characteristics of the specific request. uint16_t wIndex Interface. uint16_t wLength Data payload length in bytes. uint16_t wValue Notification value."},{"location":"apiStm/structusb__cdc__notification/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__cdc__notification/#variable-data","title":"variable Data","text":"<pre><code>uint8_t usb_cdc_notification::Data[];\n</code></pre>"},{"location":"apiStm/structusb__cdc__notification/#variable-bnotificationtype","title":"variable bNotificationType","text":"<pre><code>uint8_t usb_cdc_notification::bNotificationType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__notification/#variable-bmrequesttype","title":"variable bmRequestType","text":"<pre><code>uint8_t usb_cdc_notification::bmRequestType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__notification/#variable-windex","title":"variable wIndex","text":"<pre><code>uint16_t usb_cdc_notification::wIndex;\n</code></pre>"},{"location":"apiStm/structusb__cdc__notification/#variable-wlength","title":"variable wLength","text":"<pre><code>uint16_t usb_cdc_notification::wLength;\n</code></pre>"},{"location":"apiStm/structusb__cdc__notification/#variable-wvalue","title":"variable wValue","text":"<pre><code>uint16_t usb_cdc_notification::wValue;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_cdc.h</code></p>"},{"location":"apiStm/structusb__cdc__union__desc/","title":"Struct usb_cdc_union_desc","text":"<p>ClassList &gt; usb_cdc_union_desc</p> <p>Union Functional Descriptor. More...</p> <ul> <li><code>#include &lt;usb_cdc.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__cdc__union__desc/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bDescriptorSubType Union Functional Descriptor. uint8_t bDescriptorType CS_INTERFACE descriptor type. uint8_t bFunctionLength Size of this functional descriptor, in bytes. uint8_t bMasterInterface0 The interface number of the CDC interface designated as the master or controlling interface for the union. uint8_t bSlaveInterface0 Interface number of first slave or associated interface in the union."},{"location":"apiStm/structusb__cdc__union__desc/#detailed-description","title":"Detailed Description","text":"<p>The Union functional descriptor describes the relationship between a group of interfaces that can be considered to form a functional unit. It can only occur within the class-specific portion of an Interface descriptor. One of the interfaces in the group is designated as a master or controlling interface for the group, and certain class-specific messages can be sent to this interface to act upon the group as a whole. </p>"},{"location":"apiStm/structusb__cdc__union__desc/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__cdc__union__desc/#variable-bdescriptorsubtype","title":"variable bDescriptorSubType","text":"<pre><code>uint8_t usb_cdc_union_desc::bDescriptorSubType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__union__desc/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_cdc_union_desc::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__cdc__union__desc/#variable-bfunctionlength","title":"variable bFunctionLength","text":"<pre><code>uint8_t usb_cdc_union_desc::bFunctionLength;\n</code></pre>"},{"location":"apiStm/structusb__cdc__union__desc/#variable-bmasterinterface0","title":"variable bMasterInterface0","text":"<pre><code>uint8_t usb_cdc_union_desc::bMasterInterface0;\n</code></pre>"},{"location":"apiStm/structusb__cdc__union__desc/#variable-bslaveinterface0","title":"variable bSlaveInterface0","text":"<pre><code>uint8_t usb_cdc_union_desc::bSlaveInterface0;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_cdc.h</code></p>"},{"location":"apiStm/group__USB__STD/","title":"Group USB_STD","text":"<p>Modules &gt; USB_STD</p> <p>This module contains generic USB device framework definitions. More...</p>"},{"location":"apiStm/group__USB__STD/#modules","title":"Modules","text":"Type Name module USB standard LANGID codes"},{"location":"apiStm/group__USB__STD/#classes","title":"Classes","text":"Type Name struct usb_config_descriptor USB device configuration descriptor. struct usb_debug_descriptor USB debug descriptor. struct usb_device_descriptor Represents a USB device descriptor. struct usb_endpoint_descriptor USB endpoint descriptor. struct usb_header_descriptor common USB descriptor header struct usb_iad_descriptor USB interface association descriptor. struct usb_interface_descriptor USB interface descriptor. struct usb_qualifier_descriptor USB device qualifier descriptor. struct usb_string_descriptor USB string descriptor."},{"location":"apiStm/group__USB__STD/#public-functions","title":"Public Functions","text":"Type Name struct usb_header_descriptor __attribute__ ((packed))  struct usb_string_descriptor __attribute__ ((packed, aligned(2)))"},{"location":"apiStm/group__USB__STD/#macros","title":"Macros","text":"Type Name define INTSERIALNO_DESCRIPTOR  0xFEString descriptor is an internal serial number provided by hardware driver. define NO_DESCRIPTOR  0x00String descriptor doesn't exists in the device. define USB_ARRAY_DESC (...)  define USB_CFG_ATTR_RESERVED  0x80 define USB_CFG_ATTR_SELFPOWERED  0x40 define USB_CFG_POWER_MA (mA) ((mA) &gt;&gt; 1)Macro to set \u043caximum power consumption field for the usb_config_descriptor . define USB_CLASS_APP_SPEC  0xFEApplication Specific class. define USB_CLASS_AUDIO  0x01Audio device class. define USB_CLASS_AV  0x10Audio/Video device class. define USB_CLASS_BILLBOARD  0x11Billboard device class. define USB_CLASS_CBRIDGE  0x12USB Type-C Bridge device class. define USB_CLASS_CONTENT_SEC  0x0DContent Security device class. define USB_CLASS_CSCID  0x0BSmart Card device class. define USB_CLASS_DIAGNOSTIC  0xDCDiagnostic device class. define USB_CLASS_HEALTHCARE  0x0FPersonal Healthcare device class. define USB_CLASS_HUB  0x09HUB device class. define USB_CLASS_IAD  0xEFClass defined on interface association level. define USB_CLASS_MASS_STORAGE  0x08Mass Storage device class. define USB_CLASS_MISC  0xEFMiscellanious device class. define USB_CLASS_PER_INTERFACE  0x00Class defined on interface level. define USB_CLASS_PHYSICAL  0x05Physical device class. define USB_CLASS_PRINTER  0x07Printer device class. define USB_CLASS_STILL_IMAGE  0x06Still Imaging device class. define USB_CLASS_VENDOR  0xFFVendor specific class. define USB_CLASS_VIDEO  0x0EVideo device class. define USB_CLASS_WIRELESS  0xE0Wireless controller class. define USB_DTYPE_CONFIGURATION  0x02Configuration descriptor. define USB_DTYPE_CS_ENDPOINT  0x25Class specific endpoint descriptor. define USB_DTYPE_CS_INTERFACE  0x24Class specific interface descriptor. define USB_DTYPE_DEBUG  0x0ADebug descriptor. define USB_DTYPE_DEVICE  0x01Device descriptor. define USB_DTYPE_ENDPOINT  0x05Endpoint descriptor. define USB_DTYPE_INTERFACE  0x04Interface descriptor. define USB_DTYPE_INTERFACEPOWER  0x08Interface power descriptor. define USB_DTYPE_INTERFASEASSOC  0x0BInterface association descriptor. define USB_DTYPE_OTG  0x09OTG descriptor. define USB_DTYPE_OTHER  0x07Descriptor is of other type. define USB_DTYPE_QUALIFIER  0x06Qualifier descriptor. define USB_DTYPE_STRING  0x03String descriptor. define USB_EPATTR_ADAPTIVE  0x08Adaptive endpoint. define USB_EPATTR_ASYNC  0x04Asynchronous endpoint. define USB_EPATTR_NO_SYNC  0x00No synchronization. define USB_EPATTR_SYNC  0x0CSynchronous endpoint. define USB_EPDIR_IN  0x00Host-to-device endpoint direction. define USB_EPDIR_OUT  0x80Device-to-host endpoint direction. define USB_EPTYPE_BULK  0x02Bbulk endpoint. define USB_EPTYPE_CONTROL  0x00Control endpoint. define USB_EPTYPE_INTERRUPT  0x03Interrupt endpoint. define USB_EPTYPE_ISOCHRONUS  0x01Isochronous endpoint. define USB_EPUSAGE_DATA  0x00Data endpoint. define USB_EPUSAGE_FEEDBACK  0x10Feedback endpoint. define USB_EPUSAGE_IMP_FEEDBACK  0x20Implicit feedback Data endpoint. define USB_FEAT_DEBUG_MODE  0x06 define USB_FEAT_ENDPOINT_HALT  0x00Halt endpoint. define USB_FEAT_REMOTE_WKUP  0x01 define USB_FEAT_TEST_MODE  0x02 define USB_PROTO_IAD  0x01Protocol defined on interface association level. define USB_PROTO_NONE  0x00No protocol defined. define USB_PROTO_VENDOR  0xFFVendor specific protocol. define USB_STD_CLEAR_FEATURE  0x01Used to clear or disable a specific feature. define USB_STD_GET_CONFIG  0x08Returns the current device configuration value. define USB_STD_GET_DESCRIPTOR  0x06Returns the specified descriptor if the descriptor exists. define USB_STD_GET_INTERFACE  0x0AReturns the selected alternate setting for the specified interface. define USB_STD_GET_STATUS  0x00Returns status for the specified recipient. define USB_STD_SET_ADDRESS  0x05Sets the device address for all future device accesses. define USB_STD_SET_CONFIG  0x09Sets the device configuration. define USB_STD_SET_DESCRIPTOR  0x07This request is optional and may be used to update existing descriptors or new descriptors may be added. define USB_STD_SET_FEATURE  0x03Used to set or enable a specific feature. define USB_STD_SET_INTERFACE  0x0BAllows the host to select an alternate setting for the specified interface. define USB_STD_SYNCH_FRAME  0x0CUsed to set and then report an endpoint's synchronization frame. define USB_STRING_DESC (s)  define USB_SUBCLASS_IAD  0x02Subclass defined on interface association level. define USB_SUBCLASS_NONE  0x00No subclass defined. define USB_SUBCLASS_VENDOR  0xFFVendor specific subclass. define USB_TEST_FORCE_ENABLE  0x05Test Force Enable. define USB_TEST_J  0x01Test J. define USB_TEST_K  0x02Test K. define USB_TEST_PACKET  0x04Test Pcaket. define USB_TEST_SE0_NAK  0x03Test SE0 NAK. define VERSION_BCD (maj, min, rev) (((maj &amp; 0xFF) &lt;&lt; 8) | ((min &amp; 0x0F) &lt;&lt; 4) | (rev &amp; 0x0F))"},{"location":"apiStm/group__USB__STD/#detailed-description","title":"Detailed Description","text":"<p>This module based on * Chapter 9 of the Universal Serial Bus Specification Revision 2.0 * LUFA - the Lightweight USB Framework for AVRs. </p>"},{"location":"apiStm/group__USB__STD/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/group__USB__STD/#function-__attribute__","title":"function __attribute__","text":"<pre><code>struct usb_header_descriptor __attribute__ (\n(packed)\n) </code></pre>"},{"location":"apiStm/group__USB__STD/#function-__attribute___1","title":"function __attribute__","text":"<pre><code>struct usb_string_descriptor __attribute__ (\n(packed, aligned(2))\n) </code></pre>"},{"location":"apiStm/group__USB__STD/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/group__USB__STD/#define-intserialno_descriptor","title":"define INTSERIALNO_DESCRIPTOR","text":"<pre><code>#define INTSERIALNO_DESCRIPTOR 0xFE\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-no_descriptor","title":"define NO_DESCRIPTOR","text":"<pre><code>#define NO_DESCRIPTOR 0x00\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_array_desc","title":"define USB_ARRAY_DESC","text":"<pre><code>#define USB_ARRAY_DESC (\n...\n) {.bLength = 2 + sizeof((uint16_t[]){__VA_ARGS__}),\\\n                                    .bDescriptorType = USB_DTYPE_STRING ,\\\n                                    .wString = {__VA_ARGS__}}\n</code></pre> <p>Macro to create usb_string_descriptor from array </p>"},{"location":"apiStm/group__USB__STD/#define-usb_cfg_attr_reserved","title":"define USB_CFG_ATTR_RESERVED","text":"<pre><code>#define USB_CFG_ATTR_RESERVED 0x80\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_cfg_attr_selfpowered","title":"define USB_CFG_ATTR_SELFPOWERED","text":"<pre><code>#define USB_CFG_ATTR_SELFPOWERED 0x40\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_cfg_power_ma","title":"define USB_CFG_POWER_MA","text":"<pre><code>#define USB_CFG_POWER_MA (\nmA\n) ((mA) &gt;&gt; 1)\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_class_app_spec","title":"define USB_CLASS_APP_SPEC","text":"<pre><code>#define USB_CLASS_APP_SPEC 0xFE\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_class_audio","title":"define USB_CLASS_AUDIO","text":"<pre><code>#define USB_CLASS_AUDIO 0x01\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_class_av","title":"define USB_CLASS_AV","text":"<pre><code>#define USB_CLASS_AV 0x10\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_class_billboard","title":"define USB_CLASS_BILLBOARD","text":"<pre><code>#define USB_CLASS_BILLBOARD 0x11\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_class_cbridge","title":"define USB_CLASS_CBRIDGE","text":"<pre><code>#define USB_CLASS_CBRIDGE 0x12\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_class_content_sec","title":"define USB_CLASS_CONTENT_SEC","text":"<pre><code>#define USB_CLASS_CONTENT_SEC 0x0D\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_class_cscid","title":"define USB_CLASS_CSCID","text":"<pre><code>#define USB_CLASS_CSCID 0x0B\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_class_diagnostic","title":"define USB_CLASS_DIAGNOSTIC","text":"<pre><code>#define USB_CLASS_DIAGNOSTIC 0xDC\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_class_healthcare","title":"define USB_CLASS_HEALTHCARE","text":"<pre><code>#define USB_CLASS_HEALTHCARE 0x0F\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_class_hub","title":"define USB_CLASS_HUB","text":"<pre><code>#define USB_CLASS_HUB 0x09\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_class_iad","title":"define USB_CLASS_IAD","text":"<pre><code>#define USB_CLASS_IAD 0xEF\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_class_mass_storage","title":"define USB_CLASS_MASS_STORAGE","text":"<pre><code>#define USB_CLASS_MASS_STORAGE 0x08\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_class_misc","title":"define USB_CLASS_MISC","text":"<pre><code>#define USB_CLASS_MISC 0xEF\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_class_per_interface","title":"define USB_CLASS_PER_INTERFACE","text":"<pre><code>#define USB_CLASS_PER_INTERFACE 0x00\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_class_physical","title":"define USB_CLASS_PHYSICAL","text":"<pre><code>#define USB_CLASS_PHYSICAL 0x05\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_class_printer","title":"define USB_CLASS_PRINTER","text":"<pre><code>#define USB_CLASS_PRINTER 0x07\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_class_still_image","title":"define USB_CLASS_STILL_IMAGE","text":"<pre><code>#define USB_CLASS_STILL_IMAGE 0x06\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_class_vendor","title":"define USB_CLASS_VENDOR","text":"<pre><code>#define USB_CLASS_VENDOR 0xFF\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_class_video","title":"define USB_CLASS_VIDEO","text":"<pre><code>#define USB_CLASS_VIDEO 0x0E\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_class_wireless","title":"define USB_CLASS_WIRELESS","text":"<pre><code>#define USB_CLASS_WIRELESS 0xE0\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_dtype_configuration","title":"define USB_DTYPE_CONFIGURATION","text":"<pre><code>#define USB_DTYPE_CONFIGURATION 0x02\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_dtype_cs_endpoint","title":"define USB_DTYPE_CS_ENDPOINT","text":"<pre><code>#define USB_DTYPE_CS_ENDPOINT 0x25\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_dtype_cs_interface","title":"define USB_DTYPE_CS_INTERFACE","text":"<pre><code>#define USB_DTYPE_CS_INTERFACE 0x24\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_dtype_debug","title":"define USB_DTYPE_DEBUG","text":"<pre><code>#define USB_DTYPE_DEBUG 0x0A\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_dtype_device","title":"define USB_DTYPE_DEVICE","text":"<pre><code>#define USB_DTYPE_DEVICE 0x01\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_dtype_endpoint","title":"define USB_DTYPE_ENDPOINT","text":"<pre><code>#define USB_DTYPE_ENDPOINT 0x05\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_dtype_interface","title":"define USB_DTYPE_INTERFACE","text":"<pre><code>#define USB_DTYPE_INTERFACE 0x04\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_dtype_interfacepower","title":"define USB_DTYPE_INTERFACEPOWER","text":"<pre><code>#define USB_DTYPE_INTERFACEPOWER 0x08\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_dtype_interfaseassoc","title":"define USB_DTYPE_INTERFASEASSOC","text":"<pre><code>#define USB_DTYPE_INTERFASEASSOC 0x0B\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_dtype_otg","title":"define USB_DTYPE_OTG","text":"<pre><code>#define USB_DTYPE_OTG 0x09\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_dtype_other","title":"define USB_DTYPE_OTHER","text":"<pre><code>#define USB_DTYPE_OTHER 0x07\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_dtype_qualifier","title":"define USB_DTYPE_QUALIFIER","text":"<pre><code>#define USB_DTYPE_QUALIFIER 0x06\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_dtype_string","title":"define USB_DTYPE_STRING","text":"<pre><code>#define USB_DTYPE_STRING 0x03\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_epattr_adaptive","title":"define USB_EPATTR_ADAPTIVE","text":"<pre><code>#define USB_EPATTR_ADAPTIVE 0x08\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_epattr_async","title":"define USB_EPATTR_ASYNC","text":"<pre><code>#define USB_EPATTR_ASYNC 0x04\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_epattr_no_sync","title":"define USB_EPATTR_NO_SYNC","text":"<pre><code>#define USB_EPATTR_NO_SYNC 0x00\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_epattr_sync","title":"define USB_EPATTR_SYNC","text":"<pre><code>#define USB_EPATTR_SYNC 0x0C\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_epdir_in","title":"define USB_EPDIR_IN","text":"<pre><code>#define USB_EPDIR_IN 0x00\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_epdir_out","title":"define USB_EPDIR_OUT","text":"<pre><code>#define USB_EPDIR_OUT 0x80\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_eptype_bulk","title":"define USB_EPTYPE_BULK","text":"<pre><code>#define USB_EPTYPE_BULK 0x02\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_eptype_control","title":"define USB_EPTYPE_CONTROL","text":"<pre><code>#define USB_EPTYPE_CONTROL 0x00\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_eptype_interrupt","title":"define USB_EPTYPE_INTERRUPT","text":"<pre><code>#define USB_EPTYPE_INTERRUPT 0x03\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_eptype_isochronus","title":"define USB_EPTYPE_ISOCHRONUS","text":"<pre><code>#define USB_EPTYPE_ISOCHRONUS 0x01\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_epusage_data","title":"define USB_EPUSAGE_DATA","text":"<pre><code>#define USB_EPUSAGE_DATA 0x00\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_epusage_feedback","title":"define USB_EPUSAGE_FEEDBACK","text":"<pre><code>#define USB_EPUSAGE_FEEDBACK 0x10\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_epusage_imp_feedback","title":"define USB_EPUSAGE_IMP_FEEDBACK","text":"<pre><code>#define USB_EPUSAGE_IMP_FEEDBACK 0x20\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_feat_debug_mode","title":"define USB_FEAT_DEBUG_MODE","text":"<pre><code>#define USB_FEAT_DEBUG_MODE 0x06\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_feat_endpoint_halt","title":"define USB_FEAT_ENDPOINT_HALT","text":"<pre><code>#define USB_FEAT_ENDPOINT_HALT 0x00\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_feat_remote_wkup","title":"define USB_FEAT_REMOTE_WKUP","text":"<pre><code>#define USB_FEAT_REMOTE_WKUP 0x01\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_feat_test_mode","title":"define USB_FEAT_TEST_MODE","text":"<pre><code>#define USB_FEAT_TEST_MODE 0x02\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_proto_iad","title":"define USB_PROTO_IAD","text":"<pre><code>#define USB_PROTO_IAD 0x01\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_proto_none","title":"define USB_PROTO_NONE","text":"<pre><code>#define USB_PROTO_NONE 0x00\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_proto_vendor","title":"define USB_PROTO_VENDOR","text":"<pre><code>#define USB_PROTO_VENDOR 0xFF\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_std_clear_feature","title":"define USB_STD_CLEAR_FEATURE","text":"<pre><code>#define USB_STD_CLEAR_FEATURE 0x01\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_std_get_config","title":"define USB_STD_GET_CONFIG","text":"<pre><code>#define USB_STD_GET_CONFIG 0x08\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_std_get_descriptor","title":"define USB_STD_GET_DESCRIPTOR","text":"<pre><code>#define USB_STD_GET_DESCRIPTOR 0x06\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_std_get_interface","title":"define USB_STD_GET_INTERFACE","text":"<pre><code>#define USB_STD_GET_INTERFACE 0x0A\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_std_get_status","title":"define USB_STD_GET_STATUS","text":"<pre><code>#define USB_STD_GET_STATUS 0x00\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_std_set_address","title":"define USB_STD_SET_ADDRESS","text":"<pre><code>#define USB_STD_SET_ADDRESS 0x05\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_std_set_config","title":"define USB_STD_SET_CONFIG","text":"<pre><code>#define USB_STD_SET_CONFIG 0x09\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_std_set_descriptor","title":"define USB_STD_SET_DESCRIPTOR","text":"<pre><code>#define USB_STD_SET_DESCRIPTOR 0x07\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_std_set_feature","title":"define USB_STD_SET_FEATURE","text":"<pre><code>#define USB_STD_SET_FEATURE 0x03\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_std_set_interface","title":"define USB_STD_SET_INTERFACE","text":"<pre><code>#define USB_STD_SET_INTERFACE 0x0B\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_std_synch_frame","title":"define USB_STD_SYNCH_FRAME","text":"<pre><code>#define USB_STD_SYNCH_FRAME 0x0C\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_string_desc","title":"define USB_STRING_DESC","text":"<pre><code>#define USB_STRING_DESC (\ns\n) {.bLength = sizeof(CAT(u,s)),\\\n                                    .bDescriptorType = USB_DTYPE_STRING ,\\\n                                    .wString = {CAT(u,s)}}\n</code></pre> <p>Macro to create usb_string_descriptor from string </p>"},{"location":"apiStm/group__USB__STD/#define-usb_subclass_iad","title":"define USB_SUBCLASS_IAD","text":"<pre><code>#define USB_SUBCLASS_IAD 0x02\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_subclass_none","title":"define USB_SUBCLASS_NONE","text":"<pre><code>#define USB_SUBCLASS_NONE 0x00\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_subclass_vendor","title":"define USB_SUBCLASS_VENDOR","text":"<pre><code>#define USB_SUBCLASS_VENDOR 0xFF\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_test_force_enable","title":"define USB_TEST_FORCE_ENABLE","text":"<pre><code>#define USB_TEST_FORCE_ENABLE 0x05\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_test_j","title":"define USB_TEST_J","text":"<pre><code>#define USB_TEST_J 0x01\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_test_k","title":"define USB_TEST_K","text":"<pre><code>#define USB_TEST_K 0x02\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_test_packet","title":"define USB_TEST_PACKET","text":"<pre><code>#define USB_TEST_PACKET 0x04\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-usb_test_se0_nak","title":"define USB_TEST_SE0_NAK","text":"<pre><code>#define USB_TEST_SE0_NAK 0x03\n</code></pre>"},{"location":"apiStm/group__USB__STD/#define-version_bcd","title":"define VERSION_BCD","text":"<pre><code>#define VERSION_BCD (\nmaj,\nmin,\nrev\n) (((maj &amp; 0xFF) &lt;&lt; 8) | ((min &amp; 0x0F) &lt;&lt; 4) | (rev &amp; 0x0F))\n</code></pre> <p>Macro to encode major/minor/version number into BCD code </p> <p>Parameters:</p> <ul> <li><code>maj</code> Major version </li> <li><code>min</code> Minor version </li> <li><code>rev</code> Revision </li> </ul>"},{"location":"apiStm/group__USB__STD__LANGID/","title":"Group USB_STD_LANGID","text":"<p>Modules &gt; USB_STD_LANGID</p>"},{"location":"apiStm/group__USB__STD__LANGID/#macros","title":"Macros","text":"Type Name define USB_LANGID_AFR  0x0436Afrikaans. define USB_LANGID_ARA_AE  0x3801Arabic (U.A.E.) define USB_LANGID_ARA_BH  0x3c01Arabic (Bahrain) define USB_LANGID_ARA_DZ  0x1401Arabic (Algeria) define USB_LANGID_ARA_EG  0x0c01Arabic (Egypt) define USB_LANGID_ARA_IQ  0x0801Arabic (Iraq) define USB_LANGID_ARA_JO  0x2c01Arabic (Jordan) define USB_LANGID_ARA_KW  0x3401Arabic (Kuwait) define USB_LANGID_ARA_LB  0x3001Arabic (Lebanon) define USB_LANGID_ARA_LY  0x1001Arabic (Libya) define USB_LANGID_ARA_MA  0x1801Arabic (Morocco) define USB_LANGID_ARA_OM  0x2001Arabic (Oman) define USB_LANGID_ARA_QA  0x4001Arabic (Qatar) define USB_LANGID_ARA_SA  0x0401Arabic (Saudi Arabia) define USB_LANGID_ARA_SY  0x2801Arabic (Syria) define USB_LANGID_ARA_TN  0x1c01Arabic (Tunisia) define USB_LANGID_ARA_YE  0x2401Arabic (Yemen) define USB_LANGID_ASM  0x044dAssamese. define USB_LANGID_AZE_CYR  0x082cAzeri (Cyrillic) define USB_LANGID_AZE_LAT  0x042cAzeri (Latin) define USB_LANGID_BEL  0x0423Belarussian. define USB_LANGID_BEN  0x0445Bengali. define USB_LANGID_BUL  0x0402Bulgarian. define USB_LANGID_CAT  0x0403Catalan. define USB_LANGID_CZE  0x0405Czech. define USB_LANGID_DAN  0x0406Danish. define USB_LANGID_DEU  0x0407German (Standard) define USB_LANGID_DEU_AT  0x0c07German (Austria) define USB_LANGID_DEU_LI  0x1407German (Liechtenstein) define USB_LANGID_DEU_LU  0x1007German (Luxembourg) define USB_LANGID_DEU_SZ  0x0807German (Switzerland) define USB_LANGID_ELL  0x0408Greek. define USB_LANGID_ENG_AU  0x0c09English (Australian) define USB_LANGID_ENG_BZ  0x2809English (Belize) define USB_LANGID_ENG_CA  0x1009English (Canadian) define USB_LANGID_ENG_CAR  0x2409English (Caribbean) define USB_LANGID_ENG_IE  0x1809English (Ireland) define USB_LANGID_ENG_JM  0x2009English (Jamaica) define USB_LANGID_ENG_NZ  0x1409English (New Zealand) define USB_LANGID_ENG_PH  0x3409English (Philippines) define USB_LANGID_ENG_TH  0x2c09English (Trinidad) define USB_LANGID_ENG_UK  0x0809English (United Kingdom) define USB_LANGID_ENG_US  0x0409English (United States) define USB_LANGID_ENG_ZA  0x1c09English (South Africa) define USB_LANGID_ENG_ZW  0x3009English (Zimbabwe) define USB_LANGID_EST  0x0425Estonian. define USB_LANGID_EUS  0x042dBasque. define USB_LANGID_FAO  0x0438Faeroese. define USB_LANGID_FAS  0x0429Farsi. define USB_LANGID_FIN  0x040bFinnish. define USB_LANGID_FRA  0x040cFrench (Standard) define USB_LANGID_FRA_BE  0x080cFrench (Belgian) define USB_LANGID_FRA_CA  0x0c0cFrench (Canadian) define USB_LANGID_FRA_LU  0x140cFrench (Luxembourg) define USB_LANGID_FRA_MC  0x180cFrench (Monaco) define USB_LANGID_FRA_SZ  0x100cFrench (Switzerland) define USB_LANGID_GUJ  0x0447Gujarati. define USB_LANGID_HEB  0x040dHebrew. define USB_LANGID_HIN  0x0439Hindi. define USB_LANGID_HRV  0x041aCroatian. define USB_LANGID_HUN  0x040eHungarian. define USB_LANGID_HYE  0x042bArmenian. define USB_LANGID_IND  0x0421Indonesian. define USB_LANGID_ISL  0x040fIcelandic. define USB_LANGID_ITA  0x0410Italian (Standard) define USB_LANGID_ITA_SZ  0x0810Italian (Switzerland) define USB_LANGID_JPN  0x0411Japanese. define USB_LANGID_KAN  0x044bKannada. define USB_LANGID_KAS  0x0860Kashmiri (India) define USB_LANGID_KAT  0x0437Georgian. define USB_LANGID_KAZ  0x043fKazakh. define USB_LANGID_KOK  0x0457Konkani. define USB_LANGID_KOR  0x0412Korean. define USB_LANGID_KOR_JOH  0x0812Korean (Johab) define USB_LANGID_LAV  0x0426Latvian. define USB_LANGID_LIT  0x0427Lithuanian. define USB_LANGID_LIT_CLS  0x0827Lithuanian (Classic) define USB_LANGID_MAL  0x044cMalayalam. define USB_LANGID_MAR  0x044eMarathi. define USB_LANGID_MKD  0x042fMacedonian. define USB_LANGID_MNI  0x0458Manipuri. define USB_LANGID_MSA  0x043eMalay (Malaysian) define USB_LANGID_MSA_BN  0x083eMalay (Brunei Darussalam) define USB_LANGID_MYA  0x0455Burmese. define USB_LANGID_NEP  0x0861Nepali (India) define USB_LANGID_NLD_BE  0x0813Dutch (Belgium) define USB_LANGID_NLD_NL  0x0413Dutch (Netherlands) define USB_LANGID_NNO  0x0814Norwegian (Nynorsk) define USB_LANGID_NOB  0x0414Norwegian (Bokmal) define USB_LANGID_NSO  0x0430Sutu, Sotho. define USB_LANGID_ORI  0x0448Oriya. define USB_LANGID_PAN  0x0446Punjabi. define USB_LANGID_POL  0x0415Polish. define USB_LANGID_POR  0x0816Portuguese (Standard) define USB_LANGID_POR_BR  0x0416Portuguese (Brazil) define USB_LANGID_RON  0x0418Romanian. define USB_LANGID_RUS  0x0419Russian. define USB_LANGID_SAN  0x044fSanskrit. define USB_LANGID_SLK  0x041bSlovak. define USB_LANGID_SLV  0x0424Slovenian. define USB_LANGID_SND  0x0459Sindhi. define USB_LANGID_SPA  0x040aSpanish (Traditional Sort) define USB_LANGID_SPA_AR  0x2c0aSpanish (Argentina) define USB_LANGID_SPA_BO  0x400aSpanish (Bolivia) define USB_LANGID_SPA_CL  0x340aSpanish (Chile) define USB_LANGID_SPA_CO  0x240aSpanish (Colombia) define USB_LANGID_SPA_CR  0x140aSpanish (Costa Rica) define USB_LANGID_SPA_DO  0x1c0aSpanish (Dominican Republic) define USB_LANGID_SPA_EC  0x300aSpanish (Ecuador) define USB_LANGID_SPA_GT  0x100aSpanish (Guatemala) define USB_LANGID_SPA_HN  0x480aSpanish (Honduras) define USB_LANGID_SPA_MDN  0x0c0aSpanish (Modern Sort) define USB_LANGID_SPA_MX  0x080aSpanish (Mexican) define USB_LANGID_SPA_NI  0x4c0aSpanish (Nicaragua) define USB_LANGID_SPA_PA  0x180aSpanish (Panama) define USB_LANGID_SPA_PE  0x280aSpanish (Peru) define USB_LANGID_SPA_PR  0x500aSpanish (Puerto Rico) define USB_LANGID_SPA_PY  0x3c0aSpanish (Paraguay) define USB_LANGID_SPA_SV  0x440aSpanish (El Salvador) define USB_LANGID_SPA_UY  0x380aSpanish (Uruguay) define USB_LANGID_SPA_VE  0x200aSpanish (Venezuela) define USB_LANGID_SQI  0x041cAlbanian. define USB_LANGID_SRB_CYR  0x0c1aSerbian (Cyrillic) define USB_LANGID_SRB_LAT  0x081aSerbian (Latin) define USB_LANGID_SWA  0x0441Swahili (Kenya) define USB_LANGID_SWE  0x041dSwedish. define USB_LANGID_SWE_FI  0x081dSwedish (Finland) define USB_LANGID_TAM  0x0449Tamil. define USB_LANGID_TAT  0x0444Tatar (Tatarstan) define USB_LANGID_TEL  0x044aTelugu. define USB_LANGID_THA  0x041eThai. define USB_LANGID_TUR  0x041fTurkish. define USB_LANGID_URD_IN  0x0820Urdu (India) define USB_LANGID_URD_PK  0x0420Urdu (Pakistan) define USB_LANGID_UZB_CYR  0x0843Uzbek (Cyrillic) define USB_LANGID_UZB_LAT  0x0443Uzbek (Latin) define USB_LANGID_VIE  0x042aVietnamese. define USB_LANGID_ZHO_CN  0x0804Chinese (PRC) define USB_LANGID_ZHO_HK  0x0c04Chinese (Hong Kong SAR, PRC) define USB_LANGID_ZHO_MO  0x1404Chinese (Macau SAR) define USB_LANGID_ZHO_SG  0x1004Chinese (Singapore) define USB_LANGID_ZHO_TW  0x0404Chinese (Taiwan) define USB_LANGIG_UKR  0x0422Ukrainian."},{"location":"apiStm/group__USB__STD__LANGID/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_afr","title":"define USB_LANGID_AFR","text":"<pre><code>#define USB_LANGID_AFR 0x0436\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_ara_ae","title":"define USB_LANGID_ARA_AE","text":"<pre><code>#define USB_LANGID_ARA_AE 0x3801\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_ara_bh","title":"define USB_LANGID_ARA_BH","text":"<pre><code>#define USB_LANGID_ARA_BH 0x3c01\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_ara_dz","title":"define USB_LANGID_ARA_DZ","text":"<pre><code>#define USB_LANGID_ARA_DZ 0x1401\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_ara_eg","title":"define USB_LANGID_ARA_EG","text":"<pre><code>#define USB_LANGID_ARA_EG 0x0c01\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_ara_iq","title":"define USB_LANGID_ARA_IQ","text":"<pre><code>#define USB_LANGID_ARA_IQ 0x0801\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_ara_jo","title":"define USB_LANGID_ARA_JO","text":"<pre><code>#define USB_LANGID_ARA_JO 0x2c01\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_ara_kw","title":"define USB_LANGID_ARA_KW","text":"<pre><code>#define USB_LANGID_ARA_KW 0x3401\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_ara_lb","title":"define USB_LANGID_ARA_LB","text":"<pre><code>#define USB_LANGID_ARA_LB 0x3001\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_ara_ly","title":"define USB_LANGID_ARA_LY","text":"<pre><code>#define USB_LANGID_ARA_LY 0x1001\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_ara_ma","title":"define USB_LANGID_ARA_MA","text":"<pre><code>#define USB_LANGID_ARA_MA 0x1801\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_ara_om","title":"define USB_LANGID_ARA_OM","text":"<pre><code>#define USB_LANGID_ARA_OM 0x2001\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_ara_qa","title":"define USB_LANGID_ARA_QA","text":"<pre><code>#define USB_LANGID_ARA_QA 0x4001\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_ara_sa","title":"define USB_LANGID_ARA_SA","text":"<pre><code>#define USB_LANGID_ARA_SA 0x0401\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_ara_sy","title":"define USB_LANGID_ARA_SY","text":"<pre><code>#define USB_LANGID_ARA_SY 0x2801\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_ara_tn","title":"define USB_LANGID_ARA_TN","text":"<pre><code>#define USB_LANGID_ARA_TN 0x1c01\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_ara_ye","title":"define USB_LANGID_ARA_YE","text":"<pre><code>#define USB_LANGID_ARA_YE 0x2401\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_asm","title":"define USB_LANGID_ASM","text":"<pre><code>#define USB_LANGID_ASM 0x044d\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_aze_cyr","title":"define USB_LANGID_AZE_CYR","text":"<pre><code>#define USB_LANGID_AZE_CYR 0x082c\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_aze_lat","title":"define USB_LANGID_AZE_LAT","text":"<pre><code>#define USB_LANGID_AZE_LAT 0x042c\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_bel","title":"define USB_LANGID_BEL","text":"<pre><code>#define USB_LANGID_BEL 0x0423\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_ben","title":"define USB_LANGID_BEN","text":"<pre><code>#define USB_LANGID_BEN 0x0445\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_bul","title":"define USB_LANGID_BUL","text":"<pre><code>#define USB_LANGID_BUL 0x0402\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_cat","title":"define USB_LANGID_CAT","text":"<pre><code>#define USB_LANGID_CAT 0x0403\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_cze","title":"define USB_LANGID_CZE","text":"<pre><code>#define USB_LANGID_CZE 0x0405\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_dan","title":"define USB_LANGID_DAN","text":"<pre><code>#define USB_LANGID_DAN 0x0406\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_deu","title":"define USB_LANGID_DEU","text":"<pre><code>#define USB_LANGID_DEU 0x0407\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_deu_at","title":"define USB_LANGID_DEU_AT","text":"<pre><code>#define USB_LANGID_DEU_AT 0x0c07\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_deu_li","title":"define USB_LANGID_DEU_LI","text":"<pre><code>#define USB_LANGID_DEU_LI 0x1407\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_deu_lu","title":"define USB_LANGID_DEU_LU","text":"<pre><code>#define USB_LANGID_DEU_LU 0x1007\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_deu_sz","title":"define USB_LANGID_DEU_SZ","text":"<pre><code>#define USB_LANGID_DEU_SZ 0x0807\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_ell","title":"define USB_LANGID_ELL","text":"<pre><code>#define USB_LANGID_ELL 0x0408\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_eng_au","title":"define USB_LANGID_ENG_AU","text":"<pre><code>#define USB_LANGID_ENG_AU 0x0c09\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_eng_bz","title":"define USB_LANGID_ENG_BZ","text":"<pre><code>#define USB_LANGID_ENG_BZ 0x2809\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_eng_ca","title":"define USB_LANGID_ENG_CA","text":"<pre><code>#define USB_LANGID_ENG_CA 0x1009\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_eng_car","title":"define USB_LANGID_ENG_CAR","text":"<pre><code>#define USB_LANGID_ENG_CAR 0x2409\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_eng_ie","title":"define USB_LANGID_ENG_IE","text":"<pre><code>#define USB_LANGID_ENG_IE 0x1809\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_eng_jm","title":"define USB_LANGID_ENG_JM","text":"<pre><code>#define USB_LANGID_ENG_JM 0x2009\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_eng_nz","title":"define USB_LANGID_ENG_NZ","text":"<pre><code>#define USB_LANGID_ENG_NZ 0x1409\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_eng_ph","title":"define USB_LANGID_ENG_PH","text":"<pre><code>#define USB_LANGID_ENG_PH 0x3409\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_eng_th","title":"define USB_LANGID_ENG_TH","text":"<pre><code>#define USB_LANGID_ENG_TH 0x2c09\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_eng_uk","title":"define USB_LANGID_ENG_UK","text":"<pre><code>#define USB_LANGID_ENG_UK 0x0809\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_eng_us","title":"define USB_LANGID_ENG_US","text":"<pre><code>#define USB_LANGID_ENG_US 0x0409\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_eng_za","title":"define USB_LANGID_ENG_ZA","text":"<pre><code>#define USB_LANGID_ENG_ZA 0x1c09\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_eng_zw","title":"define USB_LANGID_ENG_ZW","text":"<pre><code>#define USB_LANGID_ENG_ZW 0x3009\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_est","title":"define USB_LANGID_EST","text":"<pre><code>#define USB_LANGID_EST 0x0425\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_eus","title":"define USB_LANGID_EUS","text":"<pre><code>#define USB_LANGID_EUS 0x042d\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_fao","title":"define USB_LANGID_FAO","text":"<pre><code>#define USB_LANGID_FAO 0x0438\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_fas","title":"define USB_LANGID_FAS","text":"<pre><code>#define USB_LANGID_FAS 0x0429\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_fin","title":"define USB_LANGID_FIN","text":"<pre><code>#define USB_LANGID_FIN 0x040b\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_fra","title":"define USB_LANGID_FRA","text":"<pre><code>#define USB_LANGID_FRA 0x040c\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_fra_be","title":"define USB_LANGID_FRA_BE","text":"<pre><code>#define USB_LANGID_FRA_BE 0x080c\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_fra_ca","title":"define USB_LANGID_FRA_CA","text":"<pre><code>#define USB_LANGID_FRA_CA 0x0c0c\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_fra_lu","title":"define USB_LANGID_FRA_LU","text":"<pre><code>#define USB_LANGID_FRA_LU 0x140c\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_fra_mc","title":"define USB_LANGID_FRA_MC","text":"<pre><code>#define USB_LANGID_FRA_MC 0x180c\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_fra_sz","title":"define USB_LANGID_FRA_SZ","text":"<pre><code>#define USB_LANGID_FRA_SZ 0x100c\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_guj","title":"define USB_LANGID_GUJ","text":"<pre><code>#define USB_LANGID_GUJ 0x0447\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_heb","title":"define USB_LANGID_HEB","text":"<pre><code>#define USB_LANGID_HEB 0x040d\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_hin","title":"define USB_LANGID_HIN","text":"<pre><code>#define USB_LANGID_HIN 0x0439\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_hrv","title":"define USB_LANGID_HRV","text":"<pre><code>#define USB_LANGID_HRV 0x041a\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_hun","title":"define USB_LANGID_HUN","text":"<pre><code>#define USB_LANGID_HUN 0x040e\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_hye","title":"define USB_LANGID_HYE","text":"<pre><code>#define USB_LANGID_HYE 0x042b\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_ind","title":"define USB_LANGID_IND","text":"<pre><code>#define USB_LANGID_IND 0x0421\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_isl","title":"define USB_LANGID_ISL","text":"<pre><code>#define USB_LANGID_ISL 0x040f\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_ita","title":"define USB_LANGID_ITA","text":"<pre><code>#define USB_LANGID_ITA 0x0410\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_ita_sz","title":"define USB_LANGID_ITA_SZ","text":"<pre><code>#define USB_LANGID_ITA_SZ 0x0810\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_jpn","title":"define USB_LANGID_JPN","text":"<pre><code>#define USB_LANGID_JPN 0x0411\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_kan","title":"define USB_LANGID_KAN","text":"<pre><code>#define USB_LANGID_KAN 0x044b\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_kas","title":"define USB_LANGID_KAS","text":"<pre><code>#define USB_LANGID_KAS 0x0860\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_kat","title":"define USB_LANGID_KAT","text":"<pre><code>#define USB_LANGID_KAT 0x0437\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_kaz","title":"define USB_LANGID_KAZ","text":"<pre><code>#define USB_LANGID_KAZ 0x043f\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_kok","title":"define USB_LANGID_KOK","text":"<pre><code>#define USB_LANGID_KOK 0x0457\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_kor","title":"define USB_LANGID_KOR","text":"<pre><code>#define USB_LANGID_KOR 0x0412\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_kor_joh","title":"define USB_LANGID_KOR_JOH","text":"<pre><code>#define USB_LANGID_KOR_JOH 0x0812\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_lav","title":"define USB_LANGID_LAV","text":"<pre><code>#define USB_LANGID_LAV 0x0426\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_lit","title":"define USB_LANGID_LIT","text":"<pre><code>#define USB_LANGID_LIT 0x0427\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_lit_cls","title":"define USB_LANGID_LIT_CLS","text":"<pre><code>#define USB_LANGID_LIT_CLS 0x0827\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_mal","title":"define USB_LANGID_MAL","text":"<pre><code>#define USB_LANGID_MAL 0x044c\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_mar","title":"define USB_LANGID_MAR","text":"<pre><code>#define USB_LANGID_MAR 0x044e\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_mkd","title":"define USB_LANGID_MKD","text":"<pre><code>#define USB_LANGID_MKD 0x042f\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_mni","title":"define USB_LANGID_MNI","text":"<pre><code>#define USB_LANGID_MNI 0x0458\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_msa","title":"define USB_LANGID_MSA","text":"<pre><code>#define USB_LANGID_MSA 0x043e\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_msa_bn","title":"define USB_LANGID_MSA_BN","text":"<pre><code>#define USB_LANGID_MSA_BN 0x083e\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_mya","title":"define USB_LANGID_MYA","text":"<pre><code>#define USB_LANGID_MYA 0x0455\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_nep","title":"define USB_LANGID_NEP","text":"<pre><code>#define USB_LANGID_NEP 0x0861\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_nld_be","title":"define USB_LANGID_NLD_BE","text":"<pre><code>#define USB_LANGID_NLD_BE 0x0813\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_nld_nl","title":"define USB_LANGID_NLD_NL","text":"<pre><code>#define USB_LANGID_NLD_NL 0x0413\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_nno","title":"define USB_LANGID_NNO","text":"<pre><code>#define USB_LANGID_NNO 0x0814\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_nob","title":"define USB_LANGID_NOB","text":"<pre><code>#define USB_LANGID_NOB 0x0414\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_nso","title":"define USB_LANGID_NSO","text":"<pre><code>#define USB_LANGID_NSO 0x0430\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_ori","title":"define USB_LANGID_ORI","text":"<pre><code>#define USB_LANGID_ORI 0x0448\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_pan","title":"define USB_LANGID_PAN","text":"<pre><code>#define USB_LANGID_PAN 0x0446\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_pol","title":"define USB_LANGID_POL","text":"<pre><code>#define USB_LANGID_POL 0x0415\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_por","title":"define USB_LANGID_POR","text":"<pre><code>#define USB_LANGID_POR 0x0816\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_por_br","title":"define USB_LANGID_POR_BR","text":"<pre><code>#define USB_LANGID_POR_BR 0x0416\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_ron","title":"define USB_LANGID_RON","text":"<pre><code>#define USB_LANGID_RON 0x0418\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_rus","title":"define USB_LANGID_RUS","text":"<pre><code>#define USB_LANGID_RUS 0x0419\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_san","title":"define USB_LANGID_SAN","text":"<pre><code>#define USB_LANGID_SAN 0x044f\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_slk","title":"define USB_LANGID_SLK","text":"<pre><code>#define USB_LANGID_SLK 0x041b\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_slv","title":"define USB_LANGID_SLV","text":"<pre><code>#define USB_LANGID_SLV 0x0424\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_snd","title":"define USB_LANGID_SND","text":"<pre><code>#define USB_LANGID_SND 0x0459\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_spa","title":"define USB_LANGID_SPA","text":"<pre><code>#define USB_LANGID_SPA 0x040a\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_spa_ar","title":"define USB_LANGID_SPA_AR","text":"<pre><code>#define USB_LANGID_SPA_AR 0x2c0a\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_spa_bo","title":"define USB_LANGID_SPA_BO","text":"<pre><code>#define USB_LANGID_SPA_BO 0x400a\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_spa_cl","title":"define USB_LANGID_SPA_CL","text":"<pre><code>#define USB_LANGID_SPA_CL 0x340a\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_spa_co","title":"define USB_LANGID_SPA_CO","text":"<pre><code>#define USB_LANGID_SPA_CO 0x240a\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_spa_cr","title":"define USB_LANGID_SPA_CR","text":"<pre><code>#define USB_LANGID_SPA_CR 0x140a\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_spa_do","title":"define USB_LANGID_SPA_DO","text":"<pre><code>#define USB_LANGID_SPA_DO 0x1c0a\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_spa_ec","title":"define USB_LANGID_SPA_EC","text":"<pre><code>#define USB_LANGID_SPA_EC 0x300a\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_spa_gt","title":"define USB_LANGID_SPA_GT","text":"<pre><code>#define USB_LANGID_SPA_GT 0x100a\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_spa_hn","title":"define USB_LANGID_SPA_HN","text":"<pre><code>#define USB_LANGID_SPA_HN 0x480a\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_spa_mdn","title":"define USB_LANGID_SPA_MDN","text":"<pre><code>#define USB_LANGID_SPA_MDN 0x0c0a\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_spa_mx","title":"define USB_LANGID_SPA_MX","text":"<pre><code>#define USB_LANGID_SPA_MX 0x080a\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_spa_ni","title":"define USB_LANGID_SPA_NI","text":"<pre><code>#define USB_LANGID_SPA_NI 0x4c0a\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_spa_pa","title":"define USB_LANGID_SPA_PA","text":"<pre><code>#define USB_LANGID_SPA_PA 0x180a\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_spa_pe","title":"define USB_LANGID_SPA_PE","text":"<pre><code>#define USB_LANGID_SPA_PE 0x280a\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_spa_pr","title":"define USB_LANGID_SPA_PR","text":"<pre><code>#define USB_LANGID_SPA_PR 0x500a\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_spa_py","title":"define USB_LANGID_SPA_PY","text":"<pre><code>#define USB_LANGID_SPA_PY 0x3c0a\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_spa_sv","title":"define USB_LANGID_SPA_SV","text":"<pre><code>#define USB_LANGID_SPA_SV 0x440a\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_spa_uy","title":"define USB_LANGID_SPA_UY","text":"<pre><code>#define USB_LANGID_SPA_UY 0x380a\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_spa_ve","title":"define USB_LANGID_SPA_VE","text":"<pre><code>#define USB_LANGID_SPA_VE 0x200a\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_sqi","title":"define USB_LANGID_SQI","text":"<pre><code>#define USB_LANGID_SQI 0x041c\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_srb_cyr","title":"define USB_LANGID_SRB_CYR","text":"<pre><code>#define USB_LANGID_SRB_CYR 0x0c1a\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_srb_lat","title":"define USB_LANGID_SRB_LAT","text":"<pre><code>#define USB_LANGID_SRB_LAT 0x081a\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_swa","title":"define USB_LANGID_SWA","text":"<pre><code>#define USB_LANGID_SWA 0x0441\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_swe","title":"define USB_LANGID_SWE","text":"<pre><code>#define USB_LANGID_SWE 0x041d\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_swe_fi","title":"define USB_LANGID_SWE_FI","text":"<pre><code>#define USB_LANGID_SWE_FI 0x081d\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_tam","title":"define USB_LANGID_TAM","text":"<pre><code>#define USB_LANGID_TAM 0x0449\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_tat","title":"define USB_LANGID_TAT","text":"<pre><code>#define USB_LANGID_TAT 0x0444\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_tel","title":"define USB_LANGID_TEL","text":"<pre><code>#define USB_LANGID_TEL 0x044a\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_tha","title":"define USB_LANGID_THA","text":"<pre><code>#define USB_LANGID_THA 0x041e\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_tur","title":"define USB_LANGID_TUR","text":"<pre><code>#define USB_LANGID_TUR 0x041f\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_urd_in","title":"define USB_LANGID_URD_IN","text":"<pre><code>#define USB_LANGID_URD_IN 0x0820\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_urd_pk","title":"define USB_LANGID_URD_PK","text":"<pre><code>#define USB_LANGID_URD_PK 0x0420\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_uzb_cyr","title":"define USB_LANGID_UZB_CYR","text":"<pre><code>#define USB_LANGID_UZB_CYR 0x0843\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_uzb_lat","title":"define USB_LANGID_UZB_LAT","text":"<pre><code>#define USB_LANGID_UZB_LAT 0x0443\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_vie","title":"define USB_LANGID_VIE","text":"<pre><code>#define USB_LANGID_VIE 0x042a\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_zho_cn","title":"define USB_LANGID_ZHO_CN","text":"<pre><code>#define USB_LANGID_ZHO_CN 0x0804\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_zho_hk","title":"define USB_LANGID_ZHO_HK","text":"<pre><code>#define USB_LANGID_ZHO_HK 0x0c04\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_zho_mo","title":"define USB_LANGID_ZHO_MO","text":"<pre><code>#define USB_LANGID_ZHO_MO 0x1404\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_zho_sg","title":"define USB_LANGID_ZHO_SG","text":"<pre><code>#define USB_LANGID_ZHO_SG 0x1004\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langid_zho_tw","title":"define USB_LANGID_ZHO_TW","text":"<pre><code>#define USB_LANGID_ZHO_TW 0x0404\n</code></pre>"},{"location":"apiStm/group__USB__STD__LANGID/#define-usb_langig_ukr","title":"define USB_LANGIG_UKR","text":"<pre><code>#define USB_LANGIG_UKR 0x0422\n</code></pre>"},{"location":"apiStm/structusb__config__descriptor/","title":"Struct usb_config_descriptor","text":"<p>ClassList &gt; usb_config_descriptor</p> <p>USB device configuration descriptor. More...</p> <ul> <li><code>#include &lt;usb_std.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__config__descriptor/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bConfigurationValue Configuration index of the current configuration. uint8_t bDescriptorType Configuration descriptor. uint8_t bLength Size of the descriptor, in bytes. uint8_t bMaxPower Maximum power consumption of the device. USB_CFG_POWER_MA() macro. uint8_t bNumInterfaces Total number of interfaces in the configuration. uint8_t bmAttributes Configuration attributes. uint8_t iConfiguration Index of a string descriptor describing the configuration. uint16_t wTotalLength Size of the configuration descriptor header, and all sub descriptors inside the configuration."},{"location":"apiStm/structusb__config__descriptor/#detailed-description","title":"Detailed Description","text":"<p>The configuration descriptor describes information about a specific device configuration. The descriptor contains a bConfigurationValue field with a value that, when used as a parameter to the SetConfiguration() request, causes the device to assume the described configuration. </p>"},{"location":"apiStm/structusb__config__descriptor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__config__descriptor/#variable-bconfigurationvalue","title":"variable bConfigurationValue","text":"<pre><code>uint8_t usb_config_descriptor::bConfigurationValue;\n</code></pre>"},{"location":"apiStm/structusb__config__descriptor/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_config_descriptor::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__config__descriptor/#variable-blength","title":"variable bLength","text":"<pre><code>uint8_t usb_config_descriptor::bLength;\n</code></pre>"},{"location":"apiStm/structusb__config__descriptor/#variable-bmaxpower","title":"variable bMaxPower","text":"<pre><code>uint8_t usb_config_descriptor::bMaxPower;\n</code></pre>"},{"location":"apiStm/structusb__config__descriptor/#variable-bnuminterfaces","title":"variable bNumInterfaces","text":"<pre><code>uint8_t usb_config_descriptor::bNumInterfaces;\n</code></pre>"},{"location":"apiStm/structusb__config__descriptor/#variable-bmattributes","title":"variable bmAttributes","text":"<p>Configuration attributes. <pre><code>uint8_t usb_config_descriptor::bmAttributes;\n</code></pre></p> <p>Comprised of a mask of <code>USB_CONFIG_ATTR_</code> masks. On all devices, this should include USB_CONFIG_ATTR_RESERVED at a minimum. </p>"},{"location":"apiStm/structusb__config__descriptor/#variable-iconfiguration","title":"variable iConfiguration","text":"<pre><code>uint8_t usb_config_descriptor::iConfiguration;\n</code></pre>"},{"location":"apiStm/structusb__config__descriptor/#variable-wtotallength","title":"variable wTotalLength","text":"<pre><code>uint16_t usb_config_descriptor::wTotalLength;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_std.h</code></p>"},{"location":"apiStm/structusb__debug__descriptor/","title":"Struct usb_debug_descriptor","text":"<p>ClassList &gt; usb_debug_descriptor</p> <p>USB debug descriptor. More...</p> <ul> <li><code>#include &lt;usb_std.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__debug__descriptor/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bDebugInEndpoint Endpoint number of the Debug Data IN endpoint. uint8_t bDebugOutEndpoint Endpoint number of the Debug Data OUTendpoint. uint8_t bDescriptorType Debug descriptor type. uint8_t bLength Size of the descriptor, in bytes."},{"location":"apiStm/structusb__debug__descriptor/#detailed-description","title":"Detailed Description","text":"<p>This descriptor is used to describe certain characteristics of the device that the host debug port driver needs to know to communicate with the device. Specifically, the debug descriptor lists the addresses of the endpoints that comprise the Debug Pipe. The endpoints are identified by endpoint number. </p>"},{"location":"apiStm/structusb__debug__descriptor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__debug__descriptor/#variable-bdebuginendpoint","title":"variable bDebugInEndpoint","text":"<pre><code>uint8_t usb_debug_descriptor::bDebugInEndpoint;\n</code></pre>"},{"location":"apiStm/structusb__debug__descriptor/#variable-bdebugoutendpoint","title":"variable bDebugOutEndpoint","text":"<pre><code>uint8_t usb_debug_descriptor::bDebugOutEndpoint;\n</code></pre>"},{"location":"apiStm/structusb__debug__descriptor/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_debug_descriptor::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__debug__descriptor/#variable-blength","title":"variable bLength","text":"<pre><code>uint8_t usb_debug_descriptor::bLength;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_std.h</code></p>"},{"location":"apiStm/structusb__device__descriptor/","title":"Struct usb_device_descriptor","text":"<p>ClassList &gt; usb_device_descriptor</p> <p>Represents a USB device descriptor. More...</p> <ul> <li><code>#include &lt;usb_std.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__device__descriptor/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bDescriptorType USB_DTYPE_DEVICE Device descriptor. uint8_t bDeviceClass USB device class. uint8_t bDeviceProtocol USB device protocol. uint8_t bDeviceSubClass USB device subclass. uint8_t bLength Size of the descriptor, in bytes. uint8_t bMaxPacketSize0 Size of the control endpoint's bank in bytes. uint8_t bNumConfigurations Total number of configurations supported by the device. uint16_t bcdDevice Product release (version) number. uint16_t bcdUSB BCD of the supported USB specification. uint8_t iManufacturer String index for the manufacturer's name. uint8_t iProduct String index for the product name/details. uint8_t iSerialNumber String index for the product serial number. uint16_t idProduct Unique product ID for the USB product. uint16_t idVendor Vendor ID for the USB product."},{"location":"apiStm/structusb__device__descriptor/#detailed-description","title":"Detailed Description","text":"<p>A device descriptor describes general information about a USB device. It includes information that applies globally to the device and all of the device\u2019s configurations. A USB device has only one device descriptor. A high-speed capable device that has different device information for full-speed and high-speed must also have a usb_qualifier_descriptor. </p>"},{"location":"apiStm/structusb__device__descriptor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__device__descriptor/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_device_descriptor::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-bdeviceclass","title":"variable bDeviceClass","text":"<pre><code>uint8_t usb_device_descriptor::bDeviceClass;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-bdeviceprotocol","title":"variable bDeviceProtocol","text":"<pre><code>uint8_t usb_device_descriptor::bDeviceProtocol;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-bdevicesubclass","title":"variable bDeviceSubClass","text":"<pre><code>uint8_t usb_device_descriptor::bDeviceSubClass;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-blength","title":"variable bLength","text":"<pre><code>uint8_t usb_device_descriptor::bLength;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-bmaxpacketsize0","title":"variable bMaxPacketSize0","text":"<pre><code>uint8_t usb_device_descriptor::bMaxPacketSize0;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-bnumconfigurations","title":"variable bNumConfigurations","text":"<pre><code>uint8_t usb_device_descriptor::bNumConfigurations;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-bcddevice","title":"variable bcdDevice","text":"<pre><code>uint16_t usb_device_descriptor::bcdDevice;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-bcdusb","title":"variable bcdUSB","text":"<pre><code>uint16_t usb_device_descriptor::bcdUSB;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-imanufacturer","title":"variable iManufacturer","text":"<pre><code>uint8_t usb_device_descriptor::iManufacturer;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-iproduct","title":"variable iProduct","text":"<pre><code>uint8_t usb_device_descriptor::iProduct;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-iserialnumber","title":"variable iSerialNumber","text":"<pre><code>uint8_t usb_device_descriptor::iSerialNumber;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-idproduct","title":"variable idProduct","text":"<pre><code>uint16_t usb_device_descriptor::idProduct;\n</code></pre>"},{"location":"apiStm/structusb__device__descriptor/#variable-idvendor","title":"variable idVendor","text":"<pre><code>uint16_t usb_device_descriptor::idVendor;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_std.h</code></p>"},{"location":"apiStm/structusb__endpoint__descriptor/","title":"Struct usb_endpoint_descriptor","text":"<p>ClassList &gt; usb_endpoint_descriptor</p> <p>USB endpoint descriptor. More...</p> <ul> <li><code>#include &lt;usb_std.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__endpoint__descriptor/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bDescriptorType Endpoint descriptor. uint8_t bEndpointAddress Logical address of the endpoint within the device for the current configuration, including direction mask. uint8_t bInterval Polling interval in milliseconds for the endpoint if it is an INTERRUPT or ISOCHRONOUS type. uint8_t bLength Size of the descriptor, in bytes. uint8_t bmAttributes Endpoint attributes, USB_ENDPOINT_DEF . uint16_t wMaxPacketSize Size of the endpoint bank, in bytes. This indicates the maximum packet size that the endpoint can receive at a time."},{"location":"apiStm/structusb__endpoint__descriptor/#detailed-description","title":"Detailed Description","text":"<p>This descriptor contains the information required by the host to determine the bandwidth requirements of each endpoint. </p>"},{"location":"apiStm/structusb__endpoint__descriptor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__endpoint__descriptor/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_endpoint_descriptor::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__endpoint__descriptor/#variable-bendpointaddress","title":"variable bEndpointAddress","text":"<pre><code>uint8_t usb_endpoint_descriptor::bEndpointAddress;\n</code></pre>"},{"location":"apiStm/structusb__endpoint__descriptor/#variable-binterval","title":"variable bInterval","text":"<pre><code>uint8_t usb_endpoint_descriptor::bInterval;\n</code></pre>"},{"location":"apiStm/structusb__endpoint__descriptor/#variable-blength","title":"variable bLength","text":"<pre><code>uint8_t usb_endpoint_descriptor::bLength;\n</code></pre>"},{"location":"apiStm/structusb__endpoint__descriptor/#variable-bmattributes","title":"variable bmAttributes","text":"<pre><code>uint8_t usb_endpoint_descriptor::bmAttributes;\n</code></pre>"},{"location":"apiStm/structusb__endpoint__descriptor/#variable-wmaxpacketsize","title":"variable wMaxPacketSize","text":"<pre><code>uint16_t usb_endpoint_descriptor::wMaxPacketSize;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_std.h</code></p>"},{"location":"apiStm/structusb__header__descriptor/","title":"Struct usb_header_descriptor","text":"<p>ClassList &gt; usb_header_descriptor</p> <p>common USB descriptor header </p> <ul> <li><code>#include &lt;usb_std.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__header__descriptor/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bDescriptorType Type of the descriptor. uint8_t bLength Size of the descriptor, in bytes."},{"location":"apiStm/structusb__header__descriptor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__header__descriptor/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_header_descriptor::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__header__descriptor/#variable-blength","title":"variable bLength","text":"<pre><code>uint8_t usb_header_descriptor::bLength;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_std.h</code></p>"},{"location":"apiStm/structusb__iad__descriptor/","title":"Struct usb_iad_descriptor","text":"<p>ClassList &gt; usb_iad_descriptor</p> <p>USB interface association descriptor. More...</p> <ul> <li><code>#include &lt;usb_std.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__iad__descriptor/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bDescriptorType IAD descriptor. uint8_t bFirstInterface Index of the first associated interface. uint8_t bFunctionClass Function class ID. uint8_t bFunctionProtocol Function protocol ID. uint8_t bFunctionSubClass Function subclass ID. uint8_t bInterfaceCount Total number of associated interfaces. uint8_t bLength Size of the descriptor, in bytes. uint8_t iFunction Index of the string descriptor describing the interface association."},{"location":"apiStm/structusb__iad__descriptor/#detailed-description","title":"Detailed Description","text":"<p>USB interface association descriptor (IAD) allows the device to group interfaces that belong to a function. </p>"},{"location":"apiStm/structusb__iad__descriptor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__iad__descriptor/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_iad_descriptor::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__iad__descriptor/#variable-bfirstinterface","title":"variable bFirstInterface","text":"<pre><code>uint8_t usb_iad_descriptor::bFirstInterface;\n</code></pre>"},{"location":"apiStm/structusb__iad__descriptor/#variable-bfunctionclass","title":"variable bFunctionClass","text":"<pre><code>uint8_t usb_iad_descriptor::bFunctionClass;\n</code></pre>"},{"location":"apiStm/structusb__iad__descriptor/#variable-bfunctionprotocol","title":"variable bFunctionProtocol","text":"<pre><code>uint8_t usb_iad_descriptor::bFunctionProtocol;\n</code></pre>"},{"location":"apiStm/structusb__iad__descriptor/#variable-bfunctionsubclass","title":"variable bFunctionSubClass","text":"<pre><code>uint8_t usb_iad_descriptor::bFunctionSubClass;\n</code></pre>"},{"location":"apiStm/structusb__iad__descriptor/#variable-binterfacecount","title":"variable bInterfaceCount","text":"<pre><code>uint8_t usb_iad_descriptor::bInterfaceCount;\n</code></pre>"},{"location":"apiStm/structusb__iad__descriptor/#variable-blength","title":"variable bLength","text":"<pre><code>uint8_t usb_iad_descriptor::bLength;\n</code></pre>"},{"location":"apiStm/structusb__iad__descriptor/#variable-ifunction","title":"variable iFunction","text":"<pre><code>uint8_t usb_iad_descriptor::iFunction;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_std.h</code></p>"},{"location":"apiStm/structusb__interface__descriptor/","title":"Struct usb_interface_descriptor","text":"<p>ClassList &gt; usb_interface_descriptor</p> <p>USB interface descriptor. More...</p> <ul> <li><code>#include &lt;usb_std.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__interface__descriptor/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bAlternateSetting Alternate setting for the interface number. uint8_t bDescriptorType Interface descriptor. uint8_t bInterfaceClass Interface class ID. uint8_t bInterfaceNumber Index of the interface in the current configuration. uint8_t bInterfaceProtocol Interface protocol ID. uint8_t bInterfaceSubClass Interface subclass ID. uint8_t bLength Size of the descriptor, in bytes. uint8_t bNumEndpoints Total number of endpoints in the interface. uint8_t iInterface Index of the string descriptor describing the interface."},{"location":"apiStm/structusb__interface__descriptor/#detailed-description","title":"Detailed Description","text":"<p>The interface descriptor describes a specific interface within a configuration. A configuration provides one or more interfaces, each with zero or more endpoint descriptors describing a unique set of endpoints within the configuration. </p>"},{"location":"apiStm/structusb__interface__descriptor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__interface__descriptor/#variable-balternatesetting","title":"variable bAlternateSetting","text":"<pre><code>uint8_t usb_interface_descriptor::bAlternateSetting;\n</code></pre>"},{"location":"apiStm/structusb__interface__descriptor/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_interface_descriptor::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__interface__descriptor/#variable-binterfaceclass","title":"variable bInterfaceClass","text":"<pre><code>uint8_t usb_interface_descriptor::bInterfaceClass;\n</code></pre>"},{"location":"apiStm/structusb__interface__descriptor/#variable-binterfacenumber","title":"variable bInterfaceNumber","text":"<pre><code>uint8_t usb_interface_descriptor::bInterfaceNumber;\n</code></pre>"},{"location":"apiStm/structusb__interface__descriptor/#variable-binterfaceprotocol","title":"variable bInterfaceProtocol","text":"<pre><code>uint8_t usb_interface_descriptor::bInterfaceProtocol;\n</code></pre>"},{"location":"apiStm/structusb__interface__descriptor/#variable-binterfacesubclass","title":"variable bInterfaceSubClass","text":"<pre><code>uint8_t usb_interface_descriptor::bInterfaceSubClass;\n</code></pre>"},{"location":"apiStm/structusb__interface__descriptor/#variable-blength","title":"variable bLength","text":"<pre><code>uint8_t usb_interface_descriptor::bLength;\n</code></pre>"},{"location":"apiStm/structusb__interface__descriptor/#variable-bnumendpoints","title":"variable bNumEndpoints","text":"<pre><code>uint8_t usb_interface_descriptor::bNumEndpoints;\n</code></pre>"},{"location":"apiStm/structusb__interface__descriptor/#variable-iinterface","title":"variable iInterface","text":"<pre><code>uint8_t usb_interface_descriptor::iInterface;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_std.h</code></p>"},{"location":"apiStm/structusb__qualifier__descriptor/","title":"Struct usb_qualifier_descriptor","text":"<p>ClassList &gt; usb_qualifier_descriptor</p> <p>USB device qualifier descriptor. More...</p> <ul> <li><code>#include &lt;usb_std.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__qualifier__descriptor/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bDescriptorType Qualifier descriptor. uint8_t bDeviceClass USB device class. uint8_t bDeviceProtocol USB device protocol. uint8_t bDeviceSubClass USB device subclass. uint8_t bLength Size of the descriptor, in bytes. uint8_t bMaxPacketSize0 Size of the control endpoint's bank in bytes. uint8_t bNumConfigurations Total number of configurations supported by the device. uint8_t bReserved Reserved for future use, must be 0. uint16_t bcdUSB BCD of the supported USB specification."},{"location":"apiStm/structusb__qualifier__descriptor/#detailed-description","title":"Detailed Description","text":"<p>The device_qualifier descriptor describes information about a high-speed capable device that would change if the device were operating at the other speed. For example, if the device is currently operating at full-speed, the device qualifier returns information about how it would operate at high-speed and vice-versa. </p>"},{"location":"apiStm/structusb__qualifier__descriptor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__qualifier__descriptor/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_qualifier_descriptor::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__qualifier__descriptor/#variable-bdeviceclass","title":"variable bDeviceClass","text":"<pre><code>uint8_t usb_qualifier_descriptor::bDeviceClass;\n</code></pre>"},{"location":"apiStm/structusb__qualifier__descriptor/#variable-bdeviceprotocol","title":"variable bDeviceProtocol","text":"<pre><code>uint8_t usb_qualifier_descriptor::bDeviceProtocol;\n</code></pre>"},{"location":"apiStm/structusb__qualifier__descriptor/#variable-bdevicesubclass","title":"variable bDeviceSubClass","text":"<pre><code>uint8_t usb_qualifier_descriptor::bDeviceSubClass;\n</code></pre>"},{"location":"apiStm/structusb__qualifier__descriptor/#variable-blength","title":"variable bLength","text":"<pre><code>uint8_t usb_qualifier_descriptor::bLength;\n</code></pre>"},{"location":"apiStm/structusb__qualifier__descriptor/#variable-bmaxpacketsize0","title":"variable bMaxPacketSize0","text":"<pre><code>uint8_t usb_qualifier_descriptor::bMaxPacketSize0;\n</code></pre>"},{"location":"apiStm/structusb__qualifier__descriptor/#variable-bnumconfigurations","title":"variable bNumConfigurations","text":"<pre><code>uint8_t usb_qualifier_descriptor::bNumConfigurations;\n</code></pre>"},{"location":"apiStm/structusb__qualifier__descriptor/#variable-breserved","title":"variable bReserved","text":"<pre><code>uint8_t usb_qualifier_descriptor::bReserved;\n</code></pre>"},{"location":"apiStm/structusb__qualifier__descriptor/#variable-bcdusb","title":"variable bcdUSB","text":"<pre><code>uint16_t usb_qualifier_descriptor::bcdUSB;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_std.h</code></p>"},{"location":"apiStm/structusb__string__descriptor/","title":"Struct usb_string_descriptor","text":"<p>ClassList &gt; usb_string_descriptor</p> <p>USB string descriptor. More...</p> <ul> <li><code>#include &lt;usb_std.h&gt;</code></li> </ul>"},{"location":"apiStm/structusb__string__descriptor/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bDescriptorType String descriptor type. uint8_t bLength Size of the descriptor, in bytes. uint16_t wString String data, as unicode characters or array of USB standard LANGID codes codes."},{"location":"apiStm/structusb__string__descriptor/#detailed-description","title":"Detailed Description","text":"<p>String descriptors are referenced by their one-based index number. A string descriptor contains one or more not NULL-terminated Unicode strings. </p> <p>Note:</p> <p>String descriptors are optional. if a device does not support string descriptors, all references to string descriptors within device, configuration, and interface descriptors must be reset to zero. </p>"},{"location":"apiStm/structusb__string__descriptor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/structusb__string__descriptor/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<pre><code>uint8_t usb_string_descriptor::bDescriptorType;\n</code></pre>"},{"location":"apiStm/structusb__string__descriptor/#variable-blength","title":"variable bLength","text":"<pre><code>uint8_t usb_string_descriptor::bLength;\n</code></pre>"},{"location":"apiStm/structusb__string__descriptor/#variable-wstring","title":"variable wString","text":"<pre><code>uint16_t usb_string_descriptor::wString[];\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_std.h</code></p>"},{"location":"apiStm/group__crDELAY/","title":"Group crDELAY","text":"<p>Modules &gt; crDELAY</p> <p>More...</p>"},{"location":"apiStm/group__crDELAY/#detailed-description","title":"Detailed Description","text":"<p>croutine. h </p> <p>Delay a co-routine for a fixed period of time.</p> <p>crDELAY can only be called from the co-routine function itself - not from within a function called by the co-routine function. This is because co-routines do not maintain their own stack.</p> <p>Parameters:</p> <ul> <li><code>xHandle</code> The handle of the co-routine to delay. This is the xHandle parameter of the co-routine function.</li> <li><code>xTickToDelay</code> The number of ticks that the co-routine should delay for. The actual amount of time this equates to is defined by configTICK_RATE_HZ (set in FreeRTOSConfig.h). The constant portTICK_PERIOD_MS can be used to convert ticks to milliseconds.</li> </ul> <p>Example usage:  </p>"},{"location":"apiStm/group__crQUEUE__RECEIVE/","title":"Group crQUEUE_RECEIVE","text":"<p>Modules &gt; crQUEUE_RECEIVE</p> <p>More...</p>"},{"location":"apiStm/group__crQUEUE__RECEIVE/#detailed-description","title":"Detailed Description","text":"<p>croutine. h </p> <p>The macro's crQUEUE_SEND() and crQUEUE_RECEIVE() are the co-routine equivalent to the xQueueSend() and xQueueReceive() functions used by tasks.</p> <p>crQUEUE_SEND and crQUEUE_RECEIVE can only be used from a co-routine whereas xQueueSend() and xQueueReceive() can only be used from tasks.</p> <p>crQUEUE_RECEIVE can only be called from the co-routine function itself - not from within a function called by the co-routine function. This is because co-routines do not maintain their own stack.</p> <p>See the co-routine section of the WEB documentation for information on passing data between tasks and co-routines and between ISR's and co-routines.</p> <p>Parameters:</p> <ul> <li><code>xHandle</code> The handle of the calling co-routine. This is the xHandle parameter of the co-routine function.</li> <li><code>pxQueue</code> The handle of the queue from which the data will be received. The handle is obtained as the return value when the queue is created using the xQueueCreate() API function.</li> <li><code>pvBuffer</code> The buffer into which the received item is to be copied. The number of bytes of each queued item is specified when the queue is created. This number of bytes is copied into pvBuffer.</li> <li><code>xTickToDelay</code> The number of ticks that the co-routine should block to wait for data to become available from the queue, should data not be available immediately. The actual amount of time this equates to is defined by configTICK_RATE_HZ (set in FreeRTOSConfig.h). The constant portTICK_PERIOD_MS can be used to convert ticks to milliseconds (see the crQUEUE_SEND example).</li> <li><code>pxResult</code> The variable pointed to by pxResult will be set to pdPASS if data was successfully retrieved from the queue, otherwise it will be set to an error code as defined within ProjDefs.h.</li> </ul> <p>Example usage:  </p>"},{"location":"apiStm/group__crQUEUE__RECEIVE__FROM__ISR/","title":"Group crQUEUE_RECEIVE_FROM_ISR","text":"<p>Modules &gt; crQUEUE_RECEIVE_FROM_ISR</p> <p>More...</p>"},{"location":"apiStm/group__crQUEUE__RECEIVE__FROM__ISR/#detailed-description","title":"Detailed Description","text":"<p>croutine. h </p> <p>The macro's crQUEUE_SEND_FROM_ISR() and crQUEUE_RECEIVE_FROM_ISR() are the co-routine equivalent to the xQueueSendFromISR() and xQueueReceiveFromISR() functions used by tasks.</p> <p>crQUEUE_SEND_FROM_ISR() and crQUEUE_RECEIVE_FROM_ISR() can only be used to pass data between a co-routine and and ISR, whereas xQueueSendFromISR() and xQueueReceiveFromISR() can only be used to pass data between a task and and ISR.</p> <p>crQUEUE_RECEIVE_FROM_ISR can only be called from an ISR to receive data from a queue that is being used from within a co-routine (a co-routine posted to the queue).</p> <p>See the co-routine section of the WEB documentation for information on passing data between tasks and co-routines and between ISR's and co-routines.</p> <p>Parameters:</p> <ul> <li><code>xQueue</code> The handle to the queue on which the item is to be posted.</li> <li><code>pvBuffer</code> A pointer to a buffer into which the received item will be placed. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from the queue into pvBuffer.</li> <li><code>pxCoRoutineWoken</code> A co-routine may be blocked waiting for space to become available on the queue. If crQUEUE_RECEIVE_FROM_ISR causes such a co-routine to unblock *pxCoRoutineWoken will get set to pdTRUE, otherwise *pxCoRoutineWoken will remain unchanged.</li> </ul> <p>Returns:</p> <p>pdTRUE an item was successfully received from the queue, otherwise pdFALSE.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__crQUEUE__SEND/","title":"Group crQUEUE_SEND","text":"<p>Modules &gt; crQUEUE_SEND</p> <p>More...</p>"},{"location":"apiStm/group__crQUEUE__SEND/#detailed-description","title":"Detailed Description","text":"<p>The macro's crQUEUE_SEND() and crQUEUE_RECEIVE() are the co-routine equivalent to the xQueueSend() and xQueueReceive() functions used by tasks.</p> <p>crQUEUE_SEND and crQUEUE_RECEIVE can only be used from a co-routine whereas xQueueSend() and xQueueReceive() can only be used from tasks.</p> <p>crQUEUE_SEND can only be called from the co-routine function itself - not from within a function called by the co-routine function. This is because co-routines do not maintain their own stack.</p> <p>See the co-routine section of the WEB documentation for information on passing data between tasks and co-routines and between ISR's and co-routines.</p> <p>Parameters:</p> <ul> <li><code>xHandle</code> The handle of the calling co-routine. This is the xHandle parameter of the co-routine function.</li> <li><code>pxQueue</code> The handle of the queue on which the data will be posted. The handle is obtained as the return value when the queue is created using the xQueueCreate() API function.</li> <li><code>pvItemToQueue</code> A pointer to the data being posted onto the queue. The number of bytes of each queued item is specified when the queue is created. This number of bytes is copied from pvItemToQueue into the queue itself.</li> <li><code>xTickToDelay</code> The number of ticks that the co-routine should block to wait for space to become available on the queue, should space not be available immediately. The actual amount of time this equates to is defined by configTICK_RATE_HZ (set in FreeRTOSConfig.h). The constant portTICK_PERIOD_MS can be used to convert ticks to milliseconds (see example below).</li> <li><code>pxResult</code> The variable pointed to by pxResult will be set to pdPASS if data was successfully posted onto the queue, otherwise it will be set to an error defined within ProjDefs.h.</li> </ul> <p>Example usage:  </p>"},{"location":"apiStm/group__crQUEUE__SEND__FROM__ISR/","title":"Group crQUEUE_SEND_FROM_ISR","text":"<p>Modules &gt; crQUEUE_SEND_FROM_ISR</p> <p>More...</p>"},{"location":"apiStm/group__crQUEUE__SEND__FROM__ISR/#detailed-description","title":"Detailed Description","text":"<p>croutine. h </p> <p>The macro's crQUEUE_SEND_FROM_ISR() and crQUEUE_RECEIVE_FROM_ISR() are the co-routine equivalent to the xQueueSendFromISR() and xQueueReceiveFromISR() functions used by tasks.</p> <p>crQUEUE_SEND_FROM_ISR() and crQUEUE_RECEIVE_FROM_ISR() can only be used to pass data between a co-routine and and ISR, whereas xQueueSendFromISR() and xQueueReceiveFromISR() can only be used to pass data between a task and and ISR.</p> <p>crQUEUE_SEND_FROM_ISR can only be called from an ISR to send data to a queue that is being used from within a co-routine.</p> <p>See the co-routine section of the WEB documentation for information on passing data between tasks and co-routines and between ISR's and co-routines.</p> <p>Parameters:</p> <ul> <li><code>xQueue</code> The handle to the queue on which the item is to be posted.</li> <li><code>pvItemToQueue</code> A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</li> <li><code>xCoRoutinePreviouslyWoken</code> This is included so an ISR can post onto the same queue multiple times from a single interrupt. The first call should always pass in pdFALSE. Subsequent calls should pass in the value returned from the previous call.</li> </ul> <p>Returns:</p> <p>pdTRUE if a co-routine was woken by posting onto the queue. This is used by the ISR to determine if a context switch may be required following the ISR.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__crSTART/","title":"Group crSTART","text":"<p>Modules &gt; crSTART</p> <p>More...</p>"},{"location":"apiStm/group__crSTART/#detailed-description","title":"Detailed Description","text":"<p>croutine. h </p> <p>This macro MUST always be called at the start of a co-routine function.</p> <p>Example usage: </p> <p>croutine. h </p> <p>This macro MUST always be called at the end of a co-routine function.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__pcTaskGetHandle/","title":"Group pcTaskGetHandle","text":"<p>Modules &gt; pcTaskGetHandle</p> <p>More...</p>"},{"location":"apiStm/group__pcTaskGetHandle/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>NOTE: This function takes a relatively long time to complete and should be used sparingly.</p> <p>Returns:</p> <p>The handle of the task that has the human readable name pcNameToQuery. NULL is returned if no matching name is found. INCLUDE_xTaskGetHandle must be set to 1 in FreeRTOSConfig.h for pcTaskGetHandle() to be available. </p>"},{"location":"apiStm/group__pcTaskGetName/","title":"Group pcTaskGetName","text":"<p>Modules &gt; pcTaskGetName</p> <p>More...</p>"},{"location":"apiStm/group__pcTaskGetName/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>Returns:</p> <p>The text (human readable) name of the task referenced by the handle xTaskToQuery. A task can query its own name by either passing in its own handle, or by setting xTaskToQuery to NULL. </p>"},{"location":"apiStm/group__taskDISABLE__INTERRUPTS/","title":"Group taskDISABLE_INTERRUPTS","text":"<p>Modules &gt; taskDISABLE_INTERRUPTS</p> <p>More...</p>"},{"location":"apiStm/group__taskDISABLE__INTERRUPTS/#detailed-description","title":"Detailed Description","text":"<p>task. h</p> <p>Macro to disable all maskable interrupts. </p>"},{"location":"apiStm/group__taskENABLE__INTERRUPTS/","title":"Group taskENABLE_INTERRUPTS","text":"<p>Modules &gt; taskENABLE_INTERRUPTS</p> <p>More...</p>"},{"location":"apiStm/group__taskENABLE__INTERRUPTS/#detailed-description","title":"Detailed Description","text":"<p>task. h</p> <p>Macro to enable microcontroller interrupts. </p>"},{"location":"apiStm/group__taskENTER__CRITICAL/","title":"Group taskENTER_CRITICAL","text":"<p>Modules &gt; taskENTER_CRITICAL</p> <p>More...</p>"},{"location":"apiStm/group__taskENTER__CRITICAL/#detailed-description","title":"Detailed Description","text":"<p>task. h</p> <p>Macro to mark the start of a critical code region. Preemptive context switches cannot occur when in a critical region.</p> <p>NOTE: This may alter the stack (depending on the portable implementation) so must be used with care! </p>"},{"location":"apiStm/group__taskEXIT__CRITICAL/","title":"Group taskEXIT_CRITICAL","text":"<p>Modules &gt; taskEXIT_CRITICAL</p> <p>More...</p>"},{"location":"apiStm/group__taskEXIT__CRITICAL/#detailed-description","title":"Detailed Description","text":"<p>task. h</p> <p>Macro to mark the end of a critical code region. Preemptive context switches cannot occur when in a critical region.</p> <p>NOTE: This may alter the stack (depending on the portable implementation) so must be used with care! </p>"},{"location":"apiStm/group__taskYIELD/","title":"Group taskYIELD","text":"<p>Modules &gt; taskYIELD</p> <p>More...</p>"},{"location":"apiStm/group__taskYIELD/#detailed-description","title":"Detailed Description","text":"<p>task. h</p> <p>Macro for forcing a context switch. </p>"},{"location":"apiStm/group__ulTaskGetIdleRunTimeCounter/","title":"Group ulTaskGetIdleRunTimeCounter","text":"<p>Modules &gt; ulTaskGetIdleRunTimeCounter</p> <p>More...</p>"},{"location":"apiStm/group__ulTaskGetIdleRunTimeCounter/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS must both be defined as 1 for this function to be available. The application must also then provide definitions for portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE() to configure a peripheral timer/counter and return the timers current count value respectively. The counter should be at least 10 times the frequency of the tick count.</p> <p>Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total accumulated execution time being stored for each task. The resolution of the accumulated time value depends on the frequency of the timer configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro. While uxTaskGetSystemState() and vTaskGetRunTimeStats() writes the total execution time of each task into a buffer, ulTaskGetIdleRunTimeCounter() returns the total execution time of just the idle task.</p> <p>Returns:</p> <p>The total run time of the idle task. This is the amount of time the idle task has actually been executing. The unit of time is dependent on the frequency configured using the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE() macros. </p>"},{"location":"apiStm/group__ulTaskNotifyTake/","title":"Group ulTaskNotifyTake","text":"<p>Modules &gt; ulTaskNotifyTake</p> <p>More...</p>"},{"location":"apiStm/group__ulTaskNotifyTake/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this function to be available.</p> <p>When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private \"notification value\", which is a 32-bit unsigned integer (uint32_t).</p> <p>Events can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object.</p> <p>A notification sent to a task can optionally perform an action, such as update, overwrite or increment the task's notification value. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.</p> <p>ulTaskNotifyTake() is intended for use when a task notification is used as a faster and lighter weight binary or counting semaphore alternative. Actual FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the equivalent action that instead uses a task notification is ulTaskNotifyTake().</p> <p>When a task is using its notification value as a binary or counting semaphore other tasks should send notifications to it using the xTaskNotifyGive() macro, or xTaskNotify() function with the eAction parameter set to eIncrement.</p> <p>ulTaskNotifyTake() can either clear the task's notification value to zero on exit, in which case the notification value acts like a binary semaphore, or decrement the task's notification value on exit, in which case the notification value acts like a counting semaphore.</p> <p>A task can use ulTaskNotifyTake() to [optionally] block to wait for a the task's notification value to be non-zero. The task does not consume any CPU time while it is in the Blocked state.</p> <p>Where as xTaskNotifyWait() will return when a notification is pending, ulTaskNotifyTake() will return when the task's notification value is not zero.</p> <p>See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.</p> <p>Parameters:</p> <ul> <li><code>xClearCountOnExit</code> if xClearCountOnExit is pdFALSE then the task's notification value is decremented when the function exits. In this way the notification value acts like a counting semaphore. If xClearCountOnExit is not pdFALSE then the task's notification value is cleared to zero when the function exits. In this way the notification value acts like a binary semaphore.</li> <li><code>xTicksToWait</code> The maximum amount of time that the task should wait in the Blocked state for the task's notification value to be greater than zero, should the count not already be greater than zero when ulTaskNotifyTake() was called. The task will not consume any processing time while it is in the Blocked state. This is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time specified in milliseconds to a time specified in ticks.</li> </ul> <p>Returns:</p> <p>The task's notification count before it is either cleared to zero or decremented (see the xClearCountOnExit parameter). </p>"},{"location":"apiStm/group__ulTaskNotifyValueClear/","title":"Group ulTaskNotifyValueClear","text":"<p>Modules &gt; ulTaskNotifyValueClear</p> <p>More...</p>"},{"location":"apiStm/group__ulTaskNotifyValueClear/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>Clears the bits specified by the ulBitsToClear bit mask in the notification value of the task referenced by xTask.</p> <p>Set ulBitsToClear to 0xffffffff (UINT_MAX on 32-bit architectures) to clear the notification value to 0. Set ulBitsToClear to 0 to query the task's notification value without clearing any bits.</p> <p>Returns:</p> <p>The value of the target task's notification value before the bits specified by ulBitsToClear were cleared. </p>"},{"location":"apiStm/group__uxQueueMessagesWaiting/","title":"Group uxQueueMessagesWaiting","text":"<p>Modules &gt; uxQueueMessagesWaiting</p> <p>More...</p>"},{"location":"apiStm/group__uxQueueMessagesWaiting/#detailed-description","title":"Detailed Description","text":"<p>queue. h </p> <p>Return the number of messages stored in a queue.</p> <p>Parameters:</p> <ul> <li><code>xQueue</code> A handle to the queue being queried.</li> </ul> <p>Returns:</p> <p>The number of messages available in the queue.</p> <p>queue. h </p> <p>Return the number of free spaces available in a queue. This is equal to the number of items that can be sent to the queue before the queue becomes full if no items are removed.</p> <p>Parameters:</p> <ul> <li><code>xQueue</code> A handle to the queue being queried.</li> </ul> <p>Returns:</p> <p>The number of spaces available in the queue. </p>"},{"location":"apiStm/group__uxTaskGetNumberOfTasks/","title":"Group uxTaskGetNumberOfTasks","text":"<p>Modules &gt; uxTaskGetNumberOfTasks</p> <p>More...</p>"},{"location":"apiStm/group__uxTaskGetNumberOfTasks/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>Returns:</p> <p>The number of tasks that the real time kernel is currently managing. This includes all ready, blocked and suspended tasks. A task that has been deleted but not yet freed by the idle task will also be included in the count. </p>"},{"location":"apiStm/group__uxTaskPriorityGet/","title":"Group uxTaskPriorityGet","text":"<p>Modules &gt; uxTaskPriorityGet</p> <p>More...</p>"},{"location":"apiStm/group__uxTaskPriorityGet/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available. See the configuration section for more information.</p> <p>Obtain the priority of any task.</p> <p>Parameters:</p> <ul> <li><code>xTask</code> Handle of the task to be queried. Passing a NULL handle results in the priority of the calling task being returned.</li> </ul> <p>Returns:</p> <p>The priority of xTask.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__vCoRoutineSchedule/","title":"Group vCoRoutineSchedule","text":"<p>Modules &gt; vCoRoutineSchedule</p> <p>More...</p>"},{"location":"apiStm/group__vCoRoutineSchedule/#detailed-description","title":"Detailed Description","text":"<p>croutine. h </p> <p>Run a co-routine.</p> <p>vCoRoutineSchedule() executes the highest priority co-routine that is able to run. The co-routine will execute until it either blocks, yields or is preempted by a task. Co-routines execute cooperatively so one co-routine cannot be preempted by another, but can be preempted by a task.</p> <p>If an application comprises of both tasks and co-routines then vCoRoutineSchedule should be called from the idle task (in an idle task hook).</p> <p>Example usage:  </p>"},{"location":"apiStm/group__vQueueDelete/","title":"Group vQueueDelete","text":"<p>Modules &gt; vQueueDelete</p> <p>More...</p>"},{"location":"apiStm/group__vQueueDelete/#detailed-description","title":"Detailed Description","text":"<p>queue. h </p> <p>Delete a queue - freeing all the memory allocated for storing of items placed on the queue.</p> <p>Parameters:</p> <ul> <li><code>xQueue</code> A handle to the queue to be deleted. </li> </ul>"},{"location":"apiStm/group__vSemaphoreCreateBinary/","title":"Group vSemaphoreCreateBinary","text":"<p>Modules &gt; vSemaphoreCreateBinary</p> <p>More...</p>"},{"location":"apiStm/group__vSemaphoreCreateBinary/#detailed-description","title":"Detailed Description","text":"<p>semphr. h </p> <p>In many usage scenarios it is faster and more memory efficient to use a direct to task notification in place of a binary semaphore! http://www.freertos.org/RTOS-task-notifications.html</p> <p>This old vSemaphoreCreateBinary() macro is now deprecated in favour of the xSemaphoreCreateBinary() function. Note that binary semaphores created using the vSemaphoreCreateBinary() macro are created in a state such that the first call to 'take' the semaphore would pass, whereas binary semaphores created using xSemaphoreCreateBinary() are created in a state such that the the semaphore must first be 'given' before it can be 'taken'.</p> <p>Macro that implements a semaphore by using the existing queue mechanism. The queue length is 1 as this is a binary semaphore. The data size is 0 as we don't want to actually store any data - we just want to know if the queue is empty or full.</p> <p>This type of semaphore can be used for pure synchronisation between tasks or between an interrupt and a task. The semaphore need not be given back once obtained, so one task/interrupt can continuously 'give' the semaphore while another continuously 'takes' the semaphore. For this reason this type of semaphore does not use a priority inheritance mechanism. For an alternative that does use priority inheritance see xSemaphoreCreateMutex().</p> <p>Parameters:</p> <ul> <li><code>xSemaphore</code> Handle to the created semaphore. Should be of type SemaphoreHandle_t.</li> </ul> <p>Example usage:  </p>"},{"location":"apiStm/group__vSemaphoreDelete/","title":"Group vSemaphoreDelete","text":"<p>Modules &gt; vSemaphoreDelete</p> <p>More...</p>"},{"location":"apiStm/group__vSemaphoreDelete/#detailed-description","title":"Detailed Description","text":"<p>semphr. h </p> <p>Delete a semaphore. This function must be used with care. For example, do not delete a mutex type semaphore if the mutex is held by a task.</p> <p>Parameters:</p> <ul> <li><code>xSemaphore</code> A handle to the semaphore to be deleted. </li> </ul>"},{"location":"apiStm/group__vStreamBufferDelete/","title":"Group vStreamBufferDelete","text":"<p>Modules &gt; vStreamBufferDelete</p> <p>More...</p>"},{"location":"apiStm/group__vStreamBufferDelete/#detailed-description","title":"Detailed Description","text":"<p>stream_buffer.h</p> <p>Deletes a stream buffer that was previously created using a call to xStreamBufferCreate() or xStreamBufferCreateStatic(). If the stream buffer was created using dynamic memory (that is, by xStreamBufferCreate()), then the allocated memory is freed.</p> <p>A stream buffer handle must not be used after the stream buffer has been deleted.</p> <p>Parameters:</p> <ul> <li><code>xStreamBuffer</code> The handle of the stream buffer to be deleted. </li> </ul>"},{"location":"apiStm/group__vTaskDelay/","title":"Group vTaskDelay","text":"<p>Modules &gt; vTaskDelay</p> <p>More...</p>"},{"location":"apiStm/group__vTaskDelay/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>Delay a task for a given number of ticks. The actual time that the task remains blocked depends on the tick rate. The constant portTICK_PERIOD_MS can be used to calculate real time from the tick rate - with the resolution of one tick period.</p> <p>INCLUDE_vTaskDelay must be defined as 1 for this function to be available. See the configuration section for more information.</p> <p>vTaskDelay() specifies a time at which the task wishes to unblock relative to the time at which vTaskDelay() is called. For example, specifying a block period of 100 ticks will cause the task to unblock 100 ticks after vTaskDelay() is called. vTaskDelay() does not therefore provide a good method of controlling the frequency of a periodic task as the path taken through the code, as well as other task and interrupt activity, will effect the frequency at which vTaskDelay() gets called and therefore the time at which the task next executes. See vTaskDelayUntil() for an alternative API function designed to facilitate fixed frequency execution. It does this by specifying an absolute time (rather than a relative time) at which the calling task should unblock.</p> <p>Parameters:</p> <ul> <li><code>xTicksToDelay</code> The amount of time, in tick periods, that the calling task should block.</li> </ul> <p>Example usage:</p> <p>void vTaskFunction( void * pvParameters ) { Block for 500ms. const TickType_t xDelay = 500 / portTICK_PERIOD_MS;  Simply toggle the LED every 500ms, blocking between each toggle. vToggleLED(); vTaskDelay( xDelay ); } } </p>"},{"location":"apiStm/group__vTaskDelayUntil/","title":"Group vTaskDelayUntil","text":"<p>Modules &gt; vTaskDelayUntil</p> <p>More...</p>"},{"location":"apiStm/group__vTaskDelayUntil/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available. See the configuration section for more information.</p> <p>Delay a task until a specified time. This function can be used by periodic tasks to ensure a constant execution frequency.</p> <p>This function differs from vTaskDelay () in one important aspect: vTaskDelay () will cause a task to block for the specified number of ticks from the time vTaskDelay () is called. It is therefore difficult to use vTaskDelay () by itself to generate a fixed execution frequency as the time between a task starting to execute and that task calling vTaskDelay () may not be fixed [the task may take a different path though the code between calls, or may get interrupted or preempted a different number of times each time it executes].</p> <p>Whereas vTaskDelay () specifies a wake time relative to the time at which the function is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to unblock.</p> <p>The constant portTICK_PERIOD_MS can be used to calculate real time from the tick rate - with the resolution of one tick period.</p> <p>Parameters:</p> <ul> <li><code>pxPreviousWakeTime</code> Pointer to a variable that holds the time at which the task was last unblocked. The variable must be initialised with the current time prior to its first use (see the example below). Following this the variable is automatically updated within vTaskDelayUntil ().</li> <li><code>xTimeIncrement</code> The cycle time period. The task will be unblocked at time *pxPreviousWakeTime + xTimeIncrement. Calling vTaskDelayUntil with the same xTimeIncrement parameter value will cause the task to execute with a fixed interface period.</li> </ul> <p>Example usage:  </p>"},{"location":"apiStm/group__vTaskDelete/","title":"Group vTaskDelete","text":"<p>Modules &gt; vTaskDelete</p> <p>More...</p>"},{"location":"apiStm/group__vTaskDelete/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>INCLUDE_vTaskDelete must be defined as 1 for this function to be available. See the configuration section for more information.</p> <p>Remove a task from the RTOS real time kernel's management. The task being deleted will be removed from all ready, blocked, suspended and event lists.</p> <p>NOTE: The idle task is responsible for freeing the kernel allocated memory from tasks that have been deleted. It is therefore important that the idle task is not starved of microcontroller processing time if your application makes any calls to vTaskDelete (). Memory allocated by the task code is not automatically freed, and should be freed before the task is deleted.</p> <p>See the demo application file death.c for sample code that utilises vTaskDelete ().</p> <p>Parameters:</p> <ul> <li><code>xTask</code> The handle of the task to be deleted. Passing NULL will cause the calling task to be deleted.</li> </ul> <p>Example usage:  </p>"},{"location":"apiStm/group__vTaskEndScheduler/","title":"Group vTaskEndScheduler","text":"<p>Modules &gt; vTaskEndScheduler</p> <p>More...</p>"},{"location":"apiStm/group__vTaskEndScheduler/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>NOTE: At the time of writing only the x86 real mode port, which runs on a PC in place of DOS, implements this function.</p> <p>Stops the real time kernel tick. All created tasks will be automatically deleted and multitasking (either preemptive or cooperative) will stop. Execution then resumes from the point where vTaskStartScheduler () was called, as if vTaskStartScheduler () had just returned.</p> <p>See the demo application file main. c in the demo/PC directory for an example that uses vTaskEndScheduler ().</p> <p>vTaskEndScheduler () requires an exit function to be defined within the portable layer (see vPortEndScheduler () in port. c for the PC port). This performs hardware specific operations such as stopping the kernel tick.</p> <p>vTaskEndScheduler () will cause all of the resources allocated by the kernel to be freed - but will not free resources allocated by application tasks.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__vTaskGetInfo/","title":"Group vTaskGetInfo","text":"<p>Modules &gt; vTaskGetInfo</p> <p>More...</p>"},{"location":"apiStm/group__vTaskGetInfo/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>configUSE_TRACE_FACILITY must be defined as 1 for this function to be available. See the configuration section for more information.</p> <p>Populates a TaskStatus_t structure with information about a task.</p> <p>Parameters:</p> <ul> <li><code>xTask</code> Handle of the task being queried. If xTask is NULL then information will be returned about the calling task.</li> <li><code>pxTaskStatus</code> A pointer to the TaskStatus_t structure that will be filled with information about the task referenced by the handle passed using the xTask parameter.</li> </ul> <p>@xGetFreeStackSpace The TaskStatus_t structure contains a member to report the stack high water mark of the task being queried. Calculating the stack high water mark takes a relatively long time, and can make the system temporarily unresponsive - so the xGetFreeStackSpace parameter is provided to allow the high water mark checking to be skipped. The high watermark value will only be written to the TaskStatus_t structure if xGetFreeStackSpace is not set to pdFALSE;</p> <p>Parameters:</p> <ul> <li><code>eState</code> The TaskStatus_t structure contains a member to report the state of the task being queried. Obtaining the task state is not as fast as a simple assignment - so the eState parameter is provided to allow the state information to be omitted from the TaskStatus_t structure. To obtain state information then set eState to eInvalid - otherwise the value passed in eState will be reported as the task state in the TaskStatus_t structure.</li> </ul> <p>Example usage:  </p>"},{"location":"apiStm/group__vTaskGetRunTimeStats/","title":"Group vTaskGetRunTimeStats","text":"<p>Modules &gt; vTaskGetRunTimeStats</p> <p>More...</p>"},{"location":"apiStm/group__vTaskGetRunTimeStats/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS must both be defined as 1 for this function to be available. The application must also then provide definitions for portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE() to configure a peripheral timer/counter and return the timers current count value respectively. The counter should be at least 10 times the frequency of the tick count.</p> <p>NOTE 1: This function will disable interrupts for its duration. It is not intended for normal application runtime use but as a debug aid.</p> <p>Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total accumulated execution time being stored for each task. The resolution of the accumulated time value depends on the frequency of the timer configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro. Calling vTaskGetRunTimeStats() writes the total execution time of each task into a buffer, both as an absolute count value and as a percentage of the total system execution time.</p> <p>NOTE 2:</p> <p>This function is provided for convenience only, and is used by many of the demo applications. Do not consider it to be part of the scheduler.</p> <p>vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the uxTaskGetSystemState() output into a human readable table that displays the amount of time each task has spent in the Running state in both absolute and percentage terms.</p> <p>vTaskGetRunTimeStats() has a dependency on the sprintf() C library function that might bloat the code size, use a lot of stack, and provide different results on different platforms. An alternative, tiny, third party, and limited functionality implementation of sprintf() is provided in many of the FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note printf-stdarg.c does not provide a full snprintf() implementation!).</p> <p>It is recommended that production systems call uxTaskGetSystemState() directly to get access to raw stats data, rather than indirectly through a call to vTaskGetRunTimeStats().</p> <p>Parameters:</p> <ul> <li><code>pcWriteBuffer</code> A buffer into which the execution times will be written, in ASCII form. This buffer is assumed to be large enough to contain the generated report. Approximately 40 bytes per task should be sufficient. </li> </ul>"},{"location":"apiStm/group__vTaskList/","title":"Group vTaskList","text":"<p>Modules &gt; vTaskList</p> <p>More...</p>"},{"location":"apiStm/group__vTaskList/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must both be defined as 1 for this function to be available. See the configuration section of the FreeRTOS.org website for more information.</p> <p>NOTE 1: This function will disable interrupts for its duration. It is not intended for normal application runtime use but as a debug aid.</p> <p>Lists all the current tasks, along with their current state and stack usage high water mark.</p> <p>Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or suspended ('S').</p> <p>PLEASE NOTE:</p> <p>This function is provided for convenience only, and is used by many of the demo applications. Do not consider it to be part of the scheduler.</p> <p>vTaskList() calls uxTaskGetSystemState(), then formats part of the uxTaskGetSystemState() output into a human readable table that displays task names, states and stack usage.</p> <p>vTaskList() has a dependency on the sprintf() C library function that might bloat the code size, use a lot of stack, and provide different results on different platforms. An alternative, tiny, third party, and limited functionality implementation of sprintf() is provided in many of the FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note printf-stdarg.c does not provide a full snprintf() implementation!).</p> <p>It is recommended that production systems call uxTaskGetSystemState() directly to get access to raw stats data, rather than indirectly through a call to vTaskList().</p> <p>Parameters:</p> <ul> <li><code>pcWriteBuffer</code> A buffer into which the above mentioned details will be written, in ASCII form. This buffer is assumed to be large enough to contain the generated report. Approximately 40 bytes per task should be sufficient. </li> </ul>"},{"location":"apiStm/group__vTaskPrioritySet/","title":"Group vTaskPrioritySet","text":"<p>Modules &gt; vTaskPrioritySet</p> <p>More...</p>"},{"location":"apiStm/group__vTaskPrioritySet/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available. See the configuration section for more information.</p> <p>Set the priority of any task.</p> <p>A context switch will occur before the function returns if the priority being set is higher than the currently executing task.</p> <p>Parameters:</p> <ul> <li><code>xTask</code> Handle to the task for which the priority is being set. Passing a NULL handle results in the priority of the calling task being set.</li> <li><code>uxNewPriority</code> The priority to which the task will be set.</li> </ul> <p>Example usage:  </p>"},{"location":"apiStm/group__vTaskResume/","title":"Group vTaskResume","text":"<p>Modules &gt; vTaskResume</p> <p>More...</p>"},{"location":"apiStm/group__vTaskResume/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>INCLUDE_vTaskSuspend must be defined as 1 for this function to be available. See the configuration section for more information.</p> <p>Resumes a suspended task.</p> <p>A task that has been suspended by one or more calls to vTaskSuspend () will be made available for running again by a single call to vTaskResume ().</p> <p>Parameters:</p> <ul> <li><code>xTaskToResume</code> Handle to the task being readied.</li> </ul> <p>Example usage:  </p>"},{"location":"apiStm/group__vTaskResumeFromISR/","title":"Group vTaskResumeFromISR","text":"<p>Modules &gt; vTaskResumeFromISR</p> <p>More...</p>"},{"location":"apiStm/group__vTaskResumeFromISR/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be available. See the configuration section for more information.</p> <p>An implementation of vTaskResume() that can be called from within an ISR.</p> <p>A task that has been suspended by one or more calls to vTaskSuspend () will be made available for running again by a single call to xTaskResumeFromISR ().</p> <p>xTaskResumeFromISR() should not be used to synchronise a task with an interrupt if there is a chance that the interrupt could arrive prior to the task being suspended - as this can lead to interrupts being missed. Use of a semaphore as a synchronisation mechanism would avoid this eventuality.</p> <p>Parameters:</p> <ul> <li><code>xTaskToResume</code> Handle to the task being readied.</li> </ul> <p>Returns:</p> <p>pdTRUE if resuming the task should result in a context switch, otherwise pdFALSE. This is used by the ISR to determine if a context switch may be required following the ISR. </p>"},{"location":"apiStm/group__vTaskSetTimeOutState/","title":"Group vTaskSetTimeOutState","text":"<p>Modules &gt; vTaskSetTimeOutState</p> <p>More...</p>"},{"location":"apiStm/group__vTaskSetTimeOutState/#detailed-description","title":"Detailed Description","text":"<p>task.h </p> <p>Capture the current time for future use with xTaskCheckForTimeOut().</p> <p>Parameters:</p> <ul> <li><code>pxTimeOut</code> Pointer to a timeout object into which the current time is to be captured. The captured time includes the tick count and the number of times the tick count has overflowed since the system first booted. </li> </ul>"},{"location":"apiStm/group__vTaskStartScheduler/","title":"Group vTaskStartScheduler","text":"<p>Modules &gt; vTaskStartScheduler</p> <p>More...</p>"},{"location":"apiStm/group__vTaskStartScheduler/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>Starts the real time kernel tick processing. After calling the kernel has control over which tasks are executed and when.</p> <p>See the demo application file main.c for an example of creating tasks and starting the kernel.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__vTaskSuspend/","title":"Group vTaskSuspend","text":"<p>Modules &gt; vTaskSuspend</p> <p>More...</p>"},{"location":"apiStm/group__vTaskSuspend/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>INCLUDE_vTaskSuspend must be defined as 1 for this function to be available. See the configuration section for more information.</p> <p>Suspend any task. When suspended a task will never get any microcontroller processing time, no matter what its priority.</p> <p>Calls to vTaskSuspend are not accumulative - i.e. calling vTaskSuspend () twice on the same task still only requires one call to vTaskResume () to ready the suspended task.</p> <p>Parameters:</p> <ul> <li><code>xTaskToSuspend</code> Handle to the task being suspended. Passing a NULL handle will cause the calling task to be suspended.</li> </ul> <p>Example usage:  </p>"},{"location":"apiStm/group__vTaskSuspendAll/","title":"Group vTaskSuspendAll","text":"<p>Modules &gt; vTaskSuspendAll</p> <p>More...</p>"},{"location":"apiStm/group__vTaskSuspendAll/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>Suspends the scheduler without disabling interrupts. Context switches will not occur while the scheduler is suspended.</p> <p>After calling vTaskSuspendAll () the calling task will continue to execute without risk of being swapped out until a call to xTaskResumeAll () has been made.</p> <p>API functions that have the potential to cause a context switch (for example, vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler is suspended.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xCoRoutineCreate/","title":"Group xCoRoutineCreate","text":"<p>Modules &gt; xCoRoutineCreate</p> <p>More...</p>"},{"location":"apiStm/group__xCoRoutineCreate/#detailed-description","title":"Detailed Description","text":"<p>croutine. h </p> <p>Create a new co-routine and add it to the list of co-routines that are ready to run.</p> <p>Parameters:</p> <ul> <li><code>pxCoRoutineCode</code> Pointer to the co-routine function. Co-routine functions require special syntax - see the co-routine section of the WEB documentation for more information.</li> <li><code>uxPriority</code> The priority with respect to other co-routines at which the co-routine will run.</li> <li><code>uxIndex</code> Used to distinguish between different co-routines that execute the same function. See the example below and the co-routine section of the WEB documentation for further information.</li> </ul> <p>Returns:</p> <p>pdPASS if the co-routine was successfully created and added to a ready list, otherwise an error code defined with ProjDefs.h.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xMessageBufferCreate/","title":"Group xMessageBufferCreate","text":"<p>Modules &gt; xMessageBufferCreate</p> <p>More...</p>"},{"location":"apiStm/group__xMessageBufferCreate/#detailed-description","title":"Detailed Description","text":"<p>message_buffer.h</p> <p>Creates a new message buffer using dynamically allocated memory. See xMessageBufferCreateStatic() for a version that uses statically allocated memory (memory that is allocated at compile time).</p> <p>configSUPPORT_DYNAMIC_ALLOCATION must be set to 1 or left undefined in FreeRTOSConfig.h for xMessageBufferCreate() to be available.</p> <p>Parameters:</p> <ul> <li><code>xBufferSizeBytes</code> The total number of bytes (not messages) the message buffer will be able to hold at any one time. When a message is written to the message buffer an additional sizeof( size_t ) bytes are also written to store the message's length. sizeof( size_t ) is typically 4 bytes on a 32-bit architecture, so on most 32-bit architectures a 10 byte message will take up 14 bytes of message buffer space.</li> </ul> <p>Returns:</p> <p>If NULL is returned, then the message buffer cannot be created because there is insufficient heap memory available for FreeRTOS to allocate the message buffer data structures and storage area. A non-NULL value being returned indicates that the message buffer has been created successfully - the returned value should be stored as the handle to the created message buffer.</p> <p>Example use:  </p>"},{"location":"apiStm/group__xMessageBufferCreateStatic/","title":"Group xMessageBufferCreateStatic","text":"<p>Modules &gt; xMessageBufferCreateStatic</p> <p>More...</p>"},{"location":"apiStm/group__xMessageBufferCreateStatic/#detailed-description","title":"Detailed Description","text":"<p>message_buffer.h</p> <p>Creates a new message buffer using statically allocated memory. See xMessageBufferCreate() for a version that uses dynamically allocated memory.</p> <p>Parameters:</p> <ul> <li><code>xBufferSizeBytes</code> The size, in bytes, of the buffer pointed to by the pucMessageBufferStorageArea parameter. When a message is written to the message buffer an additional sizeof( size_t ) bytes are also written to store the message's length. sizeof( size_t ) is typically 4 bytes on a 32-bit architecture, so on most 32-bit architecture a 10 byte message will take up 14 bytes of message buffer space. The maximum number of bytes that can be stored in the message buffer is actually (xBufferSizeBytes - 1).</li> <li><code>pucMessageBufferStorageArea</code> Must point to a uint8_t array that is at least xBufferSizeBytes + 1 big. This is the array to which messages are copied when they are written to the message buffer.</li> <li><code>pxStaticMessageBuffer</code> Must point to a variable of type StaticMessageBuffer_t, which will be used to hold the message buffer's data structure.</li> </ul> <p>Returns:</p> <p>If the message buffer is created successfully then a handle to the created message buffer is returned. If either pucMessageBufferStorageArea or pxStaticmessageBuffer are NULL then NULL is returned.</p> <p>Example use:  </p>"},{"location":"apiStm/group__xMessageBufferNextLengthBytes/","title":"Group xMessageBufferNextLengthBytes","text":"<p>Modules &gt; xMessageBufferNextLengthBytes</p> <p>More...</p>"},{"location":"apiStm/group__xMessageBufferNextLengthBytes/#detailed-description","title":"Detailed Description","text":"<p>message_buffer.h  Returns the length (in bytes) of the next message in a message buffer. Useful if xMessageBufferReceive() returned 0 because the size of the buffer passed into xMessageBufferReceive() was too small to hold the next message.</p> <p>Parameters:</p> <ul> <li><code>xMessageBuffer</code> The handle of the message buffer being queried.</li> </ul> <p>Returns:</p> <p>The length (in bytes) of the next message in the message buffer, or 0 if the message buffer is empty. </p>"},{"location":"apiStm/group__xMessageBufferReceive/","title":"Group xMessageBufferReceive","text":"<p>Modules &gt; xMessageBufferReceive</p> <p>More...</p>"},{"location":"apiStm/group__xMessageBufferReceive/#detailed-description","title":"Detailed Description","text":"<p>message_buffer.h</p> <p>Receives a discrete message from a message buffer. Messages can be of variable length and are copied out of the buffer.</p> <p>NOTE: Uniquely among FreeRTOS objects, the stream buffer implementation (so also the message buffer implementation, as message buffers are built on top of stream buffers) assumes there is only one task or interrupt that will write to the buffer (the writer), and only one task or interrupt that will read from the buffer (the reader). It is safe for the writer and reader to be different tasks or interrupts, but, unlike other FreeRTOS objects, it is not safe to have multiple different writers or multiple different readers. If there are to be multiple different writers then the application writer must place each call to a writing API function (such as xMessageBufferSend()) inside a critical section and set the send block time to 0. Likewise, if there are to be multiple different readers then the application writer must place each call to a reading API function (such as xMessageBufferRead()) inside a critical section and set the receive block time to 0.</p> <p>Use xMessageBufferReceive() to read from a message buffer from a task. Use xMessageBufferReceiveFromISR() to read from a message buffer from an interrupt service routine (ISR).</p> <p>Parameters:</p> <ul> <li><code>xMessageBuffer</code> The handle of the message buffer from which a message is being received.</li> <li><code>pvRxData</code> A pointer to the buffer into which the received message is to be copied.</li> <li><code>xBufferLengthBytes</code> The length of the buffer pointed to by the pvRxData parameter. This sets the maximum length of the message that can be received. If xBufferLengthBytes is too small to hold the next message then the message will be left in the message buffer and 0 will be returned.</li> <li><code>xTicksToWait</code> The maximum amount of time the task should remain in the Blocked state to wait for a message, should the message buffer be empty. xMessageBufferReceive() will return immediately if xTicksToWait is zero and the message buffer is empty. The block time is specified in tick periods, so the absolute time it represents is dependent on the tick frequency. The macro pdMS_TO_TICKS() can be used to convert a time specified in milliseconds into a time specified in ticks. Setting xTicksToWait to portMAX_DELAY will cause the task to wait indefinitely (without timing out), provided INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h. Tasks do not use any CPU time when they are in the Blocked state.</li> </ul> <p>Returns:</p> <p>The length, in bytes, of the message read from the message buffer, if any. If xMessageBufferReceive() times out before a message became available then zero is returned. If the length of the message is greater than xBufferLengthBytes then the message will be left in the message buffer and zero is returned.</p> <p>Example use:  </p>"},{"location":"apiStm/group__xMessageBufferReceiveCompletedFromISR/","title":"Group xMessageBufferReceiveCompletedFromISR","text":"<p>Modules &gt; xMessageBufferReceiveCompletedFromISR</p> <p>More...</p>"},{"location":"apiStm/group__xMessageBufferReceiveCompletedFromISR/#detailed-description","title":"Detailed Description","text":"<p>message_buffer.h</p> <p>For advanced users only.</p> <p>The sbRECEIVE_COMPLETED() macro is called from within the FreeRTOS APIs when data is read out of a message buffer or stream buffer. If there was a task that was blocked on the message or stream buffer waiting for data to arrive then the sbRECEIVE_COMPLETED() macro sends a notification to the task to remove it from the Blocked state. xMessageBufferReceiveCompletedFromISR() does the same thing. It is provided to enable application writers to implement their own version of sbRECEIVE_COMPLETED(), and MUST NOT BE USED AT ANY OTHER TIME.</p> <p>See the example implemented in FreeRTOS/Demo/Minimal/MessageBufferAMP.c for additional information.</p> <p>Parameters:</p> <ul> <li><code>xStreamBuffer</code> The handle of the stream buffer from which data was read.</li> <li><code>pxHigherPriorityTaskWoken</code> *pxHigherPriorityTaskWoken should be initialised to pdFALSE before it is passed into xMessageBufferReceiveCompletedFromISR(). If calling xMessageBufferReceiveCompletedFromISR() removes a task from the Blocked state, and the task has a priority above the priority of the currently running task, then *pxHigherPriorityTaskWoken will get set to pdTRUE indicating that a context switch should be performed before exiting the ISR.</li> </ul> <p>Returns:</p> <p>If a task was removed from the Blocked state then pdTRUE is returned. Otherwise pdFALSE is returned. </p>"},{"location":"apiStm/group__xMessageBufferReceiveFromISR/","title":"Group xMessageBufferReceiveFromISR","text":"<p>Modules &gt; xMessageBufferReceiveFromISR</p> <p>More...</p>"},{"location":"apiStm/group__xMessageBufferReceiveFromISR/#detailed-description","title":"Detailed Description","text":"<p>message_buffer.h</p> <p>An interrupt safe version of the API function that receives a discrete message from a message buffer. Messages can be of variable length and are copied out of the buffer.</p> <p>NOTE: Uniquely among FreeRTOS objects, the stream buffer implementation (so also the message buffer implementation, as message buffers are built on top of stream buffers) assumes there is only one task or interrupt that will write to the buffer (the writer), and only one task or interrupt that will read from the buffer (the reader). It is safe for the writer and reader to be different tasks or interrupts, but, unlike other FreeRTOS objects, it is not safe to have multiple different writers or multiple different readers. If there are to be multiple different writers then the application writer must place each call to a writing API function (such as xMessageBufferSend()) inside a critical section and set the send block time to 0. Likewise, if there are to be multiple different readers then the application writer must place each call to a reading API function (such as xMessageBufferRead()) inside a critical section and set the receive block time to 0.</p> <p>Use xMessageBufferReceive() to read from a message buffer from a task. Use xMessageBufferReceiveFromISR() to read from a message buffer from an interrupt service routine (ISR).</p> <p>Parameters:</p> <ul> <li><code>xMessageBuffer</code> The handle of the message buffer from which a message is being received.</li> <li><code>pvRxData</code> A pointer to the buffer into which the received message is to be copied.</li> <li><code>xBufferLengthBytes</code> The length of the buffer pointed to by the pvRxData parameter. This sets the maximum length of the message that can be received. If xBufferLengthBytes is too small to hold the next message then the message will be left in the message buffer and 0 will be returned.</li> <li><code>pxHigherPriorityTaskWoken</code> It is possible that a message buffer will have a task blocked on it waiting for space to become available. Calling xMessageBufferReceiveFromISR() can make space available, and so cause a task that is waiting for space to leave the Blocked state. If calling xMessageBufferReceiveFromISR() causes a task to leave the Blocked state, and the unblocked task has a priority higher than the currently executing task (the task that was interrupted), then, internally, xMessageBufferReceiveFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE. If xMessageBufferReceiveFromISR() sets this value to pdTRUE, then normally a context switch should be performed before the interrupt is exited. That will ensure the interrupt returns directly to the highest priority Ready state task. *pxHigherPriorityTaskWoken should be set to pdFALSE before it is passed into the function. See the code example below for an example.</li> </ul> <p>Returns:</p> <p>The length, in bytes, of the message read from the message buffer, if any.</p> <p>Example use:  </p>"},{"location":"apiStm/group__xMessageBufferReset/","title":"Group xMessageBufferReset","text":"<p>Modules &gt; xMessageBufferReset</p> <p>More...</p>"},{"location":"apiStm/group__xMessageBufferReset/#detailed-description","title":"Detailed Description","text":"<p>message_buffer.h </p> <p>Resets a message buffer to its initial empty state, discarding any message it contained.</p> <p>A message buffer can only be reset if there are no tasks blocked on it.</p> <p>Parameters:</p> <ul> <li><code>xMessageBuffer</code> The handle of the message buffer being reset.</li> </ul> <p>Returns:</p> <p>If the message buffer was reset then pdPASS is returned. If the message buffer could not be reset because either there was a task blocked on the message queue to wait for space to become available, or to wait for a a message to be available, then pdFAIL is returned. </p>"},{"location":"apiStm/group__xMessageBufferSend/","title":"Group xMessageBufferSend","text":"<p>Modules &gt; xMessageBufferSend</p> <p>More...</p>"},{"location":"apiStm/group__xMessageBufferSend/#detailed-description","title":"Detailed Description","text":"<p>message_buffer.h</p>"},{"location":"apiStm/group__xMessageBufferSendCompletedFromISR/","title":"Group xMessageBufferSendCompletedFromISR","text":"<p>Modules &gt; xMessageBufferSendCompletedFromISR</p> <p>More...</p>"},{"location":"apiStm/group__xMessageBufferSendCompletedFromISR/#detailed-description","title":"Detailed Description","text":"<p>message_buffer.h</p> <p>For advanced users only.</p> <p>The sbSEND_COMPLETED() macro is called from within the FreeRTOS APIs when data is sent to a message buffer or stream buffer. If there was a task that was blocked on the message or stream buffer waiting for data to arrive then the sbSEND_COMPLETED() macro sends a notification to the task to remove it from the Blocked state. xMessageBufferSendCompletedFromISR() does the same thing. It is provided to enable application writers to implement their own version of sbSEND_COMPLETED(), and MUST NOT BE USED AT ANY OTHER TIME.</p> <p>See the example implemented in FreeRTOS/Demo/Minimal/MessageBufferAMP.c for additional information.</p> <p>Parameters:</p> <ul> <li><code>xStreamBuffer</code> The handle of the stream buffer to which data was written.</li> <li><code>pxHigherPriorityTaskWoken</code> *pxHigherPriorityTaskWoken should be initialised to pdFALSE before it is passed into xMessageBufferSendCompletedFromISR(). If calling xMessageBufferSendCompletedFromISR() removes a task from the Blocked state, and the task has a priority above the priority of the currently running task, then *pxHigherPriorityTaskWoken will get set to pdTRUE indicating that a context switch should be performed before exiting the ISR.</li> </ul> <p>Returns:</p> <p>If a task was removed from the Blocked state then pdTRUE is returned. Otherwise pdFALSE is returned. </p>"},{"location":"apiStm/group__xMessageBufferSendFromISR/","title":"Group xMessageBufferSendFromISR","text":"<p>Modules &gt; xMessageBufferSendFromISR</p> <p>More...</p>"},{"location":"apiStm/group__xMessageBufferSendFromISR/#detailed-description","title":"Detailed Description","text":"<p>message_buffer.h</p>"},{"location":"apiStm/group__xMessageBufferSpaceAvailable/","title":"Group xMessageBufferSpaceAvailable","text":"<p>Modules &gt; xMessageBufferSpaceAvailable</p> <p>More...</p>"},{"location":"apiStm/group__xMessageBufferSpaceAvailable/#detailed-description","title":"Detailed Description","text":"<p>message_buffer.h  Returns the number of bytes of free space in the message buffer.</p> <p>Parameters:</p> <ul> <li><code>xMessageBuffer</code> The handle of the message buffer being queried.</li> </ul> <p>Returns:</p> <p>The number of bytes that can be written to the message buffer before the message buffer would be full. When a message is written to the message buffer an additional sizeof( size_t ) bytes are also written to store the message's length. sizeof( size_t ) is typically 4 bytes on a 32-bit architecture, so if xMessageBufferSpacesAvailable() returns 10, then the size of the largest message that can be written to the message buffer is 6 bytes. </p>"},{"location":"apiStm/group__xQueueCreate/","title":"Group xQueueCreate","text":"<p>Modules &gt; xQueueCreate</p> <p>More...</p>"},{"location":"apiStm/group__xQueueCreate/#detailed-description","title":"Detailed Description","text":"<p>queue. h </p> <p>Creates a new queue instance, and returns a handle by which the new queue can be referenced.</p> <p>Internally, within the FreeRTOS implementation, queues use two blocks of memory. The first block is used to hold the queue's data structures. The second block is used to hold items placed into the queue. If a queue is created using xQueueCreate() then both blocks of memory are automatically dynamically allocated inside the xQueueCreate() function. (see http://www.freertos.org/a00111.html). If a queue is created using xQueueCreateStatic() then the application writer must provide the memory that will get used by the queue. xQueueCreateStatic() therefore allows a queue to be created without using any dynamic memory allocation.</p> <p>http://www.FreeRTOS.org/Embedded-RTOS-Queues.html</p> <p>Parameters:</p> <ul> <li><code>uxQueueLength</code> The maximum number of items that the queue can contain.</li> <li><code>uxItemSize</code> The number of bytes each item in the queue will require. Items are queued by copy, not by reference, so this is the number of bytes that will be copied for each posted item. Each item on the queue must be the same size.</li> </ul> <p>Returns:</p> <p>If the queue is successfully create then a handle to the newly created queue is returned. If the queue cannot be created then 0 is returned.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xQueueCreateStatic/","title":"Group xQueueCreateStatic","text":"<p>Modules &gt; xQueueCreateStatic</p> <p>More...</p>"},{"location":"apiStm/group__xQueueCreateStatic/#detailed-description","title":"Detailed Description","text":"<p>queue. h </p> <p>Creates a new queue instance, and returns a handle by which the new queue can be referenced.</p> <p>Internally, within the FreeRTOS implementation, queues use two blocks of memory. The first block is used to hold the queue's data structures. The second block is used to hold items placed into the queue. If a queue is created using xQueueCreate() then both blocks of memory are automatically dynamically allocated inside the xQueueCreate() function. (see http://www.freertos.org/a00111.html). If a queue is created using xQueueCreateStatic() then the application writer must provide the memory that will get used by the queue. xQueueCreateStatic() therefore allows a queue to be created without using any dynamic memory allocation.</p> <p>http://www.FreeRTOS.org/Embedded-RTOS-Queues.html</p> <p>Parameters:</p> <ul> <li><code>uxQueueLength</code> The maximum number of items that the queue can contain.</li> <li><code>uxItemSize</code> The number of bytes each item in the queue will require. Items are queued by copy, not by reference, so this is the number of bytes that will be copied for each posted item. Each item on the queue must be the same size.</li> <li><code>pucQueueStorageBuffer</code> If uxItemSize is not zero then pucQueueStorageBuffer must point to a uint8_t array that is at least large enough to hold the maximum number of items that can be in the queue at any one time - which is ( uxQueueLength * uxItemsSize ) bytes. If uxItemSize is zero then pucQueueStorageBuffer can be NULL.</li> <li><code>pxQueueBuffer</code> Must point to a variable of type StaticQueue_t, which will be used to hold the queue's data structure.</li> </ul> <p>Returns:</p> <p>If the queue is created then a handle to the created queue is returned. If pxQueueBuffer is NULL then NULL is returned.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xQueueOverwrite/","title":"Group xQueueOverwrite","text":"<p>Modules &gt; xQueueOverwrite</p> <p>More...</p>"},{"location":"apiStm/group__xQueueOverwrite/#detailed-description","title":"Detailed Description","text":"<p>queue. h </p> <p>Only for use with queues that have a length of one - so the queue is either empty or full.</p> <p>Post an item on a queue. If the queue is already full then overwrite the value held in the queue. The item is queued by copy, not by reference.</p> <p>This function must not be called from an interrupt service routine. See xQueueOverwriteFromISR () for an alternative which may be used in an ISR.</p> <p>Parameters:</p> <ul> <li><code>xQueue</code> The handle of the queue to which the data is being sent.</li> <li><code>pvItemToQueue</code> A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</li> </ul> <p>Returns:</p> <p>xQueueOverwrite() is a macro that calls xQueueGenericSend(), and therefore has the same return values as xQueueSendToFront(). However, pdPASS is the only value that can be returned because xQueueOverwrite() will write to the queue even when the queue is already full.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xQueueOverwriteFromISR/","title":"Group xQueueOverwriteFromISR","text":"<p>Modules &gt; xQueueOverwriteFromISR</p> <p>More...</p>"},{"location":"apiStm/group__xQueueOverwriteFromISR/#detailed-description","title":"Detailed Description","text":"<p>queue. h </p> <p>A version of xQueueOverwrite() that can be used in an interrupt service routine (ISR).</p> <p>Only for use with queues that can hold a single item - so the queue is either empty or full.</p> <p>Post an item on a queue. If the queue is already full then overwrite the value held in the queue. The item is queued by copy, not by reference.</p> <p>Parameters:</p> <ul> <li><code>xQueue</code> The handle to the queue on which the item is to be posted.</li> <li><code>pvItemToQueue</code> A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</li> <li><code>pxHigherPriorityTaskWoken</code> xQueueOverwriteFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueOverwriteFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</li> </ul> <p>Returns:</p> <p>xQueueOverwriteFromISR() is a macro that calls xQueueGenericSendFromISR(), and therefore has the same return values as xQueueSendToFrontFromISR(). However, pdPASS is the only value that can be returned because xQueueOverwriteFromISR() will write to the queue even when the queue is already full.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xQueuePeek/","title":"Group xQueuePeek","text":"<p>Modules &gt; xQueuePeek</p> <p>More...</p>"},{"location":"apiStm/group__xQueuePeek/#detailed-description","title":"Detailed Description","text":"<p>queue. h </p> <p>Receive an item from a queue without removing the item from the queue. The item is received by copy so a buffer of adequate size must be provided. The number of bytes copied into the buffer was defined when the queue was created.</p> <p>Successfully received items remain on the queue so will be returned again by the next call, or a call to xQueueReceive().</p> <p>This macro must not be used in an interrupt service routine. See xQueuePeekFromISR() for an alternative that can be called from an interrupt service routine.</p> <p>Parameters:</p> <ul> <li><code>xQueue</code> The handle to the queue from which the item is to be received.</li> <li><code>pvBuffer</code> Pointer to the buffer into which the received item will be copied.</li> <li><code>xTicksToWait</code> The maximum amount of time the task should block waiting for an item to receive should the queue be empty at the time of the call. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required. xQueuePeek() will return immediately if xTicksToWait is 0 and the queue is empty.</li> </ul> <p>Returns:</p> <p>pdTRUE if an item was successfully received from the queue, otherwise pdFALSE.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xQueuePeekFromISR/","title":"Group xQueuePeekFromISR","text":"<p>Modules &gt; xQueuePeekFromISR</p> <p>More...</p>"},{"location":"apiStm/group__xQueuePeekFromISR/#detailed-description","title":"Detailed Description","text":"<p>queue. h </p> <p>A version of xQueuePeek() that can be called from an interrupt service routine (ISR).</p> <p>Receive an item from a queue without removing the item from the queue. The item is received by copy so a buffer of adequate size must be provided. The number of bytes copied into the buffer was defined when the queue was created.</p> <p>Successfully received items remain on the queue so will be returned again by the next call, or a call to xQueueReceive().</p> <p>Parameters:</p> <ul> <li><code>xQueue</code> The handle to the queue from which the item is to be received.</li> <li><code>pvBuffer</code> Pointer to the buffer into which the received item will be copied.</li> </ul> <p>Returns:</p> <p>pdTRUE if an item was successfully received from the queue, otherwise pdFALSE. </p>"},{"location":"apiStm/group__xQueueReceive/","title":"Group xQueueReceive","text":"<p>Modules &gt; xQueueReceive</p> <p>More...</p>"},{"location":"apiStm/group__xQueueReceive/#detailed-description","title":"Detailed Description","text":"<p>queue. h </p> <p>Receive an item from a queue. The item is received by copy so a buffer of adequate size must be provided. The number of bytes copied into the buffer was defined when the queue was created.</p> <p>Successfully received items are removed from the queue.</p> <p>This function must not be used in an interrupt service routine. See xQueueReceiveFromISR for an alternative that can.</p> <p>Parameters:</p> <ul> <li><code>xQueue</code> The handle to the queue from which the item is to be received.</li> <li><code>pvBuffer</code> Pointer to the buffer into which the received item will be copied.</li> <li><code>xTicksToWait</code> The maximum amount of time the task should block waiting for an item to receive should the queue be empty at the time of the call. xQueueReceive() will return immediately if xTicksToWait is zero and the queue is empty. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required.</li> </ul> <p>Returns:</p> <p>pdTRUE if an item was successfully received from the queue, otherwise pdFALSE.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xQueueReceiveFromISR/","title":"Group xQueueReceiveFromISR","text":"<p>Modules &gt; xQueueReceiveFromISR</p> <p>More...</p>"},{"location":"apiStm/group__xQueueReceiveFromISR/#detailed-description","title":"Detailed Description","text":"<p>queue. h </p> <p>Receive an item from a queue. It is safe to use this function from within an interrupt service routine.</p> <p>Parameters:</p> <ul> <li><code>xQueue</code> The handle to the queue from which the item is to be received.</li> <li><code>pvBuffer</code> Pointer to the buffer into which the received item will be copied.</li> <li><code>pxTaskWoken</code> A task may be blocked waiting for space to become available on the queue. If xQueueReceiveFromISR causes such a task to unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will remain unchanged.</li> </ul> <p>Returns:</p> <p>pdTRUE if an item was successfully received from the queue, otherwise pdFALSE.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xQueueSend/","title":"Group xQueueSend","text":"<p>Modules &gt; xQueueSend</p> <p>More...</p>"},{"location":"apiStm/group__xQueueSend/#detailed-description","title":"Detailed Description","text":"<p>queue. h </p> <p>Post an item to the front of a queue. The item is queued by copy, not by reference. This function must not be called from an interrupt service routine. See xQueueSendFromISR () for an alternative which may be used in an ISR.</p> <p>Parameters:</p> <ul> <li><code>xQueue</code> The handle to the queue on which the item is to be posted.</li> <li><code>pvItemToQueue</code> A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</li> <li><code>xTicksToWait</code> The maximum amount of time the task should block waiting for space to become available on the queue, should it already be full. The call will return immediately if this is set to 0 and the queue is full. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required.</li> </ul> <p>Returns:</p> <p>pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.</p> <p>Example usage: </p> <p>queue. h </p> <p>This is a macro that calls xQueueGenericSend().</p> <p>Post an item to the back of a queue. The item is queued by copy, not by reference. This function must not be called from an interrupt service routine. See xQueueSendFromISR () for an alternative which may be used in an ISR.</p> <p>Parameters:</p> <ul> <li><code>xQueue</code> The handle to the queue on which the item is to be posted.</li> <li><code>pvItemToQueue</code> A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</li> <li><code>xTicksToWait</code> The maximum amount of time the task should block waiting for space to become available on the queue, should it already be full. The call will return immediately if this is set to 0 and the queue is full. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required.</li> </ul> <p>Returns:</p> <p>pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.</p> <p>Example usage: </p> <p>queue. h </p> <p>This is a macro that calls xQueueGenericSend(). It is included for backward compatibility with versions of FreeRTOS.org that did not include the xQueueSendToFront() and xQueueSendToBack() macros. It is equivalent to xQueueSendToBack().</p> <p>Post an item on a queue. The item is queued by copy, not by reference. This function must not be called from an interrupt service routine. See xQueueSendFromISR () for an alternative which may be used in an ISR.</p> <p>Parameters:</p> <ul> <li><code>xQueue</code> The handle to the queue on which the item is to be posted.</li> <li><code>pvItemToQueue</code> A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</li> <li><code>xTicksToWait</code> The maximum amount of time the task should block waiting for space to become available on the queue, should it already be full. The call will return immediately if this is set to 0 and the queue is full. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required.</li> </ul> <p>Returns:</p> <p>pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.</p> <p>Example usage: </p> <p>queue. h </p> <p>It is preferred that the macros xQueueSend(), xQueueSendToFront() and xQueueSendToBack() are used in place of calling this function directly.</p> <p>Post an item on a queue. The item is queued by copy, not by reference. This function must not be called from an interrupt service routine. See xQueueSendFromISR () for an alternative which may be used in an ISR.</p> <p>Parameters:</p> <ul> <li><code>xQueue</code> The handle to the queue on which the item is to be posted.</li> <li><code>pvItemToQueue</code> A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</li> <li><code>xTicksToWait</code> The maximum amount of time the task should block waiting for space to become available on the queue, should it already be full. The call will return immediately if this is set to 0 and the queue is full. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required.</li> <li><code>xCopyPosition</code> Can take the value queueSEND_TO_BACK to place the item at the back of the queue, or queueSEND_TO_FRONT to place the item at the front of the queue (for high priority messages).</li> </ul> <p>Returns:</p> <p>pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xQueueSendFromISR/","title":"Group xQueueSendFromISR","text":"<p>Modules &gt; xQueueSendFromISR</p> <p>More...</p>"},{"location":"apiStm/group__xQueueSendFromISR/#detailed-description","title":"Detailed Description","text":"<p>queue. h </p> <p>This is a macro that calls xQueueGenericSendFromISR().</p> <p>Post an item to the front of a queue. It is safe to use this macro from within an interrupt service routine.</p> <p>Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued.</p> <p>Parameters:</p> <ul> <li><code>xQueue</code> The handle to the queue on which the item is to be posted.</li> <li><code>pvItemToQueue</code> A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</li> <li><code>pxHigherPriorityTaskWoken</code> xQueueSendToFrontFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueSendToFromFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</li> </ul> <p>Returns:</p> <p>pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.</p> <p>Example usage for buffered IO (where the ISR can obtain more than one value per call): </p> <p>queue. h </p> <p>This is a macro that calls xQueueGenericSendFromISR().</p> <p>Post an item to the back of a queue. It is safe to use this macro from within an interrupt service routine.</p> <p>Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued.</p> <p>Parameters:</p> <ul> <li><code>xQueue</code> The handle to the queue on which the item is to be posted.</li> <li><code>pvItemToQueue</code> A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</li> <li><code>pxHigherPriorityTaskWoken</code> xQueueSendToBackFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueSendToBackFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</li> </ul> <p>Returns:</p> <p>pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.</p> <p>Example usage for buffered IO (where the ISR can obtain more than one value per call): </p> <p>queue. h </p> <p>This is a macro that calls xQueueGenericSendFromISR(). It is included for backward compatibility with versions of FreeRTOS.org that did not include the xQueueSendToBackFromISR() and xQueueSendToFrontFromISR() macros.</p> <p>Post an item to the back of a queue. It is safe to use this function from within an interrupt service routine.</p> <p>Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued.</p> <p>Parameters:</p> <ul> <li><code>xQueue</code> The handle to the queue on which the item is to be posted.</li> <li><code>pvItemToQueue</code> A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</li> <li><code>pxHigherPriorityTaskWoken</code> xQueueSendFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueSendFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</li> </ul> <p>Returns:</p> <p>pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.</p> <p>Example usage for buffered IO (where the ISR can obtain more than one value per call): </p> <p>queue. h </p> <p>It is preferred that the macros xQueueSendFromISR(), xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() be used in place of calling this function directly. xQueueGiveFromISR() is an equivalent for use by semaphores that don't actually copy any data.</p> <p>Post an item on a queue. It is safe to use this function from within an interrupt service routine.</p> <p>Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued.</p> <p>Parameters:</p> <ul> <li><code>xQueue</code> The handle to the queue on which the item is to be posted.</li> <li><code>pvItemToQueue</code> A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</li> <li><code>pxHigherPriorityTaskWoken</code> xQueueGenericSendFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueGenericSendFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</li> <li><code>xCopyPosition</code> Can take the value queueSEND_TO_BACK to place the item at the back of the queue, or queueSEND_TO_FRONT to place the item at the front of the queue (for high priority messages).</li> </ul> <p>Returns:</p> <p>pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.</p> <p>Example usage for buffered IO (where the ISR can obtain more than one value per call):  </p>"},{"location":"apiStm/group__xSemaphoreCreateBinary/","title":"Group xSemaphoreCreateBinary","text":"<p>Modules &gt; xSemaphoreCreateBinary</p> <p>More...</p>"},{"location":"apiStm/group__xSemaphoreCreateBinary/#detailed-description","title":"Detailed Description","text":"<p>semphr. h </p> <p>Creates a new binary semaphore instance, and returns a handle by which the new semaphore can be referenced.</p> <p>In many usage scenarios it is faster and more memory efficient to use a direct to task notification in place of a binary semaphore! http://www.freertos.org/RTOS-task-notifications.html</p> <p>Internally, within the FreeRTOS implementation, binary semaphores use a block of memory, in which the semaphore structure is stored. If a binary semaphore is created using xSemaphoreCreateBinary() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateBinary() function. (see http://www.freertos.org/a00111.html). If a binary semaphore is created using xSemaphoreCreateBinaryStatic() then the application writer must provide the memory. xSemaphoreCreateBinaryStatic() therefore allows a binary semaphore to be created without using any dynamic memory allocation.</p> <p>The old vSemaphoreCreateBinary() macro is now deprecated in favour of this xSemaphoreCreateBinary() function. Note that binary semaphores created using the vSemaphoreCreateBinary() macro are created in a state such that the first call to 'take' the semaphore would pass, whereas binary semaphores created using xSemaphoreCreateBinary() are created in a state such that the the semaphore must first be 'given' before it can be 'taken'.</p> <p>This type of semaphore can be used for pure synchronisation between tasks or between an interrupt and a task. The semaphore need not be given back once obtained, so one task/interrupt can continuously 'give' the semaphore while another continuously 'takes' the semaphore. For this reason this type of semaphore does not use a priority inheritance mechanism. For an alternative that does use priority inheritance see xSemaphoreCreateMutex().</p> <p>Returns:</p> <p>Handle to the created semaphore, or NULL if the memory required to hold the semaphore's data structures could not be allocated.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xSemaphoreCreateBinaryStatic/","title":"Group xSemaphoreCreateBinaryStatic","text":"<p>Modules &gt; xSemaphoreCreateBinaryStatic</p> <p>More...</p>"},{"location":"apiStm/group__xSemaphoreCreateBinaryStatic/#detailed-description","title":"Detailed Description","text":"<p>semphr. h </p> <p>Creates a new binary semaphore instance, and returns a handle by which the new semaphore can be referenced.</p> <p>NOTE: In many usage scenarios it is faster and more memory efficient to use a direct to task notification in place of a binary semaphore! http://www.freertos.org/RTOS-task-notifications.html</p> <p>Internally, within the FreeRTOS implementation, binary semaphores use a block of memory, in which the semaphore structure is stored. If a binary semaphore is created using xSemaphoreCreateBinary() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateBinary() function. (see http://www.freertos.org/a00111.html). If a binary semaphore is created using xSemaphoreCreateBinaryStatic() then the application writer must provide the memory. xSemaphoreCreateBinaryStatic() therefore allows a binary semaphore to be created without using any dynamic memory allocation.</p> <p>This type of semaphore can be used for pure synchronisation between tasks or between an interrupt and a task. The semaphore need not be given back once obtained, so one task/interrupt can continuously 'give' the semaphore while another continuously 'takes' the semaphore. For this reason this type of semaphore does not use a priority inheritance mechanism. For an alternative that does use priority inheritance see xSemaphoreCreateMutex().</p> <p>Parameters:</p> <ul> <li><code>pxSemaphoreBuffer</code> Must point to a variable of type StaticSemaphore_t, which will then be used to hold the semaphore's data structure, removing the need for the memory to be allocated dynamically.</li> </ul> <p>Returns:</p> <p>If the semaphore is created then a handle to the created semaphore is returned. If pxSemaphoreBuffer is NULL then NULL is returned.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xSemaphoreCreateCounting/","title":"Group xSemaphoreCreateCounting","text":"<p>Modules &gt; xSemaphoreCreateCounting</p> <p>More...</p>"},{"location":"apiStm/group__xSemaphoreCreateCounting/#detailed-description","title":"Detailed Description","text":"<p>semphr. h </p> <p>Creates a new counting semaphore instance, and returns a handle by which the new counting semaphore can be referenced.</p> <p>In many usage scenarios it is faster and more memory efficient to use a direct to task notification in place of a counting semaphore! http://www.freertos.org/RTOS-task-notifications.html</p> <p>Internally, within the FreeRTOS implementation, counting semaphores use a block of memory, in which the counting semaphore structure is stored. If a counting semaphore is created using xSemaphoreCreateCounting() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateCounting() function. (see http://www.freertos.org/a00111.html). If a counting semaphore is created using xSemaphoreCreateCountingStatic() then the application writer can instead optionally provide the memory that will get used by the counting semaphore. xSemaphoreCreateCountingStatic() therefore allows a counting semaphore to be created without using any dynamic memory allocation.</p> <p>Counting semaphores are typically used for two things:</p> <p>1) Counting events.</p> <p>In this usage scenario an event handler will 'give' a semaphore each time an event occurs (incrementing the semaphore count value), and a handler task will 'take' a semaphore each time it processes an event (decrementing the semaphore count value). The count value is therefore the difference between the number of events that have occurred and the number that have been processed. In this case it is desirable for the initial count value to be zero.</p> <p>2) Resource management.</p> <p>In this usage scenario the count value indicates the number of resources available. To obtain control of a resource a task must first obtain a semaphore - decrementing the semaphore count value. When the count value reaches zero there are no free resources. When a task finishes with the resource it 'gives' the semaphore back - incrementing the semaphore count value. In this case it is desirable for the initial count value to be equal to the maximum count value, indicating that all resources are free.</p> <p>Parameters:</p> <ul> <li><code>uxMaxCount</code> The maximum count value that can be reached. When the semaphore reaches this value it can no longer be 'given'.</li> <li><code>uxInitialCount</code> The count value assigned to the semaphore when it is created.</li> </ul> <p>Returns:</p> <p>Handle to the created semaphore. Null if the semaphore could not be created.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xSemaphoreCreateCountingStatic/","title":"Group xSemaphoreCreateCountingStatic","text":"<p>Modules &gt; xSemaphoreCreateCountingStatic</p> <p>More...</p>"},{"location":"apiStm/group__xSemaphoreCreateCountingStatic/#detailed-description","title":"Detailed Description","text":"<p>semphr. h </p> <p>Creates a new counting semaphore instance, and returns a handle by which the new counting semaphore can be referenced.</p> <p>In many usage scenarios it is faster and more memory efficient to use a direct to task notification in place of a counting semaphore! http://www.freertos.org/RTOS-task-notifications.html</p> <p>Internally, within the FreeRTOS implementation, counting semaphores use a block of memory, in which the counting semaphore structure is stored. If a counting semaphore is created using xSemaphoreCreateCounting() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateCounting() function. (see http://www.freertos.org/a00111.html). If a counting semaphore is created using xSemaphoreCreateCountingStatic() then the application writer must provide the memory. xSemaphoreCreateCountingStatic() therefore allows a counting semaphore to be created without using any dynamic memory allocation.</p> <p>Counting semaphores are typically used for two things:</p> <p>1) Counting events.</p> <p>In this usage scenario an event handler will 'give' a semaphore each time an event occurs (incrementing the semaphore count value), and a handler task will 'take' a semaphore each time it processes an event (decrementing the semaphore count value). The count value is therefore the difference between the number of events that have occurred and the number that have been processed. In this case it is desirable for the initial count value to be zero.</p> <p>2) Resource management.</p> <p>In this usage scenario the count value indicates the number of resources available. To obtain control of a resource a task must first obtain a semaphore - decrementing the semaphore count value. When the count value reaches zero there are no free resources. When a task finishes with the resource it 'gives' the semaphore back - incrementing the semaphore count value. In this case it is desirable for the initial count value to be equal to the maximum count value, indicating that all resources are free.</p> <p>Parameters:</p> <ul> <li><code>uxMaxCount</code> The maximum count value that can be reached. When the semaphore reaches this value it can no longer be 'given'.</li> <li><code>uxInitialCount</code> The count value assigned to the semaphore when it is created.</li> <li><code>pxSemaphoreBuffer</code> Must point to a variable of type StaticSemaphore_t, which will then be used to hold the semaphore's data structure, removing the need for the memory to be allocated dynamically.</li> </ul> <p>Returns:</p> <p>If the counting semaphore was successfully created then a handle to the created counting semaphore is returned. If pxSemaphoreBuffer was NULL then NULL is returned.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xSemaphoreCreateMutex/","title":"Group xSemaphoreCreateMutex","text":"<p>Modules &gt; xSemaphoreCreateMutex</p> <p>More...</p>"},{"location":"apiStm/group__xSemaphoreCreateMutex/#detailed-description","title":"Detailed Description","text":"<p>semphr. h </p> <p>Creates a new mutex type semaphore instance, and returns a handle by which the new mutex can be referenced.</p> <p>Internally, within the FreeRTOS implementation, mutex semaphores use a block of memory, in which the mutex structure is stored. If a mutex is created using xSemaphoreCreateMutex() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateMutex() function. (see http://www.freertos.org/a00111.html). If a mutex is created using xSemaphoreCreateMutexStatic() then the application writer must provided the memory. xSemaphoreCreateMutexStatic() therefore allows a mutex to be created without using any dynamic memory allocation.</p> <p>Mutexes created using this function can be accessed using the xSemaphoreTake() and xSemaphoreGive() macros. The xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros must not be used.</p> <p>This type of semaphore uses a priority inheritance mechanism so a task 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the semaphore it is no longer required.</p> <p>Mutex type semaphores cannot be used from within interrupt service routines.</p> <p>See xSemaphoreCreateBinary() for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always 'gives' the semaphore and another always 'takes' the semaphore) and from within interrupt service routines.</p> <p>Returns:</p> <p>If the mutex was successfully created then a handle to the created semaphore is returned. If there was not enough heap to allocate the mutex data structures then NULL is returned.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xSemaphoreCreateMutexStatic/","title":"Group xSemaphoreCreateMutexStatic","text":"<p>Modules &gt; xSemaphoreCreateMutexStatic</p> <p>More...</p>"},{"location":"apiStm/group__xSemaphoreCreateMutexStatic/#detailed-description","title":"Detailed Description","text":"<p>semphr. h </p> <p>Creates a new mutex type semaphore instance, and returns a handle by which the new mutex can be referenced.</p> <p>Internally, within the FreeRTOS implementation, mutex semaphores use a block of memory, in which the mutex structure is stored. If a mutex is created using xSemaphoreCreateMutex() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateMutex() function. (see http://www.freertos.org/a00111.html). If a mutex is created using xSemaphoreCreateMutexStatic() then the application writer must provided the memory. xSemaphoreCreateMutexStatic() therefore allows a mutex to be created without using any dynamic memory allocation.</p> <p>Mutexes created using this function can be accessed using the xSemaphoreTake() and xSemaphoreGive() macros. The xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros must not be used.</p> <p>This type of semaphore uses a priority inheritance mechanism so a task 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the semaphore it is no longer required.</p> <p>Mutex type semaphores cannot be used from within interrupt service routines.</p> <p>See xSemaphoreCreateBinary() for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always 'gives' the semaphore and another always 'takes' the semaphore) and from within interrupt service routines.</p> <p>Parameters:</p> <ul> <li><code>pxMutexBuffer</code> Must point to a variable of type StaticSemaphore_t, which will be used to hold the mutex's data structure, removing the need for the memory to be allocated dynamically.</li> </ul> <p>Returns:</p> <p>If the mutex was successfully created then a handle to the created mutex is returned. If pxMutexBuffer was NULL then NULL is returned.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xSemaphoreCreateRecursiveMutex/","title":"Group xSemaphoreCreateRecursiveMutex","text":"<p>Modules &gt; xSemaphoreCreateRecursiveMutex</p> <p>More...</p>"},{"location":"apiStm/group__xSemaphoreCreateRecursiveMutex/#detailed-description","title":"Detailed Description","text":"<p>semphr. h </p> <p>Creates a new recursive mutex type semaphore instance, and returns a handle by which the new recursive mutex can be referenced.</p> <p>Internally, within the FreeRTOS implementation, recursive mutexs use a block of memory, in which the mutex structure is stored. If a recursive mutex is created using xSemaphoreCreateRecursiveMutex() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateRecursiveMutex() function. (see http://www.freertos.org/a00111.html). If a recursive mutex is created using xSemaphoreCreateRecursiveMutexStatic() then the application writer must provide the memory that will get used by the mutex. xSemaphoreCreateRecursiveMutexStatic() therefore allows a recursive mutex to be created without using any dynamic memory allocation.</p> <p>Mutexes created using this macro can be accessed using the xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros. The xSemaphoreTake() and xSemaphoreGive() macros must not be used.</p> <p>A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each successful 'take' request. For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also 'given' the mutex back exactly five times.</p> <p>This type of semaphore uses a priority inheritance mechanism so a task 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the semaphore it is no longer required.</p> <p>Mutex type semaphores cannot be used from within interrupt service routines.</p> <p>See xSemaphoreCreateBinary() for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always 'gives' the semaphore and another always 'takes' the semaphore) and from within interrupt service routines.</p> <p>Returns:</p> <p>xSemaphore Handle to the created mutex semaphore. Should be of type SemaphoreHandle_t.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xSemaphoreCreateRecursiveMutexStatic/","title":"Group xSemaphoreCreateRecursiveMutexStatic","text":"<p>Modules &gt; xSemaphoreCreateRecursiveMutexStatic</p> <p>More...</p>"},{"location":"apiStm/group__xSemaphoreCreateRecursiveMutexStatic/#detailed-description","title":"Detailed Description","text":"<p>semphr. h </p> <p>Creates a new recursive mutex type semaphore instance, and returns a handle by which the new recursive mutex can be referenced.</p> <p>Internally, within the FreeRTOS implementation, recursive mutexs use a block of memory, in which the mutex structure is stored. If a recursive mutex is created using xSemaphoreCreateRecursiveMutex() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateRecursiveMutex() function. (see http://www.freertos.org/a00111.html). If a recursive mutex is created using xSemaphoreCreateRecursiveMutexStatic() then the application writer must provide the memory that will get used by the mutex. xSemaphoreCreateRecursiveMutexStatic() therefore allows a recursive mutex to be created without using any dynamic memory allocation.</p> <p>Mutexes created using this macro can be accessed using the xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros. The xSemaphoreTake() and xSemaphoreGive() macros must not be used.</p> <p>A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each successful 'take' request. For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also 'given' the mutex back exactly five times.</p> <p>This type of semaphore uses a priority inheritance mechanism so a task 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the semaphore it is no longer required.</p> <p>Mutex type semaphores cannot be used from within interrupt service routines.</p> <p>See xSemaphoreCreateBinary() for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always 'gives' the semaphore and another always 'takes' the semaphore) and from within interrupt service routines.</p> <p>Parameters:</p> <ul> <li><code>pxMutexBuffer</code> Must point to a variable of type StaticSemaphore_t, which will then be used to hold the recursive mutex's data structure, removing the need for the memory to be allocated dynamically.</li> </ul> <p>Returns:</p> <p>If the recursive mutex was successfully created then a handle to the created recursive mutex is returned. If pxMutexBuffer was NULL then NULL is returned.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xSemaphoreGive/","title":"Group xSemaphoreGive","text":"<p>Modules &gt; xSemaphoreGive</p> <p>More...</p>"},{"location":"apiStm/group__xSemaphoreGive/#detailed-description","title":"Detailed Description","text":"<p>semphr. h </p> <p>Macro to release a semaphore. The semaphore must have previously been created with a call to xSemaphoreCreateBinary(), xSemaphoreCreateMutex() or xSemaphoreCreateCounting(). and obtained using sSemaphoreTake().</p> <p>This macro must not be used from an ISR. See xSemaphoreGiveFromISR () for an alternative which can be used from an ISR.</p> <p>This macro must also not be used on semaphores created using xSemaphoreCreateRecursiveMutex().</p> <p>Parameters:</p> <ul> <li><code>xSemaphore</code> A handle to the semaphore being released. This is the handle returned when the semaphore was created.</li> </ul> <p>Returns:</p> <p>pdTRUE if the semaphore was released. pdFALSE if an error occurred. Semaphores are implemented using queues. An error can occur if there is no space on the queue to post a message - indicating that the semaphore was not first obtained correctly.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xSemaphoreGiveFromISR/","title":"Group xSemaphoreGiveFromISR","text":"<p>Modules &gt; xSemaphoreGiveFromISR</p> <p>More...</p>"},{"location":"apiStm/group__xSemaphoreGiveFromISR/#detailed-description","title":"Detailed Description","text":"<p>semphr. h </p> <p>Macro to release a semaphore. The semaphore must have previously been created with a call to xSemaphoreCreateBinary() or xSemaphoreCreateCounting().</p> <p>Mutex type semaphores (those created using a call to xSemaphoreCreateMutex()) must not be used with this macro.</p> <p>This macro can be used from an ISR.</p> <p>Parameters:</p> <ul> <li><code>xSemaphore</code> A handle to the semaphore being released. This is the handle returned when the semaphore was created.</li> <li><code>pxHigherPriorityTaskWoken</code> xSemaphoreGiveFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if giving the semaphore caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xSemaphoreGiveFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</li> </ul> <p>Returns:</p> <p>pdTRUE if the semaphore was successfully given, otherwise errQUEUE_FULL.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xSemaphoreGiveRecursive/","title":"Group xSemaphoreGiveRecursive","text":"<p>Modules &gt; xSemaphoreGiveRecursive</p> <p>More...</p>"},{"location":"apiStm/group__xSemaphoreGiveRecursive/#detailed-description","title":"Detailed Description","text":"<p>semphr. h </p> <p>Macro to recursively release, or 'give', a mutex type semaphore. The mutex must have previously been created using a call to xSemaphoreCreateRecursiveMutex();</p> <p>configUSE_RECURSIVE_MUTEXES must be set to 1 in FreeRTOSConfig.h for this macro to be available.</p> <p>This macro must not be used on mutexes created using xSemaphoreCreateMutex().</p> <p>A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each successful 'take' request. For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also 'given' the mutex back exactly five times.</p> <p>Parameters:</p> <ul> <li><code>xMutex</code> A handle to the mutex being released, or 'given'. This is the handle returned by xSemaphoreCreateMutex();</li> </ul> <p>Returns:</p> <p>pdTRUE if the semaphore was given.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xSemaphoreTake/","title":"Group xSemaphoreTake","text":"<p>Modules &gt; xSemaphoreTake</p> <p>More...</p>"},{"location":"apiStm/group__xSemaphoreTake/#detailed-description","title":"Detailed Description","text":"<p>semphr. h </p> <p>Macro to obtain a semaphore. The semaphore must have previously been created with a call to xSemaphoreCreateBinary(), xSemaphoreCreateMutex() or xSemaphoreCreateCounting().</p> <p>Parameters:</p> <ul> <li><code>xSemaphore</code> A handle to the semaphore being taken - obtained when the semaphore was created.</li> <li><code>xBlockTime</code> The time in ticks to wait for the semaphore to become available. The macro portTICK_PERIOD_MS can be used to convert this to a real time. A block time of zero can be used to poll the semaphore. A block time of portMAX_DELAY can be used to block indefinitely (provided INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h).</li> </ul> <p>Returns:</p> <p>pdTRUE if the semaphore was obtained. pdFALSE if xBlockTime expired without the semaphore becoming available.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xSemaphoreTakeRecursive/","title":"Group xSemaphoreTakeRecursive","text":"<p>Modules &gt; xSemaphoreTakeRecursive</p> <p>More...</p>"},{"location":"apiStm/group__xSemaphoreTakeRecursive/#detailed-description","title":"Detailed Description","text":"<p>semphr. h xSemaphoreTakeRecursive( SemaphoreHandle_t xMutex, TickType_t xBlockTime )</p> <p>Macro to recursively obtain, or 'take', a mutex type semaphore. The mutex must have previously been created using a call to xSemaphoreCreateRecursiveMutex();</p> <p>configUSE_RECURSIVE_MUTEXES must be set to 1 in FreeRTOSConfig.h for this macro to be available.</p> <p>This macro must not be used on mutexes created using xSemaphoreCreateMutex().</p> <p>A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each successful 'take' request. For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also 'given' the mutex back exactly five times.</p> <p>Parameters:</p> <ul> <li><code>xMutex</code> A handle to the mutex being obtained. This is the handle returned by xSemaphoreCreateRecursiveMutex();</li> <li><code>xBlockTime</code> The time in ticks to wait for the semaphore to become available. The macro portTICK_PERIOD_MS can be used to convert this to a real time. A block time of zero can be used to poll the semaphore. If the task already owns the semaphore then xSemaphoreTakeRecursive() will return immediately no matter what the value of xBlockTime.</li> </ul> <p>Returns:</p> <p>pdTRUE if the semaphore was obtained. pdFALSE if xBlockTime expired without the semaphore becoming available.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xStreamBufferBytesAvailable/","title":"Group xStreamBufferBytesAvailable","text":"<p>Modules &gt; xStreamBufferBytesAvailable</p> <p>More...</p>"},{"location":"apiStm/group__xStreamBufferBytesAvailable/#detailed-description","title":"Detailed Description","text":"<p>stream_buffer.h</p> <p>Queries a stream buffer to see how much data it contains, which is equal to the number of bytes that can be read from the stream buffer before the stream buffer would be empty.</p> <p>Parameters:</p> <ul> <li><code>xStreamBuffer</code> The handle of the stream buffer being queried.</li> </ul> <p>Returns:</p> <p>The number of bytes that can be read from the stream buffer before the stream buffer would be empty. </p>"},{"location":"apiStm/group__xStreamBufferCreate/","title":"Group xStreamBufferCreate","text":"<p>Modules &gt; xStreamBufferCreate</p> <p>More...</p>"},{"location":"apiStm/group__xStreamBufferCreate/#detailed-description","title":"Detailed Description","text":"<p>message_buffer.h</p> <p>Creates a new stream buffer using dynamically allocated memory. See xStreamBufferCreateStatic() for a version that uses statically allocated memory (memory that is allocated at compile time).</p> <p>configSUPPORT_DYNAMIC_ALLOCATION must be set to 1 or left undefined in FreeRTOSConfig.h for xStreamBufferCreate() to be available.</p> <p>Parameters:</p> <ul> <li><code>xBufferSizeBytes</code> The total number of bytes the stream buffer will be able to hold at any one time.</li> <li><code>xTriggerLevelBytes</code> The number of bytes that must be in the stream buffer before a task that is blocked on the stream buffer to wait for data is moved out of the blocked state. For example, if a task is blocked on a read of an empty stream buffer that has a trigger level of 1 then the task will be unblocked when a single byte is written to the buffer or the task's block time expires. As another example, if a task is blocked on a read of an empty stream buffer that has a trigger level of 10 then the task will not be unblocked until the stream buffer contains at least 10 bytes or the task's block time expires. If a reading task's block time expires before the trigger level is reached then the task will still receive however many bytes are actually available. Setting a trigger level of 0 will result in a trigger level of 1 being used. It is not valid to specify a trigger level that is greater than the buffer size.</li> </ul> <p>Returns:</p> <p>If NULL is returned, then the stream buffer cannot be created because there is insufficient heap memory available for FreeRTOS to allocate the stream buffer data structures and storage area. A non-NULL value being returned indicates that the stream buffer has been created successfully - the returned value should be stored as the handle to the created stream buffer.</p> <p>Example use:  </p>"},{"location":"apiStm/group__xStreamBufferCreateStatic/","title":"Group xStreamBufferCreateStatic","text":"<p>Modules &gt; xStreamBufferCreateStatic</p> <p>More...</p>"},{"location":"apiStm/group__xStreamBufferCreateStatic/#detailed-description","title":"Detailed Description","text":"<p>stream_buffer.h</p> <p>Creates a new stream buffer using statically allocated memory. See xStreamBufferCreate() for a version that uses dynamically allocated memory.</p> <p>configSUPPORT_STATIC_ALLOCATION must be set to 1 in FreeRTOSConfig.h for xStreamBufferCreateStatic() to be available.</p> <p>Parameters:</p> <ul> <li><code>xBufferSizeBytes</code> The size, in bytes, of the buffer pointed to by the pucStreamBufferStorageArea parameter.</li> <li><code>xTriggerLevelBytes</code> The number of bytes that must be in the stream buffer before a task that is blocked on the stream buffer to wait for data is moved out of the blocked state. For example, if a task is blocked on a read of an empty stream buffer that has a trigger level of 1 then the task will be unblocked when a single byte is written to the buffer or the task's block time expires. As another example, if a task is blocked on a read of an empty stream buffer that has a trigger level of 10 then the task will not be unblocked until the stream buffer contains at least 10 bytes or the task's block time expires. If a reading task's block time expires before the trigger level is reached then the task will still receive however many bytes are actually available. Setting a trigger level of 0 will result in a trigger level of 1 being used. It is not valid to specify a trigger level that is greater than the buffer size.</li> <li><code>pucStreamBufferStorageArea</code> Must point to a uint8_t array that is at least xBufferSizeBytes + 1 big. This is the array to which streams are copied when they are written to the stream buffer.</li> <li><code>pxStaticStreamBuffer</code> Must point to a variable of type StaticStreamBuffer_t, which will be used to hold the stream buffer's data structure.</li> </ul> <p>Returns:</p> <p>If the stream buffer is created successfully then a handle to the created stream buffer is returned. If either pucStreamBufferStorageArea or pxStaticstreamBuffer are NULL then NULL is returned.</p> <p>Example use:  </p>"},{"location":"apiStm/group__xStreamBufferIsEmpty/","title":"Group xStreamBufferIsEmpty","text":"<p>Modules &gt; xStreamBufferIsEmpty</p> <p>More...</p>"},{"location":"apiStm/group__xStreamBufferIsEmpty/#detailed-description","title":"Detailed Description","text":"<p>stream_buffer.h</p> <p>Queries a stream buffer to see if it is empty. A stream buffer is empty if it does not contain any data.</p> <p>Parameters:</p> <ul> <li><code>xStreamBuffer</code> The handle of the stream buffer being queried.</li> </ul> <p>Returns:</p> <p>If the stream buffer is empty then pdTRUE is returned. Otherwise pdFALSE is returned. </p>"},{"location":"apiStm/group__xStreamBufferIsFull/","title":"Group xStreamBufferIsFull","text":"<p>Modules &gt; xStreamBufferIsFull</p> <p>More...</p>"},{"location":"apiStm/group__xStreamBufferIsFull/#detailed-description","title":"Detailed Description","text":"<p>stream_buffer.h</p> <p>Queries a stream buffer to see if it is full. A stream buffer is full if it does not have any free space, and therefore cannot accept any more data.</p> <p>Parameters:</p> <ul> <li><code>xStreamBuffer</code> The handle of the stream buffer being queried.</li> </ul> <p>Returns:</p> <p>If the stream buffer is full then pdTRUE is returned. Otherwise pdFALSE is returned. </p>"},{"location":"apiStm/group__xStreamBufferReceive/","title":"Group xStreamBufferReceive","text":"<p>Modules &gt; xStreamBufferReceive</p> <p>More...</p>"},{"location":"apiStm/group__xStreamBufferReceive/#detailed-description","title":"Detailed Description","text":"<p>stream_buffer.h</p> <p>Receives bytes from a stream buffer.</p> <p>NOTE: Uniquely among FreeRTOS objects, the stream buffer implementation (so also the message buffer implementation, as message buffers are built on top of stream buffers) assumes there is only one task or interrupt that will write to the buffer (the writer), and only one task or interrupt that will read from the buffer (the reader). It is safe for the writer and reader to be different tasks or interrupts, but, unlike other FreeRTOS objects, it is not safe to have multiple different writers or multiple different readers. If there are to be multiple different writers then the application writer must place each call to a writing API function (such as xStreamBufferSend()) inside a critical section and set the send block time to 0. Likewise, if there are to be multiple different readers then the application writer must place each call to a reading API function (such as xStreamBufferReceive()) inside a critical section and set the receive block time to 0.</p> <p>Use xStreamBufferReceive() to read from a stream buffer from a task. Use xStreamBufferReceiveFromISR() to read from a stream buffer from an interrupt service routine (ISR).</p> <p>Parameters:</p> <ul> <li><code>xStreamBuffer</code> The handle of the stream buffer from which bytes are to be received.</li> <li><code>pvRxData</code> A pointer to the buffer into which the received bytes will be copied.</li> <li><code>xBufferLengthBytes</code> The length of the buffer pointed to by the pvRxData parameter. This sets the maximum number of bytes to receive in one call. xStreamBufferReceive will return as many bytes as possible up to a maximum set by xBufferLengthBytes.</li> <li><code>xTicksToWait</code> The maximum amount of time the task should remain in the Blocked state to wait for data to become available if the stream buffer is empty. xStreamBufferReceive() will return immediately if xTicksToWait is zero. The block time is specified in tick periods, so the absolute time it represents is dependent on the tick frequency. The macro pdMS_TO_TICKS() can be used to convert a time specified in milliseconds into a time specified in ticks. Setting xTicksToWait to portMAX_DELAY will cause the task to wait indefinitely (without timing out), provided INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h. A task does not use any CPU time when it is in the Blocked state.</li> </ul> <p>Returns:</p> <p>The number of bytes actually read from the stream buffer, which will be less than xBufferLengthBytes if the call to xStreamBufferReceive() timed out before xBufferLengthBytes were available.</p> <p>Example use:  </p>"},{"location":"apiStm/group__xStreamBufferReceiveCompletedFromISR/","title":"Group xStreamBufferReceiveCompletedFromISR","text":"<p>Modules &gt; xStreamBufferReceiveCompletedFromISR</p> <p>More...</p>"},{"location":"apiStm/group__xStreamBufferReceiveCompletedFromISR/#detailed-description","title":"Detailed Description","text":"<p>stream_buffer.h</p> <p>For advanced users only.</p> <p>The sbRECEIVE_COMPLETED() macro is called from within the FreeRTOS APIs when data is read out of a message buffer or stream buffer. If there was a task that was blocked on the message or stream buffer waiting for data to arrive then the sbRECEIVE_COMPLETED() macro sends a notification to the task to remove it from the Blocked state. xStreamBufferReceiveCompletedFromISR() does the same thing. It is provided to enable application writers to implement their own version of sbRECEIVE_COMPLETED(), and MUST NOT BE USED AT ANY OTHER TIME.</p> <p>See the example implemented in FreeRTOS/Demo/Minimal/MessageBufferAMP.c for additional information.</p> <p>Parameters:</p> <ul> <li><code>xStreamBuffer</code> The handle of the stream buffer from which data was read.</li> <li><code>pxHigherPriorityTaskWoken</code> *pxHigherPriorityTaskWoken should be initialised to pdFALSE before it is passed into xStreamBufferReceiveCompletedFromISR(). If calling xStreamBufferReceiveCompletedFromISR() removes a task from the Blocked state, and the task has a priority above the priority of the currently running task, then *pxHigherPriorityTaskWoken will get set to pdTRUE indicating that a context switch should be performed before exiting the ISR.</li> </ul> <p>Returns:</p> <p>If a task was removed from the Blocked state then pdTRUE is returned. Otherwise pdFALSE is returned. </p>"},{"location":"apiStm/group__xStreamBufferReceiveFromISR/","title":"Group xStreamBufferReceiveFromISR","text":"<p>Modules &gt; xStreamBufferReceiveFromISR</p> <p>More...</p>"},{"location":"apiStm/group__xStreamBufferReceiveFromISR/#detailed-description","title":"Detailed Description","text":"<p>stream_buffer.h</p> <p>An interrupt safe version of the API function that receives bytes from a stream buffer.</p> <p>Use xStreamBufferReceive() to read bytes from a stream buffer from a task. Use xStreamBufferReceiveFromISR() to read bytes from a stream buffer from an interrupt service routine (ISR).</p> <p>Parameters:</p> <ul> <li><code>xStreamBuffer</code> The handle of the stream buffer from which a stream is being received.</li> <li><code>pvRxData</code> A pointer to the buffer into which the received bytes are copied.</li> <li><code>xBufferLengthBytes</code> The length of the buffer pointed to by the pvRxData parameter. This sets the maximum number of bytes to receive in one call. xStreamBufferReceive will return as many bytes as possible up to a maximum set by xBufferLengthBytes.</li> <li><code>pxHigherPriorityTaskWoken</code> It is possible that a stream buffer will have a task blocked on it waiting for space to become available. Calling xStreamBufferReceiveFromISR() can make space available, and so cause a task that is waiting for space to leave the Blocked state. If calling xStreamBufferReceiveFromISR() causes a task to leave the Blocked state, and the unblocked task has a priority higher than the currently executing task (the task that was interrupted), then, internally, xStreamBufferReceiveFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE. If xStreamBufferReceiveFromISR() sets this value to pdTRUE, then normally a context switch should be performed before the interrupt is exited. That will ensure the interrupt returns directly to the highest priority Ready state task. *pxHigherPriorityTaskWoken should be set to pdFALSE before it is passed into the function. See the code example below for an example.</li> </ul> <p>Returns:</p> <p>The number of bytes read from the stream buffer, if any.</p> <p>Example use:  </p>"},{"location":"apiStm/group__xStreamBufferReset/","title":"Group xStreamBufferReset","text":"<p>Modules &gt; xStreamBufferReset</p> <p>More...</p>"},{"location":"apiStm/group__xStreamBufferReset/#detailed-description","title":"Detailed Description","text":"<p>stream_buffer.h</p> <p>Resets a stream buffer to its initial, empty, state. Any data that was in the stream buffer is discarded. A stream buffer can only be reset if there are no tasks blocked waiting to either send to or receive from the stream buffer.</p> <p>Parameters:</p> <ul> <li><code>xStreamBuffer</code> The handle of the stream buffer being reset.</li> </ul> <p>Returns:</p> <p>If the stream buffer is reset then pdPASS is returned. If there was a task blocked waiting to send to or read from the stream buffer then the stream buffer is not reset and pdFAIL is returned. </p>"},{"location":"apiStm/group__xStreamBufferSend/","title":"Group xStreamBufferSend","text":"<p>Modules &gt; xStreamBufferSend</p> <p>More...</p>"},{"location":"apiStm/group__xStreamBufferSend/#detailed-description","title":"Detailed Description","text":"<p>stream_buffer.h</p> <p>Sends bytes to a stream buffer. The bytes are copied into the stream buffer.</p> <p>NOTE: Uniquely among FreeRTOS objects, the stream buffer implementation (so also the message buffer implementation, as message buffers are built on top of stream buffers) assumes there is only one task or interrupt that will write to the buffer (the writer), and only one task or interrupt that will read from the buffer (the reader). It is safe for the writer and reader to be different tasks or interrupts, but, unlike other FreeRTOS objects, it is not safe to have multiple different writers or multiple different readers. If there are to be multiple different writers then the application writer must place each call to a writing API function (such as xStreamBufferSend()) inside a critical section and set the send block time to 0. Likewise, if there are to be multiple different readers then the application writer must place each call to a reading API function (such as xStreamBufferReceive()) inside a critical section and set the receive block time to 0.</p> <p>Use xStreamBufferSend() to write to a stream buffer from a task. Use xStreamBufferSendFromISR() to write to a stream buffer from an interrupt service routine (ISR).</p> <p>Parameters:</p> <ul> <li><code>xStreamBuffer</code> The handle of the stream buffer to which a stream is being sent.</li> <li><code>pvTxData</code> A pointer to the buffer that holds the bytes to be copied into the stream buffer.</li> <li><code>xDataLengthBytes</code> The maximum number of bytes to copy from pvTxData into the stream buffer.</li> <li><code>xTicksToWait</code> The maximum amount of time the task should remain in the Blocked state to wait for enough space to become available in the stream buffer, should the stream buffer contain too little space to hold the another xDataLengthBytes bytes. The block time is specified in tick periods, so the absolute time it represents is dependent on the tick frequency. The macro pdMS_TO_TICKS() can be used to convert a time specified in milliseconds into a time specified in ticks. Setting xTicksToWait to portMAX_DELAY will cause the task to wait indefinitely (without timing out), provided INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h. If a task times out before it can write all xDataLengthBytes into the buffer it will still write as many bytes as possible. A task does not use any CPU time when it is in the blocked state.</li> </ul> <p>Returns:</p> <p>The number of bytes written to the stream buffer. If a task times out before it can write all xDataLengthBytes into the buffer it will still write as many bytes as possible.</p> <p>Example use:  </p>"},{"location":"apiStm/group__xStreamBufferSendCompletedFromISR/","title":"Group xStreamBufferSendCompletedFromISR","text":"<p>Modules &gt; xStreamBufferSendCompletedFromISR</p> <p>More...</p>"},{"location":"apiStm/group__xStreamBufferSendCompletedFromISR/#detailed-description","title":"Detailed Description","text":"<p>stream_buffer.h</p> <p>For advanced users only.</p> <p>The sbSEND_COMPLETED() macro is called from within the FreeRTOS APIs when data is sent to a message buffer or stream buffer. If there was a task that was blocked on the message or stream buffer waiting for data to arrive then the sbSEND_COMPLETED() macro sends a notification to the task to remove it from the Blocked state. xStreamBufferSendCompletedFromISR() does the same thing. It is provided to enable application writers to implement their own version of sbSEND_COMPLETED(), and MUST NOT BE USED AT ANY OTHER TIME.</p> <p>See the example implemented in FreeRTOS/Demo/Minimal/MessageBufferAMP.c for additional information.</p> <p>Parameters:</p> <ul> <li><code>xStreamBuffer</code> The handle of the stream buffer to which data was written.</li> <li><code>pxHigherPriorityTaskWoken</code> *pxHigherPriorityTaskWoken should be initialised to pdFALSE before it is passed into xStreamBufferSendCompletedFromISR(). If calling xStreamBufferSendCompletedFromISR() removes a task from the Blocked state, and the task has a priority above the priority of the currently running task, then *pxHigherPriorityTaskWoken will get set to pdTRUE indicating that a context switch should be performed before exiting the ISR.</li> </ul> <p>Returns:</p> <p>If a task was removed from the Blocked state then pdTRUE is returned. Otherwise pdFALSE is returned. </p>"},{"location":"apiStm/group__xStreamBufferSendFromISR/","title":"Group xStreamBufferSendFromISR","text":"<p>Modules &gt; xStreamBufferSendFromISR</p> <p>More...</p>"},{"location":"apiStm/group__xStreamBufferSendFromISR/#detailed-description","title":"Detailed Description","text":"<p>stream_buffer.h</p> <p>Interrupt safe version of the API function that sends a stream of bytes to the stream buffer.</p> <p>NOTE: Uniquely among FreeRTOS objects, the stream buffer implementation (so also the message buffer implementation, as message buffers are built on top of stream buffers) assumes there is only one task or interrupt that will write to the buffer (the writer), and only one task or interrupt that will read from the buffer (the reader). It is safe for the writer and reader to be different tasks or interrupts, but, unlike other FreeRTOS objects, it is not safe to have multiple different writers or multiple different readers. If there are to be multiple different writers then the application writer must place each call to a writing API function (such as xStreamBufferSend()) inside a critical section and set the send block time to 0. Likewise, if there are to be multiple different readers then the application writer must place each call to a reading API function (such as xStreamBufferReceive()) inside a critical section and set the receive block time to 0.</p> <p>Use xStreamBufferSend() to write to a stream buffer from a task. Use xStreamBufferSendFromISR() to write to a stream buffer from an interrupt service routine (ISR).</p> <p>Parameters:</p> <ul> <li><code>xStreamBuffer</code> The handle of the stream buffer to which a stream is being sent.</li> <li><code>pvTxData</code> A pointer to the data that is to be copied into the stream buffer.</li> <li><code>xDataLengthBytes</code> The maximum number of bytes to copy from pvTxData into the stream buffer.</li> <li><code>pxHigherPriorityTaskWoken</code> It is possible that a stream buffer will have a task blocked on it waiting for data. Calling xStreamBufferSendFromISR() can make data available, and so cause a task that was waiting for data to leave the Blocked state. If calling xStreamBufferSendFromISR() causes a task to leave the Blocked state, and the unblocked task has a priority higher than the currently executing task (the task that was interrupted), then, internally, xStreamBufferSendFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE. If xStreamBufferSendFromISR() sets this value to pdTRUE, then normally a context switch should be performed before the interrupt is exited. This will ensure that the interrupt returns directly to the highest priority Ready state task. *pxHigherPriorityTaskWoken should be set to pdFALSE before it is passed into the function. See the example code below for an example.</li> </ul> <p>Returns:</p> <p>The number of bytes actually written to the stream buffer, which will be less than xDataLengthBytes if the stream buffer didn't have enough free space for all the bytes to be written.</p> <p>Example use:  </p>"},{"location":"apiStm/group__xStreamBufferSetTriggerLevel/","title":"Group xStreamBufferSetTriggerLevel","text":"<p>Modules &gt; xStreamBufferSetTriggerLevel</p> <p>More...</p>"},{"location":"apiStm/group__xStreamBufferSetTriggerLevel/#detailed-description","title":"Detailed Description","text":"<p>stream_buffer.h</p> <p>A stream buffer's trigger level is the number of bytes that must be in the stream buffer before a task that is blocked on the stream buffer to wait for data is moved out of the blocked state. For example, if a task is blocked on a read of an empty stream buffer that has a trigger level of 1 then the task will be unblocked when a single byte is written to the buffer or the task's block time expires. As another example, if a task is blocked on a read of an empty stream buffer that has a trigger level of 10 then the task will not be unblocked until the stream buffer contains at least 10 bytes or the task's block time expires. If a reading task's block time expires before the trigger level is reached then the task will still receive however many bytes are actually available. Setting a trigger level of 0 will result in a trigger level of 1 being used. It is not valid to specify a trigger level that is greater than the buffer size.</p> <p>A trigger level is set when the stream buffer is created, and can be modified using xStreamBufferSetTriggerLevel().</p> <p>Parameters:</p> <ul> <li><code>xStreamBuffer</code> The handle of the stream buffer being updated.</li> <li><code>xTriggerLevel</code> The new trigger level for the stream buffer.</li> </ul> <p>Returns:</p> <p>If xTriggerLevel was less than or equal to the stream buffer's length then the trigger level will be updated and pdTRUE is returned. Otherwise pdFALSE is returned. </p>"},{"location":"apiStm/group__xStreamBufferSpacesAvailable/","title":"Group xStreamBufferSpacesAvailable","text":"<p>Modules &gt; xStreamBufferSpacesAvailable</p> <p>More...</p>"},{"location":"apiStm/group__xStreamBufferSpacesAvailable/#detailed-description","title":"Detailed Description","text":"<p>stream_buffer.h</p> <p>Queries a stream buffer to see how much free space it contains, which is equal to the amount of data that can be sent to the stream buffer before it is full.</p> <p>Parameters:</p> <ul> <li><code>xStreamBuffer</code> The handle of the stream buffer being queried.</li> </ul> <p>Returns:</p> <p>The number of bytes that can be written to the stream buffer before the stream buffer would be full. </p>"},{"location":"apiStm/group__xTaskAbortDelay/","title":"Group xTaskAbortDelay","text":"<p>Modules &gt; xTaskAbortDelay</p> <p>More...</p>"},{"location":"apiStm/group__xTaskAbortDelay/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>INCLUDE_xTaskAbortDelay must be defined as 1 in FreeRTOSConfig.h for this function to be available.</p> <p>A task will enter the Blocked state when it is waiting for an event. The event it is waiting for can be a temporal event (waiting for a time), such as when vTaskDelay() is called, or an event on an object, such as when xQueueReceive() or ulTaskNotifyTake() is called. If the handle of a task that is in the Blocked state is used in a call to xTaskAbortDelay() then the task will leave the Blocked state, and return from whichever function call placed the task into the Blocked state.</p> <p>There is no 'FromISR' version of this function as an interrupt would need to know which object a task was blocked on in order to know which actions to take. For example, if the task was blocked on a queue the interrupt handler would then need to know if the queue was locked.</p> <p>Parameters:</p> <ul> <li><code>xTask</code> The handle of the task to remove from the Blocked state.</li> </ul> <p>Returns:</p> <p>If the task referenced by xTask was not in the Blocked state then pdFAIL is returned. Otherwise pdPASS is returned. </p>"},{"location":"apiStm/group__xTaskCheckForTimeOut/","title":"Group xTaskCheckForTimeOut","text":"<p>Modules &gt; xTaskCheckForTimeOut</p> <p>More...</p>"},{"location":"apiStm/group__xTaskCheckForTimeOut/#detailed-description","title":"Detailed Description","text":"<p>task.h </p> <p>Determines if pxTicksToWait ticks has passed since a time was captured using a call to vTaskSetTimeOutState(). The captured time includes the tick count and the number of times the tick count has overflowed.</p> <p>Parameters:</p> <ul> <li><code>pxTimeOut</code> The time status as captured previously using vTaskSetTimeOutState. If the timeout has not yet occurred, it is updated to reflect the current time status. </li> <li><code>pxTicksToWait</code> The number of ticks to check for timeout i.e. if pxTicksToWait ticks have passed since pxTimeOut was last updated (either by vTaskSetTimeOutState() or xTaskCheckForTimeOut()), the timeout has occurred. If the timeout has not occurred, pxTIcksToWait is updated to reflect the number of remaining ticks.</li> </ul> <p>Returns:</p> <p>If timeout has occurred, pdTRUE is returned. Otherwise pdFALSE is returned and pxTicksToWait is updated to reflect the number of remaining ticks.</p> <p>See also: https://www.freertos.org/xTaskCheckForTimeOut.html Example Usage:  </p>"},{"location":"apiStm/group__xTaskCreate/","title":"Group xTaskCreate","text":"<p>Modules &gt; xTaskCreate</p> <p>More...</p>"},{"location":"apiStm/group__xTaskCreate/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>Create a new task and add it to the list of tasks that are ready to run.</p> <p>Internally, within the FreeRTOS implementation, tasks use two blocks of memory. The first block is used to hold the task's data structures. The second block is used by the task as its stack. If a task is created using xTaskCreate() then both blocks of memory are automatically dynamically allocated inside the xTaskCreate() function. (see http://www.freertos.org/a00111.html). If a task is created using xTaskCreateStatic() then the application writer must provide the required memory. xTaskCreateStatic() therefore allows a task to be created without using any dynamic memory allocation.</p> <p>See xTaskCreateStatic() for a version that does not use any dynamic memory allocation.</p> <p>xTaskCreate() can only be used to create a task that has unrestricted access to the entire microcontroller memory map. Systems that include MPU support can alternatively create an MPU constrained task using xTaskCreateRestricted().</p> <p>Parameters:</p> <ul> <li><code>pvTaskCode</code> Pointer to the task entry function. Tasks must be implemented to never return (i.e. continuous loop).</li> <li><code>pcName</code> A descriptive name for the task. This is mainly used to facilitate debugging. Max length defined by configMAX_TASK_NAME_LEN - default is 16.</li> <li><code>usStackDepth</code> The size of the task stack specified as the number of variables the stack can hold - not the number of bytes. For example, if the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes will be allocated for stack storage.</li> <li><code>pvParameters</code> Pointer that will be used as the parameter for the task being created.</li> <li><code>uxPriority</code> The priority at which the task should run. Systems that include MPU support can optionally create tasks in a privileged (system) mode by setting bit portPRIVILEGE_BIT of the priority parameter. For example, to create a privileged task at priority 2 the uxPriority parameter should be set to ( 2 | portPRIVILEGE_BIT ).</li> <li><code>pvCreatedTask</code> Used to pass back a handle by which the created task can be referenced.</li> </ul> <p>Returns:</p> <p>pdPASS if the task was successfully created and added to a ready list, otherwise an error code defined in the file projdefs.h</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xTaskCreateRestricted/","title":"Group xTaskCreateRestricted","text":"<p>Modules &gt; xTaskCreateRestricted</p> <p>More...</p>"},{"location":"apiStm/group__xTaskCreateRestricted/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>Only available when configSUPPORT_DYNAMIC_ALLOCATION is set to 1.</p> <p>xTaskCreateRestricted() should only be used in systems that include an MPU implementation.</p> <p>Create a new task and add it to the list of tasks that are ready to run. The function parameters define the memory regions and associated access permissions allocated to the task.</p> <p>See xTaskCreateRestrictedStatic() for a version that does not use any dynamic memory allocation.</p> <p>Parameters:</p> <ul> <li><code>pxTaskDefinition</code> Pointer to a structure that contains a member for each of the normal xTaskCreate() parameters (see the xTaskCreate() API documentation) plus an optional stack buffer and the memory region definitions.</li> <li><code>pxCreatedTask</code> Used to pass back a handle by which the created task can be referenced.</li> </ul> <p>Returns:</p> <p>pdPASS if the task was successfully created and added to a ready list, otherwise an error code defined in the file projdefs.h</p> <p>Example usage: </p> <p>task. h </p> <p>Memory regions are assigned to a restricted task when the task is created by a call to xTaskCreateRestricted(). These regions can be redefined using vTaskAllocateMPURegions().</p> <p>Parameters:</p> <ul> <li><code>xTask</code> The handle of the task being updated.</li> <li><code>xRegions</code> A pointer to an MemoryRegion_t structure that contains the new memory region definitions.</li> </ul> <p>Example usage:  </p>"},{"location":"apiStm/group__xTaskCreateRestrictedStatic/","title":"Group xTaskCreateRestrictedStatic","text":"<p>Modules &gt; xTaskCreateRestrictedStatic</p> <p>More...</p>"},{"location":"apiStm/group__xTaskCreateRestrictedStatic/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>Only available when configSUPPORT_STATIC_ALLOCATION is set to 1.</p> <p>xTaskCreateRestrictedStatic() should only be used in systems that include an MPU implementation.</p> <p>Internally, within the FreeRTOS implementation, tasks use two blocks of memory. The first block is used to hold the task's data structures. The second block is used by the task as its stack. If a task is created using xTaskCreateRestricted() then the stack is provided by the application writer, and the memory used to hold the task's data structure is automatically dynamically allocated inside the xTaskCreateRestricted() function. If a task is created using xTaskCreateRestrictedStatic() then the application writer must provide the memory used to hold the task's data structures too. xTaskCreateRestrictedStatic() therefore allows a memory protected task to be created without using any dynamic memory allocation.</p> <p>Parameters:</p> <ul> <li><code>pxTaskDefinition</code> Pointer to a structure that contains a member for each of the normal xTaskCreate() parameters (see the xTaskCreate() API documentation) plus an optional stack buffer and the memory region definitions. If configSUPPORT_STATIC_ALLOCATION is set to 1 the structure contains an additional member, which is used to point to a variable of type StaticTask_t - which is then used to hold the task's data structure.</li> <li><code>pxCreatedTask</code> Used to pass back a handle by which the created task can be referenced.</li> </ul> <p>Returns:</p> <p>pdPASS if the task was successfully created and added to a ready list, otherwise an error code defined in the file projdefs.h</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xTaskCreateStatic/","title":"Group xTaskCreateStatic","text":"<p>Modules &gt; xTaskCreateStatic</p> <p>More...</p>"},{"location":"apiStm/group__xTaskCreateStatic/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>Create a new task and add it to the list of tasks that are ready to run.</p> <p>Internally, within the FreeRTOS implementation, tasks use two blocks of memory. The first block is used to hold the task's data structures. The second block is used by the task as its stack. If a task is created using xTaskCreate() then both blocks of memory are automatically dynamically allocated inside the xTaskCreate() function. (see http://www.freertos.org/a00111.html). If a task is created using xTaskCreateStatic() then the application writer must provide the required memory. xTaskCreateStatic() therefore allows a task to be created without using any dynamic memory allocation.</p> <p>Parameters:</p> <ul> <li><code>pvTaskCode</code> Pointer to the task entry function. Tasks must be implemented to never return (i.e. continuous loop).</li> <li><code>pcName</code> A descriptive name for the task. This is mainly used to facilitate debugging. The maximum length of the string is defined by configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.</li> <li><code>ulStackDepth</code> The size of the task stack specified as the number of variables the stack can hold - not the number of bytes. For example, if the stack is 32-bits wide and ulStackDepth is defined as 100 then 400 bytes will be allocated for stack storage.</li> <li><code>pvParameters</code> Pointer that will be used as the parameter for the task being created.</li> <li><code>uxPriority</code> The priority at which the task will run.</li> <li><code>pxStackBuffer</code> Must point to a StackType_t array that has at least ulStackDepth indexes - the array will then be used as the task's stack, removing the need for the stack to be allocated dynamically.</li> <li><code>pxTaskBuffer</code> Must point to a variable of type StaticTask_t, which will then be used to hold the task's data structures, removing the need for the memory to be allocated dynamically.</li> </ul> <p>Returns:</p> <p>If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will be created and a handle to the created task is returned. If either pxStackBuffer or pxTaskBuffer are NULL then the task will not be created and NULL is returned.</p> <p>Example usage:  </p>"},{"location":"apiStm/group__xTaskGetTickCount/","title":"Group xTaskGetTickCount","text":"<p>Modules &gt; xTaskGetTickCount</p> <p>More...</p>"},{"location":"apiStm/group__xTaskGetTickCount/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>Returns:</p> <p>The count of ticks since vTaskStartScheduler was called. </p>"},{"location":"apiStm/group__xTaskGetTickCountFromISR/","title":"Group xTaskGetTickCountFromISR","text":"<p>Modules &gt; xTaskGetTickCountFromISR</p> <p>More...</p>"},{"location":"apiStm/group__xTaskGetTickCountFromISR/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>Returns:</p> <p>The count of ticks since vTaskStartScheduler was called.</p> <p>This is a version of xTaskGetTickCount() that is safe to be called from an ISR - provided that TickType_t is the natural word size of the microcontroller being used or interrupt nesting is either not supported or not being used. </p>"},{"location":"apiStm/group__xTaskNotify/","title":"Group xTaskNotify","text":"<p>Modules &gt; xTaskNotify</p> <p>More...</p>"},{"location":"apiStm/group__xTaskNotify/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this function to be available.</p> <p>When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private \"notification value\", which is a 32-bit unsigned integer (uint32_t).</p> <p>Events can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object.</p> <p>A notification sent to a task can optionally perform an action, such as update, overwrite or increment the task's notification value. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.</p> <p>A notification sent to a task will remain pending until it is cleared by the task calling xTaskNotifyWait() or ulTaskNotifyTake(). If the task was already in the Blocked state to wait for a notification when the notification arrives then the task will automatically be removed from the Blocked state (unblocked) and the notification cleared.</p> <p>A task can use xTaskNotifyWait() to [optionally] block to wait for a notification to be pending, or ulTaskNotifyTake() to [optionally] block to wait for its notification value to have a non-zero value. The task does not consume any CPU time while it is in the Blocked state.</p> <p>See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.</p> <p>Parameters:</p> <ul> <li><code>xTaskToNotify</code> The handle of the task being notified. The handle to a task can be returned from the xTaskCreate() API function used to create the task, and the handle of the currently running task can be obtained by calling xTaskGetCurrentTaskHandle().</li> <li><code>ulValue</code> Data that can be sent with the notification. How the data is used depends on the value of the eAction parameter.</li> <li><code>eAction</code> Specifies how the notification updates the task's notification value, if at all. Valid values for eAction are as follows:</li> </ul> <p>eSetBits - The task's notification value is bitwise ORed with ulValue. xTaskNofify() always returns pdPASS in this case.</p> <p>eIncrement - The task's notification value is incremented. ulValue is not used and xTaskNotify() always returns pdPASS in this case.</p> <p>eSetValueWithOverwrite - The task's notification value is set to the value of ulValue, even if the task being notified had not yet processed the previous notification (the task already had a notification pending). xTaskNotify() always returns pdPASS in this case.</p> <p>eSetValueWithoutOverwrite - If the task being notified did not already have a notification pending then the task's notification value is set to ulValue and xTaskNotify() will return pdPASS. If the task being notified already had a notification pending then no action is performed and pdFAIL is returned.</p> <p>eNoAction - The task receives a notification without its notification value being updated. ulValue is not used and xTaskNotify() always returns pdPASS in this case.</p> <p>pulPreviousNotificationValue - Can be used to pass out the subject task's notification value before any bits are modified by the notify function.</p> <p>Returns:</p> <p>Dependent on the value of eAction. See the description of the eAction parameter.</p> <p>task. h </p> <p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this function to be available.</p> <p>When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private \"notification value\", which is a 32-bit unsigned integer (uint32_t).</p> <p>A version of xTaskNotify() that can be used from an interrupt service routine (ISR).</p> <p>Events can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object.</p> <p>A notification sent to a task can optionally perform an action, such as update, overwrite or increment the task's notification value. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.</p> <p>A notification sent to a task will remain pending until it is cleared by the task calling xTaskNotifyWait() or ulTaskNotifyTake(). If the task was already in the Blocked state to wait for a notification when the notification arrives then the task will automatically be removed from the Blocked state (unblocked) and the notification cleared.</p> <p>A task can use xTaskNotifyWait() to [optionally] block to wait for a notification to be pending, or ulTaskNotifyTake() to [optionally] block to wait for its notification value to have a non-zero value. The task does not consume any CPU time while it is in the Blocked state.</p> <p>See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.</p> <p>Parameters:</p> <ul> <li><code>xTaskToNotify</code> The handle of the task being notified. The handle to a task can be returned from the xTaskCreate() API function used to create the task, and the handle of the currently running task can be obtained by calling xTaskGetCurrentTaskHandle().</li> <li><code>ulValue</code> Data that can be sent with the notification. How the data is used depends on the value of the eAction parameter.</li> <li><code>eAction</code> Specifies how the notification updates the task's notification value, if at all. Valid values for eAction are as follows:</li> </ul> <p>eSetBits - The task's notification value is bitwise ORed with ulValue. xTaskNofify() always returns pdPASS in this case.</p> <p>eIncrement - The task's notification value is incremented. ulValue is not used and xTaskNotify() always returns pdPASS in this case.</p> <p>eSetValueWithOverwrite - The task's notification value is set to the value of ulValue, even if the task being notified had not yet processed the previous notification (the task already had a notification pending). xTaskNotify() always returns pdPASS in this case.</p> <p>eSetValueWithoutOverwrite - If the task being notified did not already have a notification pending then the task's notification value is set to ulValue and xTaskNotify() will return pdPASS. If the task being notified already had a notification pending then no action is performed and pdFAIL is returned.</p> <p>eNoAction - The task receives a notification without its notification value being updated. ulValue is not used and xTaskNotify() always returns pdPASS in this case.</p> <p>Parameters:</p> <ul> <li><code>pxHigherPriorityTaskWoken</code> xTaskNotifyFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the task to which the notification was sent to leave the Blocked state, and the unblocked task has a priority higher than the currently running task. If xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited. How a context switch is requested from an ISR is dependent on the port - see the documentation page for the port in use.</li> </ul> <p>Returns:</p> <p>Dependent on the value of eAction. See the description of the eAction parameter. </p>"},{"location":"apiStm/group__xTaskNotifyGive/","title":"Group xTaskNotifyGive","text":"<p>Modules &gt; xTaskNotifyGive</p> <p>More...</p>"},{"location":"apiStm/group__xTaskNotifyGive/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro to be available.</p> <p>When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private \"notification value\", which is a 32-bit unsigned integer (uint32_t).</p> <p>Events can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object.</p> <p>A notification sent to a task can optionally perform an action, such as update, overwrite or increment the task's notification value. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.</p> <p>xTaskNotifyGive() is a helper macro intended for use when task notifications are used as light weight and faster binary or counting semaphore equivalents. Actual FreeRTOS semaphores are given using the xSemaphoreGive() API function, the equivalent action that instead uses a task notification is xTaskNotifyGive().</p> <p>When task notifications are being used as a binary or counting semaphore equivalent then the task being notified should wait for the notification using the ulTaskNotificationTake() API function rather than the xTaskNotifyWait() API function.</p> <p>See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.</p> <p>Parameters:</p> <ul> <li><code>xTaskToNotify</code> The handle of the task being notified. The handle to a task can be returned from the xTaskCreate() API function used to create the task, and the handle of the currently running task can be obtained by calling xTaskGetCurrentTaskHandle().</li> </ul> <p>Returns:</p> <p>xTaskNotifyGive() is a macro that calls xTaskNotify() with the eAction parameter set to eIncrement - so pdPASS is always returned. </p>"},{"location":"apiStm/group__xTaskNotifyStateClear/","title":"Group xTaskNotifyStateClear","text":"<p>Modules &gt; xTaskNotifyStateClear</p> <p>More...</p>"},{"location":"apiStm/group__xTaskNotifyStateClear/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>If the notification state of the task referenced by the handle xTask is eNotified, then set the task's notification state to eNotWaitingNotification. The task's notification value is not altered. Set xTask to NULL to clear the notification state of the calling task.</p> <p>Returns:</p> <p>pdTRUE if the task's notification state was set to eNotWaitingNotification, otherwise pdFALSE. </p>"},{"location":"apiStm/group__xTaskNotifyWait/","title":"Group xTaskNotifyWait","text":"<p>Modules &gt; xTaskNotifyWait</p> <p>More...</p>"},{"location":"apiStm/group__xTaskNotifyWait/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this function to be available.</p> <p>When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private \"notification value\", which is a 32-bit unsigned integer (uint32_t).</p> <p>Events can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object.</p> <p>A notification sent to a task can optionally perform an action, such as update, overwrite or increment the task's notification value. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.</p> <p>A notification sent to a task will remain pending until it is cleared by the task calling xTaskNotifyWait() or ulTaskNotifyTake(). If the task was already in the Blocked state to wait for a notification when the notification arrives then the task will automatically be removed from the Blocked state (unblocked) and the notification cleared.</p> <p>A task can use xTaskNotifyWait() to [optionally] block to wait for a notification to be pending, or ulTaskNotifyTake() to [optionally] block to wait for its notification value to have a non-zero value. The task does not consume any CPU time while it is in the Blocked state.</p> <p>See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.</p> <p>Parameters:</p> <ul> <li><code>ulBitsToClearOnEntry</code> Bits that are set in ulBitsToClearOnEntry value will be cleared in the calling task's notification value before the task checks to see if any notifications are pending, and optionally blocks if no notifications are pending. Setting ulBitsToClearOnEntry to ULONG_MAX (if limits.h is included) or 0xffffffffUL (if limits.h is not included) will have the effect of resetting the task's notification value to 0. Setting ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.</li> <li><code>ulBitsToClearOnExit</code> If a notification is pending or received before the calling task exits the xTaskNotifyWait() function then the task's notification value (see the xTaskNotify() API function) is passed out using the pulNotificationValue parameter. Then any bits that are set in ulBitsToClearOnExit will be cleared in the task's notification value (note *pulNotificationValue is set before any bits are cleared). Setting ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL (if limits.h is not included) will have the effect of resetting the task's notification value to 0 before the function exits. Setting ulBitsToClearOnExit to 0 will leave the task's notification value unchanged when the function exits (in which case the value passed out in pulNotificationValue will match the task's notification value).</li> <li><code>pulNotificationValue</code> Used to pass the task's notification value out of the function. Note the value passed out will not be effected by the clearing of any bits caused by ulBitsToClearOnExit being non-zero.</li> <li><code>xTicksToWait</code> The maximum amount of time that the task should wait in the Blocked state for a notification to be received, should a notification not already be pending when xTaskNotifyWait() was called. The task will not consume any processing time while it is in the Blocked state. This is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time specified in milliseconds to a time specified in ticks.</li> </ul> <p>Returns:</p> <p>If a notification was received (including notifications that were already pending when xTaskNotifyWait was called) then pdPASS is returned. Otherwise pdFAIL is returned.</p> <p>task. h </p>"},{"location":"apiStm/group__xTaskResumeAll/","title":"Group xTaskResumeAll","text":"<p>Modules &gt; xTaskResumeAll</p> <p>More...</p>"},{"location":"apiStm/group__xTaskResumeAll/#detailed-description","title":"Detailed Description","text":"<p>task. h </p> <p>Resumes scheduler activity after it was suspended by a call to vTaskSuspendAll().</p> <p>xTaskResumeAll() only resumes the scheduler. It does not unsuspend tasks that were previously suspended by a call to vTaskSuspend().</p> <p>Returns:</p> <p>If resuming the scheduler caused a context switch then pdTRUE is returned, otherwise pdFALSE is returned.</p> <p>Example usage:  </p>"},{"location":"apiStm/dir_b8c955b770907a816d8d814e8d2a21ac/","title":"Dir fw","text":"<p>FileList &gt; fw</p>"},{"location":"apiStm/dir_b8c955b770907a816d8d814e8d2a21ac/#directories","title":"Directories","text":"Type Name dir rbcx-coprocessor <p>The documentation for this class was generated from the following file <code>fw/</code></p>"},{"location":"apiStm/dir_7d45f881dcf2fb01e973fdd38228b27f/","title":"Dir fw/rbcx-coprocessor","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor</p>"},{"location":"apiStm/dir_7d45f881dcf2fb01e973fdd38228b27f/#files","title":"Files","text":"Type Name file .clang-format"},{"location":"apiStm/dir_7d45f881dcf2fb01e973fdd38228b27f/#directories","title":"Directories","text":"Type Name dir include dir lib dir src <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/</code></p>"},{"location":"apiStm/_8clang-format/","title":"File .clang-format","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; .clang-format</p> <p>Go to the source code of this file.</p> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/.clang-format</code></p>"},{"location":"apiStm/_8clang-format_source/","title":"File .clang-format","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; .clang-format</p> <p>Go to the documentation of this file. </p> <pre><code>---\nLanguage:        Cpp\n# BasedOnStyle:  WebKit\nAccessModifierOffset: -4\nAlignAfterOpenBracket: DontAlign\nAlignConsecutiveMacros: false\nAlignConsecutiveAssignments: false\nAlignConsecutiveDeclarations: false\nAlignEscapedNewlines: Right\nAlignOperands:   false\nAlignTrailingComments: false\nAllowAllArgumentsOnNextLine: true\nAllowAllConstructorInitializersOnNextLine: true\nAllowAllParametersOfDeclarationOnNextLine: true\nAllowShortBlocksOnASingleLine: false\nAllowShortCaseLabelsOnASingleLine: false\nAllowShortFunctionsOnASingleLine: All\nAllowShortLambdasOnASingleLine: All\nAllowShortIfStatementsOnASingleLine: Never\nAllowShortLoopsOnASingleLine: false\nAlwaysBreakAfterDefinitionReturnType: None\nAlwaysBreakAfterReturnType: None\nAlwaysBreakBeforeMultilineStrings: false\nAlwaysBreakTemplateDeclarations: MultiLine\nBinPackArguments: true\nBinPackParameters: true\nBraceWrapping:\nAfterCaseLabel:  false\nAfterClass:      true\nAfterControlStatement: false\nAfterEnum:       false\nAfterFunction:   false\nAfterNamespace:  false\nAfterObjCDeclaration: false\nAfterStruct:     false\nAfterUnion:      false\nAfterExternBlock: false\nBeforeCatch:     false\nBeforeElse:      false\nIndentBraces:    false\nSplitEmptyFunction: true\nSplitEmptyRecord: true\nSplitEmptyNamespace: true\nBreakBeforeBinaryOperators: All\nBreakBeforeBraces: Attach\nBreakBeforeInheritanceComma: false\nBreakInheritanceList: BeforeColon\nBreakBeforeTernaryOperators: true\nBreakConstructorInitializersBeforeComma: false\nBreakConstructorInitializers: BeforeComma\nBreakAfterJavaFieldAnnotations: false\nBreakStringLiterals: true\nColumnLimit:     0\nCommentPragmas:  '^ IWYU pragma:'\nCompactNamespaces: false\nConstructorInitializerAllOnOneLineOrOnePerLine: false\nConstructorInitializerIndentWidth: 4\nContinuationIndentWidth: 4\nCpp11BracedListStyle: false\nDerivePointerAlignment: false\nDisableFormat:   false\nExperimentalAutoDetectBinPacking: false\nFixNamespaceComments: false\nForEachMacros:\n- foreach\n- Q_FOREACH\n- BOOST_FOREACH\nIncludeBlocks:   Preserve\nIncludeCategories:\n- Regex:           '^\"(llvm|llvm-c|clang|clang-c)/'\nPriority:        2\n- Regex:           '^(&lt;|\"(gtest|gmock|isl|json)/)'\nPriority:        3\n- Regex:           '.*'\nPriority:        1\nIncludeIsMainRegex: '(Test)?$'\nIndentCaseLabels: false\nIndentPPDirectives: None\nIndentWidth:     4\nIndentWrappedFunctionNames: false\nJavaScriptQuotes: Leave\nJavaScriptWrapImports: true\nKeepEmptyLinesAtTheStartOfBlocks: true\nMacroBlockBegin: ''\nMacroBlockEnd:   ''\nMaxEmptyLinesToKeep: 1\nNamespaceIndentation: None\nObjCBinPackProtocolList: Auto\nObjCBlockIndentWidth: 4\nObjCSpaceAfterProperty: true\nObjCSpaceBeforeProtocolList: true\nPenaltyBreakAssignment: 2\nPenaltyBreakBeforeFirstCallParameter: 19\nPenaltyBreakComment: 300\nPenaltyBreakFirstLessLess: 120\nPenaltyBreakString: 1000\nPenaltyBreakTemplateDeclaration: 10\nPenaltyExcessCharacter: 1000000\nPenaltyReturnTypeOnItsOwnLine: 60\nPointerAlignment: Left\nReflowComments:  false\nSortIncludes:    true\nSortUsingDeclarations: true\nSpaceAfterCStyleCast: false\nSpaceAfterLogicalNot: false\nSpaceAfterTemplateKeyword: true\nSpaceBeforeAssignmentOperators: true\nSpaceBeforeCpp11BracedList: true\nSpaceBeforeCtorInitializerColon: true\nSpaceBeforeInheritanceColon: true\nSpaceBeforeParens: ControlStatements\nSpaceBeforeRangeBasedForLoopColon: true\nSpaceInEmptyParentheses: false\nSpacesBeforeTrailingComments: 1\nSpacesInAngles:  false\nSpacesInContainerLiterals: true\nSpacesInCStyleCastParentheses: false\nSpacesInParentheses: false\nSpacesInSquareBrackets: false\nStandard:        Cpp11\nStatementMacros:\n- Q_UNUSED\n- QT_REQUIRE_VERSION\nTabWidth:        8\nUseTab:          Never\nColumnLimit: 80\n...\n</code></pre>"},{"location":"apiStm/dir_8a5935015f0d5820975f6d369cb4d3c0/","title":"Dir fw/rbcx-coprocessor/include","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include</p>"},{"location":"apiStm/dir_8a5935015f0d5820975f6d369cb4d3c0/#files","title":"Files","text":"Type Name file Bsp.hpp file ButtonController.hpp file BuzzerController.hpp file CdcUartTunnel.hpp file ControlLink.hpp file DebugLink.hpp file Dispatcher.hpp file Esp32Manager.hpp file FreeRTOSConfig.h file I2cController.hpp file Motor.hpp file MotorController.hpp file Mpu6050.hpp file MpuController.hpp file OledController.hpp file OledController_fonts.hpp file Power.hpp file SmartServoController.hpp file StupidServoController.hpp file UltrasoundController.hpp file UsbCdcLink.h"},{"location":"apiStm/dir_8a5935015f0d5820975f6d369cb4d3c0/#directories","title":"Directories","text":"Type Name dir utils <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/</code></p>"},{"location":"apiStm/Bsp_8hpp/","title":"File Bsp.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; Bsp.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"FreeRTOSConfig.h\"</code></li> <li><code>#include \"stm32f1xx_hal.h\"</code></li> <li><code>#include \"stm32f1xx_hal_cortex.h\"</code></li> <li><code>#include \"stm32f1xx_hal_gpio.h\"</code></li> <li><code>#include \"stm32f1xx_ll_adc.h\"</code></li> <li><code>#include \"stm32f1xx_ll_dma.h\"</code></li> <li><code>#include \"stm32f1xx_ll_utils.h\"</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> </ul>"},{"location":"apiStm/Bsp_8hpp/#public-types","title":"Public Types","text":"Type Name typedef uint32_t ADC_channel_t typedef uint32_t ADC_rank_t typedef uint32_t DMA_channel_t typedef std::pair&lt; GPIO_TypeDef *, uint16_t &gt; PinDef"},{"location":"apiStm/Bsp_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name ADC_TypeDef *const auxiliaryAdc   = = ADC1 const IRQn_Type auxiliaryAndMotorAdcIRQn   = = ADC1_2_IRQn const unsigned auxiliaryAndMotorAdcIrqPrio   = = 9 const ADC_channel_t batteryMiddleVoltageAdcChannel   = = LL_ADC_CHANNEL_3 const ADC_rank_t batteryMiddleVoltageAdcRank   = = LL_ADC_INJ_RANK_3 const PinDef batteryMiddleVoltagePin   = = std::make_pair(GPIOA, GPIO_PIN_3) const ADC_channel_t batteryVoltageAdcChannel   = = LL_ADC_CHANNEL_6 const ADC_rank_t batteryVoltageAdcRank   = = LL_ADC_INJ_RANK_1 const PinDef batteryVoltagePin   = = std::make_pair(GPIOA, GPIO_PIN_6) const PinDef button1Pin   = = std::make_pair(GPIOE, GPIO_PIN_0) const PinDef button2Pin   = = std::make_pair(GPIOD, GPIO_PIN_10) const PinDef button3Pin   = = std::make_pair(GPIOB, GPIO_PIN_2) const PinDef button4Pin   = = std::make_pair(GPIOD, GPIO_PIN_11) const PinDef buttonOffPin   = = std::make_pair(GPIOE, GPIO_PIN_15) const PinDef buttonOnPin   = = std::make_pair(GPIOD, GPIO_PIN_14) const std::array&lt; PinDef, 6 &gt; buttonPin   = = { buttonOffPin, button1Pin, button2Pin, button3Pin, button4Pin, buttonOnPin } const PinDef buzzerPin   = = std::make_pair(GPIOD, GPIO_PIN_3) USART_TypeDef *const controlUart   = = USART3 DMA_Channel_TypeDef *const controlUartRxDmaChannel   = = DMA1_Channel3 const PinDef controlUartRxPin   = = std::make_pair(GPIOB, GPIO_PIN_11) DMA_Channel_TypeDef *const controlUartTxDmaChannel   = = DMA1_Channel2 const IRQn_Type controlUartTxDmaIRQn   = = DMA1_Channel2_IRQn const unsigned controlUartTxDmaIRQnPrio   = = 8 const PinDef controlUartTxPin   = = std::make_pair(GPIOB, GPIO_PIN_10) USART_TypeDef *const debugUart   = = UART4 const IRQn_Type debugUartIRQn   = = UART4_IRQn const unsigned debugUartIrqPrio   = = 10 DMA_Channel_TypeDef *const debugUartRxDmaChannel   = = DMA2_Channel3 const PinDef debugUartRxPin   = = std::make_pair(GPIOC, GPIO_PIN_11) DMA_Channel_TypeDef *const debugUartTxDmaChannel   = = DMA2_Channel5 const IRQn_Type debugUartTxDmaIRQn   = = DMA2_Channel4_5_IRQn const unsigned debugUartTxDmaIrqPrio   = = 9 const PinDef debugUartTxPin   = = std::make_pair(GPIOC, GPIO_PIN_10) const PinDef encoder1aPin   = = std::make_pair(GPIOD, GPIO_PIN_12) const PinDef encoder1bPin   = = std::make_pair(GPIOD, GPIO_PIN_13) const PinDef encoder2aPin   = = std::make_pair(GPIOA, GPIO_PIN_0) const PinDef encoder2bPin   = = std::make_pair(GPIOA, GPIO_PIN_1) const PinDef encoder3aPin   = = std::make_pair(GPIOA, GPIO_PIN_15) const PinDef encoder3bPin   = = std::make_pair(GPIOB, GPIO_PIN_3) const PinDef encoder4aPin   = = std::make_pair(GPIOB, GPIO_PIN_4) const PinDef encoder4bPin   = = std::make_pair(GPIOB, GPIO_PIN_5) TIM_TypeDef *const encoderTimer   = = { TIM4, TIM5, TIM2, TIM3 } const PinDef esp0Pin   = = std::make_pair(GPIOB, GPIO_PIN_10) const PinDef esp12Pin   = = std::make_pair(GPIOB, GPIO_PIN_15) const PinDef esp15Pin   = = std::make_pair(GPIOB, GPIO_PIN_14) const PinDef esp2Pin   = = std::make_pair(GPIOB, GPIO_PIN_11) const PinDef espEnPin   = = std::make_pair(GPIOD, GPIO_PIN_4) const IRQn_Type i2cErIRQn   = = I2C1_ER_IRQn const IRQn_Type i2cEvIRQn   = = I2C1_EV_IRQn const unsigned i2cIRQnPrio   = = 8 const int i2cPrio   = = 2 const PinDef i2cScl   = = std::make_pair(GPIOB, GPIO_PIN_8) const PinDef i2cSda   = = std::make_pair(GPIOB, GPIO_PIN_9) const PinDef in4aPin   = = std::make_pair(IN4PORT, IN4AMASK) const PinDef in4bPin   = = std::make_pair(IN4PORT, IN4BMASK) const ADC_rank_t internalReferenceVoltageAdcRank   = = LL_ADC_INJ_RANK_2 const PinDef led1Pin   = = std::make_pair(GPIOA, GPIO_PIN_7) const PinDef led2Pin   = = std::make_pair(GPIOA, GPIO_PIN_8) const PinDef led3Pin   = = std::make_pair(GPIOA, GPIO_PIN_9) const PinDef led4Pin   = = std::make_pair(GPIOA, GPIO_PIN_10) const std::array&lt; PinDef, 4 &gt; ledPin   = = { led1Pin, led2Pin, led3Pin, led4Pin } const PinDef ledPins   = = std::make_pair( GPIOA, led1Pin.second | led2Pin.second | led3Pin.second | led4Pin.second) const int mainTaskPrio   = = 4 const int motorTaskPrio   = = 2 const PinDef powerPin   = = std::make_pair(GPIOC, GPIO_PIN_13) const PinDef pwm1aPin   = = std::make_pair(GPIOE, GPIO_PIN_9) const PinDef pwm1bPin   = = std::make_pair(GPIOE, GPIO_PIN_8) const PinDef pwm2aPin   = = std::make_pair(GPIOE, GPIO_PIN_11) const PinDef pwm2bPin   = = std::make_pair(GPIOE, GPIO_PIN_10) const PinDef pwm3aPin   = = std::make_pair(GPIOE, GPIO_PIN_13) const PinDef pwm3bPin   = = std::make_pair(GPIOE, GPIO_PIN_12) const PinDef pwm4Pin   = = std::make_pair(GPIOE, GPIO_PIN_14) TIM_TypeDef *const pwmTimer   = = TIM1 const PinDef servo1Pin   = = std::make_pair(GPIOC, GPIO_PIN_6) const PinDef servo2Pin   = = std::make_pair(GPIOC, GPIO_PIN_7) const PinDef servo3Pin   = = std::make_pair(GPIOC, GPIO_PIN_8) const PinDef servo4Pin   = = std::make_pair(GPIOC, GPIO_PIN_9) const PinDef servoPins   = = std::make_pair(GPIOC, servo1Pin.second | servo2Pin.second | servo3Pin.second | servo4Pin.second) TIM_TypeDef *const servoTimer   = = TIM8 USART_TypeDef *const servoUart   = = UART5 const IRQn_Type servoUartIRQn   = = UART5_IRQn const unsigned servoUartIrqPrio   = = 9 const PinDef servoUartTxRxPin   = = std::make_pair(GPIOC, GPIO_PIN_12) const int softResetTaskPrio   = = configMAX_PRIORITIES - 1 const ADC_rank_t temperatureAdcRank   = = LL_ADC_INJ_RANK_4 USART_TypeDef *const tunnelUart   = = USART2 DMA_Channel_TypeDef *const tunnelUartRxDmaChannel   = = DMA1_Channel6 const PinDef tunnelUartRxPin   = = std::make_pair(GPIOD, GPIO_PIN_6) DMA_Channel_TypeDef *const tunnelUartTxDmaChannel   = = DMA1_Channel7 const PinDef tunnelUartTxPin   = = std::make_pair(GPIOD, GPIO_PIN_5) const int ultrasoundTaskPrio   = = 2 const PinDef usbBusDetectionPin   = = std::make_pair(GPIOA, GPIO_PIN_2) const PinDef usbDnPin   = = std::make_pair(GPIOA, GPIO_PIN_11) const PinDef usbDpPin   = = std::make_pair(GPIOA, GPIO_PIN_12) const PinDef usbDpPullUpPin   = = std::make_pair(USBD_DP_PORT, 1 &lt;&lt; USBD_DP_PIN) const IRQn_Type usbLpIRQn   = = USB_LP_CAN1_RX0_IRQn constexpr unsigned usbLpIRQnPrio   = = 8 USART_TypeDef *const userUart   = = USART1 const PinDef userUartRxPin   = = std::make_pair(GPIOB, GPIO_PIN_7) const PinDef userUartTxPin   = = std::make_pair(GPIOB, GPIO_PIN_6) const PinDef uts1EchoPin   = = std::make_pair(GPIOE, GPIO_PIN_6) const PinDef uts1TrigPin   = = std::make_pair(GPIOE, GPIO_PIN_1) const PinDef uts2EchoPin   = = std::make_pair(GPIOD, GPIO_PIN_7) const PinDef uts2TrigPin   = = std::make_pair(GPIOE, GPIO_PIN_2) const PinDef uts3EchoPin   = = std::make_pair(GPIOD, GPIO_PIN_8) const PinDef uts3TrigPin   = = std::make_pair(GPIOE, GPIO_PIN_3) const PinDef uts4EchoPin   = = std::make_pair(GPIOD, GPIO_PIN_9) const PinDef uts4TrigPin   = = std::make_pair(GPIOE, GPIO_PIN_4) const std::array&lt; PinDef, 4 &gt; utsEchoPin   = = { uts1EchoPin, uts2EchoPin, uts3EchoPin, uts4EchoPin } const uint32_t utsIRQPrio   = = 7 TIM_TypeDef *const utsTimer   = = TIM7 const std::array&lt; PinDef, 4 &gt; utsTrigPin   = = { uts1TrigPin, uts2TrigPin, uts3TrigPin, uts4TrigPin }"},{"location":"apiStm/Bsp_8hpp/#public-functions","title":"Public Functions","text":"Type Name void LL_ADC_SetChannelSamplingTimeFix (ADC_TypeDef * ADCx, uint32_t Channel, uint32_t SamplingTime)  void LL_GPIO_AF_Remap (uint32_t mask, uint32_t value)  void clocksInit ()  uint32_t getButtons ()  bool isPressed (PinDef button)  void pinInit (GPIO_TypeDef * port, uint32_t pinMask, uint32_t mode, uint32_t pull, uint32_t speed, bool deInitFirst=false)  void pinInit (PinDef pin, uint32_t mode, uint32_t pull, uint32_t speed, bool deInitFirst=false)  bool pinRead (PinDef pin)  void pinToggle (PinDef pin)  void pinWrite (PinDef pin, bool value)  void pinsInit ()  void reinitEspStrappingPins ()  void setLeds (uint32_t ledsOn)  void softReset ()  void softResetInit ()"},{"location":"apiStm/Bsp_8hpp/#macros","title":"Macros","text":"Type Name define AFIO_MAPR_RESERVED  0xF8E00000 define AUXILIARY_AND_MOTOR_ADC_IRQ_HANDLER  ADC1_2_IRQHandler define CONTROLUART_TX_DMA_HANDLER  DMA1_Channel2_IRQHandler define DEBUGUART_HANDLER  UART4_IRQHandler define DEBUGUART_TX_DMA_HANDLER  DMA2_Channel4_5_IRQHandler define IN4AMASK  GPIO_PIN_5 define IN4BMASK  GPIO_PIN_7 define IN4PORT  GPIOE define SERVOUART_HANDLER  UART5_IRQHandler define USB_LP_IRQ_HANDLER  USB_LP_CAN1_RX0_IRQHandler"},{"location":"apiStm/Bsp_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/Bsp_8hpp/#typedef-adc_channel_t","title":"typedef ADC_channel_t","text":"<pre><code>typedef uint32_t ADC_channel_t;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#typedef-adc_rank_t","title":"typedef ADC_rank_t","text":"<pre><code>typedef uint32_t ADC_rank_t;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#typedef-dma_channel_t","title":"typedef DMA_channel_t","text":"<pre><code>typedef uint32_t DMA_channel_t;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#typedef-pindef","title":"typedef PinDef","text":"<pre><code>using PinDef =  std::pair&lt;GPIO_TypeDef*, uint16_t&gt;;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/Bsp_8hpp/#variable-auxiliaryadc","title":"variable auxiliaryAdc","text":"<pre><code>ADC_TypeDef* const auxiliaryAdc;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-auxiliaryandmotoradcirqn","title":"variable auxiliaryAndMotorAdcIRQn","text":"<pre><code>const IRQn_Type auxiliaryAndMotorAdcIRQn;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-auxiliaryandmotoradcirqprio","title":"variable auxiliaryAndMotorAdcIrqPrio","text":"<pre><code>const unsigned auxiliaryAndMotorAdcIrqPrio;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-batterymiddlevoltageadcchannel","title":"variable batteryMiddleVoltageAdcChannel","text":"<pre><code>const ADC_channel_t batteryMiddleVoltageAdcChannel;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-batterymiddlevoltageadcrank","title":"variable batteryMiddleVoltageAdcRank","text":"<pre><code>const ADC_rank_t batteryMiddleVoltageAdcRank;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-batterymiddlevoltagepin","title":"variable batteryMiddleVoltagePin","text":"<pre><code>const PinDef batteryMiddleVoltagePin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-batteryvoltageadcchannel","title":"variable batteryVoltageAdcChannel","text":"<pre><code>const ADC_channel_t batteryVoltageAdcChannel;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-batteryvoltageadcrank","title":"variable batteryVoltageAdcRank","text":"<pre><code>const ADC_rank_t batteryVoltageAdcRank;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-batteryvoltagepin","title":"variable batteryVoltagePin","text":"<pre><code>const PinDef batteryVoltagePin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-button1pin","title":"variable button1Pin","text":"<pre><code>const PinDef button1Pin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-button2pin","title":"variable button2Pin","text":"<pre><code>const PinDef button2Pin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-button3pin","title":"variable button3Pin","text":"<pre><code>const PinDef button3Pin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-button4pin","title":"variable button4Pin","text":"<pre><code>const PinDef button4Pin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-buttonoffpin","title":"variable buttonOffPin","text":"<pre><code>const PinDef buttonOffPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-buttononpin","title":"variable buttonOnPin","text":"<pre><code>const PinDef buttonOnPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-buttonpin","title":"variable buttonPin","text":"<pre><code>const std::array&lt;PinDef, 6&gt; buttonPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-buzzerpin","title":"variable buzzerPin","text":"<pre><code>const PinDef buzzerPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-controluart","title":"variable controlUart","text":"<pre><code>USART_TypeDef* const controlUart;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-controluartrxdmachannel","title":"variable controlUartRxDmaChannel","text":"<pre><code>DMA_Channel_TypeDef* const controlUartRxDmaChannel;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-controluartrxpin","title":"variable controlUartRxPin","text":"<pre><code>const PinDef controlUartRxPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-controluarttxdmachannel","title":"variable controlUartTxDmaChannel","text":"<pre><code>DMA_Channel_TypeDef* const controlUartTxDmaChannel;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-controluarttxdmairqn","title":"variable controlUartTxDmaIRQn","text":"<pre><code>const IRQn_Type controlUartTxDmaIRQn;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-controluarttxdmairqnprio","title":"variable controlUartTxDmaIRQnPrio","text":"<pre><code>const unsigned controlUartTxDmaIRQnPrio;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-controluarttxpin","title":"variable controlUartTxPin","text":"<pre><code>const PinDef controlUartTxPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-debuguart","title":"variable debugUart","text":"<pre><code>USART_TypeDef* const debugUart;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-debuguartirqn","title":"variable debugUartIRQn","text":"<pre><code>const IRQn_Type debugUartIRQn;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-debuguartirqprio","title":"variable debugUartIrqPrio","text":"<pre><code>const unsigned debugUartIrqPrio;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-debuguartrxdmachannel","title":"variable debugUartRxDmaChannel","text":"<pre><code>DMA_Channel_TypeDef* const debugUartRxDmaChannel;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-debuguartrxpin","title":"variable debugUartRxPin","text":"<pre><code>const PinDef debugUartRxPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-debuguarttxdmachannel","title":"variable debugUartTxDmaChannel","text":"<pre><code>DMA_Channel_TypeDef* const debugUartTxDmaChannel;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-debuguarttxdmairqn","title":"variable debugUartTxDmaIRQn","text":"<pre><code>const IRQn_Type debugUartTxDmaIRQn;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-debuguarttxdmairqprio","title":"variable debugUartTxDmaIrqPrio","text":"<pre><code>const unsigned debugUartTxDmaIrqPrio;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-debuguarttxpin","title":"variable debugUartTxPin","text":"<pre><code>const PinDef debugUartTxPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-encoder1apin","title":"variable encoder1aPin","text":"<pre><code>const PinDef encoder1aPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-encoder1bpin","title":"variable encoder1bPin","text":"<pre><code>const PinDef encoder1bPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-encoder2apin","title":"variable encoder2aPin","text":"<pre><code>const PinDef encoder2aPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-encoder2bpin","title":"variable encoder2bPin","text":"<pre><code>const PinDef encoder2bPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-encoder3apin","title":"variable encoder3aPin","text":"<pre><code>const PinDef encoder3aPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-encoder3bpin","title":"variable encoder3bPin","text":"<pre><code>const PinDef encoder3bPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-encoder4apin","title":"variable encoder4aPin","text":"<pre><code>const PinDef encoder4aPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-encoder4bpin","title":"variable encoder4bPin","text":"<pre><code>const PinDef encoder4bPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-encodertimer","title":"variable encoderTimer","text":"<pre><code>TIM_TypeDef* const encoderTimer[4];\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-esp0pin","title":"variable esp0Pin","text":"<pre><code>const PinDef esp0Pin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-esp12pin","title":"variable esp12Pin","text":"<pre><code>const PinDef esp12Pin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-esp15pin","title":"variable esp15Pin","text":"<pre><code>const PinDef esp15Pin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-esp2pin","title":"variable esp2Pin","text":"<pre><code>const PinDef esp2Pin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-espenpin","title":"variable espEnPin","text":"<pre><code>const PinDef espEnPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-i2cerirqn","title":"variable i2cErIRQn","text":"<pre><code>const IRQn_Type i2cErIRQn;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-i2cevirqn","title":"variable i2cEvIRQn","text":"<pre><code>const IRQn_Type i2cEvIRQn;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-i2cirqnprio","title":"variable i2cIRQnPrio","text":"<pre><code>const unsigned i2cIRQnPrio;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-i2cprio","title":"variable i2cPrio","text":"<pre><code>const int i2cPrio;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-i2cscl","title":"variable i2cScl","text":"<pre><code>const PinDef i2cScl;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-i2csda","title":"variable i2cSda","text":"<pre><code>const PinDef i2cSda;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-in4apin","title":"variable in4aPin","text":"<pre><code>const PinDef in4aPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-in4bpin","title":"variable in4bPin","text":"<pre><code>const PinDef in4bPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-internalreferencevoltageadcrank","title":"variable internalReferenceVoltageAdcRank","text":"<pre><code>const ADC_rank_t internalReferenceVoltageAdcRank;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-led1pin","title":"variable led1Pin","text":"<pre><code>const PinDef led1Pin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-led2pin","title":"variable led2Pin","text":"<pre><code>const PinDef led2Pin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-led3pin","title":"variable led3Pin","text":"<pre><code>const PinDef led3Pin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-led4pin","title":"variable led4Pin","text":"<pre><code>const PinDef led4Pin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-ledpin","title":"variable ledPin","text":"<pre><code>const std::array&lt;PinDef, 4&gt; ledPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-ledpins","title":"variable ledPins","text":"<pre><code>const PinDef ledPins;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-maintaskprio","title":"variable mainTaskPrio","text":"<pre><code>const int mainTaskPrio;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-motortaskprio","title":"variable motorTaskPrio","text":"<pre><code>const int motorTaskPrio;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-powerpin","title":"variable powerPin","text":"<pre><code>const PinDef powerPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-pwm1apin","title":"variable pwm1aPin","text":"<pre><code>const PinDef pwm1aPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-pwm1bpin","title":"variable pwm1bPin","text":"<pre><code>const PinDef pwm1bPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-pwm2apin","title":"variable pwm2aPin","text":"<pre><code>const PinDef pwm2aPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-pwm2bpin","title":"variable pwm2bPin","text":"<pre><code>const PinDef pwm2bPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-pwm3apin","title":"variable pwm3aPin","text":"<pre><code>const PinDef pwm3aPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-pwm3bpin","title":"variable pwm3bPin","text":"<pre><code>const PinDef pwm3bPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-pwm4pin","title":"variable pwm4Pin","text":"<pre><code>const PinDef pwm4Pin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-pwmtimer","title":"variable pwmTimer","text":"<pre><code>TIM_TypeDef* const pwmTimer;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-servo1pin","title":"variable servo1Pin","text":"<pre><code>const PinDef servo1Pin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-servo2pin","title":"variable servo2Pin","text":"<pre><code>const PinDef servo2Pin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-servo3pin","title":"variable servo3Pin","text":"<pre><code>const PinDef servo3Pin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-servo4pin","title":"variable servo4Pin","text":"<pre><code>const PinDef servo4Pin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-servopins","title":"variable servoPins","text":"<pre><code>const PinDef servoPins;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-servotimer","title":"variable servoTimer","text":"<pre><code>TIM_TypeDef* const servoTimer;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-servouart","title":"variable servoUart","text":"<pre><code>USART_TypeDef* const servoUart;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-servouartirqn","title":"variable servoUartIRQn","text":"<pre><code>const IRQn_Type servoUartIRQn;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-servouartirqprio","title":"variable servoUartIrqPrio","text":"<pre><code>const unsigned servoUartIrqPrio;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-servouarttxrxpin","title":"variable servoUartTxRxPin","text":"<pre><code>const PinDef servoUartTxRxPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-softresettaskprio","title":"variable softResetTaskPrio","text":"<pre><code>const int softResetTaskPrio;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-temperatureadcrank","title":"variable temperatureAdcRank","text":"<pre><code>const ADC_rank_t temperatureAdcRank;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-tunneluart","title":"variable tunnelUart","text":"<pre><code>USART_TypeDef* const tunnelUart;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-tunneluartrxdmachannel","title":"variable tunnelUartRxDmaChannel","text":"<pre><code>DMA_Channel_TypeDef* const tunnelUartRxDmaChannel;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-tunneluartrxpin","title":"variable tunnelUartRxPin","text":"<pre><code>const PinDef tunnelUartRxPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-tunneluarttxdmachannel","title":"variable tunnelUartTxDmaChannel","text":"<pre><code>DMA_Channel_TypeDef* const tunnelUartTxDmaChannel;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-tunneluarttxpin","title":"variable tunnelUartTxPin","text":"<pre><code>const PinDef tunnelUartTxPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-ultrasoundtaskprio","title":"variable ultrasoundTaskPrio","text":"<pre><code>const int ultrasoundTaskPrio;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-usbbusdetectionpin","title":"variable usbBusDetectionPin","text":"<pre><code>const PinDef usbBusDetectionPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-usbdnpin","title":"variable usbDnPin","text":"<pre><code>const PinDef usbDnPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-usbdppin","title":"variable usbDpPin","text":"<pre><code>const PinDef usbDpPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-usbdppulluppin","title":"variable usbDpPullUpPin","text":"<pre><code>const PinDef usbDpPullUpPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-usblpirqn","title":"variable usbLpIRQn","text":"<pre><code>const IRQn_Type usbLpIRQn;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-usblpirqnprio","title":"variable usbLpIRQnPrio","text":"<pre><code>constexpr unsigned usbLpIRQnPrio;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-useruart","title":"variable userUart","text":"<pre><code>USART_TypeDef* const userUart;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-useruartrxpin","title":"variable userUartRxPin","text":"<pre><code>const PinDef userUartRxPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-useruarttxpin","title":"variable userUartTxPin","text":"<pre><code>const PinDef userUartTxPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-uts1echopin","title":"variable uts1EchoPin","text":"<pre><code>const PinDef uts1EchoPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-uts1trigpin","title":"variable uts1TrigPin","text":"<pre><code>const PinDef uts1TrigPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-uts2echopin","title":"variable uts2EchoPin","text":"<pre><code>const PinDef uts2EchoPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-uts2trigpin","title":"variable uts2TrigPin","text":"<pre><code>const PinDef uts2TrigPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-uts3echopin","title":"variable uts3EchoPin","text":"<pre><code>const PinDef uts3EchoPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-uts3trigpin","title":"variable uts3TrigPin","text":"<pre><code>const PinDef uts3TrigPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-uts4echopin","title":"variable uts4EchoPin","text":"<pre><code>const PinDef uts4EchoPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-uts4trigpin","title":"variable uts4TrigPin","text":"<pre><code>const PinDef uts4TrigPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-utsechopin","title":"variable utsEchoPin","text":"<pre><code>const std::array&lt;PinDef, 4&gt; utsEchoPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-utsirqprio","title":"variable utsIRQPrio","text":"<pre><code>const uint32_t utsIRQPrio;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-utstimer","title":"variable utsTimer","text":"<pre><code>TIM_TypeDef* const utsTimer;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#variable-utstrigpin","title":"variable utsTrigPin","text":"<pre><code>const std::array&lt;PinDef, 4&gt; utsTrigPin;\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/Bsp_8hpp/#function-ll_adc_setchannelsamplingtimefix","title":"function LL_ADC_SetChannelSamplingTimeFix","text":"<pre><code>inline void LL_ADC_SetChannelSamplingTimeFix (\nADC_TypeDef * ADCx,\nuint32_t Channel,\nuint32_t SamplingTime\n) </code></pre>"},{"location":"apiStm/Bsp_8hpp/#function-ll_gpio_af_remap","title":"function LL_GPIO_AF_Remap","text":"<pre><code>inline void LL_GPIO_AF_Remap (\nuint32_t mask,\nuint32_t value\n) </code></pre>"},{"location":"apiStm/Bsp_8hpp/#function-clocksinit","title":"function clocksInit","text":"<pre><code>inline void clocksInit () </code></pre>"},{"location":"apiStm/Bsp_8hpp/#function-getbuttons","title":"function getButtons","text":"<pre><code>inline uint32_t getButtons () </code></pre>"},{"location":"apiStm/Bsp_8hpp/#function-ispressed","title":"function isPressed","text":"<pre><code>inline bool isPressed (\nPinDef button\n) </code></pre>"},{"location":"apiStm/Bsp_8hpp/#function-pininit","title":"function pinInit","text":"<pre><code>inline void pinInit (\nGPIO_TypeDef * port,\nuint32_t pinMask,\nuint32_t mode,\nuint32_t pull,\nuint32_t speed,\nbool deInitFirst=false\n) </code></pre>"},{"location":"apiStm/Bsp_8hpp/#function-pininit_1","title":"function pinInit","text":"<pre><code>inline void pinInit (\nPinDef pin,\nuint32_t mode,\nuint32_t pull,\nuint32_t speed,\nbool deInitFirst=false\n) </code></pre>"},{"location":"apiStm/Bsp_8hpp/#function-pinread","title":"function pinRead","text":"<pre><code>inline bool pinRead (\nPinDef pin\n) </code></pre>"},{"location":"apiStm/Bsp_8hpp/#function-pintoggle","title":"function pinToggle","text":"<pre><code>inline void pinToggle (\nPinDef pin\n) </code></pre>"},{"location":"apiStm/Bsp_8hpp/#function-pinwrite","title":"function pinWrite","text":"<pre><code>inline void pinWrite (\nPinDef pin,\nbool value\n) </code></pre>"},{"location":"apiStm/Bsp_8hpp/#function-pinsinit","title":"function pinsInit","text":"<pre><code>inline void pinsInit () </code></pre>"},{"location":"apiStm/Bsp_8hpp/#function-reinitespstrappingpins","title":"function reinitEspStrappingPins","text":"<pre><code>inline void reinitEspStrappingPins () </code></pre>"},{"location":"apiStm/Bsp_8hpp/#function-setleds","title":"function setLeds","text":"<pre><code>inline void setLeds (\nuint32_t ledsOn\n) </code></pre>"},{"location":"apiStm/Bsp_8hpp/#function-softreset","title":"function softReset","text":"<pre><code>void softReset () </code></pre>"},{"location":"apiStm/Bsp_8hpp/#function-softresetinit","title":"function softResetInit","text":"<pre><code>void softResetInit () </code></pre>"},{"location":"apiStm/Bsp_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/Bsp_8hpp/#define-afio_mapr_reserved","title":"define AFIO_MAPR_RESERVED","text":"<pre><code>#define AFIO_MAPR_RESERVED 0xF8E00000\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#define-auxiliary_and_motor_adc_irq_handler","title":"define AUXILIARY_AND_MOTOR_ADC_IRQ_HANDLER","text":"<pre><code>#define AUXILIARY_AND_MOTOR_ADC_IRQ_HANDLER ADC1_2_IRQHandler\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#define-controluart_tx_dma_handler","title":"define CONTROLUART_TX_DMA_HANDLER","text":"<pre><code>#define CONTROLUART_TX_DMA_HANDLER DMA1_Channel2_IRQHandler\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#define-debuguart_handler","title":"define DEBUGUART_HANDLER","text":"<pre><code>#define DEBUGUART_HANDLER UART4_IRQHandler\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#define-debuguart_tx_dma_handler","title":"define DEBUGUART_TX_DMA_HANDLER","text":"<pre><code>#define DEBUGUART_TX_DMA_HANDLER DMA2_Channel4_5_IRQHandler\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#define-in4amask","title":"define IN4AMASK","text":"<pre><code>#define IN4AMASK GPIO_PIN_5\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#define-in4bmask","title":"define IN4BMASK","text":"<pre><code>#define IN4BMASK GPIO_PIN_7\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#define-in4port","title":"define IN4PORT","text":"<pre><code>#define IN4PORT GPIOE\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#define-servouart_handler","title":"define SERVOUART_HANDLER","text":"<pre><code>#define SERVOUART_HANDLER UART5_IRQHandler\n</code></pre>"},{"location":"apiStm/Bsp_8hpp/#define-usb_lp_irq_handler","title":"define USB_LP_IRQ_HANDLER","text":"<pre><code>#define USB_LP_IRQ_HANDLER USB_LP_CAN1_RX0_IRQHandler\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/Bsp.hpp</code></p>"},{"location":"apiStm/Bsp_8hpp_source/","title":"File Bsp.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; Bsp.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"FreeRTOSConfig.h\"\n#include \"stm32f1xx_hal.h\"\n#include \"stm32f1xx_hal_cortex.h\"\n#include \"stm32f1xx_hal_gpio.h\"\n#include \"stm32f1xx_ll_adc.h\"\n#include \"stm32f1xx_ll_dma.h\"\n#include \"stm32f1xx_ll_utils.h\"\n\n#include &lt;algorithm&gt;\n#include &lt;array&gt;\n#include &lt;cassert&gt;\n\n#include &lt;algorithm&gt;\n\nusing PinDef = std::pair&lt;GPIO_TypeDef*, uint16_t&gt;;\n\ntypedef uint32_t DMA_channel_t;\ntypedef uint32_t ADC_channel_t;\ntypedef uint32_t ADC_rank_t;\n\n#define USB_LP_IRQ_HANDLER USB_LP_CAN1_RX0_IRQHandler\ninline const IRQn_Type usbLpIRQn = USB_LP_CAN1_RX0_IRQn;\ninline constexpr unsigned usbLpIRQnPrio = 8;\n\ninline const int mainTaskPrio = 4;\ninline const int motorTaskPrio = 2;\ninline const int ultrasoundTaskPrio = 2;\ninline const int i2cPrio = 2;\ninline const int softResetTaskPrio = configMAX_PRIORITIES - 1;\n\ninline void pinInit(GPIO_TypeDef* port, uint32_t pinMask, uint32_t mode,\nuint32_t pull, uint32_t speed, bool deInitFirst = false) {\n\n// HAL_GPIO_Init leaves some flags set if called multiple times\n// on the same pin\nif (deInitFirst)\nHAL_GPIO_DeInit(port, pinMask);\n\nGPIO_InitTypeDef init;\ninit.Pin = pinMask;\ninit.Mode = mode;\ninit.Pull = pull;\ninit.Speed = speed;\nHAL_GPIO_Init(port, &amp;init);\n}\n\ninline void pinInit(PinDef pin, uint32_t mode, uint32_t pull, uint32_t speed,\nbool deInitFirst = false) {\npinInit(pin.first, pin.second, mode, pull, speed, deInitFirst);\n}\n\ninline bool pinRead(PinDef pin) {\nreturn HAL_GPIO_ReadPin(pin.first, pin.second) == GPIO_PIN_SET;\n}\n\ninline void pinWrite(PinDef pin, bool value) {\nHAL_GPIO_WritePin(\npin.first, pin.second, value ? GPIO_PIN_SET : GPIO_PIN_RESET);\n}\n\ninline void pinToggle(PinDef pin) { HAL_GPIO_TogglePin(pin.first, pin.second); }\n\n// This is because AFIO_MAPR register bits SWJ_CFG are write-only, so classical approach\n//   read-modify-write does not work.\n//   DO NOT USE LL_GPIO_AF_*Remap* FUNCTIONS!\n#define AFIO_MAPR_RESERVED 0xF8E00000\ninline void LL_GPIO_AF_Remap(uint32_t mask, uint32_t value) {\nstatic uint32_t mapr = 0;\nmask |= AFIO_MAPR_RESERVED;\nmapr = (mapr &amp; ~mask) | (value &amp; ~AFIO_MAPR_RESERVED);\nAFIO-&gt;MAPR = mapr;\n}\n\ninline void LL_ADC_SetChannelSamplingTimeFix(\nADC_TypeDef* ADCx, uint32_t Channel, uint32_t SamplingTime) {\nvolatile uint32_t* const reg\n= (Channel &amp; ADC_SMPR2_REGOFFSET) ? &amp;ADCx-&gt;SMPR2 : &amp;ADCx-&gt;SMPR1;\nconst uint8_t offset = (Channel &amp; ADC_CHANNEL_SMPx_BITOFFSET_MASK)\n&gt;&gt; ADC_CHANNEL_SMPx_BITOFFSET_POS;\n*reg = (*reg &amp; ~(ADC_SMPR2_SMP0 &lt;&lt; offset))\n| (SamplingTime &amp; ADC_SMPR2_SMP0) &lt;&lt; offset;\n}\n\n#if RBCX_HW_VER == 0x0100\n#error \"Unsupported RBCX_HW_VER\"\n#endif\n\ninline const PinDef led1Pin = std::make_pair(GPIOA, GPIO_PIN_7);\ninline const PinDef led2Pin = std::make_pair(GPIOA, GPIO_PIN_8);\ninline const PinDef led3Pin = std::make_pair(GPIOA, GPIO_PIN_9);\ninline const PinDef led4Pin = std::make_pair(GPIOA, GPIO_PIN_10);\ninline const PinDef ledPins = std::make_pair(\nGPIOA, led1Pin.second | led2Pin.second | led3Pin.second | led4Pin.second);\ninline const std::array&lt;PinDef, 4&gt; ledPin\n= { led1Pin, led2Pin, led3Pin, led4Pin };\n\ninline const PinDef powerPin = std::make_pair(GPIOC, GPIO_PIN_13);\n\ninline const PinDef buttonOffPin = std::make_pair(GPIOE, GPIO_PIN_15);\ninline const PinDef button1Pin = std::make_pair(GPIOE, GPIO_PIN_0);\ninline const PinDef button2Pin = std::make_pair(GPIOD, GPIO_PIN_10);\ninline const PinDef button3Pin = std::make_pair(GPIOB, GPIO_PIN_2);\ninline const PinDef button4Pin = std::make_pair(GPIOD, GPIO_PIN_11);\ninline const PinDef buttonOnPin = std::make_pair(GPIOD, GPIO_PIN_14);\ninline const std::array&lt;PinDef, 6&gt; buttonPin = { buttonOffPin, button1Pin,\nbutton2Pin, button3Pin, button4Pin, buttonOnPin };\n\ninline const PinDef uts1TrigPin = std::make_pair(GPIOE, GPIO_PIN_1);\ninline const PinDef uts1EchoPin = std::make_pair(GPIOE, GPIO_PIN_6);\ninline const PinDef uts2TrigPin = std::make_pair(GPIOE, GPIO_PIN_2);\ninline const PinDef uts2EchoPin = std::make_pair(GPIOD, GPIO_PIN_7);\ninline const PinDef uts3TrigPin = std::make_pair(GPIOE, GPIO_PIN_3);\ninline const PinDef uts3EchoPin = std::make_pair(GPIOD, GPIO_PIN_8);\ninline const PinDef uts4TrigPin = std::make_pair(GPIOE, GPIO_PIN_4);\ninline const PinDef uts4EchoPin = std::make_pair(GPIOD, GPIO_PIN_9);\n\ninline const std::array&lt;PinDef, 4&gt; utsTrigPin\n= { uts1TrigPin, uts2TrigPin, uts3TrigPin, uts4TrigPin };\ninline const std::array&lt;PinDef, 4&gt; utsEchoPin\n= { uts1EchoPin, uts2EchoPin, uts3EchoPin, uts4EchoPin };\n\ninline const uint32_t utsIRQPrio = 7;\n\ninline TIM_TypeDef* const utsTimer = TIM7;\n\ninline const PinDef usbDnPin = std::make_pair(GPIOA, GPIO_PIN_11);\ninline const PinDef usbDpPin = std::make_pair(GPIOA, GPIO_PIN_12);\n// defined in platformio.ini, because used by STM USB C library:\ninline const PinDef usbDpPullUpPin\n= std::make_pair(USBD_DP_PORT, 1 &lt;&lt; USBD_DP_PIN);\ninline const PinDef usbBusDetectionPin = std::make_pair(GPIOA, GPIO_PIN_2);\n\ninline const PinDef userUartTxPin = std::make_pair(GPIOB, GPIO_PIN_6);\ninline const PinDef userUartRxPin = std::make_pair(GPIOB, GPIO_PIN_7);\ninline const PinDef tunnelUartTxPin = std::make_pair(GPIOD, GPIO_PIN_5);\ninline const PinDef tunnelUartRxPin = std::make_pair(GPIOD, GPIO_PIN_6);\ninline const PinDef controlUartTxPin = std::make_pair(GPIOB, GPIO_PIN_10);\ninline const PinDef controlUartRxPin = std::make_pair(GPIOB, GPIO_PIN_11);\ninline const PinDef debugUartTxPin = std::make_pair(GPIOC, GPIO_PIN_10);\ninline const PinDef debugUartRxPin = std::make_pair(GPIOC, GPIO_PIN_11);\ninline const PinDef servoUartTxRxPin = std::make_pair(GPIOC, GPIO_PIN_12);\n\ninline const PinDef i2cSda = std::make_pair(GPIOB, GPIO_PIN_9);\ninline const PinDef i2cScl = std::make_pair(GPIOB, GPIO_PIN_8);\n\ninline const IRQn_Type i2cEvIRQn = I2C1_EV_IRQn;\ninline const IRQn_Type i2cErIRQn = I2C1_ER_IRQn;\ninline const unsigned i2cIRQnPrio = 8;\n\ninline USART_TypeDef* const userUart = USART1;\ninline USART_TypeDef* const tunnelUart = USART2;\ninline USART_TypeDef* const controlUart = USART3;\ninline USART_TypeDef* const debugUart = UART4;\ninline USART_TypeDef* const servoUart = UART5;\n\ninline DMA_Channel_TypeDef* const tunnelUartTxDmaChannel = DMA1_Channel7;\ninline DMA_Channel_TypeDef* const tunnelUartRxDmaChannel = DMA1_Channel6;\n\n#define DEBUGUART_TX_DMA_HANDLER DMA2_Channel4_5_IRQHandler\n#define DEBUGUART_HANDLER UART4_IRQHandler\ninline const IRQn_Type debugUartTxDmaIRQn = DMA2_Channel4_5_IRQn;\ninline const IRQn_Type debugUartIRQn = UART4_IRQn;\ninline const unsigned debugUartTxDmaIrqPrio = 9;\ninline const unsigned debugUartIrqPrio = 10;\ninline DMA_Channel_TypeDef* const debugUartTxDmaChannel = DMA2_Channel5;\ninline DMA_Channel_TypeDef* const debugUartRxDmaChannel = DMA2_Channel3;\n\n#define CONTROLUART_TX_DMA_HANDLER DMA1_Channel2_IRQHandler\ninline const IRQn_Type controlUartTxDmaIRQn = DMA1_Channel2_IRQn;\ninline const unsigned controlUartTxDmaIRQnPrio = 8;\ninline DMA_Channel_TypeDef* const controlUartTxDmaChannel = DMA1_Channel2;\ninline DMA_Channel_TypeDef* const controlUartRxDmaChannel = DMA1_Channel3;\n\n#define SERVOUART_HANDLER UART5_IRQHandler\ninline const IRQn_Type servoUartIRQn = UART5_IRQn;\ninline const unsigned servoUartIrqPrio = 9;\n\n#define IN4PORT GPIOE\n#define IN4AMASK GPIO_PIN_5\n#define IN4BMASK GPIO_PIN_7\ninline const PinDef pwm1bPin = std::make_pair(GPIOE, GPIO_PIN_8);\ninline const PinDef pwm1aPin = std::make_pair(GPIOE, GPIO_PIN_9);\ninline const PinDef pwm2bPin = std::make_pair(GPIOE, GPIO_PIN_10);\ninline const PinDef pwm2aPin = std::make_pair(GPIOE, GPIO_PIN_11);\ninline const PinDef pwm3bPin = std::make_pair(GPIOE, GPIO_PIN_12);\ninline const PinDef pwm3aPin = std::make_pair(GPIOE, GPIO_PIN_13);\ninline const PinDef pwm4Pin = std::make_pair(GPIOE, GPIO_PIN_14);\ninline const PinDef in4bPin = std::make_pair(IN4PORT, IN4BMASK);\ninline const PinDef in4aPin = std::make_pair(IN4PORT, IN4AMASK);\n\ninline TIM_TypeDef* const pwmTimer = TIM1;\n\ninline const PinDef encoder1aPin = std::make_pair(GPIOD, GPIO_PIN_12);\ninline const PinDef encoder1bPin = std::make_pair(GPIOD, GPIO_PIN_13);\ninline const PinDef encoder2aPin = std::make_pair(GPIOA, GPIO_PIN_0);\ninline const PinDef encoder2bPin = std::make_pair(GPIOA, GPIO_PIN_1);\ninline const PinDef encoder3aPin = std::make_pair(GPIOA, GPIO_PIN_15);\ninline const PinDef encoder3bPin = std::make_pair(GPIOB, GPIO_PIN_3);\ninline const PinDef encoder4aPin = std::make_pair(GPIOB, GPIO_PIN_4);\ninline const PinDef encoder4bPin = std::make_pair(GPIOB, GPIO_PIN_5);\n\ninline TIM_TypeDef* const encoderTimer[4] = { TIM4, TIM5, TIM2, TIM3 };\n\ninline const PinDef servo1Pin = std::make_pair(GPIOC, GPIO_PIN_6);\ninline const PinDef servo2Pin = std::make_pair(GPIOC, GPIO_PIN_7);\ninline const PinDef servo3Pin = std::make_pair(GPIOC, GPIO_PIN_8);\ninline const PinDef servo4Pin = std::make_pair(GPIOC, GPIO_PIN_9);\ninline const PinDef servoPins = std::make_pair(GPIOC,\nservo1Pin.second | servo2Pin.second | servo3Pin.second | servo4Pin.second);\n\ninline TIM_TypeDef* const servoTimer = TIM8;\n\ninline const PinDef espEnPin = std::make_pair(GPIOD, GPIO_PIN_4);\ninline const PinDef esp0Pin = std::make_pair(GPIOB, GPIO_PIN_10);\ninline const PinDef esp2Pin = std::make_pair(GPIOB, GPIO_PIN_11);\ninline const PinDef esp12Pin = std::make_pair(GPIOB, GPIO_PIN_15);\ninline const PinDef esp15Pin = std::make_pair(GPIOB, GPIO_PIN_14);\n\ninline const PinDef buzzerPin = std::make_pair(GPIOD, GPIO_PIN_3);\n\ninline const ADC_channel_t batteryVoltageAdcChannel = LL_ADC_CHANNEL_6;\ninline const ADC_channel_t batteryMiddleVoltageAdcChannel = LL_ADC_CHANNEL_3;\n\ninline const ADC_rank_t batteryVoltageAdcRank = LL_ADC_INJ_RANK_1;\ninline const ADC_rank_t internalReferenceVoltageAdcRank = LL_ADC_INJ_RANK_2;\ninline const ADC_rank_t batteryMiddleVoltageAdcRank = LL_ADC_INJ_RANK_3;\ninline const ADC_rank_t temperatureAdcRank = LL_ADC_INJ_RANK_4;\n\ninline const PinDef batteryVoltagePin = std::make_pair(GPIOA, GPIO_PIN_6);\ninline const PinDef batteryMiddleVoltagePin = std::make_pair(GPIOA, GPIO_PIN_3);\n\ninline ADC_TypeDef* const auxiliaryAdc = ADC1;\ninline const IRQn_Type auxiliaryAndMotorAdcIRQn = ADC1_2_IRQn;\ninline const unsigned auxiliaryAndMotorAdcIrqPrio = 9;\n#define AUXILIARY_AND_MOTOR_ADC_IRQ_HANDLER ADC1_2_IRQHandler\n\ninline void clocksInit() {\nRCC_OscInitTypeDef RCC_OscInitStruct;\nRCC_ClkInitTypeDef RCC_ClkInitStruct;\nRCC_PeriphCLKInitTypeDef PeriphClkInit;\n\nRCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;\nRCC_OscInitStruct.HSEState = RCC_HSE_ON;\nRCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;\nRCC_OscInitStruct.HSIState = RCC_HSI_ON;\nRCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;\nRCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;\nRCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;\nif (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK) {\nabort();\n}\n\nRCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK\n| RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;\nRCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;\nRCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;\nRCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;\nRCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;\nif (HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) {\nabort();\n}\n\nPeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;\nPeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLL_DIV1_5;\nPeriphClkInit.AdcClockSelection = RCC_CFGR_ADCPRE_DIV6;\nif (HAL_RCCEx_PeriphCLKConfig(&amp;PeriphClkInit) != HAL_OK) {\nabort();\n}\n\n__HAL_RCC_GPIOA_CLK_ENABLE();\n__HAL_RCC_GPIOB_CLK_ENABLE();\n__HAL_RCC_GPIOC_CLK_ENABLE();\n__HAL_RCC_GPIOD_CLK_ENABLE();\n__HAL_RCC_GPIOE_CLK_ENABLE();\n__HAL_RCC_AFIO_CLK_ENABLE();\n__HAL_RCC_USART1_CLK_ENABLE();\n__HAL_RCC_USART2_CLK_ENABLE();\n__HAL_RCC_USART3_CLK_ENABLE();\n__HAL_RCC_UART4_CLK_ENABLE();\n__HAL_RCC_UART5_CLK_ENABLE();\n__HAL_RCC_DMA1_CLK_ENABLE();\n__HAL_RCC_DMA2_CLK_ENABLE();\n__HAL_RCC_PWR_CLK_ENABLE();\n__HAL_RCC_BKP_CLK_ENABLE();\n__HAL_RCC_TIM1_CLK_ENABLE();\n__HAL_RCC_TIM2_CLK_ENABLE();\n__HAL_RCC_TIM3_CLK_ENABLE();\n__HAL_RCC_TIM4_CLK_ENABLE();\n__HAL_RCC_TIM5_CLK_ENABLE();\n__HAL_RCC_TIM6_CLK_ENABLE();\n__HAL_RCC_TIM7_CLK_ENABLE();\n__HAL_RCC_TIM8_CLK_ENABLE();\n__HAL_RCC_ADC1_CLK_ENABLE();\n__HAL_RCC_I2C1_CLK_ENABLE();\n}\n\n// Set-up ESP32 strapping pins for the normal mode functions. Esp32Manager\n// handles the strapping process and ESP32 reset, and calls this function\n// after the reset is done so that normal function can be restored.\ninline void reinitEspStrappingPins() {\n// controlUart uses esp0Pin and esp2Pin\npinInit(\ncontrolUartTxPin, GPIO_MODE_AF_PP, GPIO_PULLUP, GPIO_SPEED_FREQ_HIGH);\npinInit(controlUartRxPin, GPIO_MODE_AF_INPUT, GPIO_PULLUP,\nGPIO_SPEED_FREQ_HIGH);\n\n// Other pins are unused during normal function, set them to default state\npinInit(esp12Pin, GPIO_MODE_INPUT, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW, true);\npinInit(esp15Pin, GPIO_MODE_INPUT, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW, true);\n}\n\ninline void pinsInit() {\npinInit(ledPins, GPIO_MODE_OUTPUT_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW);\n\npinWrite(powerPin, 1);\npinInit(powerPin, GPIO_MODE_OUTPUT_OD, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW);\n\nfor (auto button : buttonPin)\npinInit(button, GPIO_MODE_INPUT, GPIO_PULLUP, GPIO_SPEED_FREQ_LOW);\n\npinInit(pwm1bPin, GPIO_MODE_AF_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_HIGH);\npinInit(pwm1aPin, GPIO_MODE_AF_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_HIGH);\npinInit(pwm2bPin, GPIO_MODE_AF_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_HIGH);\npinInit(pwm2aPin, GPIO_MODE_AF_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_HIGH);\npinInit(pwm3bPin, GPIO_MODE_AF_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_HIGH);\npinInit(pwm3aPin, GPIO_MODE_AF_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_HIGH);\npinInit(pwm4Pin, GPIO_MODE_AF_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_HIGH);\npinInit(in4bPin, GPIO_MODE_OUTPUT_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW);\npinInit(in4aPin, GPIO_MODE_OUTPUT_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW);\n\npinInit(encoder1aPin, GPIO_MODE_INPUT, GPIO_PULLUP, GPIO_SPEED_FREQ_MEDIUM);\npinInit(encoder1bPin, GPIO_MODE_INPUT, GPIO_PULLUP, GPIO_SPEED_FREQ_MEDIUM);\npinInit(encoder2aPin, GPIO_MODE_INPUT, GPIO_PULLUP, GPIO_SPEED_FREQ_MEDIUM);\npinInit(encoder2bPin, GPIO_MODE_INPUT, GPIO_PULLUP, GPIO_SPEED_FREQ_MEDIUM);\npinInit(encoder3aPin, GPIO_MODE_INPUT, GPIO_PULLUP, GPIO_SPEED_FREQ_MEDIUM);\npinInit(encoder3bPin, GPIO_MODE_INPUT, GPIO_PULLUP, GPIO_SPEED_FREQ_MEDIUM);\npinInit(encoder4aPin, GPIO_MODE_INPUT, GPIO_PULLUP, GPIO_SPEED_FREQ_MEDIUM);\npinInit(encoder4bPin, GPIO_MODE_INPUT, GPIO_PULLUP, GPIO_SPEED_FREQ_MEDIUM);\n\n// I2C\npinInit(i2cScl, GPIO_MODE_AF_OD, GPIO_NOPULL, GPIO_SPEED_FREQ_HIGH);\npinInit(i2cSda, GPIO_MODE_AF_OD, GPIO_NOPULL, GPIO_SPEED_FREQ_HIGH);\n\n// USB\npinInit(usbDnPin, GPIO_MODE_AF_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_HIGH);\npinInit(usbDpPin, GPIO_MODE_AF_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_HIGH);\npinInit(\nusbDpPullUpPin, GPIO_MODE_OUTPUT_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW);\npinInit(\nusbBusDetectionPin, GPIO_MODE_INPUT, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW);\n\n//LL_GPIO_AF_EnableRemap_TIM1();\nLL_GPIO_AF_Remap(AFIO_MAPR_TIM1_REMAP, AFIO_MAPR_TIM1_REMAP_FULLREMAP);\n//LL_GPIO_AF_RemapPartial1_TIM2();\nLL_GPIO_AF_Remap(AFIO_MAPR_TIM2_REMAP, AFIO_MAPR_TIM2_REMAP_PARTIALREMAP1);\n//LL_GPIO_AF_RemapPartial_TIM3();\nLL_GPIO_AF_Remap(AFIO_MAPR_TIM3_REMAP, AFIO_MAPR_TIM3_REMAP_PARTIALREMAP);\n//LL_GPIO_AF_EnableRemap_TIM4();\nLL_GPIO_AF_Remap(AFIO_MAPR_TIM4_REMAP, AFIO_MAPR_TIM4_REMAP);\n//LL_GPIO_AF_Remap_SWJ_NOJTAG();\nLL_GPIO_AF_Remap(AFIO_MAPR_SWJ_CFG, AFIO_MAPR_SWJ_CFG_JTAGDISABLE);\n//I2C1-2\nLL_GPIO_AF_Remap(AFIO_MAPR_I2C1_REMAP, AFIO_MAPR_I2C1_REMAP);\n\npinInit(servoPins, GPIO_MODE_AF_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_MEDIUM);\n\nfor (const auto&amp; p : utsTrigPin) {\npinWrite(p, 0);\npinInit(p, GPIO_MODE_OUTPUT_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_MEDIUM);\n}\nfor (const auto&amp; p : utsEchoPin) {\npinInit(p, GPIO_MODE_IT_RISING_FALLING, GPIO_PULLDOWN,\nGPIO_SPEED_FREQ_MEDIUM);\n}\n\nLL_GPIO_AF_Remap(AFIO_MAPR_USART1_REMAP, AFIO_MAPR_USART1_REMAP);\nLL_GPIO_AF_Remap(AFIO_MAPR_USART2_REMAP, AFIO_MAPR_USART2_REMAP);\n\nHAL_NVIC_SetPriority(EXTI4_IRQn, 7, 0); // ESP_EN\nHAL_NVIC_EnableIRQ(EXTI4_IRQn);\n\nHAL_NVIC_SetPriority(EXTI9_5_IRQn, utsIRQPrio, 0); // Ultrasound\nHAL_NVIC_EnableIRQ(EXTI9_5_IRQn);\n\nHAL_NVIC_SetPriority(i2cEvIRQn, i2cIRQnPrio, 0);\nHAL_NVIC_SetPriority(i2cErIRQn, i2cIRQnPrio, 0);\nHAL_NVIC_EnableIRQ(i2cEvIRQn);\nHAL_NVIC_EnableIRQ(i2cErIRQn);\n\npinInit(buzzerPin, GPIO_MODE_OUTPUT_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW);\n\nreinitEspStrappingPins();\n}\n\ninline bool isPressed(PinDef button) {\nreturn button == buttonOnPin ? pinRead(button) : !pinRead(button);\n}\n\ninline uint32_t getButtons() {\nuint32_t buttons = 0;\nfor (size_t i = 0; i &lt; buttonPin.size(); ++i) {\nbuttons |= isPressed(buttonPin[i]) &lt;&lt; i;\n}\nreturn buttons;\n}\n\ninline void setLeds(uint32_t ledsOn) {\nfor (size_t i = 0; i &lt; ledPin.size(); ++i) {\npinWrite(ledPin[i], ledsOn &amp; (1 &lt;&lt; i));\n}\n}\n\nvoid softResetInit();\nvoid softReset(); // Resets all peripherials to initial state, eg. when ESP32 restarts.\n</code></pre>"},{"location":"apiStm/ButtonController_8hpp/","title":"File ButtonController.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; ButtonController.hpp</p> <p>Go to the source code of this file.</p>"},{"location":"apiStm/ButtonController_8hpp/#public-functions","title":"Public Functions","text":"Type Name void buttonControllerPoll ()  void buttonControllerSetDebug (bool debug)"},{"location":"apiStm/ButtonController_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/ButtonController_8hpp/#function-buttoncontrollerpoll","title":"function buttonControllerPoll","text":"<pre><code>void buttonControllerPoll () </code></pre>"},{"location":"apiStm/ButtonController_8hpp/#function-buttoncontrollersetdebug","title":"function buttonControllerSetDebug","text":"<pre><code>void buttonControllerSetDebug (\nbool debug\n) </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/ButtonController.hpp</code></p>"},{"location":"apiStm/ButtonController_8hpp_source/","title":"File ButtonController.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; ButtonController.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\nvoid buttonControllerPoll();\nvoid buttonControllerSetDebug(bool debug);\n</code></pre>"},{"location":"apiStm/BuzzerController_8hpp/","title":"File BuzzerController.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; BuzzerController.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"Bsp.hpp\"</code></li> </ul>"},{"location":"apiStm/BuzzerController_8hpp/#public-functions","title":"Public Functions","text":"Type Name void buzzerSetState (bool on)"},{"location":"apiStm/BuzzerController_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/BuzzerController_8hpp/#function-buzzersetstate","title":"function buzzerSetState","text":"<pre><code>inline void buzzerSetState (\nbool on\n) </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/BuzzerController.hpp</code></p>"},{"location":"apiStm/BuzzerController_8hpp_source/","title":"File BuzzerController.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; BuzzerController.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"Bsp.hpp\"\n\ninline void buzzerSetState(bool on) { pinWrite(buzzerPin, on); }\n</code></pre>"},{"location":"apiStm/CdcUartTunnel_8hpp/","title":"File CdcUartTunnel.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; CdcUartTunnel.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"usb_cdc.h\"</code></li> </ul>"},{"location":"apiStm/CdcUartTunnel_8hpp/#public-functions","title":"Public Functions","text":"Type Name bool tunnelOnSetLineCodingInIrq (const usb_cdc_line_coding &amp; old, const usb_cdc_line_coding &amp; current)  void tunnelPoll ()  void tunnelUartInit ()"},{"location":"apiStm/CdcUartTunnel_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/CdcUartTunnel_8hpp/#function-tunnelonsetlinecodinginirq","title":"function tunnelOnSetLineCodingInIrq","text":"<pre><code>bool tunnelOnSetLineCodingInIrq (\nconst usb_cdc_line_coding &amp; old,\nconst usb_cdc_line_coding &amp; current\n) </code></pre>"},{"location":"apiStm/CdcUartTunnel_8hpp/#function-tunnelpoll","title":"function tunnelPoll","text":"<pre><code>void tunnelPoll () </code></pre>"},{"location":"apiStm/CdcUartTunnel_8hpp/#function-tunneluartinit","title":"function tunnelUartInit","text":"<pre><code>void tunnelUartInit () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/CdcUartTunnel.hpp</code></p>"},{"location":"apiStm/CdcUartTunnel_8hpp_source/","title":"File CdcUartTunnel.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; CdcUartTunnel.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"usb_cdc.h\"\n\nvoid tunnelUartInit();\nvoid tunnelPoll();\nbool tunnelOnSetLineCodingInIrq(\nconst usb_cdc_line_coding&amp; old, const usb_cdc_line_coding&amp; current);\n</code></pre>"},{"location":"apiStm/ControlLink_8hpp/","title":"File ControlLink.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; ControlLink.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stddef.h&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include \"rbcx.pb.h\"</code></li> </ul>"},{"location":"apiStm/ControlLink_8hpp/#public-functions","title":"Public Functions","text":"Type Name void controlLinkReset ()  bool controlLinkRx (CoprocReq &amp; incoming)  void controlLinkTx (const CoprocStat &amp; outgoing)  void controlUartInit ()"},{"location":"apiStm/ControlLink_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/ControlLink_8hpp/#function-controllinkreset","title":"function controlLinkReset","text":"<pre><code>void controlLinkReset () </code></pre>"},{"location":"apiStm/ControlLink_8hpp/#function-controllinkrx","title":"function controlLinkRx","text":"<pre><code>bool controlLinkRx (\nCoprocReq &amp; incoming\n) </code></pre>"},{"location":"apiStm/ControlLink_8hpp/#function-controllinktx","title":"function controlLinkTx","text":"<pre><code>void controlLinkTx (\nconst CoprocStat &amp; outgoing\n) </code></pre>"},{"location":"apiStm/ControlLink_8hpp/#function-controluartinit","title":"function controlUartInit","text":"<pre><code>void controlUartInit () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/ControlLink.hpp</code></p>"},{"location":"apiStm/ControlLink_8hpp_source/","title":"File ControlLink.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; ControlLink.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;stddef.h&gt;\n#include &lt;stdint.h&gt;\n\n#include \"rbcx.pb.h\"\n\nvoid controlUartInit();\nvoid controlLinkTx(const CoprocStat&amp; outgoing);\nbool controlLinkRx(CoprocReq&amp; incoming);\nvoid controlLinkReset();\n</code></pre>"},{"location":"apiStm/DebugLink_8hpp/","title":"File DebugLink.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; DebugLink.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;sys/types.h&gt;</code></li> </ul>"},{"location":"apiStm/DebugLink_8hpp/#public-functions","title":"Public Functions","text":"Type Name void debugLinkPoll ()  ssize_t debugLinkTx (const uint8_t * data, size_t len)  void debugUartInit ()"},{"location":"apiStm/DebugLink_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/DebugLink_8hpp/#function-debuglinkpoll","title":"function debugLinkPoll","text":"<pre><code>void debugLinkPoll () </code></pre>"},{"location":"apiStm/DebugLink_8hpp/#function-debuglinktx","title":"function debugLinkTx","text":"<pre><code>ssize_t debugLinkTx (\nconst uint8_t * data,\nsize_t len\n) </code></pre>"},{"location":"apiStm/DebugLink_8hpp/#function-debuguartinit","title":"function debugUartInit","text":"<pre><code>void debugUartInit () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/DebugLink.hpp</code></p>"},{"location":"apiStm/DebugLink_8hpp_source/","title":"File DebugLink.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; DebugLink.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;stdint.h&gt;\n#include &lt;sys/types.h&gt;\n\nvoid debugUartInit();\nvoid debugLinkPoll();\nssize_t debugLinkTx(const uint8_t* data, size_t len);\n</code></pre>"},{"location":"apiStm/Dispatcher_8hpp/","title":"File Dispatcher.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; Dispatcher.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"rbcx.pb.h\"</code></li> </ul>"},{"location":"apiStm/Dispatcher_8hpp/#public-functions","title":"Public Functions","text":"Type Name bool dispatcherEnqueueRequest (const CoprocReq &amp; request)  bool dispatcherEnqueueStatus (const CoprocStat &amp; status)  void dispatcherInit ()  void dispatcherPoll ()  void dispatcherReset ()"},{"location":"apiStm/Dispatcher_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/Dispatcher_8hpp/#function-dispatcherenqueuerequest","title":"function dispatcherEnqueueRequest","text":"<pre><code>bool dispatcherEnqueueRequest (\nconst CoprocReq &amp; request\n) </code></pre>"},{"location":"apiStm/Dispatcher_8hpp/#function-dispatcherenqueuestatus","title":"function dispatcherEnqueueStatus","text":"<pre><code>bool dispatcherEnqueueStatus (\nconst CoprocStat &amp; status\n) </code></pre>"},{"location":"apiStm/Dispatcher_8hpp/#function-dispatcherinit","title":"function dispatcherInit","text":"<pre><code>void dispatcherInit () </code></pre>"},{"location":"apiStm/Dispatcher_8hpp/#function-dispatcherpoll","title":"function dispatcherPoll","text":"<pre><code>void dispatcherPoll () </code></pre>"},{"location":"apiStm/Dispatcher_8hpp/#function-dispatcherreset","title":"function dispatcherReset","text":"<pre><code>void dispatcherReset () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/Dispatcher.hpp</code></p>"},{"location":"apiStm/Dispatcher_8hpp_source/","title":"File Dispatcher.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; Dispatcher.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"rbcx.pb.h\"\n\nvoid dispatcherInit();\nbool dispatcherEnqueueStatus(const CoprocStat&amp; status);\nbool dispatcherEnqueueRequest(const CoprocReq&amp; request);\nvoid dispatcherPoll();\nvoid dispatcherReset();\n</code></pre>"},{"location":"apiStm/Esp32Manager_8hpp/","title":"File Esp32Manager.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; Esp32Manager.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"rbcx.pb.h\"</code></li> <li><code>#include \"utils/TickTimer.hpp\"</code></li> </ul>"},{"location":"apiStm/Esp32Manager_8hpp/#classes","title":"Classes","text":"Type Name class Esp32Manager"},{"location":"apiStm/Esp32Manager_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name Esp32Manager sEsp32Manager"},{"location":"apiStm/Esp32Manager_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/Esp32Manager_8hpp/#variable-sesp32manager","title":"variable sEsp32Manager","text":"<pre><code>Esp32Manager sEsp32Manager;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/Esp32Manager.hpp</code></p>"},{"location":"apiStm/Esp32Manager_8hpp_source/","title":"File Esp32Manager.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; Esp32Manager.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"rbcx.pb.h\"\n#include \"utils/TickTimer.hpp\"\n\nclass Esp32Manager {\nEsp32Manager(const Esp32Manager&amp;) = delete;\n\npublic:\nEsp32Manager();\n~Esp32Manager();\n\nvoid init();\nvoid poll();\n\nvoid queueReset(bool bootloader = false);\n\nvoid onEnRisingInIrq();\nvoid onSerialBreakInIrq(bool dtr, bool rst);\n\nbool isInBootloader() const { return m_inBootloader; }\nvoid resetWatchdog();\nvoid setWatchdogInhibit(bool inhibit);\n\nvoid handleSettings(const CoprocReq_EspWatchdogSettings&amp; settings);\n\nprivate:\nenum EnHolderType {\nEnSerialBreaks = 0,\nEnSwReset = 1,\n};\n\nenum QueuedReset {\nRstNone = 0,\nRstNormal = 1,\nRstBootloader = 2,\n};\n\nvoid holdReset(EnHolderType typ);\nvoid releaseReset(EnHolderType typ, bool strapForBootloader = false);\n\nvoid strapPins(bool bootloader);\nvoid unstrapPins();\n\nTickTimer m_unstrapTimer;\nTickTimer m_checkBreakTimer;\nTickTimer m_watchdogTimer;\n\nuint32_t m_enPinHolders;\n\nQueuedReset m_queuedReset;\nbool m_previousEnEdge;\nbool m_lastRts;\nbool m_lastDtr;\nbool m_inBootloader;\nbool m_watchdogInhibit;\n};\n\nextern Esp32Manager sEsp32Manager;\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/","title":"File FreeRTOSConfig.h","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; FreeRTOSConfig.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"stm32f1xx.h\"</code></li> </ul>"},{"location":"apiStm/FreeRTOSConfig_8h/#macros","title":"Macros","text":"Type Name define INCLUDE_eTaskGetState  1 define INCLUDE_uxTaskGetStackHighWaterMark  1 define INCLUDE_uxTaskPriorityGet  1 define INCLUDE_vTaskDelay  1 define INCLUDE_vTaskDelayUntil  1 define INCLUDE_vTaskDelete  1 define INCLUDE_vTaskPrioritySet  1 define INCLUDE_vTaskSuspend  1 define INCLUDE_xEventGroupSetBitFromISR  1 define INCLUDE_xResumeFromISR  1 define INCLUDE_xTaskAbortDelay  1 define INCLUDE_xTaskGetCurrentTaskHandle  1 define INCLUDE_xTaskGetHandle  1 define INCLUDE_xTaskGetIdleTaskHandle  1 define INCLUDE_xTaskGetSchedulerState  1 define INCLUDE_xTaskResumeFromISR  1 define INCLUDE_xTimerPendFunctionCall  0 define USE_FreeRTOS_HEAP_4 define configASSERT (x)  define configCHECK_FOR_STACK_OVERFLOW  2 define configCPU_CLOCK_HZ  (SystemCoreClock) define configGENERATE_RUN_TIME_STATS  0 define configIDLE_SHOULD_YIELD  1 define configKERNEL_INTERRUPT_PRIORITY      (configLIBRARY_LOWEST_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS)) define configLIBRARY_LOWEST_INTERRUPT_PRIORITY  0xf define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY  5 define configMAX_CO_ROUTINE_PRIORITIES  (2) define configMAX_PRIORITIES  (7) define configMAX_SYSCALL_INTERRUPT_PRIORITY      (configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS)) define configMAX_TASK_NAME_LEN  (16) define configMINIMAL_STACK_SIZE  ((uint16_t)64) define configPRIO_BITS  4 /* 15 priority levels */ define configQUEUE_REGISTRY_SIZE  8 define configRECORD_STACK_HIGH_ADDRESS  1 define configSUPPORT_DYNAMIC_ALLOCATION  1 define configSUPPORT_STATIC_ALLOCATION  1 define configTICK_RATE_HZ  ((TickType_t)1000) define configTIMER_QUEUE_LENGTH  10 define configTIMER_TASK_PRIORITY  (3) define configTIMER_TASK_STACK_DEPTH  (512) define configTOTAL_HEAP_SIZE  ((size_t)(15 * 1024)) define configUSE_16_BIT_TICKS  0 define configUSE_APPLICATION_TASK_TAG  0 define configUSE_COUNTING_SEMAPHORES  1 define configUSE_CO_ROUTINES  0 define configUSE_IDLE_HOOK  0 define configUSE_MALLOC_FAILED_HOOK  0 define configUSE_MUTEXES  1 define configUSE_PORT_OPTIMISED_TASK_SELECTION  1 define configUSE_PREEMPTION  1 define configUSE_RECURSIVE_MUTEXES  1 define configUSE_TICK_HOOK  1 define configUSE_TIMERS  1 define configUSE_TRACE_FACILITY  1 define vPortSVCHandler  SVC_Handler define xPortPendSVHandler  PendSV_Handler define xPortSysTickHandler  SysTick_Handler"},{"location":"apiStm/FreeRTOSConfig_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/FreeRTOSConfig_8h/#define-include_etaskgetstate","title":"define INCLUDE_eTaskGetState","text":"<pre><code>#define INCLUDE_eTaskGetState 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-include_uxtaskgetstackhighwatermark","title":"define INCLUDE_uxTaskGetStackHighWaterMark","text":"<pre><code>#define INCLUDE_uxTaskGetStackHighWaterMark 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-include_uxtaskpriorityget","title":"define INCLUDE_uxTaskPriorityGet","text":"<pre><code>#define INCLUDE_uxTaskPriorityGet 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-include_vtaskdelay","title":"define INCLUDE_vTaskDelay","text":"<pre><code>#define INCLUDE_vTaskDelay 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-include_vtaskdelayuntil","title":"define INCLUDE_vTaskDelayUntil","text":"<pre><code>#define INCLUDE_vTaskDelayUntil 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-include_vtaskdelete","title":"define INCLUDE_vTaskDelete","text":"<pre><code>#define INCLUDE_vTaskDelete 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-include_vtaskpriorityset","title":"define INCLUDE_vTaskPrioritySet","text":"<pre><code>#define INCLUDE_vTaskPrioritySet 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-include_vtasksuspend","title":"define INCLUDE_vTaskSuspend","text":"<pre><code>#define INCLUDE_vTaskSuspend 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-include_xeventgroupsetbitfromisr","title":"define INCLUDE_xEventGroupSetBitFromISR","text":"<pre><code>#define INCLUDE_xEventGroupSetBitFromISR 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-include_xresumefromisr","title":"define INCLUDE_xResumeFromISR","text":"<pre><code>#define INCLUDE_xResumeFromISR 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-include_xtaskabortdelay","title":"define INCLUDE_xTaskAbortDelay","text":"<pre><code>#define INCLUDE_xTaskAbortDelay 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-include_xtaskgetcurrenttaskhandle","title":"define INCLUDE_xTaskGetCurrentTaskHandle","text":"<pre><code>#define INCLUDE_xTaskGetCurrentTaskHandle 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-include_xtaskgethandle","title":"define INCLUDE_xTaskGetHandle","text":"<pre><code>#define INCLUDE_xTaskGetHandle 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-include_xtaskgetidletaskhandle","title":"define INCLUDE_xTaskGetIdleTaskHandle","text":"<pre><code>#define INCLUDE_xTaskGetIdleTaskHandle 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-include_xtaskgetschedulerstate","title":"define INCLUDE_xTaskGetSchedulerState","text":"<pre><code>#define INCLUDE_xTaskGetSchedulerState 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-include_xtaskresumefromisr","title":"define INCLUDE_xTaskResumeFromISR","text":"<pre><code>#define INCLUDE_xTaskResumeFromISR 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-include_xtimerpendfunctioncall","title":"define INCLUDE_xTimerPendFunctionCall","text":"<pre><code>#define INCLUDE_xTimerPendFunctionCall 0\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-use_freertos_heap_4","title":"define USE_FreeRTOS_HEAP_4","text":"<pre><code>#define USE_FreeRTOS_HEAP_4 \n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configassert","title":"define configASSERT","text":"<pre><code>#define configASSERT (\nx\n) if ((x) == 0) {                                                            \\\n        taskDISABLE_INTERRUPTS();                                              \\\n        for (;;)                                                               \\\n            ;                                                                  \\\n    }\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configcheck_for_stack_overflow","title":"define configCHECK_FOR_STACK_OVERFLOW","text":"<pre><code>#define configCHECK_FOR_STACK_OVERFLOW 2\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configcpu_clock_hz","title":"define configCPU_CLOCK_HZ","text":"<pre><code>#define configCPU_CLOCK_HZ (SystemCoreClock)\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configgenerate_run_time_stats","title":"define configGENERATE_RUN_TIME_STATS","text":"<pre><code>#define configGENERATE_RUN_TIME_STATS 0\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configidle_should_yield","title":"define configIDLE_SHOULD_YIELD","text":"<pre><code>#define configIDLE_SHOULD_YIELD 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configkernel_interrupt_priority","title":"define configKERNEL_INTERRUPT_PRIORITY","text":"<pre><code>#define configKERNEL_INTERRUPT_PRIORITY (configLIBRARY_LOWEST_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS))\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configlibrary_lowest_interrupt_priority","title":"define configLIBRARY_LOWEST_INTERRUPT_PRIORITY","text":"<pre><code>#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY 0xf\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configlibrary_max_syscall_interrupt_priority","title":"define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY","text":"<pre><code>#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY 5\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configmax_co_routine_priorities","title":"define configMAX_CO_ROUTINE_PRIORITIES","text":"<pre><code>#define configMAX_CO_ROUTINE_PRIORITIES (2)\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configmax_priorities","title":"define configMAX_PRIORITIES","text":"<pre><code>#define configMAX_PRIORITIES (7)\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configmax_syscall_interrupt_priority","title":"define configMAX_SYSCALL_INTERRUPT_PRIORITY","text":"<pre><code>#define configMAX_SYSCALL_INTERRUPT_PRIORITY (configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS))\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configmax_task_name_len","title":"define configMAX_TASK_NAME_LEN","text":"<pre><code>#define configMAX_TASK_NAME_LEN (16)\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configminimal_stack_size","title":"define configMINIMAL_STACK_SIZE","text":"<pre><code>#define configMINIMAL_STACK_SIZE ((uint16_t)64)\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configprio_bits","title":"define configPRIO_BITS","text":"<pre><code>#define configPRIO_BITS 4 /* 15 priority levels */\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configqueue_registry_size","title":"define configQUEUE_REGISTRY_SIZE","text":"<pre><code>#define configQUEUE_REGISTRY_SIZE 8\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configrecord_stack_high_address","title":"define configRECORD_STACK_HIGH_ADDRESS","text":"<pre><code>#define configRECORD_STACK_HIGH_ADDRESS 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configsupport_dynamic_allocation","title":"define configSUPPORT_DYNAMIC_ALLOCATION","text":"<pre><code>#define configSUPPORT_DYNAMIC_ALLOCATION 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configsupport_static_allocation","title":"define configSUPPORT_STATIC_ALLOCATION","text":"<pre><code>#define configSUPPORT_STATIC_ALLOCATION 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configtick_rate_hz","title":"define configTICK_RATE_HZ","text":"<pre><code>#define configTICK_RATE_HZ ((TickType_t)1000)\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configtimer_queue_length","title":"define configTIMER_QUEUE_LENGTH","text":"<pre><code>#define configTIMER_QUEUE_LENGTH 10\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configtimer_task_priority","title":"define configTIMER_TASK_PRIORITY","text":"<pre><code>#define configTIMER_TASK_PRIORITY (3)\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configtimer_task_stack_depth","title":"define configTIMER_TASK_STACK_DEPTH","text":"<pre><code>#define configTIMER_TASK_STACK_DEPTH (512)\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configtotal_heap_size","title":"define configTOTAL_HEAP_SIZE","text":"<pre><code>#define configTOTAL_HEAP_SIZE ((size_t)(15 * 1024))\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configuse_16_bit_ticks","title":"define configUSE_16_BIT_TICKS","text":"<pre><code>#define configUSE_16_BIT_TICKS 0\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configuse_application_task_tag","title":"define configUSE_APPLICATION_TASK_TAG","text":"<pre><code>#define configUSE_APPLICATION_TASK_TAG 0\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configuse_counting_semaphores","title":"define configUSE_COUNTING_SEMAPHORES","text":"<pre><code>#define configUSE_COUNTING_SEMAPHORES 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configuse_co_routines","title":"define configUSE_CO_ROUTINES","text":"<pre><code>#define configUSE_CO_ROUTINES 0\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configuse_idle_hook","title":"define configUSE_IDLE_HOOK","text":"<pre><code>#define configUSE_IDLE_HOOK 0\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configuse_malloc_failed_hook","title":"define configUSE_MALLOC_FAILED_HOOK","text":"<pre><code>#define configUSE_MALLOC_FAILED_HOOK 0\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configuse_mutexes","title":"define configUSE_MUTEXES","text":"<pre><code>#define configUSE_MUTEXES 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configuse_port_optimised_task_selection","title":"define configUSE_PORT_OPTIMISED_TASK_SELECTION","text":"<pre><code>#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configuse_preemption","title":"define configUSE_PREEMPTION","text":"<pre><code>#define configUSE_PREEMPTION 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configuse_recursive_mutexes","title":"define configUSE_RECURSIVE_MUTEXES","text":"<pre><code>#define configUSE_RECURSIVE_MUTEXES 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configuse_tick_hook","title":"define configUSE_TICK_HOOK","text":"<pre><code>#define configUSE_TICK_HOOK 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configuse_timers","title":"define configUSE_TIMERS","text":"<pre><code>#define configUSE_TIMERS 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-configuse_trace_facility","title":"define configUSE_TRACE_FACILITY","text":"<pre><code>#define configUSE_TRACE_FACILITY 1\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-vportsvchandler","title":"define vPortSVCHandler","text":"<pre><code>#define vPortSVCHandler SVC_Handler\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-xportpendsvhandler","title":"define xPortPendSVHandler","text":"<pre><code>#define xPortPendSVHandler PendSV_Handler\n</code></pre>"},{"location":"apiStm/FreeRTOSConfig_8h/#define-xportsystickhandler","title":"define xPortSysTickHandler","text":"<pre><code>#define xPortSysTickHandler SysTick_Handler\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/FreeRTOSConfig.h</code></p>"},{"location":"apiStm/FreeRTOSConfig_8h_source/","title":"File FreeRTOSConfig.h","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; FreeRTOSConfig.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.0.1\n * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n#ifndef FREERTOS_CONFIG_H\n#define FREERTOS_CONFIG_H\n\n#include \"stm32f1xx.h\"\n\n/* Ensure stdint is only used by the compiler, and not the assembler. */\n#if defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__)\n#include &lt;stdint.h&gt;\nextern uint32_t SystemCoreClock;\n#endif\n\n/*  CMSIS-RTOSv2 defines 56 levels of priorities. To be able to use them\n *  all and avoid application misbehavior, configUSE_PORT_OPTIMISED_TASK_SELECTION\n *  must be set to 0 and configMAX_PRIORITIES to 56\n *\n */\n/* #define configMAX_PRIORITIES                 ( 56 ) */\n#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1\n#define configUSE_PREEMPTION 1\n#define configUSE_IDLE_HOOK 0\n#define configUSE_TICK_HOOK 1\n#define configMAX_PRIORITIES (7)\n#define configSUPPORT_STATIC_ALLOCATION 1\n#define configSUPPORT_DYNAMIC_ALLOCATION 1\n#define configCPU_CLOCK_HZ (SystemCoreClock)\n#define configTICK_RATE_HZ ((TickType_t)1000)\n#define configMINIMAL_STACK_SIZE ((uint16_t)64)\n#define configTOTAL_HEAP_SIZE ((size_t)(15 * 1024))\n#define configMAX_TASK_NAME_LEN (16)\n#define configUSE_TRACE_FACILITY 1\n#define configUSE_16_BIT_TICKS 0\n#define configIDLE_SHOULD_YIELD 1\n#define configUSE_MUTEXES 1\n#define configQUEUE_REGISTRY_SIZE 8\n#define configCHECK_FOR_STACK_OVERFLOW 2\n#define configRECORD_STACK_HIGH_ADDRESS 1\n#define configUSE_RECURSIVE_MUTEXES 1\n#define configUSE_MALLOC_FAILED_HOOK 0\n#define configUSE_APPLICATION_TASK_TAG 0\n#define configUSE_COUNTING_SEMAPHORES 1\n#define configGENERATE_RUN_TIME_STATS 0\n\n/* Co-routine definitions. */\n#define configUSE_CO_ROUTINES 0\n#define configMAX_CO_ROUTINE_PRIORITIES (2)\n\n/* Software timer definitions. */\n// #define configUSE_TIMERS 0\n// #define configTIMER_TASK_PRIORITY (2)\n// #define configTIMER_QUEUE_LENGTH 10\n// #define configTIMER_TASK_STACK_DEPTH (configMINIMAL_STACK_SIZE * 2)\n#define configUSE_TIMERS 1\n#define configTIMER_TASK_PRIORITY (3)\n#define configTIMER_QUEUE_LENGTH 10\n#define configTIMER_TASK_STACK_DEPTH (512)\n\n/* Set the following definitions to 1 to include the API function, or zero\nto exclude the API function. */\n#define INCLUDE_vTaskPrioritySet 1\n#define INCLUDE_uxTaskPriorityGet 1\n#define INCLUDE_vTaskDelete 1\n#define INCLUDE_vTaskSuspend 1\n#define INCLUDE_xResumeFromISR 1\n#define INCLUDE_vTaskDelayUntil 1\n#define INCLUDE_vTaskDelay 1\n#define INCLUDE_xTaskGetSchedulerState 1\n#define INCLUDE_xTaskGetCurrentTaskHandle 1\n#define INCLUDE_uxTaskGetStackHighWaterMark 1\n#define INCLUDE_xTaskGetIdleTaskHandle 1\n#define INCLUDE_eTaskGetState 1\n#define INCLUDE_xEventGroupSetBitFromISR 1\n#define INCLUDE_xTimerPendFunctionCall 0\n#define INCLUDE_xTaskAbortDelay 1\n#define INCLUDE_xTaskGetHandle 1\n#define INCLUDE_xTaskResumeFromISR 1\n\n/*------------- CMSIS-RTOS V2 specific defines -----------*/\n/* When using CMSIS-RTOSv2 set configSUPPORT_STATIC_ALLOCATION to 1\n * is mandatory to avoid compile errors.\n * CMSIS-RTOS V2 implmentation requires the following defines\n *\n#define configSUPPORT_STATIC_ALLOCATION          1   &lt;-- cmsis_os threads are created using xTaskCreateStatic() API\n#define configMAX_PRIORITIES                    (56) &lt;-- Priority range in CMSIS-RTOS V2 is [0 .. 56]\n#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0    &lt;-- when set to 1, configMAX_PRIORITIES can't be more than 32 which is not suitable for the new CMSIS-RTOS v2 priority range\n*/\n\n/* the CMSIS-RTOS V2 FreeRTOS wrapper is dependent on the heap implementation used\n * by the application thus the correct define need to be enabled from the list\n * below\n *\n//define USE_FreeRTOS_HEAP_1\n//define USE_FreeRTOS_HEAP_2\n//define USE_FreeRTOS_HEAP_3\n//define USE_FreeRTOS_HEAP_4\n//define USE_FreeRTOS_HEAP_5\n\n*/\n\n#define USE_FreeRTOS_HEAP_4\n\n/* Cortex-M specific definitions. */\n#ifdef __NVIC_PRIO_BITS\n/* __BVIC_PRIO_BITS will be specified when CMSIS is being used. */\n#define configPRIO_BITS __NVIC_PRIO_BITS\n#else\n#define configPRIO_BITS 4 /* 15 priority levels */\n#endif\n\n/* The lowest interrupt priority that can be used in a call to a \"set priority\"\nfunction. */\n#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY 0xf\n\n/* The highest interrupt priority that can be used by any interrupt service\nroutine that makes calls to interrupt safe FreeRTOS API functions.  DO NOT CALL\nINTERRUPT SAFE FREERTOS API FUNCTIONS FROM ANY INTERRUPT THAT HAS A HIGHER\nPRIORITY THAN THIS! (higher priorities are lower numeric values. */\n#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY 5\n\n/* Interrupt priorities used by the kernel port layer itself.  These are generic\nto all Cortex-M ports, and do not rely on any particular library functions. */\n#define configKERNEL_INTERRUPT_PRIORITY                                        \\\n    (configLIBRARY_LOWEST_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS))\n/* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!!\nSee http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. */\n#define configMAX_SYSCALL_INTERRUPT_PRIORITY                                   \\\n    (configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS))\n\n/* Normal assert() semantics without relying on the provision of an assert.h\nheader file. */\n#define configASSERT(x)                                                        \\\n    if ((x) == 0) {                                                            \\\n        taskDISABLE_INTERRUPTS();                                              \\\n        for (;;)                                                               \\\n            ;                                                                  \\\n    }\n\n/* Definitions that map the FreeRTOS port interrupt handlers to their CMSIS\n   standard names. */\n#define vPortSVCHandler SVC_Handler\n#define xPortPendSVHandler PendSV_Handler\n\n/* IMPORTANT: FreeRTOS is using the SysTick as internal time base, thus make sure the system and peripherials are\n              using a different time base (TIM based for example).\n */\n#define xPortSysTickHandler SysTick_Handler\n\n#endif /* FREERTOS_CONFIG_H */\n</code></pre>"},{"location":"apiStm/I2cController_8hpp/","title":"File I2cController.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; I2cController.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"rbcx.pb.h\"</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include &lt;string.h&gt;</code></li> <li><code>#include \"stm32f1xx_hal.h\"</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"task.h\"</code></li> <li><code>#include \"event_groups.h\"</code></li> </ul>"},{"location":"apiStm/I2cController_8hpp/#public-types","title":"Public Types","text":"Type Name enum uint32_t I2cEvents"},{"location":"apiStm/I2cController_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name EventGroupHandle_t i2cEventGroup TaskHandle_t i2cTaskHandle"},{"location":"apiStm/I2cController_8hpp/#public-functions","title":"Public Functions","text":"Type Name uint8_t I2Cdev_IsDeviceReady (uint16_t DevAddress, uint32_t Trials=2, uint32_t Timeout=0)  uint8_t I2Cdev_Master_Receive (uint16_t DevAddress, uint8_t * pData, uint16_t Size, uint32_t Timeout)  uint8_t I2Cdev_Master_Transmit (uint16_t DevAddress, uint8_t * pData, uint16_t Size, uint32_t Timeout)  uint8_t I2Cdev_Mem_Read (uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t * pData, uint16_t Size, uint32_t Timeout)  uint8_t I2Cdev_Mem_Write (uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t * pData, uint16_t Size, uint32_t Timeout)  uint8_t I2Cdev_Slave_Receive (uint8_t * pData, uint16_t Size, uint32_t Timeout)  uint8_t I2Cdev_Slave_Transmit (uint8_t * pData, uint16_t Size, uint32_t Timeout)  uint8_t I2Cdev_init ()  uint8_t I2Cdev_readBit (uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t * data, uint16_t timeout)  uint8_t I2Cdev_readBitW (uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint16_t * data, uint16_t timeout)  uint8_t I2Cdev_readBits (uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t * data, uint16_t timeout)  uint8_t I2Cdev_readBitsW (uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint16_t * data, uint16_t timeout)  uint8_t I2Cdev_readByte (uint8_t devAddr, uint8_t regAddr, uint8_t * data, uint16_t timeout)  uint8_t I2Cdev_readBytes (uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t * data, uint16_t timeout)  uint8_t I2Cdev_readWord (uint8_t devAddr, uint8_t regAddr, uint16_t * data, uint16_t timeout)  uint8_t I2Cdev_readWords (uint8_t devAddr, uint8_t regAddr, uint8_t length, uint16_t * data, uint16_t timeout)  uint8_t I2Cdev_scan ()  uint16_t I2Cdev_writeBit (uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data)  uint16_t I2Cdev_writeBitW (uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint16_t data)  uint16_t I2Cdev_writeBits (uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data)  uint16_t I2Cdev_writeBitsW (uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint16_t data)  uint16_t I2Cdev_writeByte (uint8_t devAddr, uint8_t regAddr, uint8_t data)  uint16_t I2Cdev_writeBytes (uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t * data)  uint16_t I2Cdev_writeWord (uint8_t devAddr, uint8_t regAddr, uint16_t data)  uint16_t I2Cdev_writeWords (uint8_t devAddr, uint8_t regAddr, uint8_t length, uint16_t * data)  void i2cDispatch (const CoprocReq_I2cReq &amp; req)  void i2cReset ()"},{"location":"apiStm/I2cController_8hpp/#macros","title":"Macros","text":"Type Name define I2CDEV_DEFAULT_READ_TIMEOUT  10"},{"location":"apiStm/I2cController_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/I2cController_8hpp/#enum-i2cevents","title":"enum I2cEvents","text":"<pre><code>enum I2cEvents {\nI2C_NONE = 0,\nI2C_MPU_TICK = 1,\nI2C_MESSAGE = 2\n};\n</code></pre>"},{"location":"apiStm/I2cController_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/I2cController_8hpp/#variable-i2ceventgroup","title":"variable i2cEventGroup","text":"<pre><code>EventGroupHandle_t i2cEventGroup;\n</code></pre>"},{"location":"apiStm/I2cController_8hpp/#variable-i2ctaskhandle","title":"variable i2cTaskHandle","text":"<pre><code>TaskHandle_t i2cTaskHandle;\n</code></pre>"},{"location":"apiStm/I2cController_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/I2cController_8hpp/#function-i2cdev_isdeviceready","title":"function I2Cdev_IsDeviceReady","text":"<pre><code>uint8_t I2Cdev_IsDeviceReady (\nuint16_t DevAddress,\nuint32_t Trials=2,\nuint32_t Timeout=0\n) </code></pre>"},{"location":"apiStm/I2cController_8hpp/#function-i2cdev_master_receive","title":"function I2Cdev_Master_Receive","text":"<pre><code>uint8_t I2Cdev_Master_Receive (\nuint16_t DevAddress,\nuint8_t * pData,\nuint16_t Size,\nuint32_t Timeout\n) </code></pre>"},{"location":"apiStm/I2cController_8hpp/#function-i2cdev_master_transmit","title":"function I2Cdev_Master_Transmit","text":"<pre><code>uint8_t I2Cdev_Master_Transmit (\nuint16_t DevAddress,\nuint8_t * pData,\nuint16_t Size,\nuint32_t Timeout\n) </code></pre>"},{"location":"apiStm/I2cController_8hpp/#function-i2cdev_mem_read","title":"function I2Cdev_Mem_Read","text":"<pre><code>uint8_t I2Cdev_Mem_Read (\nuint16_t DevAddress,\nuint16_t MemAddress,\nuint16_t MemAddSize,\nuint8_t * pData,\nuint16_t Size,\nuint32_t Timeout\n) </code></pre>"},{"location":"apiStm/I2cController_8hpp/#function-i2cdev_mem_write","title":"function I2Cdev_Mem_Write","text":"<pre><code>uint8_t I2Cdev_Mem_Write (\nuint16_t DevAddress,\nuint16_t MemAddress,\nuint16_t MemAddSize,\nuint8_t * pData,\nuint16_t Size,\nuint32_t Timeout\n) </code></pre>"},{"location":"apiStm/I2cController_8hpp/#function-i2cdev_slave_receive","title":"function I2Cdev_Slave_Receive","text":"<pre><code>uint8_t I2Cdev_Slave_Receive (\nuint8_t * pData,\nuint16_t Size,\nuint32_t Timeout\n) </code></pre>"},{"location":"apiStm/I2cController_8hpp/#function-i2cdev_slave_transmit","title":"function I2Cdev_Slave_Transmit","text":"<pre><code>uint8_t I2Cdev_Slave_Transmit (\nuint8_t * pData,\nuint16_t Size,\nuint32_t Timeout\n) </code></pre>"},{"location":"apiStm/I2cController_8hpp/#function-i2cdev_init","title":"function I2Cdev_init","text":"<pre><code>uint8_t I2Cdev_init () </code></pre>"},{"location":"apiStm/I2cController_8hpp/#function-i2cdev_readbit","title":"function I2Cdev_readBit","text":"<pre><code>uint8_t I2Cdev_readBit (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitNum,\nuint8_t * data,\nuint16_t timeout\n) </code></pre> <p>Read a single bit from an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to read from </li> <li><code>bitNum</code> Bit position to read (0-7) </li> <li><code>data</code> Container for single bit value </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Status of read operation (true = success) </p>"},{"location":"apiStm/I2cController_8hpp/#function-i2cdev_readbitw","title":"function I2Cdev_readBitW","text":"<pre><code>uint8_t I2Cdev_readBitW (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitNum,\nuint16_t * data,\nuint16_t timeout\n) </code></pre> <p>Read a single bit from a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to read from </li> <li><code>bitNum</code> Bit position to read (0-15) </li> <li><code>data</code> Container for single bit value </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Status of read operation (true = success) </p>"},{"location":"apiStm/I2cController_8hpp/#function-i2cdev_readbits","title":"function I2Cdev_readBits","text":"<pre><code>uint8_t I2Cdev_readBits (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitStart,\nuint8_t length,\nuint8_t * data,\nuint16_t timeout\n) </code></pre> <p>Read multiple bits from an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to read from </li> <li><code>bitStart</code> First bit position to read (0-7) </li> <li><code>length</code> Number of bits to read (not more than 8) </li> <li><code>data</code> Container for right-aligned value (i.e. '101' read from any bitStart position will equal 0x05) </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Status of read operation (true = success) </p>"},{"location":"apiStm/I2cController_8hpp/#function-i2cdev_readbitsw","title":"function I2Cdev_readBitsW","text":"<pre><code>uint8_t I2Cdev_readBitsW (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitStart,\nuint8_t length,\nuint16_t * data,\nuint16_t timeout\n) </code></pre> <p>Read multiple bits from a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to read from </li> <li><code>bitStart</code> First bit position to read (0-15) </li> <li><code>length</code> Number of bits to read (not more than 16) </li> <li><code>data</code> Container for right-aligned value (i.e. '101' read from any bitStart position will equal 0x05) </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Status of read operation (1 = success, 0 = failure, -1 = timeout) </p>"},{"location":"apiStm/I2cController_8hpp/#function-i2cdev_readbyte","title":"function I2Cdev_readByte","text":"<pre><code>uint8_t I2Cdev_readByte (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t * data,\nuint16_t timeout\n) </code></pre> <p>Read single byte from an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to read from </li> <li><code>data</code> Container for byte value read from device </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Status of read operation (true = success) </p>"},{"location":"apiStm/I2cController_8hpp/#function-i2cdev_readbytes","title":"function I2Cdev_readBytes","text":"<pre><code>uint8_t I2Cdev_readBytes (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t length,\nuint8_t * data,\nuint16_t timeout\n) </code></pre> <p>Read multiple bytes from an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> First register regAddr to read from </li> <li><code>length</code> Number of bytes to read </li> <li><code>data</code> Buffer to store read data in </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Number of bytes read (-1 indicates failure) </p>"},{"location":"apiStm/I2cController_8hpp/#function-i2cdev_readword","title":"function I2Cdev_readWord","text":"<pre><code>uint8_t I2Cdev_readWord (\nuint8_t devAddr,\nuint8_t regAddr,\nuint16_t * data,\nuint16_t timeout\n) </code></pre> <p>Read single word from a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to read from </li> <li><code>data</code> Container for word value read from device </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Status of read operation (true = success) </p>"},{"location":"apiStm/I2cController_8hpp/#function-i2cdev_readwords","title":"function I2Cdev_readWords","text":"<pre><code>uint8_t I2Cdev_readWords (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t length,\nuint16_t * data,\nuint16_t timeout\n) </code></pre> <p>Read multiple words from a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> First register regAddr to read from </li> <li><code>length</code> Number of words to read </li> <li><code>data</code> Buffer to store read data in </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Number of words read (-1 indicates failure) </p>"},{"location":"apiStm/I2cController_8hpp/#function-i2cdev_scan","title":"function I2Cdev_scan","text":"<pre><code>uint8_t I2Cdev_scan () </code></pre>"},{"location":"apiStm/I2cController_8hpp/#function-i2cdev_writebit","title":"function I2Cdev_writeBit","text":"<pre><code>uint16_t I2Cdev_writeBit (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitNum,\nuint8_t data\n) </code></pre> <p>write a single bit in an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to write to </li> <li><code>bitNum</code> Bit position to write (0-7) </li> <li><code>value</code> New bit value to write </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"apiStm/I2cController_8hpp/#function-i2cdev_writebitw","title":"function I2Cdev_writeBitW","text":"<pre><code>uint16_t I2Cdev_writeBitW (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitNum,\nuint16_t data\n) </code></pre> <p>write a single bit in a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to write to </li> <li><code>bitNum</code> Bit position to write (0-15) </li> <li><code>value</code> New bit value to write </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"apiStm/I2cController_8hpp/#function-i2cdev_writebits","title":"function I2Cdev_writeBits","text":"<pre><code>uint16_t I2Cdev_writeBits (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitStart,\nuint8_t length,\nuint8_t data\n) </code></pre> <p>Write multiple bits in an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to write to </li> <li><code>bitStart</code> First bit position to write (0-7) </li> <li><code>length</code> Number of bits to write (not more than 8) </li> <li><code>data</code> Right-aligned value to write </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"apiStm/I2cController_8hpp/#function-i2cdev_writebitsw","title":"function I2Cdev_writeBitsW","text":"<pre><code>uint16_t I2Cdev_writeBitsW (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitStart,\nuint8_t length,\nuint16_t data\n) </code></pre> <p>Write multiple bits in a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to write to </li> <li><code>bitStart</code> First bit position to write (0-15) </li> <li><code>length</code> Number of bits to write (not more than 16) </li> <li><code>data</code> Right-aligned value to write </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"apiStm/I2cController_8hpp/#function-i2cdev_writebyte","title":"function I2Cdev_writeByte","text":"<pre><code>uint16_t I2Cdev_writeByte (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t data\n) </code></pre> <p>Write single byte to an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register address to write to </li> <li><code>data</code> New byte value to write </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"apiStm/I2cController_8hpp/#function-i2cdev_writebytes","title":"function I2Cdev_writeBytes","text":"<pre><code>uint16_t I2Cdev_writeBytes (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t length,\nuint8_t * data\n) </code></pre> <p>Write multiple bytes to an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> First register address to write to </li> <li><code>length</code> Number of bytes to write </li> <li><code>data</code> Buffer to copy new data from </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"apiStm/I2cController_8hpp/#function-i2cdev_writeword","title":"function I2Cdev_writeWord","text":"<pre><code>uint16_t I2Cdev_writeWord (\nuint8_t devAddr,\nuint8_t regAddr,\nuint16_t data\n) </code></pre> <p>Write single word to a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register address to write to </li> <li><code>data</code> New word value to write </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"apiStm/I2cController_8hpp/#function-i2cdev_writewords","title":"function I2Cdev_writeWords","text":"<pre><code>uint16_t I2Cdev_writeWords (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t length,\nuint16_t * data\n) </code></pre> <p>Write multiple words to a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> First register address to write to </li> <li><code>length</code> Number of words to write </li> <li><code>data</code> Buffer to copy new data from </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"apiStm/I2cController_8hpp/#function-i2cdispatch","title":"function i2cDispatch","text":"<pre><code>void i2cDispatch (\nconst CoprocReq_I2cReq &amp; req\n) </code></pre>"},{"location":"apiStm/I2cController_8hpp/#function-i2creset","title":"function i2cReset","text":"<pre><code>void i2cReset () </code></pre>"},{"location":"apiStm/I2cController_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/I2cController_8hpp/#define-i2cdev_default_read_timeout","title":"define I2CDEV_DEFAULT_READ_TIMEOUT","text":"<pre><code>#define I2CDEV_DEFAULT_READ_TIMEOUT 10\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/I2cController.hpp</code></p>"},{"location":"apiStm/I2cController_8hpp_source/","title":"File I2cController.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; I2cController.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>// I2Cdev library collection - Main I2C device class header file\n// Abstracts bit and byte I2C R/W functions into a convenient class\n// 6/9/2012 by Jeff Rowberg &lt;jeff@rowberg.net&gt;\n// 6/6/2015 by Andrey Voloshin &lt;voloshin@think.in.ua&gt;\n//\n// Changelog:\n//      2015-06-06 - ported to STM32 HAL library from Arduino code\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2013 Jeff Rowberg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n#pragma once\n\n#include \"rbcx.pb.h\"\n\n#include &lt;stdint.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#include \"stm32f1xx_hal.h\"\n\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n\n#include \"event_groups.h\"\n\nenum I2cEvents : uint32_t {\nI2C_NONE = 0,\nI2C_MPU_TICK = 1,\nI2C_MESSAGE = 2,\n};\n\nextern TaskHandle_t i2cTaskHandle;\nextern EventGroupHandle_t i2cEventGroup;\n\nvoid i2cDispatch(const CoprocReq_I2cReq&amp; req);\nvoid i2cReset();\n\n#define I2CDEV_DEFAULT_READ_TIMEOUT 10\n\nuint8_t I2Cdev_init();\n\nuint8_t I2Cdev_Master_Transmit(\nuint16_t DevAddress, uint8_t* pData, uint16_t Size, uint32_t Timeout);\nuint8_t I2Cdev_Master_Receive(\nuint16_t DevAddress, uint8_t* pData, uint16_t Size, uint32_t Timeout);\nuint8_t I2Cdev_Slave_Transmit(uint8_t* pData, uint16_t Size, uint32_t Timeout);\nuint8_t I2Cdev_Slave_Receive(uint8_t* pData, uint16_t Size, uint32_t Timeout);\nuint8_t I2Cdev_Mem_Write(uint16_t DevAddress, uint16_t MemAddress,\nuint16_t MemAddSize, uint8_t* pData, uint16_t Size, uint32_t Timeout);\nuint8_t I2Cdev_Mem_Read(uint16_t DevAddress, uint16_t MemAddress,\nuint16_t MemAddSize, uint8_t* pData, uint16_t Size, uint32_t Timeout);\nuint8_t I2Cdev_IsDeviceReady(\nuint16_t DevAddress, uint32_t Trials = 2, uint32_t Timeout = 0);\n\nuint8_t I2Cdev_scan();\n\nuint8_t I2Cdev_readBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum,\nuint8_t* data, uint16_t timeout);\nuint8_t I2Cdev_readBitW(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum,\nuint16_t* data, uint16_t timeout);\nuint8_t I2Cdev_readBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart,\nuint8_t length, uint8_t* data, uint16_t timeout);\nuint8_t I2Cdev_readBitsW(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart,\nuint8_t length, uint16_t* data, uint16_t timeout);\nuint8_t I2Cdev_readByte(\nuint8_t devAddr, uint8_t regAddr, uint8_t* data, uint16_t timeout);\nuint8_t I2Cdev_readWord(\nuint8_t devAddr, uint8_t regAddr, uint16_t* data, uint16_t timeout);\nuint8_t I2Cdev_readBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length,\nuint8_t* data, uint16_t timeout);\nuint8_t I2Cdev_readWords(uint8_t devAddr, uint8_t regAddr, uint8_t length,\nuint16_t* data, uint16_t timeout);\n\nuint16_t I2Cdev_writeBit(\nuint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data);\nuint16_t I2Cdev_writeBitW(\nuint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint16_t data);\nuint16_t I2Cdev_writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart,\nuint8_t length, uint8_t data);\nuint16_t I2Cdev_writeBitsW(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart,\nuint8_t length, uint16_t data);\nuint16_t I2Cdev_writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data);\nuint16_t I2Cdev_writeWord(uint8_t devAddr, uint8_t regAddr, uint16_t data);\nuint16_t I2Cdev_writeBytes(\nuint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t* data);\nuint16_t I2Cdev_writeWords(\nuint8_t devAddr, uint8_t regAddr, uint8_t length, uint16_t* data);\n</code></pre>"},{"location":"apiStm/Motor_8hpp/","title":"File Motor.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; Motor.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"utils/Debug.hpp\"</code></li> <li><code>#include \"utils/Regulator.hpp\"</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"apiStm/Motor_8hpp/#classes","title":"Classes","text":"Type Name class Motor"},{"location":"apiStm/Motor_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name const uint16_t motorLoopFreq   = = 100"},{"location":"apiStm/Motor_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/Motor_8hpp/#variable-motorloopfreq","title":"variable motorLoopFreq","text":"<pre><code>const uint16_t motorLoopFreq;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/Motor.hpp</code></p>"},{"location":"apiStm/Motor_8hpp_source/","title":"File Motor.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; Motor.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"utils/Debug.hpp\"\n#include \"utils/Regulator.hpp\"\n\n#include &lt;stdint.h&gt;\n\ninline const uint16_t motorLoopFreq = 100;\n\nclass Motor {\npublic:\nMotor() {\nm_lastEncTicks = 0;\nreset();\n}\n\nvoid reset() {\nm_velocityReg = Regulator(INT16_MAX, 150000, 300000, 20000);\nm_positionReg = Regulator(500, 1000, 0, 0);\nm_dither = 0;\nm_targetVelocity = 0;\nm_actualPower = 0;\nm_actualPosition = 0;\nm_targetPosition = 0;\nm_actualTicksPerLoop = 0;\nm_posEpsilon = 3;\nm_velEpsilon = 3;\nm_maxAccel = 2000 / motorLoopFreq;\nm_mode = MotorMode_POWER;\n}\n\nbool atTargetPosition() const {\nreturn uint32_t(abs(m_actualPosition - m_targetPosition))\n&lt;= m_posEpsilon;\n}\n\nbool atStandstill() const {\nreturn uint32_t(abs(m_actualTicksPerLoop)) &lt;= m_velEpsilon;\n}\n\nMotorMode mode() const { return m_mode; }\nvoid modeChange(MotorMode newMode) { m_mode = newMode; }\n\nvoid reportStat(CoprocStat_MotorStat&amp; stat) {\nstat.mode = m_mode;\nstat.position = m_actualPosition;\nstat.power = m_actualPower;\nstat.velocity = m_actualTicksPerLoop * motorLoopFreq;\n};\n\nint16_t poll(uint16_t encTicks) {\nm_actualTicksPerLoop = encTicks - m_lastEncTicks;\nm_actualPosition += m_actualTicksPerLoop;\nm_lastEncTicks = encTicks;\n\nswitch (m_mode) {\ncase MotorMode_POSITION:\ncase MotorMode_POSITION_IDLE: {\n// DEBUG(\"i:%ld e:%ld s:%ld -&gt; v:%ld\\n\", m_positionReg.integrator(),\n//     m_positionReg.e(), m_actualPosition, m_positionReg.output());\nif (atTargetPosition() &amp;&amp; atStandstill()) {\nm_positionReg.clear();\nm_targetVelocity = 0;\nmodeChange(MotorMode_POSITION_IDLE);\n} else {\nauto action\n= m_positionReg.process(m_targetPosition, m_actualPosition);\n\n// Limit ramp-up to max acceleration\nif (action &gt; m_targetVelocity + m_maxAccel) {\nm_targetVelocity += m_maxAccel;\n} else if (action &lt; m_targetVelocity - m_maxAccel) {\nm_targetVelocity -= m_maxAccel;\n} else {\nm_targetVelocity = action;\n}\n}\n} // fallthrough\ncase MotorMode_VELOCITY: {\nint16_t targetTicksPerLoop = m_targetVelocity / motorLoopFreq;\nuint16_t targetTicksRem = abs(m_targetVelocity % motorLoopFreq);\nif ((targetTicksRem * 4) / motorLoopFreq &gt; m_dither) {\ntargetTicksPerLoop += m_targetVelocity &lt; 0 ? -1 : 1;\n}\nif (++m_dither &gt;= 4) {\nm_dither = 0;\n}\n\nauto action = m_velocityReg.process(\ntargetTicksPerLoop, m_actualTicksPerLoop);\nm_actualPower = action;\n} break;\ndefault:\nbreak;\n}\nreturn m_actualPower;\n}\n\nvoid setTargetPower(int16_t power) {\nif (m_mode != MotorMode_POWER) {\nmodeChange(MotorMode_POWER);\n}\nm_actualPower = power;\n}\n\nvoid setTargetBrakingPower(int16_t brakingPower) {\nif (m_mode != MotorMode_BRAKE) {\nmodeChange(MotorMode_BRAKE);\n}\nm_actualPower = brakingPower;\n}\n\nvoid setTargetVelocity(int16_t ticksPerSec) {\nif (m_mode != MotorMode_VELOCITY) {\nm_velocityReg.clear();\nmodeChange(MotorMode_VELOCITY);\n}\nm_targetVelocity = ticksPerSec;\n}\n\nvoid homePosition(int32_t homedTicks) {\nm_targetPosition = homedTicks;\nm_actualPosition = homedTicks;\n}\n\nvoid setTargetPosition(\nconst CoprocReq_MotorReq_SetPosition&amp; req, bool additive) {\nif (m_mode != MotorMode_POSITION) {\nm_positionReg.clear();\nmodeChange(MotorMode_POSITION);\n}\nif (additive) {\nm_targetPosition += req.targetPosition;\n} else {\nm_targetPosition = req.targetPosition;\n}\nm_positionReg.setMaxOutput(req.runningVelocity);\n}\n\nvoid setVelocityPid(const RegCoefs&amp; coefs) {\nm_velocityReg.setP(coefs.p);\nm_velocityReg.setI(coefs.i);\nm_velocityReg.setD(coefs.d);\nm_velocityReg.clear();\n}\n\nvoid setPositionPid(const RegCoefs&amp; coefs) {\nm_positionReg.setP(coefs.p);\nm_positionReg.setI(coefs.i);\nm_positionReg.setD(coefs.d);\nm_positionReg.clear();\n}\n\nvoid setConfig(const MotorConfig&amp; config) {\nm_velEpsilon = config.velEpsilon;\nm_posEpsilon = config.posEpsilon;\nm_maxAccel = config.maxAccel / motorLoopFreq;\n}\n\nprivate:\nRegulator m_velocityReg;\nRegulator m_positionReg;\nint16_t m_actualPower;\nint16_t m_targetVelocity;\nint32_t m_targetPosition;\nint32_t m_actualPosition;\nint16_t m_actualTicksPerLoop;\nuint16_t m_dither;\nuint16_t m_lastEncTicks;\nuint16_t m_posEpsilon;\nuint16_t m_velEpsilon;\nuint16_t m_maxAccel;\nMotorMode m_mode;\n};\n</code></pre>"},{"location":"apiStm/MotorController_8hpp/","title":"File MotorController.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; MotorController.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"rbcx.pb.h\"</code></li> </ul>"},{"location":"apiStm/MotorController_8hpp/#public-functions","title":"Public Functions","text":"Type Name void motorDispatch (const CoprocReq_MotorReq &amp; request)  void motorInit ()  void motorReset ()"},{"location":"apiStm/MotorController_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/MotorController_8hpp/#function-motordispatch","title":"function motorDispatch","text":"<pre><code>void motorDispatch (\nconst CoprocReq_MotorReq &amp; request\n) </code></pre>"},{"location":"apiStm/MotorController_8hpp/#function-motorinit","title":"function motorInit","text":"<pre><code>void motorInit () </code></pre>"},{"location":"apiStm/MotorController_8hpp/#function-motorreset","title":"function motorReset","text":"<pre><code>void motorReset () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/MotorController.hpp</code></p>"},{"location":"apiStm/MotorController_8hpp_source/","title":"File MotorController.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; MotorController.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"rbcx.pb.h\"\n\nvoid motorInit();\nvoid motorDispatch(const CoprocReq_MotorReq&amp; request);\nvoid motorReset();\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/","title":"File Mpu6050.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; Mpu6050.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"I2cController.hpp\"</code></li> <li><code>#include &lt;stdbool.h&gt;</code></li> </ul>"},{"location":"apiStm/Mpu6050_8hpp/#classes","title":"Classes","text":"Type Name struct MPU6050_t"},{"location":"apiStm/Mpu6050_8hpp/#public-types","title":"Public Types","text":"Type Name typedef struct MPU6050_t MPU6050_t"},{"location":"apiStm/Mpu6050_8hpp/#public-functions","title":"Public Functions","text":"Type Name void MPU6050 (uint8_t address)  bool MPU6050_getAccelFIFOEnabled ()  bool MPU6050_getAccelXSelfTest ()  bool MPU6050_getAccelYSelfTest ()  bool MPU6050_getAccelZSelfTest ()  void MPU6050_getAcceleration (int16_t * x, int16_t * y, int16_t * z)  int16_t MPU6050_getAccelerationX ()  int16_t MPU6050_getAccelerationY ()  int16_t MPU6050_getAccelerationZ ()  uint8_t MPU6050_getAccelerometerPowerOnDelay ()  uint8_t MPU6050_getAuxVDDIOLevel ()  bool MPU6050_getClockOutputEnabled ()  uint8_t MPU6050_getClockSource ()  uint8_t MPU6050_getDHPFMode ()  uint8_t MPU6050_getDLPFMode ()  uint8_t MPU6050_getDMPConfig1 ()  uint8_t MPU6050_getDMPConfig2 ()  bool MPU6050_getDMPEnabled ()  bool MPU6050_getDMPInt0Status ()  bool MPU6050_getDMPInt1Status ()  bool MPU6050_getDMPInt2Status ()  bool MPU6050_getDMPInt3Status ()  bool MPU6050_getDMPInt4Status ()  bool MPU6050_getDMPInt5Status ()  uint8_t MPU6050_getDeviceID ()  uint8_t MPU6050_getExternalFrameSync ()  uint8_t MPU6050_getExternalSensorByte (int position)  uint16_t MPU6050_getExternalSensorWord (int position)  bool MPU6050_getExternalShadowDelayEnabled ()  uint8_t MPU6050_getFIFOByte ()  void MPU6050_getFIFOBytes (uint8_t * data, uint8_t length)  uint16_t MPU6050_getFIFOCount ()  bool MPU6050_getFIFOEnabled ()  bool MPU6050_getFSyncInterruptEnabled ()  bool MPU6050_getFSyncInterruptLevel ()  uint8_t MPU6050_getFreefallDetectionCounterDecrement ()  uint8_t MPU6050_getFreefallDetectionDuration ()  uint8_t MPU6050_getFreefallDetectionThreshold ()  uint8_t MPU6050_getFullScaleAccelRange ()  uint8_t MPU6050_getFullScaleGyroRange ()  bool MPU6050_getI2CBypassEnabled ()  bool MPU6050_getI2CMasterModeEnabled ()  bool MPU6050_getIntDMPEnabled ()  bool MPU6050_getIntDMPStatus ()  bool MPU6050_getIntDataReadyEnabled ()  bool MPU6050_getIntDataReadyStatus ()  uint8_t MPU6050_getIntEnabled ()  bool MPU6050_getIntFIFOBufferOverflowEnabled ()  bool MPU6050_getIntFIFOBufferOverflowStatus ()  bool MPU6050_getIntFreefallEnabled ()  bool MPU6050_getIntFreefallStatus ()  bool MPU6050_getIntI2CMasterEnabled ()  bool MPU6050_getIntI2CMasterStatus ()  bool MPU6050_getIntMotionEnabled ()  bool MPU6050_getIntMotionStatus ()  bool MPU6050_getIntPLLReadyEnabled ()  bool MPU6050_getIntPLLReadyStatus ()  uint8_t MPU6050_getIntStatus ()  bool MPU6050_getIntZeroMotionEnabled ()  bool MPU6050_getIntZeroMotionStatus ()  bool MPU6050_getInterruptDrive ()  bool MPU6050_getInterruptLatch ()  bool MPU6050_getInterruptLatchClear ()  bool MPU6050_getInterruptMode ()  bool MPU6050_getLostArbitration ()  uint8_t MPU6050_getMasterClockSpeed ()  void MPU6050_getMotion6 (int16_t * ax, int16_t * ay, int16_t * az, int16_t * gx, int16_t * gy, int16_t * gz)  void MPU6050_getMotion9 (int16_t * ax, int16_t * ay, int16_t * az, int16_t * gx, int16_t * gy, int16_t * gz, int16_t * mx, int16_t * my, int16_t * mz)  uint8_t MPU6050_getMotionDetectionCounterDecrement ()  uint8_t MPU6050_getMotionDetectionDuration ()  uint8_t MPU6050_getMotionDetectionThreshold ()  bool MPU6050_getMultiMasterEnabled ()  uint8_t MPU6050_getOTPBankValid ()  bool MPU6050_getPassthroughStatus ()  uint8_t MPU6050_getRate ()  void MPU6050_getRotation (int16_t * x, int16_t * y, int16_t * z)  int16_t MPU6050_getRotationX ()  int16_t MPU6050_getRotationY ()  int16_t MPU6050_getRotationZ ()  uint8_t MPU6050_getSlate4InputByte ()  bool MPU6050_getSlave0FIFOEnabled ()  bool MPU6050_getSlave0Nack ()  bool MPU6050_getSlave1FIFOEnabled ()  bool MPU6050_getSlave1Nack ()  bool MPU6050_getSlave2FIFOEnabled ()  bool MPU6050_getSlave2Nack ()  bool MPU6050_getSlave3FIFOEnabled ()  bool MPU6050_getSlave3Nack ()  uint8_t MPU6050_getSlave4Address ()  bool MPU6050_getSlave4Enabled ()  bool MPU6050_getSlave4InterruptEnabled ()  bool MPU6050_getSlave4IsDone ()  uint8_t MPU6050_getSlave4MasterDelay ()  bool MPU6050_getSlave4Nack ()  uint8_t MPU6050_getSlave4Register ()  bool MPU6050_getSlave4WriteMode ()  uint8_t MPU6050_getSlaveAddress (uint8_t num)  uint8_t MPU6050_getSlaveDataLength (uint8_t num)  bool MPU6050_getSlaveDelayEnabled (uint8_t num)  bool MPU6050_getSlaveEnabled (uint8_t num)  bool MPU6050_getSlaveReadWriteTransitionEnabled ()  uint8_t MPU6050_getSlaveRegister (uint8_t num)  bool MPU6050_getSlaveWordByteSwap (uint8_t num)  bool MPU6050_getSlaveWordGroupOffset (uint8_t num)  bool MPU6050_getSlaveWriteMode (uint8_t num)  bool MPU6050_getSleepEnabled ()  bool MPU6050_getStandbyXAccelEnabled ()  bool MPU6050_getStandbyXGyroEnabled ()  bool MPU6050_getStandbyYAccelEnabled ()  bool MPU6050_getStandbyYGyroEnabled ()  bool MPU6050_getStandbyZAccelEnabled ()  bool MPU6050_getStandbyZGyroEnabled ()  bool MPU6050_getTempFIFOEnabled ()  bool MPU6050_getTempSensorEnabled ()  int16_t MPU6050_getTemperature ()  bool MPU6050_getWaitForExternalSensorEnabled ()  bool MPU6050_getWakeCycleEnabled ()  uint8_t MPU6050_getWakeFrequency ()  int16_t MPU6050_getXAccelOffset ()  bool MPU6050_getXGyroFIFOEnabled ()  int16_t MPU6050_getXGyroOffset ()  bool MPU6050_getXNegMotionDetected ()  bool MPU6050_getXPosMotionDetected ()  int16_t MPU6050_getYAccelOffset ()  bool MPU6050_getYGyroFIFOEnabled ()  int16_t MPU6050_getYGyroOffset ()  bool MPU6050_getYNegMotionDetected ()  bool MPU6050_getYPosMotionDetected ()  int16_t MPU6050_getZAccelOffset ()  bool MPU6050_getZGyroFIFOEnabled ()  int16_t MPU6050_getZGyroOffset ()  bool MPU6050_getZNegMotionDetected ()  bool MPU6050_getZPosMotionDetected ()  bool MPU6050_getZeroMotionDetected ()  uint8_t MPU6050_getZeroMotionDetectionDuration ()  uint8_t MPU6050_getZeroMotionDetectionThreshold ()  void MPU6050_init ()  void MPU6050_initialize ()  void MPU6050_readMemoryBlock (uint8_t * data, uint16_t dataSize, uint8_t bank, uint8_t address)  uint8_t MPU6050_readMemoryByte ()  void MPU6050_reset ()  void MPU6050_resetAccelerometerPath ()  void MPU6050_resetDMP ()  void MPU6050_resetFIFO ()  void MPU6050_resetGyroscopePath ()  void MPU6050_resetI2CMaster ()  void MPU6050_resetSensors ()  void MPU6050_resetTemperaturePath ()  void MPU6050_setAccelFIFOEnabled (bool enabled)  void MPU6050_setAccelXSelfTest (bool enabled)  void MPU6050_setAccelYSelfTest (bool enabled)  void MPU6050_setAccelZSelfTest (bool enabled)  void MPU6050_setAccelerometerPowerOnDelay (uint8_t delay)  void MPU6050_setAuxVDDIOLevel (uint8_t level)  void MPU6050_setClockOutputEnabled (bool enabled)  void MPU6050_setClockSource (uint8_t source)  void MPU6050_setDHPFMode (uint8_t mode)  void MPU6050_setDLPFMode (uint8_t bandwidth)  void MPU6050_setDMPConfig1 (uint8_t config)  void MPU6050_setDMPConfig2 (uint8_t config)  void MPU6050_setDMPEnabled (bool enabled)  void MPU6050_setDeviceID (uint8_t id)  void MPU6050_setExternalFrameSync (uint8_t sync)  void MPU6050_setExternalShadowDelayEnabled (bool enabled)  void MPU6050_setFIFOByte (uint8_t data)  void MPU6050_setFIFOEnabled (bool enabled)  void MPU6050_setFSyncInterruptEnabled (bool enabled)  void MPU6050_setFSyncInterruptLevel (bool level)  void MPU6050_setFreefallDetectionCounterDecrement (uint8_t decrement)  void MPU6050_setFreefallDetectionDuration (uint8_t duration)  void MPU6050_setFreefallDetectionThreshold (uint8_t threshold)  void MPU6050_setFullScaleAccelRange (uint8_t range)  void MPU6050_setFullScaleGyroRange (uint8_t range)  void MPU6050_setI2CBypassEnabled (bool enabled)  void MPU6050_setI2CMasterModeEnabled (bool enabled)  void MPU6050_setIntDMPEnabled (bool enabled)  void MPU6050_setIntDataReadyEnabled (bool enabled)  void MPU6050_setIntEnabled (uint8_t enabled)  void MPU6050_setIntFIFOBufferOverflowEnabled (bool enabled)  void MPU6050_setIntFreefallEnabled (bool enabled)  void MPU6050_setIntI2CMasterEnabled (bool enabled)  void MPU6050_setIntMotionEnabled (bool enabled)  void MPU6050_setIntPLLReadyEnabled (bool enabled)  void MPU6050_setIntZeroMotionEnabled (bool enabled)  void MPU6050_setInterruptDrive (bool drive)  void MPU6050_setInterruptLatch (bool latch)  void MPU6050_setInterruptLatchClear (bool clear)  void MPU6050_setInterruptMode (bool mode)  void MPU6050_setMasterClockSpeed (uint8_t speed)  void MPU6050_setMemoryBank (uint8_t bank, bool prefetchEnabled, bool userBank)  void MPU6050_setMemoryStartAddress (uint8_t address)  void MPU6050_setMotionDetectionCounterDecrement (uint8_t decrement)  void MPU6050_setMotionDetectionDuration (uint8_t duration)  void MPU6050_setMotionDetectionThreshold (uint8_t threshold)  void MPU6050_setMultiMasterEnabled (bool enabled)  void MPU6050_setOTPBankValid (bool enabled)  void MPU6050_setRate (uint8_t rate)  void MPU6050_setSlave0FIFOEnabled (bool enabled)  void MPU6050_setSlave1FIFOEnabled (bool enabled)  void MPU6050_setSlave2FIFOEnabled (bool enabled)  void MPU6050_setSlave3FIFOEnabled (bool enabled)  void MPU6050_setSlave4Address (uint8_t address)  void MPU6050_setSlave4Enabled (bool enabled)  void MPU6050_setSlave4InterruptEnabled (bool enabled)  void MPU6050_setSlave4MasterDelay (uint8_t delay)  void MPU6050_setSlave4OutputByte (uint8_t data)  void MPU6050_setSlave4Register (uint8_t reg)  void MPU6050_setSlave4WriteMode (bool mode)  void MPU6050_setSlaveAddress (uint8_t num, uint8_t address)  void MPU6050_setSlaveDataLength (uint8_t num, uint8_t length)  void MPU6050_setSlaveDelayEnabled (uint8_t num, bool enabled)  void MPU6050_setSlaveEnabled (uint8_t num, bool enabled)  void MPU6050_setSlaveOutputByte (uint8_t num, uint8_t data)  void MPU6050_setSlaveReadWriteTransitionEnabled (bool enabled)  void MPU6050_setSlaveRegister (uint8_t num, uint8_t reg)  void MPU6050_setSlaveWordByteSwap (uint8_t num, bool enabled)  void MPU6050_setSlaveWordGroupOffset (uint8_t num, bool enabled)  void MPU6050_setSlaveWriteMode (uint8_t num, bool mode)  void MPU6050_setSleepEnabled (bool enabled)  void MPU6050_setStandbyXAccelEnabled (bool enabled)  void MPU6050_setStandbyXGyroEnabled (bool enabled)  void MPU6050_setStandbyYAccelEnabled (bool enabled)  void MPU6050_setStandbyYGyroEnabled (bool enabled)  void MPU6050_setStandbyZAccelEnabled (bool enabled)  void MPU6050_setStandbyZGyroEnabled (bool enabled)  void MPU6050_setTempFIFOEnabled (bool enabled)  void MPU6050_setTempSensorEnabled (bool enabled)  void MPU6050_setWaitForExternalSensorEnabled (bool enabled)  void MPU6050_setWakeCycleEnabled (bool enabled)  void MPU6050_setWakeFrequency (uint8_t frequency)  void MPU6050_setXAccelOffset (int16_t offset)  void MPU6050_setXFineGain (int8_t gain)  void MPU6050_setXGyroFIFOEnabled (bool enabled)  void MPU6050_setXGyroOffset (int16_t offset)  void MPU6050_setXGyroOffsetTC (int8_t offset)  void MPU6050_setYAccelOffset (int16_t offset)  void MPU6050_setYFineGain (int8_t gain)  void MPU6050_setYGyroFIFOEnabled (bool enabled)  void MPU6050_setYGyroOffset (int16_t offset)  void MPU6050_setYGyroOffsetTC (int8_t offset)  void MPU6050_setZAccelOffset (int16_t offset)  void MPU6050_setZFineGain (int8_t gain)  void MPU6050_setZGyroFIFOEnabled (bool enabled)  void MPU6050_setZGyroOffset (int16_t offset)  void MPU6050_setZGyroOffsetTC (int8_t offset)  void MPU6050_setZeroMotionDetectionDuration (uint8_t duration)  void MPU6050_setZeroMotionDetectionThreshold (uint8_t threshold)  void MPU6050_switchSPIEnabled (bool enabled)  bool MPU6050_testConnection ()  void MPU6050_writeMemoryByte (uint8_t data)  uint32_t getExternalSensorDWord (int position)  int8_t getXFineGain ()  int8_t getXGyroOffsetTC ()  int8_t getYFineGain ()  int8_t getYGyroOffsetTC ()  int8_t getZFineGain ()  int8_t getZGyroOffsetTC ()"},{"location":"apiStm/Mpu6050_8hpp/#macros","title":"Macros","text":"Type Name define MPU6050_ACCEL_FIFO_EN_BIT  3 define MPU6050_ACCEL_FS_16  0x03 define MPU6050_ACCEL_FS_2  0x00 define MPU6050_ACCEL_FS_4  0x01 define MPU6050_ACCEL_FS_8  0x02 define MPU6050_ACONFIG_ACCEL_HPF_BIT  2 define MPU6050_ACONFIG_ACCEL_HPF_LENGTH  3 define MPU6050_ACONFIG_AFS_SEL_BIT  4 define MPU6050_ACONFIG_AFS_SEL_LENGTH  2 define MPU6050_ACONFIG_XA_ST_BIT  7 define MPU6050_ACONFIG_YA_ST_BIT  6 define MPU6050_ACONFIG_ZA_ST_BIT  5 define MPU6050_ADDRESS_AD0_HIGH  0x69 define MPU6050_ADDRESS_AD0_LOW  0x68 define MPU6050_BANKSEL_CFG_USER_BANK_BIT  5 define MPU6050_BANKSEL_MEM_SEL_BIT  4 define MPU6050_BANKSEL_MEM_SEL_LENGTH  5 define MPU6050_BANKSEL_PRFTCH_EN_BIT  6 define MPU6050_CFG_DLPF_CFG_BIT  2 define MPU6050_CFG_DLPF_CFG_LENGTH  3 define MPU6050_CFG_EXT_SYNC_SET_BIT  5 define MPU6050_CFG_EXT_SYNC_SET_LENGTH  3 define MPU6050_CLOCK_DIV_258  0x8 define MPU6050_CLOCK_DIV_267  0x7 define MPU6050_CLOCK_DIV_276  0x6 define MPU6050_CLOCK_DIV_286  0x5 define MPU6050_CLOCK_DIV_296  0x4 define MPU6050_CLOCK_DIV_308  0x3 define MPU6050_CLOCK_DIV_320  0x2 define MPU6050_CLOCK_DIV_333  0x1 define MPU6050_CLOCK_DIV_348  0x0 define MPU6050_CLOCK_DIV_364  0xF define MPU6050_CLOCK_DIV_381  0xE define MPU6050_CLOCK_DIV_400  0xD define MPU6050_CLOCK_DIV_421  0xC define MPU6050_CLOCK_DIV_444  0xB define MPU6050_CLOCK_DIV_471  0xA define MPU6050_CLOCK_DIV_500  0x9 define MPU6050_CLOCK_INTERNAL  0x00 define MPU6050_CLOCK_KEEP_RESET  0x07 define MPU6050_CLOCK_PLL_EXT19M  0x05 define MPU6050_CLOCK_PLL_EXT32K  0x04 define MPU6050_CLOCK_PLL_XGYRO  0x01 define MPU6050_CLOCK_PLL_YGYRO  0x02 define MPU6050_CLOCK_PLL_ZGYRO  0x03 define MPU6050_DEFAULT_ADDRESS  MPU6050_ADDRESS_AD0_LOW define MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT  7 define MPU6050_DELAYCTRL_I2C_SLV0_DLY_EN_BIT  0 define MPU6050_DELAYCTRL_I2C_SLV1_DLY_EN_BIT  1 define MPU6050_DELAYCTRL_I2C_SLV2_DLY_EN_BIT  2 define MPU6050_DELAYCTRL_I2C_SLV3_DLY_EN_BIT  3 define MPU6050_DELAYCTRL_I2C_SLV4_DLY_EN_BIT  4 define MPU6050_DETECT_ACCEL_ON_DELAY_BIT  5 define MPU6050_DETECT_ACCEL_ON_DELAY_LENGTH  2 define MPU6050_DETECT_DECREMENT_1  0x1 define MPU6050_DETECT_DECREMENT_2  0x2 define MPU6050_DETECT_DECREMENT_4  0x3 define MPU6050_DETECT_DECREMENT_RESET  0x0 define MPU6050_DETECT_FF_COUNT_BIT  3 define MPU6050_DETECT_FF_COUNT_LENGTH  2 define MPU6050_DETECT_MOT_COUNT_BIT  1 define MPU6050_DETECT_MOT_COUNT_LENGTH  2 define MPU6050_DHPF_0P63  0x04 define MPU6050_DHPF_1P25  0x03 define MPU6050_DHPF_2P5  0x02 define MPU6050_DHPF_5  0x01 define MPU6050_DHPF_HOLD  0x07 define MPU6050_DHPF_RESET  0x00 define MPU6050_DLPF_BW_10  0x05 define MPU6050_DLPF_BW_188  0x01 define MPU6050_DLPF_BW_20  0x04 define MPU6050_DLPF_BW_256  0x00 define MPU6050_DLPF_BW_42  0x03 define MPU6050_DLPF_BW_5  0x06 define MPU6050_DLPF_BW_98  0x02 define MPU6050_DMPINT_0_BIT  0 define MPU6050_DMPINT_1_BIT  1 define MPU6050_DMPINT_2_BIT  2 define MPU6050_DMPINT_3_BIT  3 define MPU6050_DMPINT_4_BIT  4 define MPU6050_DMPINT_5_BIT  5 define MPU6050_DMP_MEMORY_BANKS  8 define MPU6050_DMP_MEMORY_BANK_SIZE  256 define MPU6050_DMP_MEMORY_CHUNK_SIZE  16 define MPU6050_EXT_SYNC_ACCEL_XOUT_L  0x5 define MPU6050_EXT_SYNC_ACCEL_YOUT_L  0x6 define MPU6050_EXT_SYNC_ACCEL_ZOUT_L  0x7 define MPU6050_EXT_SYNC_DISABLED  0x0 define MPU6050_EXT_SYNC_GYRO_XOUT_L  0x2 define MPU6050_EXT_SYNC_GYRO_YOUT_L  0x3 define MPU6050_EXT_SYNC_GYRO_ZOUT_L  0x4 define MPU6050_EXT_SYNC_TEMP_OUT_L  0x1 define MPU6050_GCONFIG_FS_SEL_BIT  4 define MPU6050_GCONFIG_FS_SEL_LENGTH  2 define MPU6050_GYRO_FS_1000  0x02 define MPU6050_GYRO_FS_2000  0x03 define MPU6050_GYRO_FS_250  0x00 define MPU6050_GYRO_FS_500  0x01 define MPU6050_I2C_MST_CLK_BIT  3 define MPU6050_I2C_MST_CLK_LENGTH  4 define MPU6050_I2C_MST_P_NSR_BIT  4 define MPU6050_I2C_SLV4_ADDR_BIT  6 define MPU6050_I2C_SLV4_ADDR_LENGTH  7 define MPU6050_I2C_SLV4_EN_BIT  7 define MPU6050_I2C_SLV4_INT_EN_BIT  6 define MPU6050_I2C_SLV4_MST_DLY_BIT  4 define MPU6050_I2C_SLV4_MST_DLY_LENGTH  5 define MPU6050_I2C_SLV4_REG_DIS_BIT  5 define MPU6050_I2C_SLV4_RW_BIT  7 define MPU6050_I2C_SLV_ADDR_BIT  6 define MPU6050_I2C_SLV_ADDR_LENGTH  7 define MPU6050_I2C_SLV_BYTE_SW_BIT  6 define MPU6050_I2C_SLV_EN_BIT  7 define MPU6050_I2C_SLV_GRP_BIT  4 define MPU6050_I2C_SLV_LEN_BIT  3 define MPU6050_I2C_SLV_LEN_LENGTH  4 define MPU6050_I2C_SLV_REG_DIS_BIT  5 define MPU6050_I2C_SLV_RW_BIT  7 define MPU6050_INTCFG_CLKOUT_EN_BIT  0 define MPU6050_INTCFG_FSYNC_INT_EN_BIT  2 define MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT  3 define MPU6050_INTCFG_I2C_BYPASS_EN_BIT  1 define MPU6050_INTCFG_INT_LEVEL_BIT  7 define MPU6050_INTCFG_INT_OPEN_BIT  6 define MPU6050_INTCFG_INT_RD_CLEAR_BIT  4 define MPU6050_INTCFG_LATCH_INT_EN_BIT  5 define MPU6050_INTCLEAR_ANYREAD  0x01 define MPU6050_INTCLEAR_STATUSREAD  0x00 define MPU6050_INTDRV_OPENDRAIN  0x01 define MPU6050_INTDRV_PUSHPULL  0x00 define MPU6050_INTERRUPT_DATA_RDY_BIT  0 define MPU6050_INTERRUPT_DMP_INT_BIT  1 define MPU6050_INTERRUPT_FF_BIT  7 define MPU6050_INTERRUPT_FIFO_OFLOW_BIT  4 define MPU6050_INTERRUPT_I2C_MST_INT_BIT  3 define MPU6050_INTERRUPT_MOT_BIT  6 define MPU6050_INTERRUPT_PLL_RDY_INT_BIT  2 define MPU6050_INTERRUPT_ZMOT_BIT  5 define MPU6050_INTLATCH_50USPULSE  0x00 define MPU6050_INTLATCH_WAITCLEAR  0x01 define MPU6050_INTMODE_ACTIVEHIGH  0x00 define MPU6050_INTMODE_ACTIVELOW  0x01 define MPU6050_MOTION_MOT_XNEG_BIT  7 define MPU6050_MOTION_MOT_XPOS_BIT  6 define MPU6050_MOTION_MOT_YNEG_BIT  5 define MPU6050_MOTION_MOT_YPOS_BIT  4 define MPU6050_MOTION_MOT_ZNEG_BIT  3 define MPU6050_MOTION_MOT_ZPOS_BIT  2 define MPU6050_MOTION_MOT_ZRMOT_BIT  0 define MPU6050_MST_I2C_LOST_ARB_BIT  5 define MPU6050_MST_I2C_SLV0_NACK_BIT  0 define MPU6050_MST_I2C_SLV1_NACK_BIT  1 define MPU6050_MST_I2C_SLV2_NACK_BIT  2 define MPU6050_MST_I2C_SLV3_NACK_BIT  3 define MPU6050_MST_I2C_SLV4_DONE_BIT  6 define MPU6050_MST_I2C_SLV4_NACK_BIT  4 define MPU6050_MST_PASS_THROUGH_BIT  7 define MPU6050_MULT_MST_EN_BIT  7 define MPU6050_PATHRESET_ACCEL_RESET_BIT  1 define MPU6050_PATHRESET_GYRO_RESET_BIT  2 define MPU6050_PATHRESET_TEMP_RESET_BIT  0 define MPU6050_PWR1_CLKSEL_BIT  2 define MPU6050_PWR1_CLKSEL_LENGTH  3 define MPU6050_PWR1_CYCLE_BIT  5 define MPU6050_PWR1_DEVICE_RESET_BIT  7 define MPU6050_PWR1_SLEEP_BIT  6 define MPU6050_PWR1_TEMP_DIS_BIT  3 define MPU6050_PWR2_LP_WAKE_CTRL_BIT  7 define MPU6050_PWR2_LP_WAKE_CTRL_LENGTH  2 define MPU6050_PWR2_STBY_XA_BIT  5 define MPU6050_PWR2_STBY_XG_BIT  2 define MPU6050_PWR2_STBY_YA_BIT  4 define MPU6050_PWR2_STBY_YG_BIT  1 define MPU6050_PWR2_STBY_ZA_BIT  3 define MPU6050_PWR2_STBY_ZG_BIT  0 define MPU6050_RA_ACCEL_CONFIG  0x1C define MPU6050_RA_ACCEL_XOUT_H  0x3B define MPU6050_RA_ACCEL_XOUT_L  0x3C define MPU6050_RA_ACCEL_YOUT_H  0x3D define MPU6050_RA_ACCEL_YOUT_L  0x3E define MPU6050_RA_ACCEL_ZOUT_H  0x3F define MPU6050_RA_ACCEL_ZOUT_L  0x40 define MPU6050_RA_BANK_SEL  0x6D define MPU6050_RA_CONFIG  0x1A define MPU6050_RA_DMP_CFG_1  0x70 define MPU6050_RA_DMP_CFG_2  0x71 define MPU6050_RA_DMP_INT_STATUS  0x39 define MPU6050_RA_EXT_SENS_DATA_00  0x49 define MPU6050_RA_EXT_SENS_DATA_01  0x4A define MPU6050_RA_EXT_SENS_DATA_02  0x4B define MPU6050_RA_EXT_SENS_DATA_03  0x4C define MPU6050_RA_EXT_SENS_DATA_04  0x4D define MPU6050_RA_EXT_SENS_DATA_05  0x4E define MPU6050_RA_EXT_SENS_DATA_06  0x4F define MPU6050_RA_EXT_SENS_DATA_07  0x50 define MPU6050_RA_EXT_SENS_DATA_08  0x51 define MPU6050_RA_EXT_SENS_DATA_09  0x52 define MPU6050_RA_EXT_SENS_DATA_10  0x53 define MPU6050_RA_EXT_SENS_DATA_11  0x54 define MPU6050_RA_EXT_SENS_DATA_12  0x55 define MPU6050_RA_EXT_SENS_DATA_13  0x56 define MPU6050_RA_EXT_SENS_DATA_14  0x57 define MPU6050_RA_EXT_SENS_DATA_15  0x58 define MPU6050_RA_EXT_SENS_DATA_16  0x59 define MPU6050_RA_EXT_SENS_DATA_17  0x5A define MPU6050_RA_EXT_SENS_DATA_18  0x5B define MPU6050_RA_EXT_SENS_DATA_19  0x5C define MPU6050_RA_EXT_SENS_DATA_20  0x5D define MPU6050_RA_EXT_SENS_DATA_21  0x5E define MPU6050_RA_EXT_SENS_DATA_22  0x5F define MPU6050_RA_EXT_SENS_DATA_23  0x60 define MPU6050_RA_FF_DUR  0x1E define MPU6050_RA_FF_THR  0x1D define MPU6050_RA_FIFO_COUNTH  0x72 define MPU6050_RA_FIFO_COUNTL  0x73 define MPU6050_RA_FIFO_EN  0x23 define MPU6050_RA_FIFO_R_W  0x74 define MPU6050_RA_GYRO_CONFIG  0x1B define MPU6050_RA_GYRO_XOUT_H  0x43 define MPU6050_RA_GYRO_XOUT_L  0x44 define MPU6050_RA_GYRO_YOUT_H  0x45 define MPU6050_RA_GYRO_YOUT_L  0x46 define MPU6050_RA_GYRO_ZOUT_H  0x47 define MPU6050_RA_GYRO_ZOUT_L  0x48 define MPU6050_RA_I2C_MST_CTRL  0x24 define MPU6050_RA_I2C_MST_DELAY_CTRL  0x67 define MPU6050_RA_I2C_MST_STATUS  0x36 define MPU6050_RA_I2C_SLV0_ADDR  0x25 define MPU6050_RA_I2C_SLV0_CTRL  0x27 define MPU6050_RA_I2C_SLV0_DO  0x63 define MPU6050_RA_I2C_SLV0_REG  0x26 define MPU6050_RA_I2C_SLV1_ADDR  0x28 define MPU6050_RA_I2C_SLV1_CTRL  0x2A define MPU6050_RA_I2C_SLV1_DO  0x64 define MPU6050_RA_I2C_SLV1_REG  0x29 define MPU6050_RA_I2C_SLV2_ADDR  0x2B define MPU6050_RA_I2C_SLV2_CTRL  0x2D define MPU6050_RA_I2C_SLV2_DO  0x65 define MPU6050_RA_I2C_SLV2_REG  0x2C define MPU6050_RA_I2C_SLV3_ADDR  0x2E define MPU6050_RA_I2C_SLV3_CTRL  0x30 define MPU6050_RA_I2C_SLV3_DO  0x66 define MPU6050_RA_I2C_SLV3_REG  0x2F define MPU6050_RA_I2C_SLV4_ADDR  0x31 define MPU6050_RA_I2C_SLV4_CTRL  0x34 define MPU6050_RA_I2C_SLV4_DI  0x35 define MPU6050_RA_I2C_SLV4_DO  0x33 define MPU6050_RA_I2C_SLV4_REG  0x32 define MPU6050_RA_INT_ENABLE  0x38 define MPU6050_RA_INT_PIN_CFG  0x37 define MPU6050_RA_INT_STATUS  0x3A define MPU6050_RA_MEM_R_W  0x6F define MPU6050_RA_MEM_START_ADDR  0x6E define MPU6050_RA_MOT_DETECT_CTRL  0x69 define MPU6050_RA_MOT_DETECT_STATUS  0x61 define MPU6050_RA_MOT_DUR  0x20 define MPU6050_RA_MOT_THR  0x1F define MPU6050_RA_PWR_MGMT_1  0x6B define MPU6050_RA_PWR_MGMT_2  0x6C define MPU6050_RA_SIGNAL_PATH_RESET  0x68 define MPU6050_RA_SMPLRT_DIV  0x19 define MPU6050_RA_TEMP_OUT_H  0x41 define MPU6050_RA_TEMP_OUT_L  0x42 define MPU6050_RA_USER_CTRL  0x6A define MPU6050_RA_WHO_AM_I  0x75 define MPU6050_RA_XA_OFFS_H  0x06 define MPU6050_RA_XA_OFFS_L_TC  0x07 define MPU6050_RA_XG_OFFS_TC  0x00 define MPU6050_RA_XG_OFFS_USRH  0x13 define MPU6050_RA_XG_OFFS_USRL  0x14 define MPU6050_RA_X_FINE_GAIN  0x03 define MPU6050_RA_YA_OFFS_H  0x08 define MPU6050_RA_YA_OFFS_L_TC  0x09 define MPU6050_RA_YG_OFFS_TC  0x01 define MPU6050_RA_YG_OFFS_USRH  0x15 define MPU6050_RA_YG_OFFS_USRL  0x16 define MPU6050_RA_Y_FINE_GAIN  0x04 define MPU6050_RA_ZA_OFFS_H  0x0A define MPU6050_RA_ZA_OFFS_L_TC  0x0B define MPU6050_RA_ZG_OFFS_TC  0x02 define MPU6050_RA_ZG_OFFS_USRH  0x17 define MPU6050_RA_ZG_OFFS_USRL  0x18 define MPU6050_RA_ZRMOT_DUR  0x22 define MPU6050_RA_ZRMOT_THR  0x21 define MPU6050_RA_Z_FINE_GAIN  0x05 define MPU6050_SLV0_FIFO_EN_BIT  0 define MPU6050_SLV1_FIFO_EN_BIT  1 define MPU6050_SLV2_FIFO_EN_BIT  2 define MPU6050_SLV_3_FIFO_EN_BIT  5 define MPU6050_TC_OFFSET_BIT  6 define MPU6050_TC_OFFSET_LENGTH  6 define MPU6050_TC_OTP_BNK_VLD_BIT  0 define MPU6050_TC_PWR_MODE_BIT  7 define MPU6050_TEMP_FIFO_EN_BIT  7 define MPU6050_USERCTRL_DMP_EN_BIT  7 define MPU6050_USERCTRL_DMP_RESET_BIT  3 define MPU6050_USERCTRL_FIFO_EN_BIT  6 define MPU6050_USERCTRL_FIFO_RESET_BIT  2 define MPU6050_USERCTRL_I2C_IF_DIS_BIT  4 define MPU6050_USERCTRL_I2C_MST_EN_BIT  5 define MPU6050_USERCTRL_I2C_MST_RESET_BIT  1 define MPU6050_USERCTRL_SIG_COND_RESET_BIT  0 define MPU6050_VDDIO_LEVEL_VDD  1 define MPU6050_VDDIO_LEVEL_VLOGIC  0 define MPU6050_WAIT_FOR_ES_BIT  6 define MPU6050_WAKE_FREQ_10  0x3 define MPU6050_WAKE_FREQ_1P25  0x0 define MPU6050_WAKE_FREQ_2P5  0x1 define MPU6050_WAKE_FREQ_5  0x2 define MPU6050_WHO_AM_I_BIT  6 define MPU6050_WHO_AM_I_LENGTH  6 define MPU6050_XG_FIFO_EN_BIT  6 define MPU6050_YG_FIFO_EN_BIT  5 define MPU6050_ZG_FIFO_EN_BIT  4"},{"location":"apiStm/Mpu6050_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/Mpu6050_8hpp/#typedef-mpu6050_t","title":"typedef MPU6050_t","text":"<pre><code>typedef struct MPU6050_t MPU6050_t;\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050","title":"function MPU6050","text":"<pre><code>void MPU6050 (\nuint8_t address\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getaccelfifoenabled","title":"function MPU6050_getAccelFIFOEnabled","text":"<pre><code>bool MPU6050_getAccelFIFOEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getaccelxselftest","title":"function MPU6050_getAccelXSelfTest","text":"<pre><code>bool MPU6050_getAccelXSelfTest () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getaccelyselftest","title":"function MPU6050_getAccelYSelfTest","text":"<pre><code>bool MPU6050_getAccelYSelfTest () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getaccelzselftest","title":"function MPU6050_getAccelZSelfTest","text":"<pre><code>bool MPU6050_getAccelZSelfTest () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getacceleration","title":"function MPU6050_getAcceleration","text":"<pre><code>void MPU6050_getAcceleration (\nint16_t * x,\nint16_t * y,\nint16_t * z\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getaccelerationx","title":"function MPU6050_getAccelerationX","text":"<pre><code>int16_t MPU6050_getAccelerationX () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getaccelerationy","title":"function MPU6050_getAccelerationY","text":"<pre><code>int16_t MPU6050_getAccelerationY () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getaccelerationz","title":"function MPU6050_getAccelerationZ","text":"<pre><code>int16_t MPU6050_getAccelerationZ () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getaccelerometerpowerondelay","title":"function MPU6050_getAccelerometerPowerOnDelay","text":"<pre><code>uint8_t MPU6050_getAccelerometerPowerOnDelay () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getauxvddiolevel","title":"function MPU6050_getAuxVDDIOLevel","text":"<pre><code>uint8_t MPU6050_getAuxVDDIOLevel () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getclockoutputenabled","title":"function MPU6050_getClockOutputEnabled","text":"<pre><code>bool MPU6050_getClockOutputEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getclocksource","title":"function MPU6050_getClockSource","text":"<pre><code>uint8_t MPU6050_getClockSource () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getdhpfmode","title":"function MPU6050_getDHPFMode","text":"<pre><code>uint8_t MPU6050_getDHPFMode () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getdlpfmode","title":"function MPU6050_getDLPFMode","text":"<pre><code>uint8_t MPU6050_getDLPFMode () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getdmpconfig1","title":"function MPU6050_getDMPConfig1","text":"<pre><code>uint8_t MPU6050_getDMPConfig1 () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getdmpconfig2","title":"function MPU6050_getDMPConfig2","text":"<pre><code>uint8_t MPU6050_getDMPConfig2 () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getdmpenabled","title":"function MPU6050_getDMPEnabled","text":"<pre><code>bool MPU6050_getDMPEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getdmpint0status","title":"function MPU6050_getDMPInt0Status","text":"<pre><code>bool MPU6050_getDMPInt0Status () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getdmpint1status","title":"function MPU6050_getDMPInt1Status","text":"<pre><code>bool MPU6050_getDMPInt1Status () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getdmpint2status","title":"function MPU6050_getDMPInt2Status","text":"<pre><code>bool MPU6050_getDMPInt2Status () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getdmpint3status","title":"function MPU6050_getDMPInt3Status","text":"<pre><code>bool MPU6050_getDMPInt3Status () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getdmpint4status","title":"function MPU6050_getDMPInt4Status","text":"<pre><code>bool MPU6050_getDMPInt4Status () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getdmpint5status","title":"function MPU6050_getDMPInt5Status","text":"<pre><code>bool MPU6050_getDMPInt5Status () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getdeviceid","title":"function MPU6050_getDeviceID","text":"<pre><code>uint8_t MPU6050_getDeviceID () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getexternalframesync","title":"function MPU6050_getExternalFrameSync","text":"<pre><code>uint8_t MPU6050_getExternalFrameSync () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getexternalsensorbyte","title":"function MPU6050_getExternalSensorByte","text":"<pre><code>uint8_t MPU6050_getExternalSensorByte (\nint position\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getexternalsensorword","title":"function MPU6050_getExternalSensorWord","text":"<pre><code>uint16_t MPU6050_getExternalSensorWord (\nint position\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getexternalshadowdelayenabled","title":"function MPU6050_getExternalShadowDelayEnabled","text":"<pre><code>bool MPU6050_getExternalShadowDelayEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getfifobyte","title":"function MPU6050_getFIFOByte","text":"<pre><code>uint8_t MPU6050_getFIFOByte () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getfifobytes","title":"function MPU6050_getFIFOBytes","text":"<pre><code>void MPU6050_getFIFOBytes (\nuint8_t * data,\nuint8_t length\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getfifocount","title":"function MPU6050_getFIFOCount","text":"<pre><code>uint16_t MPU6050_getFIFOCount () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getfifoenabled","title":"function MPU6050_getFIFOEnabled","text":"<pre><code>bool MPU6050_getFIFOEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getfsyncinterruptenabled","title":"function MPU6050_getFSyncInterruptEnabled","text":"<pre><code>bool MPU6050_getFSyncInterruptEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getfsyncinterruptlevel","title":"function MPU6050_getFSyncInterruptLevel","text":"<pre><code>bool MPU6050_getFSyncInterruptLevel () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getfreefalldetectioncounterdecrement","title":"function MPU6050_getFreefallDetectionCounterDecrement","text":"<pre><code>uint8_t MPU6050_getFreefallDetectionCounterDecrement () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getfreefalldetectionduration","title":"function MPU6050_getFreefallDetectionDuration","text":"<pre><code>uint8_t MPU6050_getFreefallDetectionDuration () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getfreefalldetectionthreshold","title":"function MPU6050_getFreefallDetectionThreshold","text":"<pre><code>uint8_t MPU6050_getFreefallDetectionThreshold () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getfullscaleaccelrange","title":"function MPU6050_getFullScaleAccelRange","text":"<pre><code>uint8_t MPU6050_getFullScaleAccelRange () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getfullscalegyrorange","title":"function MPU6050_getFullScaleGyroRange","text":"<pre><code>uint8_t MPU6050_getFullScaleGyroRange () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_geti2cbypassenabled","title":"function MPU6050_getI2CBypassEnabled","text":"<pre><code>bool MPU6050_getI2CBypassEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_geti2cmastermodeenabled","title":"function MPU6050_getI2CMasterModeEnabled","text":"<pre><code>bool MPU6050_getI2CMasterModeEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getintdmpenabled","title":"function MPU6050_getIntDMPEnabled","text":"<pre><code>bool MPU6050_getIntDMPEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getintdmpstatus","title":"function MPU6050_getIntDMPStatus","text":"<pre><code>bool MPU6050_getIntDMPStatus () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getintdatareadyenabled","title":"function MPU6050_getIntDataReadyEnabled","text":"<pre><code>bool MPU6050_getIntDataReadyEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getintdatareadystatus","title":"function MPU6050_getIntDataReadyStatus","text":"<pre><code>bool MPU6050_getIntDataReadyStatus () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getintenabled","title":"function MPU6050_getIntEnabled","text":"<pre><code>uint8_t MPU6050_getIntEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getintfifobufferoverflowenabled","title":"function MPU6050_getIntFIFOBufferOverflowEnabled","text":"<pre><code>bool MPU6050_getIntFIFOBufferOverflowEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getintfifobufferoverflowstatus","title":"function MPU6050_getIntFIFOBufferOverflowStatus","text":"<pre><code>bool MPU6050_getIntFIFOBufferOverflowStatus () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getintfreefallenabled","title":"function MPU6050_getIntFreefallEnabled","text":"<pre><code>bool MPU6050_getIntFreefallEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getintfreefallstatus","title":"function MPU6050_getIntFreefallStatus","text":"<pre><code>bool MPU6050_getIntFreefallStatus () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getinti2cmasterenabled","title":"function MPU6050_getIntI2CMasterEnabled","text":"<pre><code>bool MPU6050_getIntI2CMasterEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getinti2cmasterstatus","title":"function MPU6050_getIntI2CMasterStatus","text":"<pre><code>bool MPU6050_getIntI2CMasterStatus () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getintmotionenabled","title":"function MPU6050_getIntMotionEnabled","text":"<pre><code>bool MPU6050_getIntMotionEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getintmotionstatus","title":"function MPU6050_getIntMotionStatus","text":"<pre><code>bool MPU6050_getIntMotionStatus () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getintpllreadyenabled","title":"function MPU6050_getIntPLLReadyEnabled","text":"<pre><code>bool MPU6050_getIntPLLReadyEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getintpllreadystatus","title":"function MPU6050_getIntPLLReadyStatus","text":"<pre><code>bool MPU6050_getIntPLLReadyStatus () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getintstatus","title":"function MPU6050_getIntStatus","text":"<pre><code>uint8_t MPU6050_getIntStatus () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getintzeromotionenabled","title":"function MPU6050_getIntZeroMotionEnabled","text":"<pre><code>bool MPU6050_getIntZeroMotionEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getintzeromotionstatus","title":"function MPU6050_getIntZeroMotionStatus","text":"<pre><code>bool MPU6050_getIntZeroMotionStatus () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getinterruptdrive","title":"function MPU6050_getInterruptDrive","text":"<pre><code>bool MPU6050_getInterruptDrive () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getinterruptlatch","title":"function MPU6050_getInterruptLatch","text":"<pre><code>bool MPU6050_getInterruptLatch () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getinterruptlatchclear","title":"function MPU6050_getInterruptLatchClear","text":"<pre><code>bool MPU6050_getInterruptLatchClear () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getinterruptmode","title":"function MPU6050_getInterruptMode","text":"<pre><code>bool MPU6050_getInterruptMode () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getlostarbitration","title":"function MPU6050_getLostArbitration","text":"<pre><code>bool MPU6050_getLostArbitration () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getmasterclockspeed","title":"function MPU6050_getMasterClockSpeed","text":"<pre><code>uint8_t MPU6050_getMasterClockSpeed () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getmotion6","title":"function MPU6050_getMotion6","text":"<pre><code>void MPU6050_getMotion6 (\nint16_t * ax,\nint16_t * ay,\nint16_t * az,\nint16_t * gx,\nint16_t * gy,\nint16_t * gz\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getmotion9","title":"function MPU6050_getMotion9","text":"<pre><code>void MPU6050_getMotion9 (\nint16_t * ax,\nint16_t * ay,\nint16_t * az,\nint16_t * gx,\nint16_t * gy,\nint16_t * gz,\nint16_t * mx,\nint16_t * my,\nint16_t * mz\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getmotiondetectioncounterdecrement","title":"function MPU6050_getMotionDetectionCounterDecrement","text":"<pre><code>uint8_t MPU6050_getMotionDetectionCounterDecrement () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getmotiondetectionduration","title":"function MPU6050_getMotionDetectionDuration","text":"<pre><code>uint8_t MPU6050_getMotionDetectionDuration () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getmotiondetectionthreshold","title":"function MPU6050_getMotionDetectionThreshold","text":"<pre><code>uint8_t MPU6050_getMotionDetectionThreshold () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getmultimasterenabled","title":"function MPU6050_getMultiMasterEnabled","text":"<pre><code>bool MPU6050_getMultiMasterEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getotpbankvalid","title":"function MPU6050_getOTPBankValid","text":"<pre><code>uint8_t MPU6050_getOTPBankValid () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getpassthroughstatus","title":"function MPU6050_getPassthroughStatus","text":"<pre><code>bool MPU6050_getPassthroughStatus () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getrate","title":"function MPU6050_getRate","text":"<pre><code>uint8_t MPU6050_getRate () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getrotation","title":"function MPU6050_getRotation","text":"<pre><code>void MPU6050_getRotation (\nint16_t * x,\nint16_t * y,\nint16_t * z\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getrotationx","title":"function MPU6050_getRotationX","text":"<pre><code>int16_t MPU6050_getRotationX () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getrotationy","title":"function MPU6050_getRotationY","text":"<pre><code>int16_t MPU6050_getRotationY () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getrotationz","title":"function MPU6050_getRotationZ","text":"<pre><code>int16_t MPU6050_getRotationZ () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslate4inputbyte","title":"function MPU6050_getSlate4InputByte","text":"<pre><code>uint8_t MPU6050_getSlate4InputByte () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslave0fifoenabled","title":"function MPU6050_getSlave0FIFOEnabled","text":"<pre><code>bool MPU6050_getSlave0FIFOEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslave0nack","title":"function MPU6050_getSlave0Nack","text":"<pre><code>bool MPU6050_getSlave0Nack () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslave1fifoenabled","title":"function MPU6050_getSlave1FIFOEnabled","text":"<pre><code>bool MPU6050_getSlave1FIFOEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslave1nack","title":"function MPU6050_getSlave1Nack","text":"<pre><code>bool MPU6050_getSlave1Nack () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslave2fifoenabled","title":"function MPU6050_getSlave2FIFOEnabled","text":"<pre><code>bool MPU6050_getSlave2FIFOEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslave2nack","title":"function MPU6050_getSlave2Nack","text":"<pre><code>bool MPU6050_getSlave2Nack () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslave3fifoenabled","title":"function MPU6050_getSlave3FIFOEnabled","text":"<pre><code>bool MPU6050_getSlave3FIFOEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslave3nack","title":"function MPU6050_getSlave3Nack","text":"<pre><code>bool MPU6050_getSlave3Nack () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslave4address","title":"function MPU6050_getSlave4Address","text":"<pre><code>uint8_t MPU6050_getSlave4Address () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslave4enabled","title":"function MPU6050_getSlave4Enabled","text":"<pre><code>bool MPU6050_getSlave4Enabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslave4interruptenabled","title":"function MPU6050_getSlave4InterruptEnabled","text":"<pre><code>bool MPU6050_getSlave4InterruptEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslave4isdone","title":"function MPU6050_getSlave4IsDone","text":"<pre><code>bool MPU6050_getSlave4IsDone () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslave4masterdelay","title":"function MPU6050_getSlave4MasterDelay","text":"<pre><code>uint8_t MPU6050_getSlave4MasterDelay () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslave4nack","title":"function MPU6050_getSlave4Nack","text":"<pre><code>bool MPU6050_getSlave4Nack () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslave4register","title":"function MPU6050_getSlave4Register","text":"<pre><code>uint8_t MPU6050_getSlave4Register () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslave4writemode","title":"function MPU6050_getSlave4WriteMode","text":"<pre><code>bool MPU6050_getSlave4WriteMode () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslaveaddress","title":"function MPU6050_getSlaveAddress","text":"<pre><code>uint8_t MPU6050_getSlaveAddress (\nuint8_t num\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslavedatalength","title":"function MPU6050_getSlaveDataLength","text":"<pre><code>uint8_t MPU6050_getSlaveDataLength (\nuint8_t num\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslavedelayenabled","title":"function MPU6050_getSlaveDelayEnabled","text":"<pre><code>bool MPU6050_getSlaveDelayEnabled (\nuint8_t num\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslaveenabled","title":"function MPU6050_getSlaveEnabled","text":"<pre><code>bool MPU6050_getSlaveEnabled (\nuint8_t num\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslavereadwritetransitionenabled","title":"function MPU6050_getSlaveReadWriteTransitionEnabled","text":"<pre><code>bool MPU6050_getSlaveReadWriteTransitionEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslaveregister","title":"function MPU6050_getSlaveRegister","text":"<pre><code>uint8_t MPU6050_getSlaveRegister (\nuint8_t num\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslavewordbyteswap","title":"function MPU6050_getSlaveWordByteSwap","text":"<pre><code>bool MPU6050_getSlaveWordByteSwap (\nuint8_t num\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslavewordgroupoffset","title":"function MPU6050_getSlaveWordGroupOffset","text":"<pre><code>bool MPU6050_getSlaveWordGroupOffset (\nuint8_t num\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getslavewritemode","title":"function MPU6050_getSlaveWriteMode","text":"<pre><code>bool MPU6050_getSlaveWriteMode (\nuint8_t num\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getsleepenabled","title":"function MPU6050_getSleepEnabled","text":"<pre><code>bool MPU6050_getSleepEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getstandbyxaccelenabled","title":"function MPU6050_getStandbyXAccelEnabled","text":"<pre><code>bool MPU6050_getStandbyXAccelEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getstandbyxgyroenabled","title":"function MPU6050_getStandbyXGyroEnabled","text":"<pre><code>bool MPU6050_getStandbyXGyroEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getstandbyyaccelenabled","title":"function MPU6050_getStandbyYAccelEnabled","text":"<pre><code>bool MPU6050_getStandbyYAccelEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getstandbyygyroenabled","title":"function MPU6050_getStandbyYGyroEnabled","text":"<pre><code>bool MPU6050_getStandbyYGyroEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getstandbyzaccelenabled","title":"function MPU6050_getStandbyZAccelEnabled","text":"<pre><code>bool MPU6050_getStandbyZAccelEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getstandbyzgyroenabled","title":"function MPU6050_getStandbyZGyroEnabled","text":"<pre><code>bool MPU6050_getStandbyZGyroEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_gettempfifoenabled","title":"function MPU6050_getTempFIFOEnabled","text":"<pre><code>bool MPU6050_getTempFIFOEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_gettempsensorenabled","title":"function MPU6050_getTempSensorEnabled","text":"<pre><code>bool MPU6050_getTempSensorEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_gettemperature","title":"function MPU6050_getTemperature","text":"<pre><code>int16_t MPU6050_getTemperature () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getwaitforexternalsensorenabled","title":"function MPU6050_getWaitForExternalSensorEnabled","text":"<pre><code>bool MPU6050_getWaitForExternalSensorEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getwakecycleenabled","title":"function MPU6050_getWakeCycleEnabled","text":"<pre><code>bool MPU6050_getWakeCycleEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getwakefrequency","title":"function MPU6050_getWakeFrequency","text":"<pre><code>uint8_t MPU6050_getWakeFrequency () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getxacceloffset","title":"function MPU6050_getXAccelOffset","text":"<pre><code>int16_t MPU6050_getXAccelOffset () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getxgyrofifoenabled","title":"function MPU6050_getXGyroFIFOEnabled","text":"<pre><code>bool MPU6050_getXGyroFIFOEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getxgyrooffset","title":"function MPU6050_getXGyroOffset","text":"<pre><code>int16_t MPU6050_getXGyroOffset () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getxnegmotiondetected","title":"function MPU6050_getXNegMotionDetected","text":"<pre><code>bool MPU6050_getXNegMotionDetected () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getxposmotiondetected","title":"function MPU6050_getXPosMotionDetected","text":"<pre><code>bool MPU6050_getXPosMotionDetected () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getyacceloffset","title":"function MPU6050_getYAccelOffset","text":"<pre><code>int16_t MPU6050_getYAccelOffset () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getygyrofifoenabled","title":"function MPU6050_getYGyroFIFOEnabled","text":"<pre><code>bool MPU6050_getYGyroFIFOEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getygyrooffset","title":"function MPU6050_getYGyroOffset","text":"<pre><code>int16_t MPU6050_getYGyroOffset () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getynegmotiondetected","title":"function MPU6050_getYNegMotionDetected","text":"<pre><code>bool MPU6050_getYNegMotionDetected () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getyposmotiondetected","title":"function MPU6050_getYPosMotionDetected","text":"<pre><code>bool MPU6050_getYPosMotionDetected () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getzacceloffset","title":"function MPU6050_getZAccelOffset","text":"<pre><code>int16_t MPU6050_getZAccelOffset () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getzgyrofifoenabled","title":"function MPU6050_getZGyroFIFOEnabled","text":"<pre><code>bool MPU6050_getZGyroFIFOEnabled () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getzgyrooffset","title":"function MPU6050_getZGyroOffset","text":"<pre><code>int16_t MPU6050_getZGyroOffset () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getznegmotiondetected","title":"function MPU6050_getZNegMotionDetected","text":"<pre><code>bool MPU6050_getZNegMotionDetected () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getzposmotiondetected","title":"function MPU6050_getZPosMotionDetected","text":"<pre><code>bool MPU6050_getZPosMotionDetected () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getzeromotiondetected","title":"function MPU6050_getZeroMotionDetected","text":"<pre><code>bool MPU6050_getZeroMotionDetected () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getzeromotiondetectionduration","title":"function MPU6050_getZeroMotionDetectionDuration","text":"<pre><code>uint8_t MPU6050_getZeroMotionDetectionDuration () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_getzeromotiondetectionthreshold","title":"function MPU6050_getZeroMotionDetectionThreshold","text":"<pre><code>uint8_t MPU6050_getZeroMotionDetectionThreshold () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_init","title":"function MPU6050_init","text":"<pre><code>void MPU6050_init () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_initialize","title":"function MPU6050_initialize","text":"<pre><code>void MPU6050_initialize () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_readmemoryblock","title":"function MPU6050_readMemoryBlock","text":"<pre><code>void MPU6050_readMemoryBlock (\nuint8_t * data,\nuint16_t dataSize,\nuint8_t bank,\nuint8_t address\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_readmemorybyte","title":"function MPU6050_readMemoryByte","text":"<pre><code>uint8_t MPU6050_readMemoryByte () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_reset","title":"function MPU6050_reset","text":"<pre><code>void MPU6050_reset () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_resetaccelerometerpath","title":"function MPU6050_resetAccelerometerPath","text":"<pre><code>void MPU6050_resetAccelerometerPath () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_resetdmp","title":"function MPU6050_resetDMP","text":"<pre><code>void MPU6050_resetDMP () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_resetfifo","title":"function MPU6050_resetFIFO","text":"<pre><code>void MPU6050_resetFIFO () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_resetgyroscopepath","title":"function MPU6050_resetGyroscopePath","text":"<pre><code>void MPU6050_resetGyroscopePath () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_reseti2cmaster","title":"function MPU6050_resetI2CMaster","text":"<pre><code>void MPU6050_resetI2CMaster () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_resetsensors","title":"function MPU6050_resetSensors","text":"<pre><code>void MPU6050_resetSensors () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_resettemperaturepath","title":"function MPU6050_resetTemperaturePath","text":"<pre><code>void MPU6050_resetTemperaturePath () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setaccelfifoenabled","title":"function MPU6050_setAccelFIFOEnabled","text":"<pre><code>void MPU6050_setAccelFIFOEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setaccelxselftest","title":"function MPU6050_setAccelXSelfTest","text":"<pre><code>void MPU6050_setAccelXSelfTest (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setaccelyselftest","title":"function MPU6050_setAccelYSelfTest","text":"<pre><code>void MPU6050_setAccelYSelfTest (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setaccelzselftest","title":"function MPU6050_setAccelZSelfTest","text":"<pre><code>void MPU6050_setAccelZSelfTest (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setaccelerometerpowerondelay","title":"function MPU6050_setAccelerometerPowerOnDelay","text":"<pre><code>void MPU6050_setAccelerometerPowerOnDelay (\nuint8_t delay\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setauxvddiolevel","title":"function MPU6050_setAuxVDDIOLevel","text":"<pre><code>void MPU6050_setAuxVDDIOLevel (\nuint8_t level\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setclockoutputenabled","title":"function MPU6050_setClockOutputEnabled","text":"<pre><code>void MPU6050_setClockOutputEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setclocksource","title":"function MPU6050_setClockSource","text":"<pre><code>void MPU6050_setClockSource (\nuint8_t source\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setdhpfmode","title":"function MPU6050_setDHPFMode","text":"<pre><code>void MPU6050_setDHPFMode (\nuint8_t mode\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setdlpfmode","title":"function MPU6050_setDLPFMode","text":"<pre><code>void MPU6050_setDLPFMode (\nuint8_t bandwidth\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setdmpconfig1","title":"function MPU6050_setDMPConfig1","text":"<pre><code>void MPU6050_setDMPConfig1 (\nuint8_t config\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setdmpconfig2","title":"function MPU6050_setDMPConfig2","text":"<pre><code>void MPU6050_setDMPConfig2 (\nuint8_t config\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setdmpenabled","title":"function MPU6050_setDMPEnabled","text":"<pre><code>void MPU6050_setDMPEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setdeviceid","title":"function MPU6050_setDeviceID","text":"<pre><code>void MPU6050_setDeviceID (\nuint8_t id\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setexternalframesync","title":"function MPU6050_setExternalFrameSync","text":"<pre><code>void MPU6050_setExternalFrameSync (\nuint8_t sync\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setexternalshadowdelayenabled","title":"function MPU6050_setExternalShadowDelayEnabled","text":"<pre><code>void MPU6050_setExternalShadowDelayEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setfifobyte","title":"function MPU6050_setFIFOByte","text":"<pre><code>void MPU6050_setFIFOByte (\nuint8_t data\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setfifoenabled","title":"function MPU6050_setFIFOEnabled","text":"<pre><code>void MPU6050_setFIFOEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setfsyncinterruptenabled","title":"function MPU6050_setFSyncInterruptEnabled","text":"<pre><code>void MPU6050_setFSyncInterruptEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setfsyncinterruptlevel","title":"function MPU6050_setFSyncInterruptLevel","text":"<pre><code>void MPU6050_setFSyncInterruptLevel (\nbool level\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setfreefalldetectioncounterdecrement","title":"function MPU6050_setFreefallDetectionCounterDecrement","text":"<pre><code>void MPU6050_setFreefallDetectionCounterDecrement (\nuint8_t decrement\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setfreefalldetectionduration","title":"function MPU6050_setFreefallDetectionDuration","text":"<pre><code>void MPU6050_setFreefallDetectionDuration (\nuint8_t duration\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setfreefalldetectionthreshold","title":"function MPU6050_setFreefallDetectionThreshold","text":"<pre><code>void MPU6050_setFreefallDetectionThreshold (\nuint8_t threshold\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setfullscaleaccelrange","title":"function MPU6050_setFullScaleAccelRange","text":"<pre><code>void MPU6050_setFullScaleAccelRange (\nuint8_t range\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setfullscalegyrorange","title":"function MPU6050_setFullScaleGyroRange","text":"<pre><code>void MPU6050_setFullScaleGyroRange (\nuint8_t range\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_seti2cbypassenabled","title":"function MPU6050_setI2CBypassEnabled","text":"<pre><code>void MPU6050_setI2CBypassEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_seti2cmastermodeenabled","title":"function MPU6050_setI2CMasterModeEnabled","text":"<pre><code>void MPU6050_setI2CMasterModeEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setintdmpenabled","title":"function MPU6050_setIntDMPEnabled","text":"<pre><code>void MPU6050_setIntDMPEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setintdatareadyenabled","title":"function MPU6050_setIntDataReadyEnabled","text":"<pre><code>void MPU6050_setIntDataReadyEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setintenabled","title":"function MPU6050_setIntEnabled","text":"<pre><code>void MPU6050_setIntEnabled (\nuint8_t enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setintfifobufferoverflowenabled","title":"function MPU6050_setIntFIFOBufferOverflowEnabled","text":"<pre><code>void MPU6050_setIntFIFOBufferOverflowEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setintfreefallenabled","title":"function MPU6050_setIntFreefallEnabled","text":"<pre><code>void MPU6050_setIntFreefallEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setinti2cmasterenabled","title":"function MPU6050_setIntI2CMasterEnabled","text":"<pre><code>void MPU6050_setIntI2CMasterEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setintmotionenabled","title":"function MPU6050_setIntMotionEnabled","text":"<pre><code>void MPU6050_setIntMotionEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setintpllreadyenabled","title":"function MPU6050_setIntPLLReadyEnabled","text":"<pre><code>void MPU6050_setIntPLLReadyEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setintzeromotionenabled","title":"function MPU6050_setIntZeroMotionEnabled","text":"<pre><code>void MPU6050_setIntZeroMotionEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setinterruptdrive","title":"function MPU6050_setInterruptDrive","text":"<pre><code>void MPU6050_setInterruptDrive (\nbool drive\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setinterruptlatch","title":"function MPU6050_setInterruptLatch","text":"<pre><code>void MPU6050_setInterruptLatch (\nbool latch\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setinterruptlatchclear","title":"function MPU6050_setInterruptLatchClear","text":"<pre><code>void MPU6050_setInterruptLatchClear (\nbool clear\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setinterruptmode","title":"function MPU6050_setInterruptMode","text":"<pre><code>void MPU6050_setInterruptMode (\nbool mode\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setmasterclockspeed","title":"function MPU6050_setMasterClockSpeed","text":"<pre><code>void MPU6050_setMasterClockSpeed (\nuint8_t speed\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setmemorybank","title":"function MPU6050_setMemoryBank","text":"<pre><code>void MPU6050_setMemoryBank (\nuint8_t bank,\nbool prefetchEnabled,\nbool userBank\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setmemorystartaddress","title":"function MPU6050_setMemoryStartAddress","text":"<pre><code>void MPU6050_setMemoryStartAddress (\nuint8_t address\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setmotiondetectioncounterdecrement","title":"function MPU6050_setMotionDetectionCounterDecrement","text":"<pre><code>void MPU6050_setMotionDetectionCounterDecrement (\nuint8_t decrement\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setmotiondetectionduration","title":"function MPU6050_setMotionDetectionDuration","text":"<pre><code>void MPU6050_setMotionDetectionDuration (\nuint8_t duration\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setmotiondetectionthreshold","title":"function MPU6050_setMotionDetectionThreshold","text":"<pre><code>void MPU6050_setMotionDetectionThreshold (\nuint8_t threshold\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setmultimasterenabled","title":"function MPU6050_setMultiMasterEnabled","text":"<pre><code>void MPU6050_setMultiMasterEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setotpbankvalid","title":"function MPU6050_setOTPBankValid","text":"<pre><code>void MPU6050_setOTPBankValid (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setrate","title":"function MPU6050_setRate","text":"<pre><code>void MPU6050_setRate (\nuint8_t rate\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setslave0fifoenabled","title":"function MPU6050_setSlave0FIFOEnabled","text":"<pre><code>void MPU6050_setSlave0FIFOEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setslave1fifoenabled","title":"function MPU6050_setSlave1FIFOEnabled","text":"<pre><code>void MPU6050_setSlave1FIFOEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setslave2fifoenabled","title":"function MPU6050_setSlave2FIFOEnabled","text":"<pre><code>void MPU6050_setSlave2FIFOEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setslave3fifoenabled","title":"function MPU6050_setSlave3FIFOEnabled","text":"<pre><code>void MPU6050_setSlave3FIFOEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setslave4address","title":"function MPU6050_setSlave4Address","text":"<pre><code>void MPU6050_setSlave4Address (\nuint8_t address\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setslave4enabled","title":"function MPU6050_setSlave4Enabled","text":"<pre><code>void MPU6050_setSlave4Enabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setslave4interruptenabled","title":"function MPU6050_setSlave4InterruptEnabled","text":"<pre><code>void MPU6050_setSlave4InterruptEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setslave4masterdelay","title":"function MPU6050_setSlave4MasterDelay","text":"<pre><code>void MPU6050_setSlave4MasterDelay (\nuint8_t delay\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setslave4outputbyte","title":"function MPU6050_setSlave4OutputByte","text":"<pre><code>void MPU6050_setSlave4OutputByte (\nuint8_t data\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setslave4register","title":"function MPU6050_setSlave4Register","text":"<pre><code>void MPU6050_setSlave4Register (\nuint8_t reg\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setslave4writemode","title":"function MPU6050_setSlave4WriteMode","text":"<pre><code>void MPU6050_setSlave4WriteMode (\nbool mode\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setslaveaddress","title":"function MPU6050_setSlaveAddress","text":"<pre><code>void MPU6050_setSlaveAddress (\nuint8_t num,\nuint8_t address\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setslavedatalength","title":"function MPU6050_setSlaveDataLength","text":"<pre><code>void MPU6050_setSlaveDataLength (\nuint8_t num,\nuint8_t length\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setslavedelayenabled","title":"function MPU6050_setSlaveDelayEnabled","text":"<pre><code>void MPU6050_setSlaveDelayEnabled (\nuint8_t num,\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setslaveenabled","title":"function MPU6050_setSlaveEnabled","text":"<pre><code>void MPU6050_setSlaveEnabled (\nuint8_t num,\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setslaveoutputbyte","title":"function MPU6050_setSlaveOutputByte","text":"<pre><code>void MPU6050_setSlaveOutputByte (\nuint8_t num,\nuint8_t data\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setslavereadwritetransitionenabled","title":"function MPU6050_setSlaveReadWriteTransitionEnabled","text":"<pre><code>void MPU6050_setSlaveReadWriteTransitionEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setslaveregister","title":"function MPU6050_setSlaveRegister","text":"<pre><code>void MPU6050_setSlaveRegister (\nuint8_t num,\nuint8_t reg\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setslavewordbyteswap","title":"function MPU6050_setSlaveWordByteSwap","text":"<pre><code>void MPU6050_setSlaveWordByteSwap (\nuint8_t num,\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setslavewordgroupoffset","title":"function MPU6050_setSlaveWordGroupOffset","text":"<pre><code>void MPU6050_setSlaveWordGroupOffset (\nuint8_t num,\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setslavewritemode","title":"function MPU6050_setSlaveWriteMode","text":"<pre><code>void MPU6050_setSlaveWriteMode (\nuint8_t num,\nbool mode\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setsleepenabled","title":"function MPU6050_setSleepEnabled","text":"<pre><code>void MPU6050_setSleepEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setstandbyxaccelenabled","title":"function MPU6050_setStandbyXAccelEnabled","text":"<pre><code>void MPU6050_setStandbyXAccelEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setstandbyxgyroenabled","title":"function MPU6050_setStandbyXGyroEnabled","text":"<pre><code>void MPU6050_setStandbyXGyroEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setstandbyyaccelenabled","title":"function MPU6050_setStandbyYAccelEnabled","text":"<pre><code>void MPU6050_setStandbyYAccelEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setstandbyygyroenabled","title":"function MPU6050_setStandbyYGyroEnabled","text":"<pre><code>void MPU6050_setStandbyYGyroEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setstandbyzaccelenabled","title":"function MPU6050_setStandbyZAccelEnabled","text":"<pre><code>void MPU6050_setStandbyZAccelEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setstandbyzgyroenabled","title":"function MPU6050_setStandbyZGyroEnabled","text":"<pre><code>void MPU6050_setStandbyZGyroEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_settempfifoenabled","title":"function MPU6050_setTempFIFOEnabled","text":"<pre><code>void MPU6050_setTempFIFOEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_settempsensorenabled","title":"function MPU6050_setTempSensorEnabled","text":"<pre><code>void MPU6050_setTempSensorEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setwaitforexternalsensorenabled","title":"function MPU6050_setWaitForExternalSensorEnabled","text":"<pre><code>void MPU6050_setWaitForExternalSensorEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setwakecycleenabled","title":"function MPU6050_setWakeCycleEnabled","text":"<pre><code>void MPU6050_setWakeCycleEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setwakefrequency","title":"function MPU6050_setWakeFrequency","text":"<pre><code>void MPU6050_setWakeFrequency (\nuint8_t frequency\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setxacceloffset","title":"function MPU6050_setXAccelOffset","text":"<pre><code>void MPU6050_setXAccelOffset (\nint16_t offset\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setxfinegain","title":"function MPU6050_setXFineGain","text":"<pre><code>void MPU6050_setXFineGain (\nint8_t gain\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setxgyrofifoenabled","title":"function MPU6050_setXGyroFIFOEnabled","text":"<pre><code>void MPU6050_setXGyroFIFOEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setxgyrooffset","title":"function MPU6050_setXGyroOffset","text":"<pre><code>void MPU6050_setXGyroOffset (\nint16_t offset\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setxgyrooffsettc","title":"function MPU6050_setXGyroOffsetTC","text":"<pre><code>void MPU6050_setXGyroOffsetTC (\nint8_t offset\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setyacceloffset","title":"function MPU6050_setYAccelOffset","text":"<pre><code>void MPU6050_setYAccelOffset (\nint16_t offset\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setyfinegain","title":"function MPU6050_setYFineGain","text":"<pre><code>void MPU6050_setYFineGain (\nint8_t gain\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setygyrofifoenabled","title":"function MPU6050_setYGyroFIFOEnabled","text":"<pre><code>void MPU6050_setYGyroFIFOEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setygyrooffset","title":"function MPU6050_setYGyroOffset","text":"<pre><code>void MPU6050_setYGyroOffset (\nint16_t offset\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setygyrooffsettc","title":"function MPU6050_setYGyroOffsetTC","text":"<pre><code>void MPU6050_setYGyroOffsetTC (\nint8_t offset\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setzacceloffset","title":"function MPU6050_setZAccelOffset","text":"<pre><code>void MPU6050_setZAccelOffset (\nint16_t offset\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setzfinegain","title":"function MPU6050_setZFineGain","text":"<pre><code>void MPU6050_setZFineGain (\nint8_t gain\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setzgyrofifoenabled","title":"function MPU6050_setZGyroFIFOEnabled","text":"<pre><code>void MPU6050_setZGyroFIFOEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setzgyrooffset","title":"function MPU6050_setZGyroOffset","text":"<pre><code>void MPU6050_setZGyroOffset (\nint16_t offset\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setzgyrooffsettc","title":"function MPU6050_setZGyroOffsetTC","text":"<pre><code>void MPU6050_setZGyroOffsetTC (\nint8_t offset\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setzeromotiondetectionduration","title":"function MPU6050_setZeroMotionDetectionDuration","text":"<pre><code>void MPU6050_setZeroMotionDetectionDuration (\nuint8_t duration\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_setzeromotiondetectionthreshold","title":"function MPU6050_setZeroMotionDetectionThreshold","text":"<pre><code>void MPU6050_setZeroMotionDetectionThreshold (\nuint8_t threshold\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_switchspienabled","title":"function MPU6050_switchSPIEnabled","text":"<pre><code>void MPU6050_switchSPIEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_testconnection","title":"function MPU6050_testConnection","text":"<pre><code>bool MPU6050_testConnection () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-mpu6050_writememorybyte","title":"function MPU6050_writeMemoryByte","text":"<pre><code>void MPU6050_writeMemoryByte (\nuint8_t data\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-getexternalsensordword","title":"function getExternalSensorDWord","text":"<pre><code>uint32_t getExternalSensorDWord (\nint position\n) </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-getxfinegain","title":"function getXFineGain","text":"<pre><code>int8_t getXFineGain () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-getxgyrooffsettc","title":"function getXGyroOffsetTC","text":"<pre><code>int8_t getXGyroOffsetTC () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-getyfinegain","title":"function getYFineGain","text":"<pre><code>int8_t getYFineGain () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-getygyrooffsettc","title":"function getYGyroOffsetTC","text":"<pre><code>int8_t getYGyroOffsetTC () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-getzfinegain","title":"function getZFineGain","text":"<pre><code>int8_t getZFineGain () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#function-getzgyrooffsettc","title":"function getZGyroOffsetTC","text":"<pre><code>int8_t getZGyroOffsetTC () </code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_accel_fifo_en_bit","title":"define MPU6050_ACCEL_FIFO_EN_BIT","text":"<pre><code>#define MPU6050_ACCEL_FIFO_EN_BIT 3\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_accel_fs_16","title":"define MPU6050_ACCEL_FS_16","text":"<pre><code>#define MPU6050_ACCEL_FS_16 0x03\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_accel_fs_2","title":"define MPU6050_ACCEL_FS_2","text":"<pre><code>#define MPU6050_ACCEL_FS_2 0x00\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_accel_fs_4","title":"define MPU6050_ACCEL_FS_4","text":"<pre><code>#define MPU6050_ACCEL_FS_4 0x01\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_accel_fs_8","title":"define MPU6050_ACCEL_FS_8","text":"<pre><code>#define MPU6050_ACCEL_FS_8 0x02\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_aconfig_accel_hpf_bit","title":"define MPU6050_ACONFIG_ACCEL_HPF_BIT","text":"<pre><code>#define MPU6050_ACONFIG_ACCEL_HPF_BIT 2\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_aconfig_accel_hpf_length","title":"define MPU6050_ACONFIG_ACCEL_HPF_LENGTH","text":"<pre><code>#define MPU6050_ACONFIG_ACCEL_HPF_LENGTH 3\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_aconfig_afs_sel_bit","title":"define MPU6050_ACONFIG_AFS_SEL_BIT","text":"<pre><code>#define MPU6050_ACONFIG_AFS_SEL_BIT 4\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_aconfig_afs_sel_length","title":"define MPU6050_ACONFIG_AFS_SEL_LENGTH","text":"<pre><code>#define MPU6050_ACONFIG_AFS_SEL_LENGTH 2\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_aconfig_xa_st_bit","title":"define MPU6050_ACONFIG_XA_ST_BIT","text":"<pre><code>#define MPU6050_ACONFIG_XA_ST_BIT 7\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_aconfig_ya_st_bit","title":"define MPU6050_ACONFIG_YA_ST_BIT","text":"<pre><code>#define MPU6050_ACONFIG_YA_ST_BIT 6\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_aconfig_za_st_bit","title":"define MPU6050_ACONFIG_ZA_ST_BIT","text":"<pre><code>#define MPU6050_ACONFIG_ZA_ST_BIT 5\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_address_ad0_high","title":"define MPU6050_ADDRESS_AD0_HIGH","text":"<pre><code>#define MPU6050_ADDRESS_AD0_HIGH 0x69\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_address_ad0_low","title":"define MPU6050_ADDRESS_AD0_LOW","text":"<pre><code>#define MPU6050_ADDRESS_AD0_LOW 0x68\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_banksel_cfg_user_bank_bit","title":"define MPU6050_BANKSEL_CFG_USER_BANK_BIT","text":"<pre><code>#define MPU6050_BANKSEL_CFG_USER_BANK_BIT 5\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_banksel_mem_sel_bit","title":"define MPU6050_BANKSEL_MEM_SEL_BIT","text":"<pre><code>#define MPU6050_BANKSEL_MEM_SEL_BIT 4\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_banksel_mem_sel_length","title":"define MPU6050_BANKSEL_MEM_SEL_LENGTH","text":"<pre><code>#define MPU6050_BANKSEL_MEM_SEL_LENGTH 5\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_banksel_prftch_en_bit","title":"define MPU6050_BANKSEL_PRFTCH_EN_BIT","text":"<pre><code>#define MPU6050_BANKSEL_PRFTCH_EN_BIT 6\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_cfg_dlpf_cfg_bit","title":"define MPU6050_CFG_DLPF_CFG_BIT","text":"<pre><code>#define MPU6050_CFG_DLPF_CFG_BIT 2\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_cfg_dlpf_cfg_length","title":"define MPU6050_CFG_DLPF_CFG_LENGTH","text":"<pre><code>#define MPU6050_CFG_DLPF_CFG_LENGTH 3\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_cfg_ext_sync_set_bit","title":"define MPU6050_CFG_EXT_SYNC_SET_BIT","text":"<pre><code>#define MPU6050_CFG_EXT_SYNC_SET_BIT 5\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_cfg_ext_sync_set_length","title":"define MPU6050_CFG_EXT_SYNC_SET_LENGTH","text":"<pre><code>#define MPU6050_CFG_EXT_SYNC_SET_LENGTH 3\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_clock_div_258","title":"define MPU6050_CLOCK_DIV_258","text":"<pre><code>#define MPU6050_CLOCK_DIV_258 0x8\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_clock_div_267","title":"define MPU6050_CLOCK_DIV_267","text":"<pre><code>#define MPU6050_CLOCK_DIV_267 0x7\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_clock_div_276","title":"define MPU6050_CLOCK_DIV_276","text":"<pre><code>#define MPU6050_CLOCK_DIV_276 0x6\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_clock_div_286","title":"define MPU6050_CLOCK_DIV_286","text":"<pre><code>#define MPU6050_CLOCK_DIV_286 0x5\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_clock_div_296","title":"define MPU6050_CLOCK_DIV_296","text":"<pre><code>#define MPU6050_CLOCK_DIV_296 0x4\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_clock_div_308","title":"define MPU6050_CLOCK_DIV_308","text":"<pre><code>#define MPU6050_CLOCK_DIV_308 0x3\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_clock_div_320","title":"define MPU6050_CLOCK_DIV_320","text":"<pre><code>#define MPU6050_CLOCK_DIV_320 0x2\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_clock_div_333","title":"define MPU6050_CLOCK_DIV_333","text":"<pre><code>#define MPU6050_CLOCK_DIV_333 0x1\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_clock_div_348","title":"define MPU6050_CLOCK_DIV_348","text":"<pre><code>#define MPU6050_CLOCK_DIV_348 0x0\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_clock_div_364","title":"define MPU6050_CLOCK_DIV_364","text":"<pre><code>#define MPU6050_CLOCK_DIV_364 0xF\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_clock_div_381","title":"define MPU6050_CLOCK_DIV_381","text":"<pre><code>#define MPU6050_CLOCK_DIV_381 0xE\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_clock_div_400","title":"define MPU6050_CLOCK_DIV_400","text":"<pre><code>#define MPU6050_CLOCK_DIV_400 0xD\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_clock_div_421","title":"define MPU6050_CLOCK_DIV_421","text":"<pre><code>#define MPU6050_CLOCK_DIV_421 0xC\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_clock_div_444","title":"define MPU6050_CLOCK_DIV_444","text":"<pre><code>#define MPU6050_CLOCK_DIV_444 0xB\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_clock_div_471","title":"define MPU6050_CLOCK_DIV_471","text":"<pre><code>#define MPU6050_CLOCK_DIV_471 0xA\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_clock_div_500","title":"define MPU6050_CLOCK_DIV_500","text":"<pre><code>#define MPU6050_CLOCK_DIV_500 0x9\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_clock_internal","title":"define MPU6050_CLOCK_INTERNAL","text":"<pre><code>#define MPU6050_CLOCK_INTERNAL 0x00\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_clock_keep_reset","title":"define MPU6050_CLOCK_KEEP_RESET","text":"<pre><code>#define MPU6050_CLOCK_KEEP_RESET 0x07\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_clock_pll_ext19m","title":"define MPU6050_CLOCK_PLL_EXT19M","text":"<pre><code>#define MPU6050_CLOCK_PLL_EXT19M 0x05\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_clock_pll_ext32k","title":"define MPU6050_CLOCK_PLL_EXT32K","text":"<pre><code>#define MPU6050_CLOCK_PLL_EXT32K 0x04\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_clock_pll_xgyro","title":"define MPU6050_CLOCK_PLL_XGYRO","text":"<pre><code>#define MPU6050_CLOCK_PLL_XGYRO 0x01\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_clock_pll_ygyro","title":"define MPU6050_CLOCK_PLL_YGYRO","text":"<pre><code>#define MPU6050_CLOCK_PLL_YGYRO 0x02\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_clock_pll_zgyro","title":"define MPU6050_CLOCK_PLL_ZGYRO","text":"<pre><code>#define MPU6050_CLOCK_PLL_ZGYRO 0x03\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_default_address","title":"define MPU6050_DEFAULT_ADDRESS","text":"<pre><code>#define MPU6050_DEFAULT_ADDRESS MPU6050_ADDRESS_AD0_LOW\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_delayctrl_delay_es_shadow_bit","title":"define MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT","text":"<pre><code>#define MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT 7\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_delayctrl_i2c_slv0_dly_en_bit","title":"define MPU6050_DELAYCTRL_I2C_SLV0_DLY_EN_BIT","text":"<pre><code>#define MPU6050_DELAYCTRL_I2C_SLV0_DLY_EN_BIT 0\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_delayctrl_i2c_slv1_dly_en_bit","title":"define MPU6050_DELAYCTRL_I2C_SLV1_DLY_EN_BIT","text":"<pre><code>#define MPU6050_DELAYCTRL_I2C_SLV1_DLY_EN_BIT 1\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_delayctrl_i2c_slv2_dly_en_bit","title":"define MPU6050_DELAYCTRL_I2C_SLV2_DLY_EN_BIT","text":"<pre><code>#define MPU6050_DELAYCTRL_I2C_SLV2_DLY_EN_BIT 2\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_delayctrl_i2c_slv3_dly_en_bit","title":"define MPU6050_DELAYCTRL_I2C_SLV3_DLY_EN_BIT","text":"<pre><code>#define MPU6050_DELAYCTRL_I2C_SLV3_DLY_EN_BIT 3\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_delayctrl_i2c_slv4_dly_en_bit","title":"define MPU6050_DELAYCTRL_I2C_SLV4_DLY_EN_BIT","text":"<pre><code>#define MPU6050_DELAYCTRL_I2C_SLV4_DLY_EN_BIT 4\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_detect_accel_on_delay_bit","title":"define MPU6050_DETECT_ACCEL_ON_DELAY_BIT","text":"<pre><code>#define MPU6050_DETECT_ACCEL_ON_DELAY_BIT 5\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_detect_accel_on_delay_length","title":"define MPU6050_DETECT_ACCEL_ON_DELAY_LENGTH","text":"<pre><code>#define MPU6050_DETECT_ACCEL_ON_DELAY_LENGTH 2\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_detect_decrement_1","title":"define MPU6050_DETECT_DECREMENT_1","text":"<pre><code>#define MPU6050_DETECT_DECREMENT_1 0x1\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_detect_decrement_2","title":"define MPU6050_DETECT_DECREMENT_2","text":"<pre><code>#define MPU6050_DETECT_DECREMENT_2 0x2\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_detect_decrement_4","title":"define MPU6050_DETECT_DECREMENT_4","text":"<pre><code>#define MPU6050_DETECT_DECREMENT_4 0x3\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_detect_decrement_reset","title":"define MPU6050_DETECT_DECREMENT_RESET","text":"<pre><code>#define MPU6050_DETECT_DECREMENT_RESET 0x0\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_detect_ff_count_bit","title":"define MPU6050_DETECT_FF_COUNT_BIT","text":"<pre><code>#define MPU6050_DETECT_FF_COUNT_BIT 3\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_detect_ff_count_length","title":"define MPU6050_DETECT_FF_COUNT_LENGTH","text":"<pre><code>#define MPU6050_DETECT_FF_COUNT_LENGTH 2\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_detect_mot_count_bit","title":"define MPU6050_DETECT_MOT_COUNT_BIT","text":"<pre><code>#define MPU6050_DETECT_MOT_COUNT_BIT 1\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_detect_mot_count_length","title":"define MPU6050_DETECT_MOT_COUNT_LENGTH","text":"<pre><code>#define MPU6050_DETECT_MOT_COUNT_LENGTH 2\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_dhpf_0p63","title":"define MPU6050_DHPF_0P63","text":"<pre><code>#define MPU6050_DHPF_0P63 0x04\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_dhpf_1p25","title":"define MPU6050_DHPF_1P25","text":"<pre><code>#define MPU6050_DHPF_1P25 0x03\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_dhpf_2p5","title":"define MPU6050_DHPF_2P5","text":"<pre><code>#define MPU6050_DHPF_2P5 0x02\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_dhpf_5","title":"define MPU6050_DHPF_5","text":"<pre><code>#define MPU6050_DHPF_5 0x01\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_dhpf_hold","title":"define MPU6050_DHPF_HOLD","text":"<pre><code>#define MPU6050_DHPF_HOLD 0x07\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_dhpf_reset","title":"define MPU6050_DHPF_RESET","text":"<pre><code>#define MPU6050_DHPF_RESET 0x00\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_dlpf_bw_10","title":"define MPU6050_DLPF_BW_10","text":"<pre><code>#define MPU6050_DLPF_BW_10 0x05\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_dlpf_bw_188","title":"define MPU6050_DLPF_BW_188","text":"<pre><code>#define MPU6050_DLPF_BW_188 0x01\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_dlpf_bw_20","title":"define MPU6050_DLPF_BW_20","text":"<pre><code>#define MPU6050_DLPF_BW_20 0x04\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_dlpf_bw_256","title":"define MPU6050_DLPF_BW_256","text":"<pre><code>#define MPU6050_DLPF_BW_256 0x00\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_dlpf_bw_42","title":"define MPU6050_DLPF_BW_42","text":"<pre><code>#define MPU6050_DLPF_BW_42 0x03\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_dlpf_bw_5","title":"define MPU6050_DLPF_BW_5","text":"<pre><code>#define MPU6050_DLPF_BW_5 0x06\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_dlpf_bw_98","title":"define MPU6050_DLPF_BW_98","text":"<pre><code>#define MPU6050_DLPF_BW_98 0x02\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_dmpint_0_bit","title":"define MPU6050_DMPINT_0_BIT","text":"<pre><code>#define MPU6050_DMPINT_0_BIT 0\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_dmpint_1_bit","title":"define MPU6050_DMPINT_1_BIT","text":"<pre><code>#define MPU6050_DMPINT_1_BIT 1\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_dmpint_2_bit","title":"define MPU6050_DMPINT_2_BIT","text":"<pre><code>#define MPU6050_DMPINT_2_BIT 2\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_dmpint_3_bit","title":"define MPU6050_DMPINT_3_BIT","text":"<pre><code>#define MPU6050_DMPINT_3_BIT 3\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_dmpint_4_bit","title":"define MPU6050_DMPINT_4_BIT","text":"<pre><code>#define MPU6050_DMPINT_4_BIT 4\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_dmpint_5_bit","title":"define MPU6050_DMPINT_5_BIT","text":"<pre><code>#define MPU6050_DMPINT_5_BIT 5\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_dmp_memory_banks","title":"define MPU6050_DMP_MEMORY_BANKS","text":"<pre><code>#define MPU6050_DMP_MEMORY_BANKS 8\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_dmp_memory_bank_size","title":"define MPU6050_DMP_MEMORY_BANK_SIZE","text":"<pre><code>#define MPU6050_DMP_MEMORY_BANK_SIZE 256\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_dmp_memory_chunk_size","title":"define MPU6050_DMP_MEMORY_CHUNK_SIZE","text":"<pre><code>#define MPU6050_DMP_MEMORY_CHUNK_SIZE 16\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ext_sync_accel_xout_l","title":"define MPU6050_EXT_SYNC_ACCEL_XOUT_L","text":"<pre><code>#define MPU6050_EXT_SYNC_ACCEL_XOUT_L 0x5\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ext_sync_accel_yout_l","title":"define MPU6050_EXT_SYNC_ACCEL_YOUT_L","text":"<pre><code>#define MPU6050_EXT_SYNC_ACCEL_YOUT_L 0x6\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ext_sync_accel_zout_l","title":"define MPU6050_EXT_SYNC_ACCEL_ZOUT_L","text":"<pre><code>#define MPU6050_EXT_SYNC_ACCEL_ZOUT_L 0x7\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ext_sync_disabled","title":"define MPU6050_EXT_SYNC_DISABLED","text":"<pre><code>#define MPU6050_EXT_SYNC_DISABLED 0x0\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ext_sync_gyro_xout_l","title":"define MPU6050_EXT_SYNC_GYRO_XOUT_L","text":"<pre><code>#define MPU6050_EXT_SYNC_GYRO_XOUT_L 0x2\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ext_sync_gyro_yout_l","title":"define MPU6050_EXT_SYNC_GYRO_YOUT_L","text":"<pre><code>#define MPU6050_EXT_SYNC_GYRO_YOUT_L 0x3\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ext_sync_gyro_zout_l","title":"define MPU6050_EXT_SYNC_GYRO_ZOUT_L","text":"<pre><code>#define MPU6050_EXT_SYNC_GYRO_ZOUT_L 0x4\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ext_sync_temp_out_l","title":"define MPU6050_EXT_SYNC_TEMP_OUT_L","text":"<pre><code>#define MPU6050_EXT_SYNC_TEMP_OUT_L 0x1\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_gconfig_fs_sel_bit","title":"define MPU6050_GCONFIG_FS_SEL_BIT","text":"<pre><code>#define MPU6050_GCONFIG_FS_SEL_BIT 4\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_gconfig_fs_sel_length","title":"define MPU6050_GCONFIG_FS_SEL_LENGTH","text":"<pre><code>#define MPU6050_GCONFIG_FS_SEL_LENGTH 2\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_gyro_fs_1000","title":"define MPU6050_GYRO_FS_1000","text":"<pre><code>#define MPU6050_GYRO_FS_1000 0x02\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_gyro_fs_2000","title":"define MPU6050_GYRO_FS_2000","text":"<pre><code>#define MPU6050_GYRO_FS_2000 0x03\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_gyro_fs_250","title":"define MPU6050_GYRO_FS_250","text":"<pre><code>#define MPU6050_GYRO_FS_250 0x00\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_gyro_fs_500","title":"define MPU6050_GYRO_FS_500","text":"<pre><code>#define MPU6050_GYRO_FS_500 0x01\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_i2c_mst_clk_bit","title":"define MPU6050_I2C_MST_CLK_BIT","text":"<pre><code>#define MPU6050_I2C_MST_CLK_BIT 3\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_i2c_mst_clk_length","title":"define MPU6050_I2C_MST_CLK_LENGTH","text":"<pre><code>#define MPU6050_I2C_MST_CLK_LENGTH 4\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_i2c_mst_p_nsr_bit","title":"define MPU6050_I2C_MST_P_NSR_BIT","text":"<pre><code>#define MPU6050_I2C_MST_P_NSR_BIT 4\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_i2c_slv4_addr_bit","title":"define MPU6050_I2C_SLV4_ADDR_BIT","text":"<pre><code>#define MPU6050_I2C_SLV4_ADDR_BIT 6\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_i2c_slv4_addr_length","title":"define MPU6050_I2C_SLV4_ADDR_LENGTH","text":"<pre><code>#define MPU6050_I2C_SLV4_ADDR_LENGTH 7\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_i2c_slv4_en_bit","title":"define MPU6050_I2C_SLV4_EN_BIT","text":"<pre><code>#define MPU6050_I2C_SLV4_EN_BIT 7\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_i2c_slv4_int_en_bit","title":"define MPU6050_I2C_SLV4_INT_EN_BIT","text":"<pre><code>#define MPU6050_I2C_SLV4_INT_EN_BIT 6\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_i2c_slv4_mst_dly_bit","title":"define MPU6050_I2C_SLV4_MST_DLY_BIT","text":"<pre><code>#define MPU6050_I2C_SLV4_MST_DLY_BIT 4\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_i2c_slv4_mst_dly_length","title":"define MPU6050_I2C_SLV4_MST_DLY_LENGTH","text":"<pre><code>#define MPU6050_I2C_SLV4_MST_DLY_LENGTH 5\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_i2c_slv4_reg_dis_bit","title":"define MPU6050_I2C_SLV4_REG_DIS_BIT","text":"<pre><code>#define MPU6050_I2C_SLV4_REG_DIS_BIT 5\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_i2c_slv4_rw_bit","title":"define MPU6050_I2C_SLV4_RW_BIT","text":"<pre><code>#define MPU6050_I2C_SLV4_RW_BIT 7\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_i2c_slv_addr_bit","title":"define MPU6050_I2C_SLV_ADDR_BIT","text":"<pre><code>#define MPU6050_I2C_SLV_ADDR_BIT 6\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_i2c_slv_addr_length","title":"define MPU6050_I2C_SLV_ADDR_LENGTH","text":"<pre><code>#define MPU6050_I2C_SLV_ADDR_LENGTH 7\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_i2c_slv_byte_sw_bit","title":"define MPU6050_I2C_SLV_BYTE_SW_BIT","text":"<pre><code>#define MPU6050_I2C_SLV_BYTE_SW_BIT 6\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_i2c_slv_en_bit","title":"define MPU6050_I2C_SLV_EN_BIT","text":"<pre><code>#define MPU6050_I2C_SLV_EN_BIT 7\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_i2c_slv_grp_bit","title":"define MPU6050_I2C_SLV_GRP_BIT","text":"<pre><code>#define MPU6050_I2C_SLV_GRP_BIT 4\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_i2c_slv_len_bit","title":"define MPU6050_I2C_SLV_LEN_BIT","text":"<pre><code>#define MPU6050_I2C_SLV_LEN_BIT 3\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_i2c_slv_len_length","title":"define MPU6050_I2C_SLV_LEN_LENGTH","text":"<pre><code>#define MPU6050_I2C_SLV_LEN_LENGTH 4\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_i2c_slv_reg_dis_bit","title":"define MPU6050_I2C_SLV_REG_DIS_BIT","text":"<pre><code>#define MPU6050_I2C_SLV_REG_DIS_BIT 5\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_i2c_slv_rw_bit","title":"define MPU6050_I2C_SLV_RW_BIT","text":"<pre><code>#define MPU6050_I2C_SLV_RW_BIT 7\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_intcfg_clkout_en_bit","title":"define MPU6050_INTCFG_CLKOUT_EN_BIT","text":"<pre><code>#define MPU6050_INTCFG_CLKOUT_EN_BIT 0\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_intcfg_fsync_int_en_bit","title":"define MPU6050_INTCFG_FSYNC_INT_EN_BIT","text":"<pre><code>#define MPU6050_INTCFG_FSYNC_INT_EN_BIT 2\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_intcfg_fsync_int_level_bit","title":"define MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT","text":"<pre><code>#define MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT 3\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_intcfg_i2c_bypass_en_bit","title":"define MPU6050_INTCFG_I2C_BYPASS_EN_BIT","text":"<pre><code>#define MPU6050_INTCFG_I2C_BYPASS_EN_BIT 1\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_intcfg_int_level_bit","title":"define MPU6050_INTCFG_INT_LEVEL_BIT","text":"<pre><code>#define MPU6050_INTCFG_INT_LEVEL_BIT 7\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_intcfg_int_open_bit","title":"define MPU6050_INTCFG_INT_OPEN_BIT","text":"<pre><code>#define MPU6050_INTCFG_INT_OPEN_BIT 6\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_intcfg_int_rd_clear_bit","title":"define MPU6050_INTCFG_INT_RD_CLEAR_BIT","text":"<pre><code>#define MPU6050_INTCFG_INT_RD_CLEAR_BIT 4\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_intcfg_latch_int_en_bit","title":"define MPU6050_INTCFG_LATCH_INT_EN_BIT","text":"<pre><code>#define MPU6050_INTCFG_LATCH_INT_EN_BIT 5\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_intclear_anyread","title":"define MPU6050_INTCLEAR_ANYREAD","text":"<pre><code>#define MPU6050_INTCLEAR_ANYREAD 0x01\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_intclear_statusread","title":"define MPU6050_INTCLEAR_STATUSREAD","text":"<pre><code>#define MPU6050_INTCLEAR_STATUSREAD 0x00\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_intdrv_opendrain","title":"define MPU6050_INTDRV_OPENDRAIN","text":"<pre><code>#define MPU6050_INTDRV_OPENDRAIN 0x01\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_intdrv_pushpull","title":"define MPU6050_INTDRV_PUSHPULL","text":"<pre><code>#define MPU6050_INTDRV_PUSHPULL 0x00\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_interrupt_data_rdy_bit","title":"define MPU6050_INTERRUPT_DATA_RDY_BIT","text":"<pre><code>#define MPU6050_INTERRUPT_DATA_RDY_BIT 0\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_interrupt_dmp_int_bit","title":"define MPU6050_INTERRUPT_DMP_INT_BIT","text":"<pre><code>#define MPU6050_INTERRUPT_DMP_INT_BIT 1\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_interrupt_ff_bit","title":"define MPU6050_INTERRUPT_FF_BIT","text":"<pre><code>#define MPU6050_INTERRUPT_FF_BIT 7\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_interrupt_fifo_oflow_bit","title":"define MPU6050_INTERRUPT_FIFO_OFLOW_BIT","text":"<pre><code>#define MPU6050_INTERRUPT_FIFO_OFLOW_BIT 4\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_interrupt_i2c_mst_int_bit","title":"define MPU6050_INTERRUPT_I2C_MST_INT_BIT","text":"<pre><code>#define MPU6050_INTERRUPT_I2C_MST_INT_BIT 3\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_interrupt_mot_bit","title":"define MPU6050_INTERRUPT_MOT_BIT","text":"<pre><code>#define MPU6050_INTERRUPT_MOT_BIT 6\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_interrupt_pll_rdy_int_bit","title":"define MPU6050_INTERRUPT_PLL_RDY_INT_BIT","text":"<pre><code>#define MPU6050_INTERRUPT_PLL_RDY_INT_BIT 2\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_interrupt_zmot_bit","title":"define MPU6050_INTERRUPT_ZMOT_BIT","text":"<pre><code>#define MPU6050_INTERRUPT_ZMOT_BIT 5\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_intlatch_50uspulse","title":"define MPU6050_INTLATCH_50USPULSE","text":"<pre><code>#define MPU6050_INTLATCH_50USPULSE 0x00\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_intlatch_waitclear","title":"define MPU6050_INTLATCH_WAITCLEAR","text":"<pre><code>#define MPU6050_INTLATCH_WAITCLEAR 0x01\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_intmode_activehigh","title":"define MPU6050_INTMODE_ACTIVEHIGH","text":"<pre><code>#define MPU6050_INTMODE_ACTIVEHIGH 0x00\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_intmode_activelow","title":"define MPU6050_INTMODE_ACTIVELOW","text":"<pre><code>#define MPU6050_INTMODE_ACTIVELOW 0x01\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_motion_mot_xneg_bit","title":"define MPU6050_MOTION_MOT_XNEG_BIT","text":"<pre><code>#define MPU6050_MOTION_MOT_XNEG_BIT 7\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_motion_mot_xpos_bit","title":"define MPU6050_MOTION_MOT_XPOS_BIT","text":"<pre><code>#define MPU6050_MOTION_MOT_XPOS_BIT 6\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_motion_mot_yneg_bit","title":"define MPU6050_MOTION_MOT_YNEG_BIT","text":"<pre><code>#define MPU6050_MOTION_MOT_YNEG_BIT 5\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_motion_mot_ypos_bit","title":"define MPU6050_MOTION_MOT_YPOS_BIT","text":"<pre><code>#define MPU6050_MOTION_MOT_YPOS_BIT 4\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_motion_mot_zneg_bit","title":"define MPU6050_MOTION_MOT_ZNEG_BIT","text":"<pre><code>#define MPU6050_MOTION_MOT_ZNEG_BIT 3\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_motion_mot_zpos_bit","title":"define MPU6050_MOTION_MOT_ZPOS_BIT","text":"<pre><code>#define MPU6050_MOTION_MOT_ZPOS_BIT 2\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_motion_mot_zrmot_bit","title":"define MPU6050_MOTION_MOT_ZRMOT_BIT","text":"<pre><code>#define MPU6050_MOTION_MOT_ZRMOT_BIT 0\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_mst_i2c_lost_arb_bit","title":"define MPU6050_MST_I2C_LOST_ARB_BIT","text":"<pre><code>#define MPU6050_MST_I2C_LOST_ARB_BIT 5\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_mst_i2c_slv0_nack_bit","title":"define MPU6050_MST_I2C_SLV0_NACK_BIT","text":"<pre><code>#define MPU6050_MST_I2C_SLV0_NACK_BIT 0\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_mst_i2c_slv1_nack_bit","title":"define MPU6050_MST_I2C_SLV1_NACK_BIT","text":"<pre><code>#define MPU6050_MST_I2C_SLV1_NACK_BIT 1\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_mst_i2c_slv2_nack_bit","title":"define MPU6050_MST_I2C_SLV2_NACK_BIT","text":"<pre><code>#define MPU6050_MST_I2C_SLV2_NACK_BIT 2\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_mst_i2c_slv3_nack_bit","title":"define MPU6050_MST_I2C_SLV3_NACK_BIT","text":"<pre><code>#define MPU6050_MST_I2C_SLV3_NACK_BIT 3\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_mst_i2c_slv4_done_bit","title":"define MPU6050_MST_I2C_SLV4_DONE_BIT","text":"<pre><code>#define MPU6050_MST_I2C_SLV4_DONE_BIT 6\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_mst_i2c_slv4_nack_bit","title":"define MPU6050_MST_I2C_SLV4_NACK_BIT","text":"<pre><code>#define MPU6050_MST_I2C_SLV4_NACK_BIT 4\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_mst_pass_through_bit","title":"define MPU6050_MST_PASS_THROUGH_BIT","text":"<pre><code>#define MPU6050_MST_PASS_THROUGH_BIT 7\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_mult_mst_en_bit","title":"define MPU6050_MULT_MST_EN_BIT","text":"<pre><code>#define MPU6050_MULT_MST_EN_BIT 7\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_pathreset_accel_reset_bit","title":"define MPU6050_PATHRESET_ACCEL_RESET_BIT","text":"<pre><code>#define MPU6050_PATHRESET_ACCEL_RESET_BIT 1\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_pathreset_gyro_reset_bit","title":"define MPU6050_PATHRESET_GYRO_RESET_BIT","text":"<pre><code>#define MPU6050_PATHRESET_GYRO_RESET_BIT 2\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_pathreset_temp_reset_bit","title":"define MPU6050_PATHRESET_TEMP_RESET_BIT","text":"<pre><code>#define MPU6050_PATHRESET_TEMP_RESET_BIT 0\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_pwr1_clksel_bit","title":"define MPU6050_PWR1_CLKSEL_BIT","text":"<pre><code>#define MPU6050_PWR1_CLKSEL_BIT 2\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_pwr1_clksel_length","title":"define MPU6050_PWR1_CLKSEL_LENGTH","text":"<pre><code>#define MPU6050_PWR1_CLKSEL_LENGTH 3\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_pwr1_cycle_bit","title":"define MPU6050_PWR1_CYCLE_BIT","text":"<pre><code>#define MPU6050_PWR1_CYCLE_BIT 5\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_pwr1_device_reset_bit","title":"define MPU6050_PWR1_DEVICE_RESET_BIT","text":"<pre><code>#define MPU6050_PWR1_DEVICE_RESET_BIT 7\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_pwr1_sleep_bit","title":"define MPU6050_PWR1_SLEEP_BIT","text":"<pre><code>#define MPU6050_PWR1_SLEEP_BIT 6\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_pwr1_temp_dis_bit","title":"define MPU6050_PWR1_TEMP_DIS_BIT","text":"<pre><code>#define MPU6050_PWR1_TEMP_DIS_BIT 3\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_pwr2_lp_wake_ctrl_bit","title":"define MPU6050_PWR2_LP_WAKE_CTRL_BIT","text":"<pre><code>#define MPU6050_PWR2_LP_WAKE_CTRL_BIT 7\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_pwr2_lp_wake_ctrl_length","title":"define MPU6050_PWR2_LP_WAKE_CTRL_LENGTH","text":"<pre><code>#define MPU6050_PWR2_LP_WAKE_CTRL_LENGTH 2\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_pwr2_stby_xa_bit","title":"define MPU6050_PWR2_STBY_XA_BIT","text":"<pre><code>#define MPU6050_PWR2_STBY_XA_BIT 5\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_pwr2_stby_xg_bit","title":"define MPU6050_PWR2_STBY_XG_BIT","text":"<pre><code>#define MPU6050_PWR2_STBY_XG_BIT 2\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_pwr2_stby_ya_bit","title":"define MPU6050_PWR2_STBY_YA_BIT","text":"<pre><code>#define MPU6050_PWR2_STBY_YA_BIT 4\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_pwr2_stby_yg_bit","title":"define MPU6050_PWR2_STBY_YG_BIT","text":"<pre><code>#define MPU6050_PWR2_STBY_YG_BIT 1\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_pwr2_stby_za_bit","title":"define MPU6050_PWR2_STBY_ZA_BIT","text":"<pre><code>#define MPU6050_PWR2_STBY_ZA_BIT 3\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_pwr2_stby_zg_bit","title":"define MPU6050_PWR2_STBY_ZG_BIT","text":"<pre><code>#define MPU6050_PWR2_STBY_ZG_BIT 0\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_accel_config","title":"define MPU6050_RA_ACCEL_CONFIG","text":"<pre><code>#define MPU6050_RA_ACCEL_CONFIG 0x1C\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_accel_xout_h","title":"define MPU6050_RA_ACCEL_XOUT_H","text":"<pre><code>#define MPU6050_RA_ACCEL_XOUT_H 0x3B\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_accel_xout_l","title":"define MPU6050_RA_ACCEL_XOUT_L","text":"<pre><code>#define MPU6050_RA_ACCEL_XOUT_L 0x3C\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_accel_yout_h","title":"define MPU6050_RA_ACCEL_YOUT_H","text":"<pre><code>#define MPU6050_RA_ACCEL_YOUT_H 0x3D\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_accel_yout_l","title":"define MPU6050_RA_ACCEL_YOUT_L","text":"<pre><code>#define MPU6050_RA_ACCEL_YOUT_L 0x3E\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_accel_zout_h","title":"define MPU6050_RA_ACCEL_ZOUT_H","text":"<pre><code>#define MPU6050_RA_ACCEL_ZOUT_H 0x3F\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_accel_zout_l","title":"define MPU6050_RA_ACCEL_ZOUT_L","text":"<pre><code>#define MPU6050_RA_ACCEL_ZOUT_L 0x40\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_bank_sel","title":"define MPU6050_RA_BANK_SEL","text":"<pre><code>#define MPU6050_RA_BANK_SEL 0x6D\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_config","title":"define MPU6050_RA_CONFIG","text":"<pre><code>#define MPU6050_RA_CONFIG 0x1A\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_dmp_cfg_1","title":"define MPU6050_RA_DMP_CFG_1","text":"<pre><code>#define MPU6050_RA_DMP_CFG_1 0x70\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_dmp_cfg_2","title":"define MPU6050_RA_DMP_CFG_2","text":"<pre><code>#define MPU6050_RA_DMP_CFG_2 0x71\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_dmp_int_status","title":"define MPU6050_RA_DMP_INT_STATUS","text":"<pre><code>#define MPU6050_RA_DMP_INT_STATUS 0x39\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_00","title":"define MPU6050_RA_EXT_SENS_DATA_00","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_00 0x49\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_01","title":"define MPU6050_RA_EXT_SENS_DATA_01","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_01 0x4A\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_02","title":"define MPU6050_RA_EXT_SENS_DATA_02","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_02 0x4B\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_03","title":"define MPU6050_RA_EXT_SENS_DATA_03","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_03 0x4C\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_04","title":"define MPU6050_RA_EXT_SENS_DATA_04","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_04 0x4D\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_05","title":"define MPU6050_RA_EXT_SENS_DATA_05","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_05 0x4E\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_06","title":"define MPU6050_RA_EXT_SENS_DATA_06","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_06 0x4F\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_07","title":"define MPU6050_RA_EXT_SENS_DATA_07","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_07 0x50\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_08","title":"define MPU6050_RA_EXT_SENS_DATA_08","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_08 0x51\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_09","title":"define MPU6050_RA_EXT_SENS_DATA_09","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_09 0x52\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_10","title":"define MPU6050_RA_EXT_SENS_DATA_10","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_10 0x53\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_11","title":"define MPU6050_RA_EXT_SENS_DATA_11","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_11 0x54\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_12","title":"define MPU6050_RA_EXT_SENS_DATA_12","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_12 0x55\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_13","title":"define MPU6050_RA_EXT_SENS_DATA_13","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_13 0x56\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_14","title":"define MPU6050_RA_EXT_SENS_DATA_14","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_14 0x57\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_15","title":"define MPU6050_RA_EXT_SENS_DATA_15","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_15 0x58\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_16","title":"define MPU6050_RA_EXT_SENS_DATA_16","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_16 0x59\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_17","title":"define MPU6050_RA_EXT_SENS_DATA_17","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_17 0x5A\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_18","title":"define MPU6050_RA_EXT_SENS_DATA_18","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_18 0x5B\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_19","title":"define MPU6050_RA_EXT_SENS_DATA_19","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_19 0x5C\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_20","title":"define MPU6050_RA_EXT_SENS_DATA_20","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_20 0x5D\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_21","title":"define MPU6050_RA_EXT_SENS_DATA_21","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_21 0x5E\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_22","title":"define MPU6050_RA_EXT_SENS_DATA_22","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_22 0x5F\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ext_sens_data_23","title":"define MPU6050_RA_EXT_SENS_DATA_23","text":"<pre><code>#define MPU6050_RA_EXT_SENS_DATA_23 0x60\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ff_dur","title":"define MPU6050_RA_FF_DUR","text":"<pre><code>#define MPU6050_RA_FF_DUR 0x1E\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ff_thr","title":"define MPU6050_RA_FF_THR","text":"<pre><code>#define MPU6050_RA_FF_THR 0x1D\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_fifo_counth","title":"define MPU6050_RA_FIFO_COUNTH","text":"<pre><code>#define MPU6050_RA_FIFO_COUNTH 0x72\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_fifo_countl","title":"define MPU6050_RA_FIFO_COUNTL","text":"<pre><code>#define MPU6050_RA_FIFO_COUNTL 0x73\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_fifo_en","title":"define MPU6050_RA_FIFO_EN","text":"<pre><code>#define MPU6050_RA_FIFO_EN 0x23\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_fifo_r_w","title":"define MPU6050_RA_FIFO_R_W","text":"<pre><code>#define MPU6050_RA_FIFO_R_W 0x74\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_gyro_config","title":"define MPU6050_RA_GYRO_CONFIG","text":"<pre><code>#define MPU6050_RA_GYRO_CONFIG 0x1B\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_gyro_xout_h","title":"define MPU6050_RA_GYRO_XOUT_H","text":"<pre><code>#define MPU6050_RA_GYRO_XOUT_H 0x43\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_gyro_xout_l","title":"define MPU6050_RA_GYRO_XOUT_L","text":"<pre><code>#define MPU6050_RA_GYRO_XOUT_L 0x44\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_gyro_yout_h","title":"define MPU6050_RA_GYRO_YOUT_H","text":"<pre><code>#define MPU6050_RA_GYRO_YOUT_H 0x45\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_gyro_yout_l","title":"define MPU6050_RA_GYRO_YOUT_L","text":"<pre><code>#define MPU6050_RA_GYRO_YOUT_L 0x46\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_gyro_zout_h","title":"define MPU6050_RA_GYRO_ZOUT_H","text":"<pre><code>#define MPU6050_RA_GYRO_ZOUT_H 0x47\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_gyro_zout_l","title":"define MPU6050_RA_GYRO_ZOUT_L","text":"<pre><code>#define MPU6050_RA_GYRO_ZOUT_L 0x48\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_mst_ctrl","title":"define MPU6050_RA_I2C_MST_CTRL","text":"<pre><code>#define MPU6050_RA_I2C_MST_CTRL 0x24\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_mst_delay_ctrl","title":"define MPU6050_RA_I2C_MST_DELAY_CTRL","text":"<pre><code>#define MPU6050_RA_I2C_MST_DELAY_CTRL 0x67\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_mst_status","title":"define MPU6050_RA_I2C_MST_STATUS","text":"<pre><code>#define MPU6050_RA_I2C_MST_STATUS 0x36\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv0_addr","title":"define MPU6050_RA_I2C_SLV0_ADDR","text":"<pre><code>#define MPU6050_RA_I2C_SLV0_ADDR 0x25\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv0_ctrl","title":"define MPU6050_RA_I2C_SLV0_CTRL","text":"<pre><code>#define MPU6050_RA_I2C_SLV0_CTRL 0x27\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv0_do","title":"define MPU6050_RA_I2C_SLV0_DO","text":"<pre><code>#define MPU6050_RA_I2C_SLV0_DO 0x63\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv0_reg","title":"define MPU6050_RA_I2C_SLV0_REG","text":"<pre><code>#define MPU6050_RA_I2C_SLV0_REG 0x26\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv1_addr","title":"define MPU6050_RA_I2C_SLV1_ADDR","text":"<pre><code>#define MPU6050_RA_I2C_SLV1_ADDR 0x28\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv1_ctrl","title":"define MPU6050_RA_I2C_SLV1_CTRL","text":"<pre><code>#define MPU6050_RA_I2C_SLV1_CTRL 0x2A\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv1_do","title":"define MPU6050_RA_I2C_SLV1_DO","text":"<pre><code>#define MPU6050_RA_I2C_SLV1_DO 0x64\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv1_reg","title":"define MPU6050_RA_I2C_SLV1_REG","text":"<pre><code>#define MPU6050_RA_I2C_SLV1_REG 0x29\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv2_addr","title":"define MPU6050_RA_I2C_SLV2_ADDR","text":"<pre><code>#define MPU6050_RA_I2C_SLV2_ADDR 0x2B\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv2_ctrl","title":"define MPU6050_RA_I2C_SLV2_CTRL","text":"<pre><code>#define MPU6050_RA_I2C_SLV2_CTRL 0x2D\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv2_do","title":"define MPU6050_RA_I2C_SLV2_DO","text":"<pre><code>#define MPU6050_RA_I2C_SLV2_DO 0x65\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv2_reg","title":"define MPU6050_RA_I2C_SLV2_REG","text":"<pre><code>#define MPU6050_RA_I2C_SLV2_REG 0x2C\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv3_addr","title":"define MPU6050_RA_I2C_SLV3_ADDR","text":"<pre><code>#define MPU6050_RA_I2C_SLV3_ADDR 0x2E\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv3_ctrl","title":"define MPU6050_RA_I2C_SLV3_CTRL","text":"<pre><code>#define MPU6050_RA_I2C_SLV3_CTRL 0x30\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv3_do","title":"define MPU6050_RA_I2C_SLV3_DO","text":"<pre><code>#define MPU6050_RA_I2C_SLV3_DO 0x66\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv3_reg","title":"define MPU6050_RA_I2C_SLV3_REG","text":"<pre><code>#define MPU6050_RA_I2C_SLV3_REG 0x2F\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv4_addr","title":"define MPU6050_RA_I2C_SLV4_ADDR","text":"<pre><code>#define MPU6050_RA_I2C_SLV4_ADDR 0x31\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv4_ctrl","title":"define MPU6050_RA_I2C_SLV4_CTRL","text":"<pre><code>#define MPU6050_RA_I2C_SLV4_CTRL 0x34\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv4_di","title":"define MPU6050_RA_I2C_SLV4_DI","text":"<pre><code>#define MPU6050_RA_I2C_SLV4_DI 0x35\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv4_do","title":"define MPU6050_RA_I2C_SLV4_DO","text":"<pre><code>#define MPU6050_RA_I2C_SLV4_DO 0x33\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_i2c_slv4_reg","title":"define MPU6050_RA_I2C_SLV4_REG","text":"<pre><code>#define MPU6050_RA_I2C_SLV4_REG 0x32\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_int_enable","title":"define MPU6050_RA_INT_ENABLE","text":"<pre><code>#define MPU6050_RA_INT_ENABLE 0x38\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_int_pin_cfg","title":"define MPU6050_RA_INT_PIN_CFG","text":"<pre><code>#define MPU6050_RA_INT_PIN_CFG 0x37\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_int_status","title":"define MPU6050_RA_INT_STATUS","text":"<pre><code>#define MPU6050_RA_INT_STATUS 0x3A\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_mem_r_w","title":"define MPU6050_RA_MEM_R_W","text":"<pre><code>#define MPU6050_RA_MEM_R_W 0x6F\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_mem_start_addr","title":"define MPU6050_RA_MEM_START_ADDR","text":"<pre><code>#define MPU6050_RA_MEM_START_ADDR 0x6E\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_mot_detect_ctrl","title":"define MPU6050_RA_MOT_DETECT_CTRL","text":"<pre><code>#define MPU6050_RA_MOT_DETECT_CTRL 0x69\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_mot_detect_status","title":"define MPU6050_RA_MOT_DETECT_STATUS","text":"<pre><code>#define MPU6050_RA_MOT_DETECT_STATUS 0x61\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_mot_dur","title":"define MPU6050_RA_MOT_DUR","text":"<pre><code>#define MPU6050_RA_MOT_DUR 0x20\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_mot_thr","title":"define MPU6050_RA_MOT_THR","text":"<pre><code>#define MPU6050_RA_MOT_THR 0x1F\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_pwr_mgmt_1","title":"define MPU6050_RA_PWR_MGMT_1","text":"<pre><code>#define MPU6050_RA_PWR_MGMT_1 0x6B\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_pwr_mgmt_2","title":"define MPU6050_RA_PWR_MGMT_2","text":"<pre><code>#define MPU6050_RA_PWR_MGMT_2 0x6C\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_signal_path_reset","title":"define MPU6050_RA_SIGNAL_PATH_RESET","text":"<pre><code>#define MPU6050_RA_SIGNAL_PATH_RESET 0x68\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_smplrt_div","title":"define MPU6050_RA_SMPLRT_DIV","text":"<pre><code>#define MPU6050_RA_SMPLRT_DIV 0x19\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_temp_out_h","title":"define MPU6050_RA_TEMP_OUT_H","text":"<pre><code>#define MPU6050_RA_TEMP_OUT_H 0x41\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_temp_out_l","title":"define MPU6050_RA_TEMP_OUT_L","text":"<pre><code>#define MPU6050_RA_TEMP_OUT_L 0x42\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_user_ctrl","title":"define MPU6050_RA_USER_CTRL","text":"<pre><code>#define MPU6050_RA_USER_CTRL 0x6A\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_who_am_i","title":"define MPU6050_RA_WHO_AM_I","text":"<pre><code>#define MPU6050_RA_WHO_AM_I 0x75\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_xa_offs_h","title":"define MPU6050_RA_XA_OFFS_H","text":"<pre><code>#define MPU6050_RA_XA_OFFS_H 0x06\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_xa_offs_l_tc","title":"define MPU6050_RA_XA_OFFS_L_TC","text":"<pre><code>#define MPU6050_RA_XA_OFFS_L_TC 0x07\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_xg_offs_tc","title":"define MPU6050_RA_XG_OFFS_TC","text":"<pre><code>#define MPU6050_RA_XG_OFFS_TC 0x00\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_xg_offs_usrh","title":"define MPU6050_RA_XG_OFFS_USRH","text":"<pre><code>#define MPU6050_RA_XG_OFFS_USRH 0x13\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_xg_offs_usrl","title":"define MPU6050_RA_XG_OFFS_USRL","text":"<pre><code>#define MPU6050_RA_XG_OFFS_USRL 0x14\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_x_fine_gain","title":"define MPU6050_RA_X_FINE_GAIN","text":"<pre><code>#define MPU6050_RA_X_FINE_GAIN 0x03\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ya_offs_h","title":"define MPU6050_RA_YA_OFFS_H","text":"<pre><code>#define MPU6050_RA_YA_OFFS_H 0x08\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_ya_offs_l_tc","title":"define MPU6050_RA_YA_OFFS_L_TC","text":"<pre><code>#define MPU6050_RA_YA_OFFS_L_TC 0x09\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_yg_offs_tc","title":"define MPU6050_RA_YG_OFFS_TC","text":"<pre><code>#define MPU6050_RA_YG_OFFS_TC 0x01\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_yg_offs_usrh","title":"define MPU6050_RA_YG_OFFS_USRH","text":"<pre><code>#define MPU6050_RA_YG_OFFS_USRH 0x15\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_yg_offs_usrl","title":"define MPU6050_RA_YG_OFFS_USRL","text":"<pre><code>#define MPU6050_RA_YG_OFFS_USRL 0x16\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_y_fine_gain","title":"define MPU6050_RA_Y_FINE_GAIN","text":"<pre><code>#define MPU6050_RA_Y_FINE_GAIN 0x04\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_za_offs_h","title":"define MPU6050_RA_ZA_OFFS_H","text":"<pre><code>#define MPU6050_RA_ZA_OFFS_H 0x0A\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_za_offs_l_tc","title":"define MPU6050_RA_ZA_OFFS_L_TC","text":"<pre><code>#define MPU6050_RA_ZA_OFFS_L_TC 0x0B\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_zg_offs_tc","title":"define MPU6050_RA_ZG_OFFS_TC","text":"<pre><code>#define MPU6050_RA_ZG_OFFS_TC 0x02\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_zg_offs_usrh","title":"define MPU6050_RA_ZG_OFFS_USRH","text":"<pre><code>#define MPU6050_RA_ZG_OFFS_USRH 0x17\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_zg_offs_usrl","title":"define MPU6050_RA_ZG_OFFS_USRL","text":"<pre><code>#define MPU6050_RA_ZG_OFFS_USRL 0x18\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_zrmot_dur","title":"define MPU6050_RA_ZRMOT_DUR","text":"<pre><code>#define MPU6050_RA_ZRMOT_DUR 0x22\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_zrmot_thr","title":"define MPU6050_RA_ZRMOT_THR","text":"<pre><code>#define MPU6050_RA_ZRMOT_THR 0x21\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_ra_z_fine_gain","title":"define MPU6050_RA_Z_FINE_GAIN","text":"<pre><code>#define MPU6050_RA_Z_FINE_GAIN 0x05\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_slv0_fifo_en_bit","title":"define MPU6050_SLV0_FIFO_EN_BIT","text":"<pre><code>#define MPU6050_SLV0_FIFO_EN_BIT 0\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_slv1_fifo_en_bit","title":"define MPU6050_SLV1_FIFO_EN_BIT","text":"<pre><code>#define MPU6050_SLV1_FIFO_EN_BIT 1\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_slv2_fifo_en_bit","title":"define MPU6050_SLV2_FIFO_EN_BIT","text":"<pre><code>#define MPU6050_SLV2_FIFO_EN_BIT 2\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_slv_3_fifo_en_bit","title":"define MPU6050_SLV_3_FIFO_EN_BIT","text":"<pre><code>#define MPU6050_SLV_3_FIFO_EN_BIT 5\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_tc_offset_bit","title":"define MPU6050_TC_OFFSET_BIT","text":"<pre><code>#define MPU6050_TC_OFFSET_BIT 6\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_tc_offset_length","title":"define MPU6050_TC_OFFSET_LENGTH","text":"<pre><code>#define MPU6050_TC_OFFSET_LENGTH 6\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_tc_otp_bnk_vld_bit","title":"define MPU6050_TC_OTP_BNK_VLD_BIT","text":"<pre><code>#define MPU6050_TC_OTP_BNK_VLD_BIT 0\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_tc_pwr_mode_bit","title":"define MPU6050_TC_PWR_MODE_BIT","text":"<pre><code>#define MPU6050_TC_PWR_MODE_BIT 7\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_temp_fifo_en_bit","title":"define MPU6050_TEMP_FIFO_EN_BIT","text":"<pre><code>#define MPU6050_TEMP_FIFO_EN_BIT 7\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_userctrl_dmp_en_bit","title":"define MPU6050_USERCTRL_DMP_EN_BIT","text":"<pre><code>#define MPU6050_USERCTRL_DMP_EN_BIT 7\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_userctrl_dmp_reset_bit","title":"define MPU6050_USERCTRL_DMP_RESET_BIT","text":"<pre><code>#define MPU6050_USERCTRL_DMP_RESET_BIT 3\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_userctrl_fifo_en_bit","title":"define MPU6050_USERCTRL_FIFO_EN_BIT","text":"<pre><code>#define MPU6050_USERCTRL_FIFO_EN_BIT 6\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_userctrl_fifo_reset_bit","title":"define MPU6050_USERCTRL_FIFO_RESET_BIT","text":"<pre><code>#define MPU6050_USERCTRL_FIFO_RESET_BIT 2\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_userctrl_i2c_if_dis_bit","title":"define MPU6050_USERCTRL_I2C_IF_DIS_BIT","text":"<pre><code>#define MPU6050_USERCTRL_I2C_IF_DIS_BIT 4\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_userctrl_i2c_mst_en_bit","title":"define MPU6050_USERCTRL_I2C_MST_EN_BIT","text":"<pre><code>#define MPU6050_USERCTRL_I2C_MST_EN_BIT 5\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_userctrl_i2c_mst_reset_bit","title":"define MPU6050_USERCTRL_I2C_MST_RESET_BIT","text":"<pre><code>#define MPU6050_USERCTRL_I2C_MST_RESET_BIT 1\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_userctrl_sig_cond_reset_bit","title":"define MPU6050_USERCTRL_SIG_COND_RESET_BIT","text":"<pre><code>#define MPU6050_USERCTRL_SIG_COND_RESET_BIT 0\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_vddio_level_vdd","title":"define MPU6050_VDDIO_LEVEL_VDD","text":"<pre><code>#define MPU6050_VDDIO_LEVEL_VDD 1\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_vddio_level_vlogic","title":"define MPU6050_VDDIO_LEVEL_VLOGIC","text":"<pre><code>#define MPU6050_VDDIO_LEVEL_VLOGIC 0\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_wait_for_es_bit","title":"define MPU6050_WAIT_FOR_ES_BIT","text":"<pre><code>#define MPU6050_WAIT_FOR_ES_BIT 6\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_wake_freq_10","title":"define MPU6050_WAKE_FREQ_10","text":"<pre><code>#define MPU6050_WAKE_FREQ_10 0x3\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_wake_freq_1p25","title":"define MPU6050_WAKE_FREQ_1P25","text":"<pre><code>#define MPU6050_WAKE_FREQ_1P25 0x0\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_wake_freq_2p5","title":"define MPU6050_WAKE_FREQ_2P5","text":"<pre><code>#define MPU6050_WAKE_FREQ_2P5 0x1\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_wake_freq_5","title":"define MPU6050_WAKE_FREQ_5","text":"<pre><code>#define MPU6050_WAKE_FREQ_5 0x2\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_who_am_i_bit","title":"define MPU6050_WHO_AM_I_BIT","text":"<pre><code>#define MPU6050_WHO_AM_I_BIT 6\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_who_am_i_length","title":"define MPU6050_WHO_AM_I_LENGTH","text":"<pre><code>#define MPU6050_WHO_AM_I_LENGTH 6\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_xg_fifo_en_bit","title":"define MPU6050_XG_FIFO_EN_BIT","text":"<pre><code>#define MPU6050_XG_FIFO_EN_BIT 6\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_yg_fifo_en_bit","title":"define MPU6050_YG_FIFO_EN_BIT","text":"<pre><code>#define MPU6050_YG_FIFO_EN_BIT 5\n</code></pre>"},{"location":"apiStm/Mpu6050_8hpp/#define-mpu6050_zg_fifo_en_bit","title":"define MPU6050_ZG_FIFO_EN_BIT","text":"<pre><code>#define MPU6050_ZG_FIFO_EN_BIT 4\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/Mpu6050.hpp</code></p>"},{"location":"apiStm/Mpu6050_8hpp_source/","title":"File Mpu6050.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; Mpu6050.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>// I2Cdev library collection - MPU6050 I2C device class\n// Based on InvenSense MPU-6050 register map document rev. 2.0, 5/19/2011 (RM-MPU-6000A-00)\n// 10/3/2011 by Jeff Rowberg &lt;jeff@rowberg.net&gt;\n// 11/28/2014 by Marton Sebok &lt;sebokmarton@gmail.com&gt;\n//\n// Updates should (hopefully) always be available at https://github.com/jrowberg/i2cdevlib\n//\n// Changelog:\n//     ...        - ongoing debug release\n//     2014-11-28 - ported to PIC18 peripheral library from Arduino code\n//     2017-03-11 - tested basic functions on STM32\n\n// NOTE: THIS IS ONLY A PARIAL RELEASE. THIS DEVICE CLASS IS CURRENTLY UNDERGOING ACTIVE\n// DEVELOPMENT AND IS STILL MISSING SOME IMPORTANT FEATURES. PLEASE KEEP THIS IN MIND IF\n// YOU DECIDE TO USE THIS PARTICULAR CODE FOR ANYTHING.\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2012 Jeff Rowberg\nCopyright (c) 2014 Marton Sebok\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n\n#ifndef _MPU6050_H_\n#define _MPU6050_H_\n\n#include \"I2cController.hpp\"\n#include &lt;stdbool.h&gt;\n\n// clang-format off\n\n#if ((defined MPU6050_INCLUDE_DMP_MOTIONAPPS20) || (defined MPU6050_INCLUDE_DMP_MOTIONAPPS41))\n#error DMP is not supported yet\n#endif\n\n#define MPU6050_ADDRESS_AD0_LOW     0x68 // address pin low (GND), default for InvenSense evaluation board\n#define MPU6050_ADDRESS_AD0_HIGH    0x69 // address pin high (VCC)\n#define MPU6050_DEFAULT_ADDRESS     MPU6050_ADDRESS_AD0_LOW\n\n#define MPU6050_RA_XG_OFFS_TC       0x00 //[7] PWR_MODE, [6:1] XG_OFFS_TC, [0] OTP_BNK_VLD\n#define MPU6050_RA_YG_OFFS_TC       0x01 //[7] PWR_MODE, [6:1] YG_OFFS_TC, [0] OTP_BNK_VLD\n#define MPU6050_RA_ZG_OFFS_TC       0x02 //[7] PWR_MODE, [6:1] ZG_OFFS_TC, [0] OTP_BNK_VLD\n#define MPU6050_RA_X_FINE_GAIN      0x03 //[7:0] X_FINE_GAIN\n#define MPU6050_RA_Y_FINE_GAIN      0x04 //[7:0] Y_FINE_GAIN\n#define MPU6050_RA_Z_FINE_GAIN      0x05 //[7:0] Z_FINE_GAIN\n#define MPU6050_RA_XA_OFFS_H        0x06 //[15:0] XA_OFFS\n#define MPU6050_RA_XA_OFFS_L_TC     0x07\n#define MPU6050_RA_YA_OFFS_H        0x08 //[15:0] YA_OFFS\n#define MPU6050_RA_YA_OFFS_L_TC     0x09\n#define MPU6050_RA_ZA_OFFS_H        0x0A //[15:0] ZA_OFFS\n#define MPU6050_RA_ZA_OFFS_L_TC     0x0B\n#define MPU6050_RA_XG_OFFS_USRH     0x13 //[15:0] XG_OFFS_USR\n#define MPU6050_RA_XG_OFFS_USRL     0x14\n#define MPU6050_RA_YG_OFFS_USRH     0x15 //[15:0] YG_OFFS_USR\n#define MPU6050_RA_YG_OFFS_USRL     0x16\n#define MPU6050_RA_ZG_OFFS_USRH     0x17 //[15:0] ZG_OFFS_USR\n#define MPU6050_RA_ZG_OFFS_USRL     0x18\n#define MPU6050_RA_SMPLRT_DIV       0x19\n#define MPU6050_RA_CONFIG           0x1A\n#define MPU6050_RA_GYRO_CONFIG      0x1B\n#define MPU6050_RA_ACCEL_CONFIG     0x1C\n#define MPU6050_RA_FF_THR           0x1D\n#define MPU6050_RA_FF_DUR           0x1E\n#define MPU6050_RA_MOT_THR          0x1F\n#define MPU6050_RA_MOT_DUR          0x20\n#define MPU6050_RA_ZRMOT_THR        0x21\n#define MPU6050_RA_ZRMOT_DUR        0x22\n#define MPU6050_RA_FIFO_EN          0x23\n#define MPU6050_RA_I2C_MST_CTRL     0x24\n#define MPU6050_RA_I2C_SLV0_ADDR    0x25\n#define MPU6050_RA_I2C_SLV0_REG     0x26\n#define MPU6050_RA_I2C_SLV0_CTRL    0x27\n#define MPU6050_RA_I2C_SLV1_ADDR    0x28\n#define MPU6050_RA_I2C_SLV1_REG     0x29\n#define MPU6050_RA_I2C_SLV1_CTRL    0x2A\n#define MPU6050_RA_I2C_SLV2_ADDR    0x2B\n#define MPU6050_RA_I2C_SLV2_REG     0x2C\n#define MPU6050_RA_I2C_SLV2_CTRL    0x2D\n#define MPU6050_RA_I2C_SLV3_ADDR    0x2E\n#define MPU6050_RA_I2C_SLV3_REG     0x2F\n#define MPU6050_RA_I2C_SLV3_CTRL    0x30\n#define MPU6050_RA_I2C_SLV4_ADDR    0x31\n#define MPU6050_RA_I2C_SLV4_REG     0x32\n#define MPU6050_RA_I2C_SLV4_DO      0x33\n#define MPU6050_RA_I2C_SLV4_CTRL    0x34\n#define MPU6050_RA_I2C_SLV4_DI      0x35\n#define MPU6050_RA_I2C_MST_STATUS   0x36\n#define MPU6050_RA_INT_PIN_CFG      0x37\n#define MPU6050_RA_INT_ENABLE       0x38\n#define MPU6050_RA_DMP_INT_STATUS   0x39\n#define MPU6050_RA_INT_STATUS       0x3A\n#define MPU6050_RA_ACCEL_XOUT_H     0x3B\n#define MPU6050_RA_ACCEL_XOUT_L     0x3C\n#define MPU6050_RA_ACCEL_YOUT_H     0x3D\n#define MPU6050_RA_ACCEL_YOUT_L     0x3E\n#define MPU6050_RA_ACCEL_ZOUT_H     0x3F\n#define MPU6050_RA_ACCEL_ZOUT_L     0x40\n#define MPU6050_RA_TEMP_OUT_H       0x41\n#define MPU6050_RA_TEMP_OUT_L       0x42\n#define MPU6050_RA_GYRO_XOUT_H      0x43\n#define MPU6050_RA_GYRO_XOUT_L      0x44\n#define MPU6050_RA_GYRO_YOUT_H      0x45\n#define MPU6050_RA_GYRO_YOUT_L      0x46\n#define MPU6050_RA_GYRO_ZOUT_H      0x47\n#define MPU6050_RA_GYRO_ZOUT_L      0x48\n#define MPU6050_RA_EXT_SENS_DATA_00 0x49\n#define MPU6050_RA_EXT_SENS_DATA_01 0x4A\n#define MPU6050_RA_EXT_SENS_DATA_02 0x4B\n#define MPU6050_RA_EXT_SENS_DATA_03 0x4C\n#define MPU6050_RA_EXT_SENS_DATA_04 0x4D\n#define MPU6050_RA_EXT_SENS_DATA_05 0x4E\n#define MPU6050_RA_EXT_SENS_DATA_06 0x4F\n#define MPU6050_RA_EXT_SENS_DATA_07 0x50\n#define MPU6050_RA_EXT_SENS_DATA_08 0x51\n#define MPU6050_RA_EXT_SENS_DATA_09 0x52\n#define MPU6050_RA_EXT_SENS_DATA_10 0x53\n#define MPU6050_RA_EXT_SENS_DATA_11 0x54\n#define MPU6050_RA_EXT_SENS_DATA_12 0x55\n#define MPU6050_RA_EXT_SENS_DATA_13 0x56\n#define MPU6050_RA_EXT_SENS_DATA_14 0x57\n#define MPU6050_RA_EXT_SENS_DATA_15 0x58\n#define MPU6050_RA_EXT_SENS_DATA_16 0x59\n#define MPU6050_RA_EXT_SENS_DATA_17 0x5A\n#define MPU6050_RA_EXT_SENS_DATA_18 0x5B\n#define MPU6050_RA_EXT_SENS_DATA_19 0x5C\n#define MPU6050_RA_EXT_SENS_DATA_20 0x5D\n#define MPU6050_RA_EXT_SENS_DATA_21 0x5E\n#define MPU6050_RA_EXT_SENS_DATA_22 0x5F\n#define MPU6050_RA_EXT_SENS_DATA_23 0x60\n#define MPU6050_RA_MOT_DETECT_STATUS    0x61\n#define MPU6050_RA_I2C_SLV0_DO      0x63\n#define MPU6050_RA_I2C_SLV1_DO      0x64\n#define MPU6050_RA_I2C_SLV2_DO      0x65\n#define MPU6050_RA_I2C_SLV3_DO      0x66\n#define MPU6050_RA_I2C_MST_DELAY_CTRL   0x67\n#define MPU6050_RA_SIGNAL_PATH_RESET    0x68\n#define MPU6050_RA_MOT_DETECT_CTRL      0x69\n#define MPU6050_RA_USER_CTRL        0x6A\n#define MPU6050_RA_PWR_MGMT_1       0x6B\n#define MPU6050_RA_PWR_MGMT_2       0x6C\n#define MPU6050_RA_BANK_SEL         0x6D\n#define MPU6050_RA_MEM_START_ADDR   0x6E\n#define MPU6050_RA_MEM_R_W          0x6F\n#define MPU6050_RA_DMP_CFG_1        0x70\n#define MPU6050_RA_DMP_CFG_2        0x71\n#define MPU6050_RA_FIFO_COUNTH      0x72\n#define MPU6050_RA_FIFO_COUNTL      0x73\n#define MPU6050_RA_FIFO_R_W         0x74\n#define MPU6050_RA_WHO_AM_I         0x75\n\n#define MPU6050_TC_PWR_MODE_BIT     7\n#define MPU6050_TC_OFFSET_BIT       6\n#define MPU6050_TC_OFFSET_LENGTH    6\n#define MPU6050_TC_OTP_BNK_VLD_BIT  0\n\n#define MPU6050_VDDIO_LEVEL_VLOGIC  0\n#define MPU6050_VDDIO_LEVEL_VDD     1\n\n#define MPU6050_CFG_EXT_SYNC_SET_BIT    5\n#define MPU6050_CFG_EXT_SYNC_SET_LENGTH 3\n#define MPU6050_CFG_DLPF_CFG_BIT    2\n#define MPU6050_CFG_DLPF_CFG_LENGTH 3\n\n#define MPU6050_EXT_SYNC_DISABLED       0x0\n#define MPU6050_EXT_SYNC_TEMP_OUT_L     0x1\n#define MPU6050_EXT_SYNC_GYRO_XOUT_L    0x2\n#define MPU6050_EXT_SYNC_GYRO_YOUT_L    0x3\n#define MPU6050_EXT_SYNC_GYRO_ZOUT_L    0x4\n#define MPU6050_EXT_SYNC_ACCEL_XOUT_L   0x5\n#define MPU6050_EXT_SYNC_ACCEL_YOUT_L   0x6\n#define MPU6050_EXT_SYNC_ACCEL_ZOUT_L   0x7\n\n#define MPU6050_DLPF_BW_256         0x00\n#define MPU6050_DLPF_BW_188         0x01\n#define MPU6050_DLPF_BW_98          0x02\n#define MPU6050_DLPF_BW_42          0x03\n#define MPU6050_DLPF_BW_20          0x04\n#define MPU6050_DLPF_BW_10          0x05\n#define MPU6050_DLPF_BW_5           0x06\n\n#define MPU6050_GCONFIG_FS_SEL_BIT      4\n#define MPU6050_GCONFIG_FS_SEL_LENGTH   2\n\n#define MPU6050_GYRO_FS_250         0x00\n#define MPU6050_GYRO_FS_500         0x01\n#define MPU6050_GYRO_FS_1000        0x02\n#define MPU6050_GYRO_FS_2000        0x03\n\n#define MPU6050_ACONFIG_XA_ST_BIT           7\n#define MPU6050_ACONFIG_YA_ST_BIT           6\n#define MPU6050_ACONFIG_ZA_ST_BIT           5\n#define MPU6050_ACONFIG_AFS_SEL_BIT         4\n#define MPU6050_ACONFIG_AFS_SEL_LENGTH      2\n#define MPU6050_ACONFIG_ACCEL_HPF_BIT       2\n#define MPU6050_ACONFIG_ACCEL_HPF_LENGTH    3\n\n#define MPU6050_ACCEL_FS_2          0x00\n#define MPU6050_ACCEL_FS_4          0x01\n#define MPU6050_ACCEL_FS_8          0x02\n#define MPU6050_ACCEL_FS_16         0x03\n\n#define MPU6050_DHPF_RESET          0x00\n#define MPU6050_DHPF_5              0x01\n#define MPU6050_DHPF_2P5            0x02\n#define MPU6050_DHPF_1P25           0x03\n#define MPU6050_DHPF_0P63           0x04\n#define MPU6050_DHPF_HOLD           0x07\n\n#define MPU6050_TEMP_FIFO_EN_BIT    7\n#define MPU6050_XG_FIFO_EN_BIT      6\n#define MPU6050_YG_FIFO_EN_BIT      5\n#define MPU6050_ZG_FIFO_EN_BIT      4\n#define MPU6050_ACCEL_FIFO_EN_BIT   3\n#define MPU6050_SLV2_FIFO_EN_BIT    2\n#define MPU6050_SLV1_FIFO_EN_BIT    1\n#define MPU6050_SLV0_FIFO_EN_BIT    0\n\n#define MPU6050_MULT_MST_EN_BIT     7\n#define MPU6050_WAIT_FOR_ES_BIT     6\n#define MPU6050_SLV_3_FIFO_EN_BIT   5\n#define MPU6050_I2C_MST_P_NSR_BIT   4\n#define MPU6050_I2C_MST_CLK_BIT     3\n#define MPU6050_I2C_MST_CLK_LENGTH  4\n\n#define MPU6050_CLOCK_DIV_348       0x0\n#define MPU6050_CLOCK_DIV_333       0x1\n#define MPU6050_CLOCK_DIV_320       0x2\n#define MPU6050_CLOCK_DIV_308       0x3\n#define MPU6050_CLOCK_DIV_296       0x4\n#define MPU6050_CLOCK_DIV_286       0x5\n#define MPU6050_CLOCK_DIV_276       0x6\n#define MPU6050_CLOCK_DIV_267       0x7\n#define MPU6050_CLOCK_DIV_258       0x8\n#define MPU6050_CLOCK_DIV_500       0x9\n#define MPU6050_CLOCK_DIV_471       0xA\n#define MPU6050_CLOCK_DIV_444       0xB\n#define MPU6050_CLOCK_DIV_421       0xC\n#define MPU6050_CLOCK_DIV_400       0xD\n#define MPU6050_CLOCK_DIV_381       0xE\n#define MPU6050_CLOCK_DIV_364       0xF\n\n#define MPU6050_I2C_SLV_RW_BIT      7\n#define MPU6050_I2C_SLV_ADDR_BIT    6\n#define MPU6050_I2C_SLV_ADDR_LENGTH 7\n#define MPU6050_I2C_SLV_EN_BIT      7\n#define MPU6050_I2C_SLV_BYTE_SW_BIT 6\n#define MPU6050_I2C_SLV_REG_DIS_BIT 5\n#define MPU6050_I2C_SLV_GRP_BIT     4\n#define MPU6050_I2C_SLV_LEN_BIT     3\n#define MPU6050_I2C_SLV_LEN_LENGTH  4\n\n#define MPU6050_I2C_SLV4_RW_BIT         7\n#define MPU6050_I2C_SLV4_ADDR_BIT       6\n#define MPU6050_I2C_SLV4_ADDR_LENGTH    7\n#define MPU6050_I2C_SLV4_EN_BIT         7\n#define MPU6050_I2C_SLV4_INT_EN_BIT     6\n#define MPU6050_I2C_SLV4_REG_DIS_BIT    5\n#define MPU6050_I2C_SLV4_MST_DLY_BIT    4\n#define MPU6050_I2C_SLV4_MST_DLY_LENGTH 5\n\n#define MPU6050_MST_PASS_THROUGH_BIT    7\n#define MPU6050_MST_I2C_SLV4_DONE_BIT   6\n#define MPU6050_MST_I2C_LOST_ARB_BIT    5\n#define MPU6050_MST_I2C_SLV4_NACK_BIT   4\n#define MPU6050_MST_I2C_SLV3_NACK_BIT   3\n#define MPU6050_MST_I2C_SLV2_NACK_BIT   2\n#define MPU6050_MST_I2C_SLV1_NACK_BIT   1\n#define MPU6050_MST_I2C_SLV0_NACK_BIT   0\n\n#define MPU6050_INTCFG_INT_LEVEL_BIT        7\n#define MPU6050_INTCFG_INT_OPEN_BIT         6\n#define MPU6050_INTCFG_LATCH_INT_EN_BIT     5\n#define MPU6050_INTCFG_INT_RD_CLEAR_BIT     4\n#define MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT  3\n#define MPU6050_INTCFG_FSYNC_INT_EN_BIT     2\n#define MPU6050_INTCFG_I2C_BYPASS_EN_BIT    1\n#define MPU6050_INTCFG_CLKOUT_EN_BIT        0\n\n#define MPU6050_INTMODE_ACTIVEHIGH  0x00\n#define MPU6050_INTMODE_ACTIVELOW   0x01\n\n#define MPU6050_INTDRV_PUSHPULL     0x00\n#define MPU6050_INTDRV_OPENDRAIN    0x01\n\n#define MPU6050_INTLATCH_50USPULSE  0x00\n#define MPU6050_INTLATCH_WAITCLEAR  0x01\n\n#define MPU6050_INTCLEAR_STATUSREAD 0x00\n#define MPU6050_INTCLEAR_ANYREAD    0x01\n\n#define MPU6050_INTERRUPT_FF_BIT            7\n#define MPU6050_INTERRUPT_MOT_BIT           6\n#define MPU6050_INTERRUPT_ZMOT_BIT          5\n#define MPU6050_INTERRUPT_FIFO_OFLOW_BIT    4\n#define MPU6050_INTERRUPT_I2C_MST_INT_BIT   3\n#define MPU6050_INTERRUPT_PLL_RDY_INT_BIT   2\n#define MPU6050_INTERRUPT_DMP_INT_BIT       1\n#define MPU6050_INTERRUPT_DATA_RDY_BIT      0\n\n// TODO: figure out what these actually do\n// UMPL source code is not very obivous\n#define MPU6050_DMPINT_5_BIT            5\n#define MPU6050_DMPINT_4_BIT            4\n#define MPU6050_DMPINT_3_BIT            3\n#define MPU6050_DMPINT_2_BIT            2\n#define MPU6050_DMPINT_1_BIT            1\n#define MPU6050_DMPINT_0_BIT            0\n\n#define MPU6050_MOTION_MOT_XNEG_BIT     7\n#define MPU6050_MOTION_MOT_XPOS_BIT     6\n#define MPU6050_MOTION_MOT_YNEG_BIT     5\n#define MPU6050_MOTION_MOT_YPOS_BIT     4\n#define MPU6050_MOTION_MOT_ZNEG_BIT     3\n#define MPU6050_MOTION_MOT_ZPOS_BIT     2\n#define MPU6050_MOTION_MOT_ZRMOT_BIT    0\n\n#define MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT   7\n#define MPU6050_DELAYCTRL_I2C_SLV4_DLY_EN_BIT   4\n#define MPU6050_DELAYCTRL_I2C_SLV3_DLY_EN_BIT   3\n#define MPU6050_DELAYCTRL_I2C_SLV2_DLY_EN_BIT   2\n#define MPU6050_DELAYCTRL_I2C_SLV1_DLY_EN_BIT   1\n#define MPU6050_DELAYCTRL_I2C_SLV0_DLY_EN_BIT   0\n\n#define MPU6050_PATHRESET_GYRO_RESET_BIT    2\n#define MPU6050_PATHRESET_ACCEL_RESET_BIT   1\n#define MPU6050_PATHRESET_TEMP_RESET_BIT    0\n\n#define MPU6050_DETECT_ACCEL_ON_DELAY_BIT       5\n#define MPU6050_DETECT_ACCEL_ON_DELAY_LENGTH    2\n#define MPU6050_DETECT_FF_COUNT_BIT             3\n#define MPU6050_DETECT_FF_COUNT_LENGTH          2\n#define MPU6050_DETECT_MOT_COUNT_BIT            1\n#define MPU6050_DETECT_MOT_COUNT_LENGTH         2\n\n#define MPU6050_DETECT_DECREMENT_RESET  0x0\n#define MPU6050_DETECT_DECREMENT_1      0x1\n#define MPU6050_DETECT_DECREMENT_2      0x2\n#define MPU6050_DETECT_DECREMENT_4      0x3\n\n#define MPU6050_USERCTRL_DMP_EN_BIT             7\n#define MPU6050_USERCTRL_FIFO_EN_BIT            6\n#define MPU6050_USERCTRL_I2C_MST_EN_BIT         5\n#define MPU6050_USERCTRL_I2C_IF_DIS_BIT         4\n#define MPU6050_USERCTRL_DMP_RESET_BIT          3\n#define MPU6050_USERCTRL_FIFO_RESET_BIT         2\n#define MPU6050_USERCTRL_I2C_MST_RESET_BIT      1\n#define MPU6050_USERCTRL_SIG_COND_RESET_BIT     0\n\n#define MPU6050_PWR1_DEVICE_RESET_BIT   7\n#define MPU6050_PWR1_SLEEP_BIT          6\n#define MPU6050_PWR1_CYCLE_BIT          5\n#define MPU6050_PWR1_TEMP_DIS_BIT       3\n#define MPU6050_PWR1_CLKSEL_BIT         2\n#define MPU6050_PWR1_CLKSEL_LENGTH      3\n\n#define MPU6050_CLOCK_INTERNAL          0x00\n#define MPU6050_CLOCK_PLL_XGYRO         0x01\n#define MPU6050_CLOCK_PLL_YGYRO         0x02\n#define MPU6050_CLOCK_PLL_ZGYRO         0x03\n#define MPU6050_CLOCK_PLL_EXT32K        0x04\n#define MPU6050_CLOCK_PLL_EXT19M        0x05\n#define MPU6050_CLOCK_KEEP_RESET        0x07\n\n#define MPU6050_PWR2_LP_WAKE_CTRL_BIT       7\n#define MPU6050_PWR2_LP_WAKE_CTRL_LENGTH    2\n#define MPU6050_PWR2_STBY_XA_BIT            5\n#define MPU6050_PWR2_STBY_YA_BIT            4\n#define MPU6050_PWR2_STBY_ZA_BIT            3\n#define MPU6050_PWR2_STBY_XG_BIT            2\n#define MPU6050_PWR2_STBY_YG_BIT            1\n#define MPU6050_PWR2_STBY_ZG_BIT            0\n\n#define MPU6050_WAKE_FREQ_1P25      0x0\n#define MPU6050_WAKE_FREQ_2P5       0x1\n#define MPU6050_WAKE_FREQ_5         0x2\n#define MPU6050_WAKE_FREQ_10        0x3\n\n#define MPU6050_BANKSEL_PRFTCH_EN_BIT       6\n#define MPU6050_BANKSEL_CFG_USER_BANK_BIT   5\n#define MPU6050_BANKSEL_MEM_SEL_BIT         4\n#define MPU6050_BANKSEL_MEM_SEL_LENGTH      5\n\n#define MPU6050_WHO_AM_I_BIT        6\n#define MPU6050_WHO_AM_I_LENGTH     6\n\n#define MPU6050_DMP_MEMORY_BANKS        8\n#define MPU6050_DMP_MEMORY_BANK_SIZE    256\n#define MPU6050_DMP_MEMORY_CHUNK_SIZE   16\n\n// note: DMP code memory blocks defined at end of header file\n\ntypedef struct MPU6050_t {\nuint8_t devAddr;\nuint8_t buffer[14];\n} MPU6050_t;\n\nvoid MPU6050_init();\n\nvoid MPU6050(uint8_t address);\n\nvoid MPU6050_initialize();\nbool MPU6050_testConnection();\n\n// AUX_VDDIO register\nuint8_t MPU6050_getAuxVDDIOLevel();\nvoid MPU6050_setAuxVDDIOLevel(uint8_t level);\n\n// SMPLRT_DIV register\nuint8_t MPU6050_getRate();\nvoid MPU6050_setRate(uint8_t rate);\n\n// CONFIG register\nuint8_t MPU6050_getExternalFrameSync();\nvoid MPU6050_setExternalFrameSync(uint8_t sync);\nuint8_t MPU6050_getDLPFMode();\nvoid MPU6050_setDLPFMode(uint8_t bandwidth);\n\n// GYRO_CONFIG register\nuint8_t MPU6050_getFullScaleGyroRange();\nvoid MPU6050_setFullScaleGyroRange(uint8_t range);\n\n// ACCEL_CONFIG register\nbool MPU6050_getAccelXSelfTest();\nvoid MPU6050_setAccelXSelfTest(bool enabled);\nbool MPU6050_getAccelYSelfTest();\nvoid MPU6050_setAccelYSelfTest(bool enabled);\nbool MPU6050_getAccelZSelfTest();\nvoid MPU6050_setAccelZSelfTest(bool enabled);\nuint8_t MPU6050_getFullScaleAccelRange();\nvoid MPU6050_setFullScaleAccelRange(uint8_t range);\nuint8_t MPU6050_getDHPFMode();\nvoid MPU6050_setDHPFMode(uint8_t mode);\n\n// FF_THR register\nuint8_t MPU6050_getFreefallDetectionThreshold();\nvoid MPU6050_setFreefallDetectionThreshold(uint8_t threshold);\n\n// FF_DUR register\nuint8_t MPU6050_getFreefallDetectionDuration();\nvoid MPU6050_setFreefallDetectionDuration(uint8_t duration);\n\n// MOT_THR register\nuint8_t MPU6050_getMotionDetectionThreshold();\nvoid MPU6050_setMotionDetectionThreshold(uint8_t threshold);\n\n// MOT_DUR register\nuint8_t MPU6050_getMotionDetectionDuration();\nvoid MPU6050_setMotionDetectionDuration(uint8_t duration);\n\n// ZRMOT_THR register\nuint8_t MPU6050_getZeroMotionDetectionThreshold();\nvoid MPU6050_setZeroMotionDetectionThreshold(uint8_t threshold);\n\n// ZRMOT_DUR register\nuint8_t MPU6050_getZeroMotionDetectionDuration();\nvoid MPU6050_setZeroMotionDetectionDuration(uint8_t duration);\n\n// FIFO_EN register\nbool MPU6050_getTempFIFOEnabled();\nvoid MPU6050_setTempFIFOEnabled(bool enabled);\nbool MPU6050_getXGyroFIFOEnabled();\nvoid MPU6050_setXGyroFIFOEnabled(bool enabled);\nbool MPU6050_getYGyroFIFOEnabled();\nvoid MPU6050_setYGyroFIFOEnabled(bool enabled);\nbool MPU6050_getZGyroFIFOEnabled();\nvoid MPU6050_setZGyroFIFOEnabled(bool enabled);\nbool MPU6050_getAccelFIFOEnabled();\nvoid MPU6050_setAccelFIFOEnabled(bool enabled);\nbool MPU6050_getSlave2FIFOEnabled();\nvoid MPU6050_setSlave2FIFOEnabled(bool enabled);\nbool MPU6050_getSlave1FIFOEnabled();\nvoid MPU6050_setSlave1FIFOEnabled(bool enabled);\nbool MPU6050_getSlave0FIFOEnabled();\nvoid MPU6050_setSlave0FIFOEnabled(bool enabled);\n\n// I2C_MST_CTRL register\nbool MPU6050_getMultiMasterEnabled();\nvoid MPU6050_setMultiMasterEnabled(bool enabled);\nbool MPU6050_getWaitForExternalSensorEnabled();\nvoid MPU6050_setWaitForExternalSensorEnabled(bool enabled);\nbool MPU6050_getSlave3FIFOEnabled();\nvoid MPU6050_setSlave3FIFOEnabled(bool enabled);\nbool MPU6050_getSlaveReadWriteTransitionEnabled();\nvoid MPU6050_setSlaveReadWriteTransitionEnabled(bool enabled);\nuint8_t MPU6050_getMasterClockSpeed();\nvoid MPU6050_setMasterClockSpeed(uint8_t speed);\n\n// I2C_SLV* registers (Slave 0-3)\nuint8_t MPU6050_getSlaveAddress(uint8_t num);\nvoid MPU6050_setSlaveAddress(uint8_t num, uint8_t address);\nuint8_t MPU6050_getSlaveRegister(uint8_t num);\nvoid MPU6050_setSlaveRegister(uint8_t num, uint8_t reg);\nbool MPU6050_getSlaveEnabled(uint8_t num);\nvoid MPU6050_setSlaveEnabled(uint8_t num, bool enabled);\nbool MPU6050_getSlaveWordByteSwap(uint8_t num);\nvoid MPU6050_setSlaveWordByteSwap(uint8_t num, bool enabled);\nbool MPU6050_getSlaveWriteMode(uint8_t num);\nvoid MPU6050_setSlaveWriteMode(uint8_t num, bool mode);\nbool MPU6050_getSlaveWordGroupOffset(uint8_t num);\nvoid MPU6050_setSlaveWordGroupOffset(uint8_t num, bool enabled);\nuint8_t MPU6050_getSlaveDataLength(uint8_t num);\nvoid MPU6050_setSlaveDataLength(uint8_t num, uint8_t length);\n\n// I2C_SLV* registers (Slave 4)\nuint8_t MPU6050_getSlave4Address();\nvoid MPU6050_setSlave4Address(uint8_t address);\nuint8_t MPU6050_getSlave4Register();\nvoid MPU6050_setSlave4Register(uint8_t reg);\nvoid MPU6050_setSlave4OutputByte(uint8_t data);\nbool MPU6050_getSlave4Enabled();\nvoid MPU6050_setSlave4Enabled(bool enabled);\nbool MPU6050_getSlave4InterruptEnabled();\nvoid MPU6050_setSlave4InterruptEnabled(bool enabled);\nbool MPU6050_getSlave4WriteMode();\nvoid MPU6050_setSlave4WriteMode(bool mode);\nuint8_t MPU6050_getSlave4MasterDelay();\nvoid MPU6050_setSlave4MasterDelay(uint8_t delay);\nuint8_t MPU6050_getSlate4InputByte();\n\n// I2C_MST_STATUS register\nbool MPU6050_getPassthroughStatus();\nbool MPU6050_getSlave4IsDone();\nbool MPU6050_getLostArbitration();\nbool MPU6050_getSlave4Nack();\nbool MPU6050_getSlave3Nack();\nbool MPU6050_getSlave2Nack();\nbool MPU6050_getSlave1Nack();\nbool MPU6050_getSlave0Nack();\n\n// INT_PIN_CFG register\nbool MPU6050_getInterruptMode();\nvoid MPU6050_setInterruptMode(bool mode);\nbool MPU6050_getInterruptDrive();\nvoid MPU6050_setInterruptDrive(bool drive);\nbool MPU6050_getInterruptLatch();\nvoid MPU6050_setInterruptLatch(bool latch);\nbool MPU6050_getInterruptLatchClear();\nvoid MPU6050_setInterruptLatchClear(bool clear);\nbool MPU6050_getFSyncInterruptLevel();\nvoid MPU6050_setFSyncInterruptLevel(bool level);\nbool MPU6050_getFSyncInterruptEnabled();\nvoid MPU6050_setFSyncInterruptEnabled(bool enabled);\nbool MPU6050_getI2CBypassEnabled();\nvoid MPU6050_setI2CBypassEnabled(bool enabled);\nbool MPU6050_getClockOutputEnabled();\nvoid MPU6050_setClockOutputEnabled(bool enabled);\n\n// INT_ENABLE register\nuint8_t MPU6050_getIntEnabled();\nvoid MPU6050_setIntEnabled(uint8_t enabled);\nbool MPU6050_getIntFreefallEnabled();\nvoid MPU6050_setIntFreefallEnabled(bool enabled);\nbool MPU6050_getIntMotionEnabled();\nvoid MPU6050_setIntMotionEnabled(bool enabled);\nbool MPU6050_getIntZeroMotionEnabled();\nvoid MPU6050_setIntZeroMotionEnabled(bool enabled);\nbool MPU6050_getIntFIFOBufferOverflowEnabled();\nvoid MPU6050_setIntFIFOBufferOverflowEnabled(bool enabled);\nbool MPU6050_getIntI2CMasterEnabled();\nvoid MPU6050_setIntI2CMasterEnabled(bool enabled);\nbool MPU6050_getIntDataReadyEnabled();\nvoid MPU6050_setIntDataReadyEnabled(bool enabled);\n\n// INT_STATUS register\nuint8_t MPU6050_getIntStatus();\nbool MPU6050_getIntFreefallStatus();\nbool MPU6050_getIntMotionStatus();\nbool MPU6050_getIntZeroMotionStatus();\nbool MPU6050_getIntFIFOBufferOverflowStatus();\nbool MPU6050_getIntI2CMasterStatus();\nbool MPU6050_getIntDataReadyStatus();\n\n// ACCEL_*OUT_* registers\nvoid MPU6050_getMotion9(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz, int16_t* mx, int16_t* my, int16_t* mz);\nvoid MPU6050_getMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz);\nvoid MPU6050_getAcceleration(int16_t* x, int16_t* y, int16_t* z);\nint16_t MPU6050_getAccelerationX();\nint16_t MPU6050_getAccelerationY();\nint16_t MPU6050_getAccelerationZ();\n\n// TEMP_OUT_* registers\nint16_t MPU6050_getTemperature();\n\n// GYRO_*OUT_* registers\nvoid MPU6050_getRotation(int16_t* x, int16_t* y, int16_t* z);\nint16_t MPU6050_getRotationX();\nint16_t MPU6050_getRotationY();\nint16_t MPU6050_getRotationZ();\n\n// EXT_SENS_DATA_* registers\nuint8_t MPU6050_getExternalSensorByte(int position);\nuint16_t MPU6050_getExternalSensorWord(int position);\nuint32_t getExternalSensorDWord(int position);\n\n// MOT_DETECT_STATUS register\nbool MPU6050_getXNegMotionDetected();\nbool MPU6050_getXPosMotionDetected();\nbool MPU6050_getYNegMotionDetected();\nbool MPU6050_getYPosMotionDetected();\nbool MPU6050_getZNegMotionDetected();\nbool MPU6050_getZPosMotionDetected();\nbool MPU6050_getZeroMotionDetected();\n\n// I2C_SLV*_DO register\nvoid MPU6050_setSlaveOutputByte(uint8_t num, uint8_t data);\n\n// I2C_MST_DELAY_CTRL register\nbool MPU6050_getExternalShadowDelayEnabled();\nvoid MPU6050_setExternalShadowDelayEnabled(bool enabled);\nbool MPU6050_getSlaveDelayEnabled(uint8_t num);\nvoid MPU6050_setSlaveDelayEnabled(uint8_t num, bool enabled);\n\n// SIGNAL_PATH_RESET register\nvoid MPU6050_resetGyroscopePath();\nvoid MPU6050_resetAccelerometerPath();\nvoid MPU6050_resetTemperaturePath();\n\n// MOT_DETECT_CTRL register\nuint8_t MPU6050_getAccelerometerPowerOnDelay();\nvoid MPU6050_setAccelerometerPowerOnDelay(uint8_t delay);\nuint8_t MPU6050_getFreefallDetectionCounterDecrement();\nvoid MPU6050_setFreefallDetectionCounterDecrement(uint8_t decrement);\nuint8_t MPU6050_getMotionDetectionCounterDecrement();\nvoid MPU6050_setMotionDetectionCounterDecrement(uint8_t decrement);\n\n// USER_CTRL register\nbool MPU6050_getFIFOEnabled();\nvoid MPU6050_setFIFOEnabled(bool enabled);\nbool MPU6050_getI2CMasterModeEnabled();\nvoid MPU6050_setI2CMasterModeEnabled(bool enabled);\nvoid MPU6050_switchSPIEnabled(bool enabled);\nvoid MPU6050_resetFIFO();\nvoid MPU6050_resetI2CMaster();\nvoid MPU6050_resetSensors();\n\n// PWR_MGMT_1 register\nvoid MPU6050_reset();\nbool MPU6050_getSleepEnabled();\nvoid MPU6050_setSleepEnabled(bool enabled);\nbool MPU6050_getWakeCycleEnabled();\nvoid MPU6050_setWakeCycleEnabled(bool enabled);\nbool MPU6050_getTempSensorEnabled();\nvoid MPU6050_setTempSensorEnabled(bool enabled);\nuint8_t MPU6050_getClockSource();\nvoid MPU6050_setClockSource(uint8_t source);\n\n// PWR_MGMT_2 register\nuint8_t MPU6050_getWakeFrequency();\nvoid MPU6050_setWakeFrequency(uint8_t frequency);\nbool MPU6050_getStandbyXAccelEnabled();\nvoid MPU6050_setStandbyXAccelEnabled(bool enabled);\nbool MPU6050_getStandbyYAccelEnabled();\nvoid MPU6050_setStandbyYAccelEnabled(bool enabled);\nbool MPU6050_getStandbyZAccelEnabled();\nvoid MPU6050_setStandbyZAccelEnabled(bool enabled);\nbool MPU6050_getStandbyXGyroEnabled();\nvoid MPU6050_setStandbyXGyroEnabled(bool enabled);\nbool MPU6050_getStandbyYGyroEnabled();\nvoid MPU6050_setStandbyYGyroEnabled(bool enabled);\nbool MPU6050_getStandbyZGyroEnabled();\nvoid MPU6050_setStandbyZGyroEnabled(bool enabled);\n\n// FIFO_COUNT_* registers\nuint16_t MPU6050_getFIFOCount();\n\n// FIFO_R_W register\nuint8_t MPU6050_getFIFOByte();\nvoid MPU6050_setFIFOByte(uint8_t data);\nvoid MPU6050_getFIFOBytes(uint8_t *data, uint8_t length);\n\n// WHO_AM_I register\nuint8_t MPU6050_getDeviceID();\nvoid MPU6050_setDeviceID(uint8_t id);\n\n// ======== UNDOCUMENTED/DMP REGISTERS/METHODS ========\n\n// XG_OFFS_TC register\nuint8_t MPU6050_getOTPBankValid();\nvoid MPU6050_setOTPBankValid(bool enabled);\nint8_t getXGyroOffsetTC();\nvoid MPU6050_setXGyroOffsetTC(int8_t offset);\n\n// YG_OFFS_TC register\nint8_t getYGyroOffsetTC();\nvoid MPU6050_setYGyroOffsetTC(int8_t offset);\n\n// ZG_OFFS_TC register\nint8_t getZGyroOffsetTC();\nvoid MPU6050_setZGyroOffsetTC(int8_t offset);\n\n// X_FINE_GAIN register\nint8_t getXFineGain();\nvoid MPU6050_setXFineGain(int8_t gain);\n\n// Y_FINE_GAIN register\nint8_t getYFineGain();\nvoid MPU6050_setYFineGain(int8_t gain);\n\n// Z_FINE_GAIN register\nint8_t getZFineGain();\nvoid MPU6050_setZFineGain(int8_t gain);\n\n// XA_OFFS_* registers\nint16_t MPU6050_getXAccelOffset();\nvoid MPU6050_setXAccelOffset(int16_t offset);\n\n// YA_OFFS_* register\nint16_t MPU6050_getYAccelOffset();\nvoid MPU6050_setYAccelOffset(int16_t offset);\n\n// ZA_OFFS_* register\nint16_t MPU6050_getZAccelOffset();\nvoid MPU6050_setZAccelOffset(int16_t offset);\n\n// XG_OFFS_USR* registers\nint16_t MPU6050_getXGyroOffset();\nvoid MPU6050_setXGyroOffset(int16_t offset);\n\n// YG_OFFS_USR* register\nint16_t MPU6050_getYGyroOffset();\nvoid MPU6050_setYGyroOffset(int16_t offset);\n\n// ZG_OFFS_USR* register\nint16_t MPU6050_getZGyroOffset();\nvoid MPU6050_setZGyroOffset(int16_t offset);\n\n// INT_ENABLE register (DMP functions)\nbool MPU6050_getIntPLLReadyEnabled();\nvoid MPU6050_setIntPLLReadyEnabled(bool enabled);\nbool MPU6050_getIntDMPEnabled();\nvoid MPU6050_setIntDMPEnabled(bool enabled);\n\n// DMP_INT_STATUS\nbool MPU6050_getDMPInt5Status();\nbool MPU6050_getDMPInt4Status();\nbool MPU6050_getDMPInt3Status();\nbool MPU6050_getDMPInt2Status();\nbool MPU6050_getDMPInt1Status();\nbool MPU6050_getDMPInt0Status();\n\n// INT_STATUS register (DMP functions)\nbool MPU6050_getIntPLLReadyStatus();\nbool MPU6050_getIntDMPStatus();\n\n// USER_CTRL register (DMP functions)\nbool MPU6050_getDMPEnabled();\nvoid MPU6050_setDMPEnabled(bool enabled);\nvoid MPU6050_resetDMP();\n\n// BANK_SEL register\nvoid MPU6050_setMemoryBank(uint8_t bank, bool prefetchEnabled, bool userBank);\n\n// MEM_START_ADDR register\nvoid MPU6050_setMemoryStartAddress(uint8_t address);\n\n// MEM_R_W register\nuint8_t MPU6050_readMemoryByte();\nvoid MPU6050_writeMemoryByte(uint8_t data);\nvoid MPU6050_readMemoryBlock(uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address);\n//bool MPU6050_writeMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify, bool useProgMem);\n//bool MPU6050_writeProgMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify);\n\n//bool MPU6050_writeDMPConfigurationSet(const uint8_t *data, uint16_t dataSize, bool useProgMem);\n//bool MPU6050_writeProgDMPConfigurationSet(const uint8_t *data, uint16_t dataSize);\n\n// DMP_CFG_1 register\nuint8_t MPU6050_getDMPConfig1();\nvoid MPU6050_setDMPConfig1(uint8_t config);\n\n// DMP_CFG_2 register\nuint8_t MPU6050_getDMPConfig2();\nvoid MPU6050_setDMPConfig2(uint8_t config);\n\n#endif /* _MPU6050_H_ */\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/","title":"File MpuController.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; MpuController.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"I2cController.hpp\"</code></li> <li><code>#include \"rbcx.pb.h\"</code></li> <li><code>#include &lt;stdbool.h&gt;</code></li> </ul>"},{"location":"apiStm/MpuController_8hpp/#classes","title":"Classes","text":"Type Name struct mpu_t"},{"location":"apiStm/MpuController_8hpp/#public-types","title":"Public Types","text":"Type Name typedef struct mpu_t mpu_t"},{"location":"apiStm/MpuController_8hpp/#public-functions","title":"Public Functions","text":"Type Name uint32_t getExternalSensorDWord (int position)  int8_t getXFineGain ()  int8_t getXGyroOffsetTC ()  int8_t getYFineGain ()  int8_t getYGyroOffsetTC ()  int8_t getZFineGain ()  int8_t getZGyroOffsetTC ()  void mpuCreate ()  void mpuDispatch (const CoprocReq_MpuReq &amp; request)  void mpuInitialize ()  void mpuReset ()  void mpuTick ()  bool mpu_getAccelFIFOEnabled ()  bool mpu_getAccelXSelfTest ()  bool mpu_getAccelYSelfTest ()  bool mpu_getAccelZSelfTest ()  void mpu_getAcceleration (int16_t * x, int16_t * y, int16_t * z)  int16_t mpu_getAccelerationX ()  int16_t mpu_getAccelerationY ()  int16_t mpu_getAccelerationZ ()  uint8_t mpu_getAccelerometerPowerOnDelay ()  uint8_t mpu_getAuxVDDIOLevel ()  bool mpu_getClockOutputEnabled ()  uint8_t mpu_getClockSource ()  uint8_t mpu_getDHPFMode ()  uint8_t mpu_getDLPFMode ()  uint8_t mpu_getDMPConfig1 ()  uint8_t mpu_getDMPConfig2 ()  bool mpu_getDMPEnabled ()  bool mpu_getDMPInt0Status ()  bool mpu_getDMPInt1Status ()  bool mpu_getDMPInt2Status ()  bool mpu_getDMPInt3Status ()  bool mpu_getDMPInt4Status ()  bool mpu_getDMPInt5Status ()  uint8_t mpu_getDeviceID ()  uint8_t mpu_getExternalFrameSync ()  uint8_t mpu_getExternalSensorByte (int position)  uint16_t mpu_getExternalSensorWord (int position)  bool mpu_getExternalShadowDelayEnabled ()  uint8_t mpu_getFIFOByte ()  void mpu_getFIFOBytes (uint8_t * data, uint8_t length)  uint16_t mpu_getFIFOCount ()  bool mpu_getFIFOEnabled ()  bool mpu_getFSyncInterruptEnabled ()  bool mpu_getFSyncInterruptLevel ()  uint8_t mpu_getFreefallDetectionCounterDecrement ()  uint8_t mpu_getFreefallDetectionDuration ()  uint8_t mpu_getFreefallDetectionThreshold ()  uint8_t mpu_getFullScaleAccelRange ()  uint8_t mpu_getFullScaleGyroRange ()  bool mpu_getI2CBypassEnabled ()  bool mpu_getI2CMasterModeEnabled ()  bool mpu_getIntDMPEnabled ()  bool mpu_getIntDMPStatus ()  bool mpu_getIntDataReadyEnabled ()  bool mpu_getIntDataReadyStatus ()  uint8_t mpu_getIntEnabled ()  bool mpu_getIntFIFOBufferOverflowEnabled ()  bool mpu_getIntFIFOBufferOverflowStatus ()  bool mpu_getIntFreefallEnabled ()  bool mpu_getIntFreefallStatus ()  bool mpu_getIntI2CMasterEnabled ()  bool mpu_getIntI2CMasterStatus ()  bool mpu_getIntMotionEnabled ()  bool mpu_getIntMotionStatus ()  bool mpu_getIntPLLReadyEnabled ()  bool mpu_getIntPLLReadyStatus ()  uint8_t mpu_getIntStatus ()  bool mpu_getIntZeroMotionEnabled ()  bool mpu_getIntZeroMotionStatus ()  bool mpu_getInterruptDrive ()  bool mpu_getInterruptLatch ()  bool mpu_getInterruptLatchClear ()  bool mpu_getInterruptMode ()  bool mpu_getLostArbitration ()  uint8_t mpu_getMasterClockSpeed ()  void mpu_getMotion6 (int16_t * ax, int16_t * ay, int16_t * az, int16_t * gx, int16_t * gy, int16_t * gz)  void mpu_getMotion9 (int16_t * ax, int16_t * ay, int16_t * az, int16_t * gx, int16_t * gy, int16_t * gz, int16_t * mx, int16_t * my, int16_t * mz)  uint8_t mpu_getMotionDetectionCounterDecrement ()  uint8_t mpu_getMotionDetectionDuration ()  uint8_t mpu_getMotionDetectionThreshold ()  bool mpu_getMultiMasterEnabled ()  uint8_t mpu_getOTPBankValid ()  bool mpu_getPassthroughStatus ()  uint8_t mpu_getRate ()  void mpu_getRotation (int16_t * x, int16_t * y, int16_t * z)  int16_t mpu_getRotationX ()  int16_t mpu_getRotationY ()  int16_t mpu_getRotationZ ()  uint8_t mpu_getSlate4InputByte ()  bool mpu_getSlave0FIFOEnabled ()  bool mpu_getSlave0Nack ()  bool mpu_getSlave1FIFOEnabled ()  bool mpu_getSlave1Nack ()  bool mpu_getSlave2FIFOEnabled ()  bool mpu_getSlave2Nack ()  bool mpu_getSlave3FIFOEnabled ()  bool mpu_getSlave3Nack ()  uint8_t mpu_getSlave4Address ()  bool mpu_getSlave4Enabled ()  bool mpu_getSlave4InterruptEnabled ()  bool mpu_getSlave4IsDone ()  uint8_t mpu_getSlave4MasterDelay ()  bool mpu_getSlave4Nack ()  uint8_t mpu_getSlave4Register ()  bool mpu_getSlave4WriteMode ()  uint8_t mpu_getSlaveAddress (uint8_t num)  uint8_t mpu_getSlaveDataLength (uint8_t num)  bool mpu_getSlaveDelayEnabled (uint8_t num)  bool mpu_getSlaveEnabled (uint8_t num)  bool mpu_getSlaveReadWriteTransitionEnabled ()  uint8_t mpu_getSlaveRegister (uint8_t num)  bool mpu_getSlaveWordByteSwap (uint8_t num)  bool mpu_getSlaveWordGroupOffset (uint8_t num)  bool mpu_getSlaveWriteMode (uint8_t num)  bool mpu_getSleepEnabled ()  bool mpu_getStandbyXAccelEnabled ()  bool mpu_getStandbyXGyroEnabled ()  bool mpu_getStandbyYAccelEnabled ()  bool mpu_getStandbyYGyroEnabled ()  bool mpu_getStandbyZAccelEnabled ()  bool mpu_getStandbyZGyroEnabled ()  bool mpu_getTempFIFOEnabled ()  bool mpu_getTempSensorEnabled ()  int16_t mpu_getTemperature ()  bool mpu_getWaitForExternalSensorEnabled ()  bool mpu_getWakeCycleEnabled ()  uint8_t mpu_getWakeFrequency ()  int16_t mpu_getXAccelOffset ()  bool mpu_getXGyroFIFOEnabled ()  int16_t mpu_getXGyroOffset ()  bool mpu_getXNegMotionDetected ()  bool mpu_getXPosMotionDetected ()  int16_t mpu_getYAccelOffset ()  bool mpu_getYGyroFIFOEnabled ()  int16_t mpu_getYGyroOffset ()  bool mpu_getYNegMotionDetected ()  bool mpu_getYPosMotionDetected ()  int16_t mpu_getZAccelOffset ()  bool mpu_getZGyroFIFOEnabled ()  int16_t mpu_getZGyroOffset ()  bool mpu_getZNegMotionDetected ()  bool mpu_getZPosMotionDetected ()  bool mpu_getZeroMotionDetected ()  uint8_t mpu_getZeroMotionDetectionDuration ()  uint8_t mpu_getZeroMotionDetectionThreshold ()  void mpu_readMemoryBlock (uint8_t * data, uint16_t dataSize, uint8_t bank, uint8_t address)  uint8_t mpu_readMemoryByte ()  void mpu_reset ()  void mpu_resetAccelerometerPath ()  void mpu_resetDMP ()  void mpu_resetFIFO ()  void mpu_resetGyroscopePath ()  void mpu_resetI2CMaster ()  void mpu_resetSensors ()  void mpu_resetTemperaturePath ()  void mpu_setAccelFIFOEnabled (bool enabled)  void mpu_setAccelXSelfTest (bool enabled)  void mpu_setAccelYSelfTest (bool enabled)  void mpu_setAccelZSelfTest (bool enabled)  void mpu_setAccelerometerPowerOnDelay (uint8_t delay)  void mpu_setAuxVDDIOLevel (uint8_t level)  void mpu_setClockOutputEnabled (bool enabled)  void mpu_setClockSource (uint8_t source)  void mpu_setDHPFMode (uint8_t mode)  void mpu_setDLPFMode (uint8_t bandwidth)  void mpu_setDMPConfig1 (uint8_t config)  void mpu_setDMPConfig2 (uint8_t config)  void mpu_setDMPEnabled (bool enabled)  void mpu_setDeviceID (uint8_t id)  void mpu_setExternalFrameSync (uint8_t sync)  void mpu_setExternalShadowDelayEnabled (bool enabled)  void mpu_setFIFOByte (uint8_t data)  void mpu_setFIFOEnabled (bool enabled)  void mpu_setFSyncInterruptEnabled (bool enabled)  void mpu_setFSyncInterruptLevel (bool level)  void mpu_setFreefallDetectionCounterDecrement (uint8_t decrement)  void mpu_setFreefallDetectionDuration (uint8_t duration)  void mpu_setFreefallDetectionThreshold (uint8_t threshold)  void mpu_setFullScaleAccelRange (uint8_t range)  void mpu_setFullScaleGyroRange (uint8_t range)  void mpu_setI2CBypassEnabled (bool enabled)  void mpu_setI2CMasterModeEnabled (bool enabled)  void mpu_setIntDMPEnabled (bool enabled)  void mpu_setIntDataReadyEnabled (bool enabled)  void mpu_setIntEnabled (uint8_t enabled)  void mpu_setIntFIFOBufferOverflowEnabled (bool enabled)  void mpu_setIntFreefallEnabled (bool enabled)  void mpu_setIntI2CMasterEnabled (bool enabled)  void mpu_setIntMotionEnabled (bool enabled)  void mpu_setIntPLLReadyEnabled (bool enabled)  void mpu_setIntZeroMotionEnabled (bool enabled)  void mpu_setInterruptDrive (bool drive)  void mpu_setInterruptLatch (bool latch)  void mpu_setInterruptLatchClear (bool clear)  void mpu_setInterruptMode (bool mode)  void mpu_setMasterClockSpeed (uint8_t speed)  void mpu_setMemoryBank (uint8_t bank, bool prefetchEnabled, bool userBank)  void mpu_setMemoryStartAddress (uint8_t address)  void mpu_setMotionDetectionCounterDecrement (uint8_t decrement)  void mpu_setMotionDetectionDuration (uint8_t duration)  void mpu_setMotionDetectionThreshold (uint8_t threshold)  void mpu_setMultiMasterEnabled (bool enabled)  void mpu_setOTPBankValid (bool enabled)  void mpu_setRate (uint8_t rate)  void mpu_setSlave0FIFOEnabled (bool enabled)  void mpu_setSlave1FIFOEnabled (bool enabled)  void mpu_setSlave2FIFOEnabled (bool enabled)  void mpu_setSlave3FIFOEnabled (bool enabled)  void mpu_setSlave4Address (uint8_t address)  void mpu_setSlave4Enabled (bool enabled)  void mpu_setSlave4InterruptEnabled (bool enabled)  void mpu_setSlave4MasterDelay (uint8_t delay)  void mpu_setSlave4OutputByte (uint8_t data)  void mpu_setSlave4Register (uint8_t reg)  void mpu_setSlave4WriteMode (bool mode)  void mpu_setSlaveAddress (uint8_t num, uint8_t address)  void mpu_setSlaveDataLength (uint8_t num, uint8_t length)  void mpu_setSlaveDelayEnabled (uint8_t num, bool enabled)  void mpu_setSlaveEnabled (uint8_t num, bool enabled)  void mpu_setSlaveOutputByte (uint8_t num, uint8_t data)  void mpu_setSlaveReadWriteTransitionEnabled (bool enabled)  void mpu_setSlaveRegister (uint8_t num, uint8_t reg)  void mpu_setSlaveWordByteSwap (uint8_t num, bool enabled)  void mpu_setSlaveWordGroupOffset (uint8_t num, bool enabled)  void mpu_setSlaveWriteMode (uint8_t num, bool mode)  void mpu_setSleepEnabled (bool enabled)  void mpu_setStandbyXAccelEnabled (bool enabled)  void mpu_setStandbyXGyroEnabled (bool enabled)  void mpu_setStandbyYAccelEnabled (bool enabled)  void mpu_setStandbyYGyroEnabled (bool enabled)  void mpu_setStandbyZAccelEnabled (bool enabled)  void mpu_setStandbyZGyroEnabled (bool enabled)  void mpu_setTempFIFOEnabled (bool enabled)  void mpu_setTempSensorEnabled (bool enabled)  void mpu_setWaitForExternalSensorEnabled (bool enabled)  void mpu_setWakeCycleEnabled (bool enabled)  void mpu_setWakeFrequency (uint8_t frequency)  void mpu_setXAccelOffset (int16_t offset)  void mpu_setXFineGain (int8_t gain)  void mpu_setXGyroFIFOEnabled (bool enabled)  void mpu_setXGyroOffset (int16_t offset)  void mpu_setXGyroOffsetTC (int8_t offset)  void mpu_setYAccelOffset (int16_t offset)  void mpu_setYFineGain (int8_t gain)  void mpu_setYGyroFIFOEnabled (bool enabled)  void mpu_setYGyroOffset (int16_t offset)  void mpu_setYGyroOffsetTC (int8_t offset)  void mpu_setZAccelOffset (int16_t offset)  void mpu_setZFineGain (int8_t gain)  void mpu_setZGyroFIFOEnabled (bool enabled)  void mpu_setZGyroOffset (int16_t offset)  void mpu_setZGyroOffsetTC (int8_t offset)  void mpu_setZeroMotionDetectionDuration (uint8_t duration)  void mpu_setZeroMotionDetectionThreshold (uint8_t threshold)  void mpu_switchSPIEnabled (bool enabled)  bool mpu_testConnection ()  void mpu_writeMemoryByte (uint8_t data)"},{"location":"apiStm/MpuController_8hpp/#macros","title":"Macros","text":"Type Name define mpu_ACCEL_FIFO_EN_BIT  3 define mpu_ACCEL_FS_16  0x03 define mpu_ACCEL_FS_2  0x00 define mpu_ACCEL_FS_4  0x01 define mpu_ACCEL_FS_8  0x02 define mpu_ACONFIG_ACCEL_HPF_BIT  2 define mpu_ACONFIG_ACCEL_HPF_LENGTH  3 define mpu_ACONFIG_AFS_SEL_BIT  4 define mpu_ACONFIG_AFS_SEL_LENGTH  2 define mpu_ACONFIG_XA_ST_BIT  7 define mpu_ACONFIG_YA_ST_BIT  6 define mpu_ACONFIG_ZA_ST_BIT  5 define mpu_ADDRESS_AD0_HIGH  0x69 define mpu_ADDRESS_AD0_LOW      0x68 define mpu_BANKSEL_CFG_USER_BANK_BIT  5 define mpu_BANKSEL_MEM_SEL_BIT  4 define mpu_BANKSEL_MEM_SEL_LENGTH  5 define mpu_BANKSEL_PRFTCH_EN_BIT  6 define mpu_CFG_DLPF_CFG_BIT  2 define mpu_CFG_DLPF_CFG_LENGTH  3 define mpu_CFG_EXT_SYNC_SET_BIT  5 define mpu_CFG_EXT_SYNC_SET_LENGTH  3 define mpu_CLOCK_DIV_258  0x8 define mpu_CLOCK_DIV_267  0x7 define mpu_CLOCK_DIV_276  0x6 define mpu_CLOCK_DIV_286  0x5 define mpu_CLOCK_DIV_296  0x4 define mpu_CLOCK_DIV_308  0x3 define mpu_CLOCK_DIV_320  0x2 define mpu_CLOCK_DIV_333  0x1 define mpu_CLOCK_DIV_348  0x0 define mpu_CLOCK_DIV_364  0xF define mpu_CLOCK_DIV_381  0xE define mpu_CLOCK_DIV_400  0xD define mpu_CLOCK_DIV_421  0xC define mpu_CLOCK_DIV_444  0xB define mpu_CLOCK_DIV_471  0xA define mpu_CLOCK_DIV_500  0x9 define mpu_CLOCK_INTERNAL  0x00 define mpu_CLOCK_KEEP_RESET  0x07 define mpu_CLOCK_PLL_EXT19M  0x05 define mpu_CLOCK_PLL_EXT32K  0x04 define mpu_CLOCK_PLL_XGYRO  0x01 define mpu_CLOCK_PLL_YGYRO  0x02 define mpu_CLOCK_PLL_ZGYRO  0x03 define mpu_DEFAULT_ADDRESS  mpu_ADDRESS_AD0_LOW define mpu_DELAYCTRL_DELAY_ES_SHADOW_BIT  7 define mpu_DELAYCTRL_I2C_SLV0_DLY_EN_BIT  0 define mpu_DELAYCTRL_I2C_SLV1_DLY_EN_BIT  1 define mpu_DELAYCTRL_I2C_SLV2_DLY_EN_BIT  2 define mpu_DELAYCTRL_I2C_SLV3_DLY_EN_BIT  3 define mpu_DELAYCTRL_I2C_SLV4_DLY_EN_BIT  4 define mpu_DETECT_ACCEL_ON_DELAY_BIT  5 define mpu_DETECT_ACCEL_ON_DELAY_LENGTH  2 define mpu_DETECT_DECREMENT_1  0x1 define mpu_DETECT_DECREMENT_2  0x2 define mpu_DETECT_DECREMENT_4  0x3 define mpu_DETECT_DECREMENT_RESET  0x0 define mpu_DETECT_FF_COUNT_BIT  3 define mpu_DETECT_FF_COUNT_LENGTH  2 define mpu_DETECT_MOT_COUNT_BIT  1 define mpu_DETECT_MOT_COUNT_LENGTH  2 define mpu_DHPF_0P63  0x04 define mpu_DHPF_1P25  0x03 define mpu_DHPF_2P5  0x02 define mpu_DHPF_5  0x01 define mpu_DHPF_HOLD  0x07 define mpu_DHPF_RESET  0x00 define mpu_DLPF_BW_10  0x05 define mpu_DLPF_BW_188  0x01 define mpu_DLPF_BW_20  0x04 define mpu_DLPF_BW_256  0x00 define mpu_DLPF_BW_42  0x03 define mpu_DLPF_BW_5  0x06 define mpu_DLPF_BW_98  0x02 define mpu_DMPINT_0_BIT  0 define mpu_DMPINT_1_BIT  1 define mpu_DMPINT_2_BIT  2 define mpu_DMPINT_3_BIT  3 define mpu_DMPINT_4_BIT  4 define mpu_DMPINT_5_BIT  5 define mpu_DMP_MEMORY_BANKS  8 define mpu_DMP_MEMORY_BANK_SIZE  256 define mpu_DMP_MEMORY_CHUNK_SIZE  16 define mpu_EXT_SYNC_ACCEL_XOUT_L  0x5 define mpu_EXT_SYNC_ACCEL_YOUT_L  0x6 define mpu_EXT_SYNC_ACCEL_ZOUT_L  0x7 define mpu_EXT_SYNC_DISABLED  0x0 define mpu_EXT_SYNC_GYRO_XOUT_L  0x2 define mpu_EXT_SYNC_GYRO_YOUT_L  0x3 define mpu_EXT_SYNC_GYRO_ZOUT_L  0x4 define mpu_EXT_SYNC_TEMP_OUT_L  0x1 define mpu_GCONFIG_FS_SEL_BIT  4 define mpu_GCONFIG_FS_SEL_LENGTH  2 define mpu_GYRO_FS_1000  0x02 define mpu_GYRO_FS_2000  0x03 define mpu_GYRO_FS_250  0x00 define mpu_GYRO_FS_500  0x01 define mpu_I2C_MST_CLK_BIT  3 define mpu_I2C_MST_CLK_LENGTH  4 define mpu_I2C_MST_P_NSR_BIT  4 define mpu_I2C_SLV4_ADDR_BIT  6 define mpu_I2C_SLV4_ADDR_LENGTH  7 define mpu_I2C_SLV4_EN_BIT  7 define mpu_I2C_SLV4_INT_EN_BIT  6 define mpu_I2C_SLV4_MST_DLY_BIT  4 define mpu_I2C_SLV4_MST_DLY_LENGTH  5 define mpu_I2C_SLV4_REG_DIS_BIT  5 define mpu_I2C_SLV4_RW_BIT  7 define mpu_I2C_SLV_ADDR_BIT  6 define mpu_I2C_SLV_ADDR_LENGTH  7 define mpu_I2C_SLV_BYTE_SW_BIT  6 define mpu_I2C_SLV_EN_BIT  7 define mpu_I2C_SLV_GRP_BIT  4 define mpu_I2C_SLV_LEN_BIT  3 define mpu_I2C_SLV_LEN_LENGTH  4 define mpu_I2C_SLV_REG_DIS_BIT  5 define mpu_I2C_SLV_RW_BIT  7 define mpu_INTCFG_CLKOUT_EN_BIT  0 define mpu_INTCFG_FSYNC_INT_EN_BIT  2 define mpu_INTCFG_FSYNC_INT_LEVEL_BIT  3 define mpu_INTCFG_I2C_BYPASS_EN_BIT  1 define mpu_INTCFG_INT_LEVEL_BIT  7 define mpu_INTCFG_INT_OPEN_BIT  6 define mpu_INTCFG_INT_RD_CLEAR_BIT  4 define mpu_INTCFG_LATCH_INT_EN_BIT  5 define mpu_INTCLEAR_ANYREAD  0x01 define mpu_INTCLEAR_STATUSREAD  0x00 define mpu_INTDRV_OPENDRAIN  0x01 define mpu_INTDRV_PUSHPULL  0x00 define mpu_INTERRUPT_DATA_RDY_BIT  0 define mpu_INTERRUPT_DMP_INT_BIT  1 define mpu_INTERRUPT_FF_BIT  7 define mpu_INTERRUPT_FIFO_OFLOW_BIT  4 define mpu_INTERRUPT_I2C_MST_INT_BIT  3 define mpu_INTERRUPT_MOT_BIT  6 define mpu_INTERRUPT_PLL_RDY_INT_BIT  2 define mpu_INTERRUPT_ZMOT_BIT  5 define mpu_INTLATCH_50USPULSE  0x00 define mpu_INTLATCH_WAITCLEAR  0x01 define mpu_INTMODE_ACTIVEHIGH  0x00 define mpu_INTMODE_ACTIVELOW  0x01 define mpu_MOTION_MOT_XNEG_BIT  7 define mpu_MOTION_MOT_XPOS_BIT  6 define mpu_MOTION_MOT_YNEG_BIT  5 define mpu_MOTION_MOT_YPOS_BIT  4 define mpu_MOTION_MOT_ZNEG_BIT  3 define mpu_MOTION_MOT_ZPOS_BIT  2 define mpu_MOTION_MOT_ZRMOT_BIT  0 define mpu_MST_I2C_LOST_ARB_BIT  5 define mpu_MST_I2C_SLV0_NACK_BIT  0 define mpu_MST_I2C_SLV1_NACK_BIT  1 define mpu_MST_I2C_SLV2_NACK_BIT  2 define mpu_MST_I2C_SLV3_NACK_BIT  3 define mpu_MST_I2C_SLV4_DONE_BIT  6 define mpu_MST_I2C_SLV4_NACK_BIT  4 define mpu_MST_PASS_THROUGH_BIT  7 define mpu_MULT_MST_EN_BIT  7 define mpu_PATHRESET_ACCEL_RESET_BIT  1 define mpu_PATHRESET_GYRO_RESET_BIT  2 define mpu_PATHRESET_TEMP_RESET_BIT  0 define mpu_PWR1_CLKSEL_BIT  2 define mpu_PWR1_CLKSEL_LENGTH  3 define mpu_PWR1_CYCLE_BIT  5 define mpu_PWR1_DEVICE_RESET_BIT  7 define mpu_PWR1_SLEEP_BIT  6 define mpu_PWR1_TEMP_DIS_BIT  3 define mpu_PWR2_LP_WAKE_CTRL_BIT  7 define mpu_PWR2_LP_WAKE_CTRL_LENGTH  2 define mpu_PWR2_STBY_XA_BIT  5 define mpu_PWR2_STBY_XG_BIT  2 define mpu_PWR2_STBY_YA_BIT  4 define mpu_PWR2_STBY_YG_BIT  1 define mpu_PWR2_STBY_ZA_BIT  3 define mpu_PWR2_STBY_ZG_BIT  0 define mpu_RA_ACCEL_CONFIG  0x1C define mpu_RA_ACCEL_XOUT_H  0x3B define mpu_RA_ACCEL_XOUT_L  0x3C define mpu_RA_ACCEL_YOUT_H  0x3D define mpu_RA_ACCEL_YOUT_L  0x3E define mpu_RA_ACCEL_ZOUT_H  0x3F define mpu_RA_ACCEL_ZOUT_L  0x40 define mpu_RA_BANK_SEL  0x6D define mpu_RA_CONFIG  0x1A define mpu_RA_DMP_CFG_1  0x70 define mpu_RA_DMP_CFG_2  0x71 define mpu_RA_DMP_INT_STATUS  0x39 define mpu_RA_EXT_SENS_DATA_00  0x49 define mpu_RA_EXT_SENS_DATA_01  0x4A define mpu_RA_EXT_SENS_DATA_02  0x4B define mpu_RA_EXT_SENS_DATA_03  0x4C define mpu_RA_EXT_SENS_DATA_04  0x4D define mpu_RA_EXT_SENS_DATA_05  0x4E define mpu_RA_EXT_SENS_DATA_06  0x4F define mpu_RA_EXT_SENS_DATA_07  0x50 define mpu_RA_EXT_SENS_DATA_08  0x51 define mpu_RA_EXT_SENS_DATA_09  0x52 define mpu_RA_EXT_SENS_DATA_10  0x53 define mpu_RA_EXT_SENS_DATA_11  0x54 define mpu_RA_EXT_SENS_DATA_12  0x55 define mpu_RA_EXT_SENS_DATA_13  0x56 define mpu_RA_EXT_SENS_DATA_14  0x57 define mpu_RA_EXT_SENS_DATA_15  0x58 define mpu_RA_EXT_SENS_DATA_16  0x59 define mpu_RA_EXT_SENS_DATA_17  0x5A define mpu_RA_EXT_SENS_DATA_18  0x5B define mpu_RA_EXT_SENS_DATA_19  0x5C define mpu_RA_EXT_SENS_DATA_20  0x5D define mpu_RA_EXT_SENS_DATA_21  0x5E define mpu_RA_EXT_SENS_DATA_22  0x5F define mpu_RA_EXT_SENS_DATA_23  0x60 define mpu_RA_FF_DUR  0x1E define mpu_RA_FF_THR  0x1D define mpu_RA_FIFO_COUNTH  0x72 define mpu_RA_FIFO_COUNTL  0x73 define mpu_RA_FIFO_EN  0x23 define mpu_RA_FIFO_R_W  0x74 define mpu_RA_GYRO_CONFIG  0x1B define mpu_RA_GYRO_XOUT_H  0x43 define mpu_RA_GYRO_XOUT_L  0x44 define mpu_RA_GYRO_YOUT_H  0x45 define mpu_RA_GYRO_YOUT_L  0x46 define mpu_RA_GYRO_ZOUT_H  0x47 define mpu_RA_GYRO_ZOUT_L  0x48 define mpu_RA_I2C_MST_CTRL  0x24 define mpu_RA_I2C_MST_DELAY_CTRL  0x67 define mpu_RA_I2C_MST_STATUS  0x36 define mpu_RA_I2C_SLV0_ADDR  0x25 define mpu_RA_I2C_SLV0_CTRL  0x27 define mpu_RA_I2C_SLV0_DO  0x63 define mpu_RA_I2C_SLV0_REG  0x26 define mpu_RA_I2C_SLV1_ADDR  0x28 define mpu_RA_I2C_SLV1_CTRL  0x2A define mpu_RA_I2C_SLV1_DO  0x64 define mpu_RA_I2C_SLV1_REG  0x29 define mpu_RA_I2C_SLV2_ADDR  0x2B define mpu_RA_I2C_SLV2_CTRL  0x2D define mpu_RA_I2C_SLV2_DO  0x65 define mpu_RA_I2C_SLV2_REG  0x2C define mpu_RA_I2C_SLV3_ADDR  0x2E define mpu_RA_I2C_SLV3_CTRL  0x30 define mpu_RA_I2C_SLV3_DO  0x66 define mpu_RA_I2C_SLV3_REG  0x2F define mpu_RA_I2C_SLV4_ADDR  0x31 define mpu_RA_I2C_SLV4_CTRL  0x34 define mpu_RA_I2C_SLV4_DI  0x35 define mpu_RA_I2C_SLV4_DO  0x33 define mpu_RA_I2C_SLV4_REG  0x32 define mpu_RA_INT_ENABLE  0x38 define mpu_RA_INT_PIN_CFG  0x37 define mpu_RA_INT_STATUS  0x3A define mpu_RA_MEM_R_W  0x6F define mpu_RA_MEM_START_ADDR  0x6E define mpu_RA_MOT_DETECT_CTRL  0x69 define mpu_RA_MOT_DETECT_STATUS  0x61 define mpu_RA_MOT_DUR  0x20 define mpu_RA_MOT_THR  0x1F define mpu_RA_PWR_MGMT_1  0x6B define mpu_RA_PWR_MGMT_2  0x6C define mpu_RA_SIGNAL_PATH_RESET  0x68 define mpu_RA_SMPLRT_DIV  0x19 define mpu_RA_TEMP_OUT_H  0x41 define mpu_RA_TEMP_OUT_L  0x42 define mpu_RA_USER_CTRL  0x6A define mpu_RA_WHO_AM_I  0x75 define mpu_RA_XA_OFFS_H  0x06 define mpu_RA_XA_OFFS_L_TC  0x07 define mpu_RA_XG_OFFS_TC  0x00 define mpu_RA_XG_OFFS_USRH  0x13 define mpu_RA_XG_OFFS_USRL  0x14 define mpu_RA_X_FINE_GAIN  0x03 define mpu_RA_YA_OFFS_H  0x08 define mpu_RA_YA_OFFS_L_TC  0x09 define mpu_RA_YG_OFFS_TC  0x01 define mpu_RA_YG_OFFS_USRH  0x15 define mpu_RA_YG_OFFS_USRL  0x16 define mpu_RA_Y_FINE_GAIN  0x04 define mpu_RA_ZA_OFFS_H  0x0A define mpu_RA_ZA_OFFS_L_TC  0x0B define mpu_RA_ZG_OFFS_TC  0x02 define mpu_RA_ZG_OFFS_USRH  0x17 define mpu_RA_ZG_OFFS_USRL  0x18 define mpu_RA_ZRMOT_DUR  0x22 define mpu_RA_ZRMOT_THR  0x21 define mpu_RA_Z_FINE_GAIN  0x05 define mpu_SLV0_FIFO_EN_BIT  0 define mpu_SLV1_FIFO_EN_BIT  1 define mpu_SLV2_FIFO_EN_BIT  2 define mpu_SLV_3_FIFO_EN_BIT  5 define mpu_TC_OFFSET_BIT  6 define mpu_TC_OFFSET_LENGTH  6 define mpu_TC_OTP_BNK_VLD_BIT  0 define mpu_TC_PWR_MODE_BIT  7 define mpu_TEMP_FIFO_EN_BIT  7 define mpu_USERCTRL_DMP_EN_BIT  7 define mpu_USERCTRL_DMP_RESET_BIT  3 define mpu_USERCTRL_FIFO_EN_BIT  6 define mpu_USERCTRL_FIFO_RESET_BIT  2 define mpu_USERCTRL_I2C_IF_DIS_BIT  4 define mpu_USERCTRL_I2C_MST_EN_BIT  5 define mpu_USERCTRL_I2C_MST_RESET_BIT  1 define mpu_USERCTRL_SIG_COND_RESET_BIT  0 define mpu_VDDIO_LEVEL_VDD  1 define mpu_VDDIO_LEVEL_VLOGIC  0 define mpu_WAIT_FOR_ES_BIT  6 define mpu_WAKE_FREQ_10  0x3 define mpu_WAKE_FREQ_1P25  0x0 define mpu_WAKE_FREQ_2P5  0x1 define mpu_WAKE_FREQ_5  0x2 define mpu_WHO_AM_I_BIT  6 define mpu_WHO_AM_I_LENGTH  6 define mpu_XG_FIFO_EN_BIT  6 define mpu_YG_FIFO_EN_BIT  5 define mpu_ZG_FIFO_EN_BIT  4"},{"location":"apiStm/MpuController_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/MpuController_8hpp/#typedef-mpu_t","title":"typedef mpu_t","text":"<pre><code>typedef struct mpu_t mpu_t;\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/MpuController_8hpp/#function-getexternalsensordword","title":"function getExternalSensorDWord","text":"<pre><code>uint32_t getExternalSensorDWord (\nint position\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-getxfinegain","title":"function getXFineGain","text":"<pre><code>int8_t getXFineGain () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-getxgyrooffsettc","title":"function getXGyroOffsetTC","text":"<pre><code>int8_t getXGyroOffsetTC () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-getyfinegain","title":"function getYFineGain","text":"<pre><code>int8_t getYFineGain () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-getygyrooffsettc","title":"function getYGyroOffsetTC","text":"<pre><code>int8_t getYGyroOffsetTC () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-getzfinegain","title":"function getZFineGain","text":"<pre><code>int8_t getZFineGain () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-getzgyrooffsettc","title":"function getZGyroOffsetTC","text":"<pre><code>int8_t getZGyroOffsetTC () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpucreate","title":"function mpuCreate","text":"<pre><code>void mpuCreate () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpudispatch","title":"function mpuDispatch","text":"<pre><code>void mpuDispatch (\nconst CoprocReq_MpuReq &amp; request\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpuinitialize","title":"function mpuInitialize","text":"<pre><code>void mpuInitialize () </code></pre> <p>Power on and prepare for general usage. This will activate the device and take it out of sleep mode (which must be done after start-up). This function also sets both the accelerometer and the gyroscope to their most sensitive settings, namely +/- 2g and +/- 250 degrees/sec, and sets the clock source to use the X Gyro for reference, which is slightly better than the default internal clock source. </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpureset","title":"function mpuReset","text":"<pre><code>void mpuReset () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mputick","title":"function mpuTick","text":"<pre><code>void mpuTick () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getaccelfifoenabled","title":"function mpu_getAccelFIFOEnabled","text":"<pre><code>bool mpu_getAccelFIFOEnabled () </code></pre> <p>Get accelerometer FIFO enabled value. When set to 1, this bit enables ACCEL_XOUT_H, ACCEL_XOUT_L, ACCEL_YOUT_H, ACCEL_YOUT_L, ACCEL_ZOUT_H, and ACCEL_ZOUT_L (Registers 59 to 64) to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current accelerometer FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getaccelxselftest","title":"function mpu_getAccelXSelfTest","text":"<pre><code>bool mpu_getAccelXSelfTest () </code></pre> <p>Get self-test enabled setting for accelerometer X axis. </p> <p>Returns:</p> <p>Self-test enabled value </p> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getaccelyselftest","title":"function mpu_getAccelYSelfTest","text":"<pre><code>bool mpu_getAccelYSelfTest () </code></pre> <p>Get self-test enabled value for accelerometer Y axis. </p> <p>Returns:</p> <p>Self-test enabled value </p> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getaccelzselftest","title":"function mpu_getAccelZSelfTest","text":"<pre><code>bool mpu_getAccelZSelfTest () </code></pre> <p>Get self-test enabled value for accelerometer Z axis. </p> <p>Returns:</p> <p>Self-test enabled value </p> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getacceleration","title":"function mpu_getAcceleration","text":"<pre><code>void mpu_getAcceleration (\nint16_t * x,\nint16_t * y,\nint16_t * z\n) </code></pre> <p>Get 3-axis accelerometer readings. These registers store the most recent accelerometer measurements. Accelerometer measurements are written to these registers at the Sample Rate as defined in Register 25.</p> <p>The accelerometer measurement registers, along with the temperature measurement registers, gyroscope measurement registers, and external sensor data registers, are composed of two sets of registers: an internal register set and a user-facing read register set.</p> <p>The data within the accelerometer sensors' internal register set is always updated at the Sample Rate. Meanwhile, the user-facing read register set duplicates the internal register set's data values whenever the serial interface is idle. This guarantees that a burst read of sensor registers will read measurements from the same sampling instant. Note that if burst reads are not used, the user is responsible for ensuring a set of single byte reads correspond to a single sampling instant by checking the Data Ready interrupt.</p> <p>Each 16-bit accelerometer measurement has a full scale defined in ACCEL_FS (Register 28). For each full scale setting, the accelerometers' sensitivity per LSB in ACCEL_xOUT is shown in the table below:</p> <p>Parameters:</p> <ul> <li><code>x</code> 16-bit signed integer container for X-axis acceleration </li> <li><code>y</code> 16-bit signed integer container for Y-axis acceleration </li> <li><code>z</code> 16-bit signed integer container for Z-axis acceleration </li> </ul> <p>See also: mpu_RA_GYRO_XOUT_H </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getaccelerationx","title":"function mpu_getAccelerationX","text":"<pre><code>int16_t mpu_getAccelerationX () </code></pre> <p>Get X-axis accelerometer reading. </p> <p>Returns:</p> <p>X-axis acceleration measurement in 16-bit 2's complement format </p> <p>See also: getMotion6() </p> <p>See also: mpu_RA_ACCEL_XOUT_H </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getaccelerationy","title":"function mpu_getAccelerationY","text":"<pre><code>int16_t mpu_getAccelerationY () </code></pre> <p>Get Y-axis accelerometer reading. </p> <p>Returns:</p> <p>Y-axis acceleration measurement in 16-bit 2's complement format </p> <p>See also: getMotion6() </p> <p>See also: mpu_RA_ACCEL_YOUT_H </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getaccelerationz","title":"function mpu_getAccelerationZ","text":"<pre><code>int16_t mpu_getAccelerationZ () </code></pre> <p>Get Z-axis accelerometer reading. </p> <p>Returns:</p> <p>Z-axis acceleration measurement in 16-bit 2's complement format </p> <p>See also: getMotion6() </p> <p>See also: mpu_RA_ACCEL_ZOUT_H </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getaccelerometerpowerondelay","title":"function mpu_getAccelerometerPowerOnDelay","text":"<pre><code>uint8_t mpu_getAccelerometerPowerOnDelay () </code></pre> <p>Get accelerometer power-on delay. The accelerometer data path provides samples to the sensor registers, Motion detection, Zero Motion detection, and Free Fall detection modules. The signal path contains filters which must be flushed on wake-up with new samples before the detection modules begin operations. The default wake-up delay, of 4ms can be lengthened by up to 3ms. This additional delay is specified in ACCEL_ON_DELAY in units of 1 LSB = 1 ms. The user may select any value above zero unless instructed otherwise by InvenSense. Please refer to Section 8 of the MPU-6000/MPU-6050 Product Specification document for further information regarding the detection modules. </p> <p>Returns:</p> <p>Current accelerometer power-on delay </p> <p>See also: mpu_RA_MOT_DETECT_CTRL </p> <p>See also: mpu_DETECT_ACCEL_ON_DELAY_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getauxvddiolevel","title":"function mpu_getAuxVDDIOLevel","text":"<pre><code>uint8_t mpu_getAuxVDDIOLevel () </code></pre> <p>Get the auxiliary I2C supply voltage level. When set to 1, the auxiliary I2C bus high logic level is VDD. When cleared to 0, the auxiliary I2C bus high logic level is VLOGIC. This does not apply to the MPU-6000, which does not have a VLOGIC pin. </p> <p>Returns:</p> <p>I2C supply voltage level (0=VLOGIC, 1=VDD) </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getclockoutputenabled","title":"function mpu_getClockOutputEnabled","text":"<pre><code>bool mpu_getClockOutputEnabled () </code></pre> <p>Get reference clock output enabled status. When this bit is equal to 1, a reference clock output is provided at the CLKOUT pin. When this bit is equal to 0, the clock output is disabled. For further information regarding CLKOUT, please refer to the MPU-60X0 Product Specification document. </p> <p>Returns:</p> <p>Current reference clock output enabled status </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_CLKOUT_EN_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getclocksource","title":"function mpu_getClockSource","text":"<pre><code>uint8_t mpu_getClockSource () </code></pre> <p>Get clock source setting. </p> <p>Returns:</p> <p>Current clock source setting </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_CLKSEL_BIT </p> <p>See also: mpu_PWR1_CLKSEL_LENGTH </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getdhpfmode","title":"function mpu_getDHPFMode","text":"<pre><code>uint8_t mpu_getDHPFMode () </code></pre> <p>Get the high-pass filter configuration. The DHPF is a filter module in the path leading to motion detectors (Free Fall, Motion threshold, and Zero Motion). The high pass filter output is not available to the data registers (see Figure in Section 8 of the MPU-6000/ MPU-6050 Product Specification document).</p> <p>The high pass filter has three modes:</p> <p>Returns:</p> <p>Current high-pass filter configuration </p> <p>See also: mpu_DHPF_RESET </p> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getdlpfmode","title":"function mpu_getDLPFMode","text":"<pre><code>uint8_t mpu_getDLPFMode () </code></pre> <p>Get digital low-pass filter configuration. The DLPF_CFG parameter sets the digital low pass filter configuration. It also determines the internal sampling rate used by the device as shown in the table below.</p> <p>Note: The accelerometer output rate is 1kHz. This means that for a Sample Rate greater than 1kHz, the same accelerometer sample may be output to the FIFO, DMP, and sensor registers more than once.</p> <p>Returns:</p> <p>DLFP configuration </p> <p>See also: mpu_RA_CONFIG </p> <p>See also: mpu_CFG_DLPF_CFG_BIT </p> <p>See also: mpu_CFG_DLPF_CFG_LENGTH </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getdmpconfig1","title":"function mpu_getDMPConfig1","text":"<pre><code>uint8_t mpu_getDMPConfig1 () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getdmpconfig2","title":"function mpu_getDMPConfig2","text":"<pre><code>uint8_t mpu_getDMPConfig2 () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getdmpenabled","title":"function mpu_getDMPEnabled","text":"<pre><code>bool mpu_getDMPEnabled () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getdmpint0status","title":"function mpu_getDMPInt0Status","text":"<pre><code>bool mpu_getDMPInt0Status () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getdmpint1status","title":"function mpu_getDMPInt1Status","text":"<pre><code>bool mpu_getDMPInt1Status () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getdmpint2status","title":"function mpu_getDMPInt2Status","text":"<pre><code>bool mpu_getDMPInt2Status () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getdmpint3status","title":"function mpu_getDMPInt3Status","text":"<pre><code>bool mpu_getDMPInt3Status () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getdmpint4status","title":"function mpu_getDMPInt4Status","text":"<pre><code>bool mpu_getDMPInt4Status () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getdmpint5status","title":"function mpu_getDMPInt5Status","text":"<pre><code>bool mpu_getDMPInt5Status () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getdeviceid","title":"function mpu_getDeviceID","text":"<pre><code>uint8_t mpu_getDeviceID () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getexternalframesync","title":"function mpu_getExternalFrameSync","text":"<pre><code>uint8_t mpu_getExternalFrameSync () </code></pre> <p>Get external FSYNC configuration. Configures the external Frame Synchronization (FSYNC) pin sampling. An external signal connected to the FSYNC pin can be sampled by configuring EXT_SYNC_SET. Signal changes to the FSYNC pin are latched so that short strobes may be captured. The latched FSYNC signal will be sampled at the Sampling Rate, as defined in register 25. After sampling, the latch will reset to the current FSYNC signal state.</p> <p>The sampled value will be reported in place of the least significant bit in a sensor data register determined by the value of EXT_SYNC_SET according to the following table.</p> <p>Returns:</p> <p>FSYNC configuration value </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getexternalsensorbyte","title":"function mpu_getExternalSensorByte","text":"<pre><code>uint8_t mpu_getExternalSensorByte (\nint position\n) </code></pre> <p>Read single byte from external sensor data register. These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53).</p> <p>External sensor data is written to these registers at the Sample Rate as defined in Register 25. This access rate can be reduced by using the Slave Delay Enable registers (Register 103).</p> <p>External sensor data registers, along with the gyroscope measurement registers, accelerometer measurement registers, and temperature measurement registers, are composed of two sets of registers: an internal register set and a user-facing read register set.</p> <p>The data within the external sensors' internal register set is always updated at the Sample Rate (or the reduced access rate) whenever the serial interface is idle. This guarantees that a burst read of sensor registers will read measurements from the same sampling instant. Note that if burst reads are not used, the user is responsible for ensuring a set of single byte reads correspond to a single sampling instant by checking the Data Ready interrupt.</p> <p>Data is placed in these external sensor data registers according to I2C_SLV0_CTRL, I2C_SLV1_CTRL, I2C_SLV2_CTRL, and I2C_SLV3_CTRL (Registers 39, 42, 45, and 48). When more than zero bytes are read (I2C_SLVx_LEN &gt; 0) from an enabled slave (I2C_SLVx_EN = 1), the slave is read at the Sample Rate (as defined in Register 25) or delayed rate (if specified in Register 52 and 103). During each Sample cycle, slave reads are performed in order of Slave number. If all slaves are enabled with more than zero bytes to be read, the order will be Slave 0, followed by Slave 1, Slave 2, and Slave 3.</p> <p>Each enabled slave will have EXT_SENS_DATA registers associated with it by number of bytes read (I2C_SLVx_LEN) in order of slave number, starting from EXT_SENS_DATA_00. Note that this means enabling or disabling a slave may change the higher numbered slaves' associated registers. Furthermore, if fewer total bytes are being read from the external sensors as a result of such a change, then the data remaining in the registers which no longer have an associated slave device (i.e. high numbered registers) will remain in these previously allocated registers unless reset.</p> <p>If the sum of the read lengths of all SLVx transactions exceed the number of available EXT_SENS_DATA registers, the excess bytes will be dropped. There are 24 EXT_SENS_DATA registers and hence the total read lengths between all the slaves cannot be greater than 24 or some bytes will be lost.</p> <p>Note: Slave 4's behavior is distinct from that of Slaves 0-3. For further information regarding the characteristics of Slave 4, please refer to Registers 49 to 53.</p> <p>EXAMPLE: Suppose that Slave 0 is enabled with 4 bytes to be read (I2C_SLV0_EN = 1 and I2C_SLV0_LEN = 4) while Slave 1 is enabled with 2 bytes to be read so that I2C_SLV1_EN = 1 and I2C_SLV1_LEN = 2. In such a situation, EXT_SENS_DATA _00 through _03 will be associated with Slave 0, while EXT_SENS_DATA _04 and 05 will be associated with Slave 1. If Slave 2 is enabled as well, registers starting from EXT_SENS_DATA_06 will be allocated to Slave 2.</p> <p>If Slave 2 is disabled while Slave 3 is enabled in this same situation, then registers starting from EXT_SENS_DATA_06 will be allocated to Slave 3 instead.</p> <p>REGISTER ALLOCATION FOR DYNAMIC DISABLE VS. NORMAL DISABLE: If a slave is disabled at any time, the space initially allocated to the slave in the EXT_SENS_DATA register, will remain associated with that slave. This is to avoid dynamic adjustment of the register allocation.</p> <p>The allocation of the EXT_SENS_DATA registers is recomputed only when (1) all slaves are disabled, or (2) the I2C_MST_RST bit is set (Register 106).</p> <p>This above is also true if one of the slaves gets NACKed and stops functioning.</p> <p>Parameters:</p> <ul> <li><code>position</code> Starting position (0-23) </li> </ul> <p>Returns:</p> <p>Byte read from register </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getexternalsensorword","title":"function mpu_getExternalSensorWord","text":"<pre><code>uint16_t mpu_getExternalSensorWord (\nint position\n) </code></pre> <p>Read word (2 bytes) from external sensor data registers. </p> <p>Parameters:</p> <ul> <li><code>position</code> Starting position (0-21) </li> </ul> <p>Returns:</p> <p>Word read from register </p> <p>See also: getExternalSensorByte() </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getexternalshadowdelayenabled","title":"function mpu_getExternalShadowDelayEnabled","text":"<pre><code>bool mpu_getExternalShadowDelayEnabled () </code></pre> <p>Get external data shadow delay enabled status. This register is used to specify the timing of external sensor data shadowing. When DELAY_ES_SHADOW is set to 1, shadowing of external sensor data is delayed until all data has been received. </p> <p>Returns:</p> <p>Current external data shadow delay enabled status. </p> <p>See also: mpu_RA_I2C_MST_DELAY_CTRL </p> <p>See also: mpu_DELAYCTRL_DELAY_ES_SHADOW_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getfifobyte","title":"function mpu_getFIFOByte","text":"<pre><code>uint8_t mpu_getFIFOByte () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getfifobytes","title":"function mpu_getFIFOBytes","text":"<pre><code>void mpu_getFIFOBytes (\nuint8_t * data,\nuint8_t length\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getfifocount","title":"function mpu_getFIFOCount","text":"<pre><code>uint16_t mpu_getFIFOCount () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getfifoenabled","title":"function mpu_getFIFOEnabled","text":"<pre><code>bool mpu_getFIFOEnabled () </code></pre> <p>Get FIFO enabled status. When this bit is set to 0, the FIFO mpu6050.buffer is disabled. The FIFO mpu6050.buffer cannot be written to or read from while disabled. The FIFO mpu6050.buffer's state does not change unless the MPU-60X0 is power cycled. </p> <p>Returns:</p> <p>Current FIFO enabled status </p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_FIFO_EN_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getfsyncinterruptenabled","title":"function mpu_getFSyncInterruptEnabled","text":"<pre><code>bool mpu_getFSyncInterruptEnabled () </code></pre> <p>Get FSYNC pin interrupt enabled setting. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled setting </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_FSYNC_INT_EN_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getfsyncinterruptlevel","title":"function mpu_getFSyncInterruptLevel","text":"<pre><code>bool mpu_getFSyncInterruptLevel () </code></pre> <p>Get FSYNC interrupt logic level mode. </p> <p>Returns:</p> <p>Current FSYNC interrupt mode (0=active-high, 1=active-low) </p> <p>See also: getFSyncInterruptMode() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_FSYNC_INT_LEVEL_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getfreefalldetectioncounterdecrement","title":"function mpu_getFreefallDetectionCounterDecrement","text":"<pre><code>uint8_t mpu_getFreefallDetectionCounterDecrement () </code></pre> <p>Get Free Fall detection counter decrement configuration. Detection is registered by the Free Fall detection module after accelerometer measurements meet their respective threshold conditions over a specified number of samples. When the threshold conditions are met, the corresponding detection counter increments by 1. The user may control the rate at which the detection counter decrements when the threshold condition is not met by configuring FF_COUNT. The decrement rate can be set according to the following table:</p> <p>When FF_COUNT is configured to 0 (reset), any non-qualifying sample will reset the counter to 0. For further information on Free Fall detection, please refer to Registers 29 to 32.</p> <p>Returns:</p> <p>Current decrement configuration </p> <p>See also: mpu_RA_MOT_DETECT_CTRL </p> <p>See also: mpu_DETECT_FF_COUNT_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getfreefalldetectionduration","title":"function mpu_getFreefallDetectionDuration","text":"<pre><code>uint8_t mpu_getFreefallDetectionDuration () </code></pre> <p>Get free-fall event duration threshold. This register configures the duration counter threshold for Free Fall event detection. The duration counter ticks at 1kHz, therefore FF_DUR has a unit of 1 LSB = 1 ms.</p> <p>The Free Fall duration counter increments while the absolute value of the accelerometer measurements are each less than the detection threshold (Register 29). The Free Fall interrupt is triggered when the Free Fall duration counter reaches the time specified in this register.</p> <p>For more details on the Free Fall detection interrupt, see Section 8.2 of the MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and 58 of this document.</p> <p>Returns:</p> <p>Current free-fall duration threshold value (LSB = 1ms) </p> <p>See also: mpu_RA_FF_DUR </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getfreefalldetectionthreshold","title":"function mpu_getFreefallDetectionThreshold","text":"<pre><code>uint8_t mpu_getFreefallDetectionThreshold () </code></pre> <p>Get free-fall event acceleration threshold. This register configures the detection threshold for Free Fall event detection. The unit of FF_THR is 1LSB = 2mg. Free Fall is detected when the absolute value of the accelerometer measurements for the three axes are each less than the detection threshold. This condition increments the Free Fall duration counter (Register 30). The Free Fall interrupt is triggered when the Free Fall duration counter reaches the time specified in FF_DUR.</p> <p>For more details on the Free Fall detection interrupt, see Section 8.2 of the MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and 58 of this document.</p> <p>Returns:</p> <p>Current free-fall acceleration threshold value (LSB = 2mg) </p> <p>See also: mpu_RA_FF_THR </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getfullscaleaccelrange","title":"function mpu_getFullScaleAccelRange","text":"<pre><code>uint8_t mpu_getFullScaleAccelRange () </code></pre> <p>Get full-scale accelerometer range. The FS_SEL parameter allows setting the full-scale range of the accelerometer sensors, as described in the table below.</p> <p>Returns:</p> <p>Current full-scale accelerometer range setting </p> <p>See also: mpu_ACCEL_FS_2 </p> <p>See also: mpu_RA_ACCEL_CONFIG </p> <p>See also: mpu_ACONFIG_AFS_SEL_BIT </p> <p>See also: mpu_ACONFIG_AFS_SEL_LENGTH </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getfullscalegyrorange","title":"function mpu_getFullScaleGyroRange","text":"<pre><code>uint8_t mpu_getFullScaleGyroRange () </code></pre> <p>Get full-scale gyroscope range. The FS_SEL parameter allows setting the full-scale range of the gyro sensors, as described in the table below.</p> <p>Returns:</p> <p>Current full-scale gyroscope range setting </p> <p>See also: mpu_GYRO_FS_250 </p> <p>See also: mpu_RA_GYRO_CONFIG </p> <p>See also: mpu_GCONFIG_FS_SEL_BIT </p> <p>See also: mpu_GCONFIG_FS_SEL_LENGTH </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_geti2cbypassenabled","title":"function mpu_getI2CBypassEnabled","text":"<pre><code>bool mpu_getI2CBypassEnabled () </code></pre> <p>Get I2C bypass enabled status. When this bit is equal to 1 and I2C_MST_EN (Register 106 bit[5]) is equal to 0, the host application processor will be able to directly access the auxiliary I2C bus of the MPU-60X0. When this bit is equal to 0, the host application processor will not be able to directly access the auxiliary I2C bus of the MPU-60X0 regardless of the state of I2C_MST_EN (Register 106 bit[5]). </p> <p>Returns:</p> <p>Current I2C bypass enabled status </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_I2C_BYPASS_EN_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_geti2cmastermodeenabled","title":"function mpu_getI2CMasterModeEnabled","text":"<pre><code>bool mpu_getI2CMasterModeEnabled () </code></pre> <p>Get I2C Master Mode enabled status. When this mode is enabled, the MPU-60X0 acts as the I2C Master to the external sensor slave devices on the auxiliary I2C bus. When this bit is cleared to 0, the auxiliary I2C bus lines (AUX_DA and AUX_CL) are logically driven by the primary I2C bus (SDA and SCL). This is a precondition to enabling Bypass Mode. For further information regarding Bypass Mode, please refer to Register 55. </p> <p>Returns:</p> <p>Current I2C Master Mode enabled status </p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_I2C_MST_EN_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getintdmpenabled","title":"function mpu_getIntDMPEnabled","text":"<pre><code>bool mpu_getIntDMPEnabled () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getintdmpstatus","title":"function mpu_getIntDMPStatus","text":"<pre><code>bool mpu_getIntDMPStatus () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getintdatareadyenabled","title":"function mpu_getIntDataReadyEnabled","text":"<pre><code>bool mpu_getIntDataReadyEnabled () </code></pre> <p>Get Data Ready interrupt enabled setting. This event occurs each time a write operation to all of the sensor registers has been completed. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_DATA_RDY_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getintdatareadystatus","title":"function mpu_getIntDataReadyStatus","text":"<pre><code>bool mpu_getIntDataReadyStatus () </code></pre> <p>Get Data Ready interrupt status. This bit automatically sets to 1 when a Data Ready interrupt has been generated. The bit clears to 0 after the register has been read. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p> <p>See also: mpu_INTERRUPT_DATA_RDY_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getintenabled","title":"function mpu_getIntEnabled","text":"<pre><code>uint8_t mpu_getIntEnabled () </code></pre> <p>Get full interrupt enabled status. Full register byte for all interrupts, for quick reading. Each bit will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_FF_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getintfifobufferoverflowenabled","title":"function mpu_getIntFIFOBufferOverflowEnabled","text":"<pre><code>bool mpu_getIntFIFOBufferOverflowEnabled () </code></pre> <p>Get FIFO Buffer Overflow interrupt enabled status. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_FIFO_OFLOW_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getintfifobufferoverflowstatus","title":"function mpu_getIntFIFOBufferOverflowStatus","text":"<pre><code>bool mpu_getIntFIFOBufferOverflowStatus () </code></pre> <p>Get FIFO Buffer Overflow interrupt status. This bit automatically sets to 1 when a Free Fall interrupt has been generated. The bit clears to 0 after the register has been read. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p> <p>See also: mpu_INTERRUPT_FIFO_OFLOW_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getintfreefallenabled","title":"function mpu_getIntFreefallEnabled","text":"<pre><code>bool mpu_getIntFreefallEnabled () </code></pre> <p>Get Free Fall interrupt enabled status. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_FF_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getintfreefallstatus","title":"function mpu_getIntFreefallStatus","text":"<pre><code>bool mpu_getIntFreefallStatus () </code></pre> <p>Get Free Fall interrupt status. This bit automatically sets to 1 when a Free Fall interrupt has been generated. The bit clears to 0 after the register has been read. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p> <p>See also: mpu_INTERRUPT_FF_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getinti2cmasterenabled","title":"function mpu_getIntI2CMasterEnabled","text":"<pre><code>bool mpu_getIntI2CMasterEnabled () </code></pre> <p>Get I2C Master interrupt enabled status. This enables any of the I2C Master interrupt sources to generate an interrupt. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_I2C_MST_INT_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getinti2cmasterstatus","title":"function mpu_getIntI2CMasterStatus","text":"<pre><code>bool mpu_getIntI2CMasterStatus () </code></pre> <p>Get I2C Master interrupt status. This bit automatically sets to 1 when an I2C Master interrupt has been generated. For a list of I2C Master interrupts, please refer to Register 54. The bit clears to 0 after the register has been read. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p> <p>See also: mpu_INTERRUPT_I2C_MST_INT_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getintmotionenabled","title":"function mpu_getIntMotionEnabled","text":"<pre><code>bool mpu_getIntMotionEnabled () </code></pre> <p>Get Motion Detection interrupt enabled status. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_MOT_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getintmotionstatus","title":"function mpu_getIntMotionStatus","text":"<pre><code>bool mpu_getIntMotionStatus () </code></pre> <p>Get Motion Detection interrupt status. This bit automatically sets to 1 when a Motion Detection interrupt has been generated. The bit clears to 0 after the register has been read. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p> <p>See also: mpu_INTERRUPT_MOT_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getintpllreadyenabled","title":"function mpu_getIntPLLReadyEnabled","text":"<pre><code>bool mpu_getIntPLLReadyEnabled () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getintpllreadystatus","title":"function mpu_getIntPLLReadyStatus","text":"<pre><code>bool mpu_getIntPLLReadyStatus () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getintstatus","title":"function mpu_getIntStatus","text":"<pre><code>uint8_t mpu_getIntStatus () </code></pre> <p>Get full set of interrupt status bits. These bits clear to 0 after the register has been read. Very useful for getting multiple INT statuses, since each single bit read clears all of them because it has to read the whole byte. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getintzeromotionenabled","title":"function mpu_getIntZeroMotionEnabled","text":"<pre><code>bool mpu_getIntZeroMotionEnabled () </code></pre> <p>Get Zero Motion Detection interrupt enabled status. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_ZMOT_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getintzeromotionstatus","title":"function mpu_getIntZeroMotionStatus","text":"<pre><code>bool mpu_getIntZeroMotionStatus () </code></pre> <p>Get Zero Motion Detection interrupt status. This bit automatically sets to 1 when a Zero Motion Detection interrupt has been generated. The bit clears to 0 after the register has been read. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p> <p>See also: mpu_INTERRUPT_ZMOT_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getinterruptdrive","title":"function mpu_getInterruptDrive","text":"<pre><code>bool mpu_getInterruptDrive () </code></pre> <p>Get interrupt drive mode. Will be set 0 for push-pull, 1 for open-drain. </p> <p>Returns:</p> <p>Current interrupt drive mode (0=push-pull, 1=open-drain) </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_INT_OPEN_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getinterruptlatch","title":"function mpu_getInterruptLatch","text":"<pre><code>bool mpu_getInterruptLatch () </code></pre> <p>Get interrupt latch mode. Will be set 0 for 50us-pulse, 1 for latch-until-int-cleared. </p> <p>Returns:</p> <p>Current latch mode (0=50us-pulse, 1=latch-until-int-cleared) </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_LATCH_INT_EN_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getinterruptlatchclear","title":"function mpu_getInterruptLatchClear","text":"<pre><code>bool mpu_getInterruptLatchClear () </code></pre> <p>Get interrupt latch clear mode. Will be set 0 for status-read-only, 1 for any-register-read. </p> <p>Returns:</p> <p>Current latch clear mode (0=status-read-only, 1=any-register-read) </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_INT_RD_CLEAR_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getinterruptmode","title":"function mpu_getInterruptMode","text":"<pre><code>bool mpu_getInterruptMode () </code></pre> <p>Get interrupt logic level mode. Will be set 0 for active-high, 1 for active-low. </p> <p>Returns:</p> <p>Current interrupt mode (0=active-high, 1=active-low) </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_INT_LEVEL_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getlostarbitration","title":"function mpu_getLostArbitration","text":"<pre><code>bool mpu_getLostArbitration () </code></pre> <p>Get master arbitration lost status. This bit automatically sets to 1 when the I2C Master has lost arbitration of the auxiliary I2C bus (an error condition). This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted. </p> <p>Returns:</p> <p>Master arbitration lost status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getmasterclockspeed","title":"function mpu_getMasterClockSpeed","text":"<pre><code>uint8_t mpu_getMasterClockSpeed () </code></pre> <p>Get I2C master clock speed. I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the MPU-60X0 internal 8MHz clock. It sets the I2C master clock speed according to the following table:</p> <p>Returns:</p> <p>Current I2C master clock speed </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getmotion6","title":"function mpu_getMotion6","text":"<pre><code>void mpu_getMotion6 (\nint16_t * ax,\nint16_t * ay,\nint16_t * az,\nint16_t * gx,\nint16_t * gy,\nint16_t * gz\n) </code></pre> <p>Get raw 6-axis motion sensor readings (accel/gyro). Retrieves all currently available motion sensor values. </p> <p>Parameters:</p> <ul> <li><code>ax</code> 16-bit signed integer container for accelerometer X-axis value </li> <li><code>ay</code> 16-bit signed integer container for accelerometer Y-axis value </li> <li><code>az</code> 16-bit signed integer container for accelerometer Z-axis value </li> <li><code>gx</code> 16-bit signed integer container for gyroscope X-axis value </li> <li><code>gy</code> 16-bit signed integer container for gyroscope Y-axis value </li> <li><code>gz</code> 16-bit signed integer container for gyroscope Z-axis value </li> </ul> <p>See also: getAcceleration() </p> <p>See also: getRotation() </p> <p>See also: mpu_RA_ACCEL_XOUT_H </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getmotion9","title":"function mpu_getMotion9","text":"<pre><code>void mpu_getMotion9 (\nint16_t * ax,\nint16_t * ay,\nint16_t * az,\nint16_t * gx,\nint16_t * gy,\nint16_t * gz,\nint16_t * mx,\nint16_t * my,\nint16_t * mz\n) </code></pre> <p>Get raw 9-axis motion sensor readings (accel/gyro/compass). FUNCTION NOT FULLY IMPLEMENTED YET. </p> <p>Parameters:</p> <ul> <li><code>ax</code> 16-bit signed integer container for accelerometer X-axis value </li> <li><code>ay</code> 16-bit signed integer container for accelerometer Y-axis value </li> <li><code>az</code> 16-bit signed integer container for accelerometer Z-axis value </li> <li><code>gx</code> 16-bit signed integer container for gyroscope X-axis value </li> <li><code>gy</code> 16-bit signed integer container for gyroscope Y-axis value </li> <li><code>gz</code> 16-bit signed integer container for gyroscope Z-axis value </li> <li><code>mx</code> 16-bit signed integer container for magnetometer X-axis value </li> <li><code>my</code> 16-bit signed integer container for magnetometer Y-axis value </li> <li><code>mz</code> 16-bit signed integer container for magnetometer Z-axis value </li> </ul> <p>See also: getMotion6() </p> <p>See also: getAcceleration() </p> <p>See also: getRotation() </p> <p>See also: mpu_RA_ACCEL_XOUT_H </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getmotiondetectioncounterdecrement","title":"function mpu_getMotionDetectionCounterDecrement","text":"<pre><code>uint8_t mpu_getMotionDetectionCounterDecrement () </code></pre> <p>Get Motion detection counter decrement configuration. Detection is registered by the Motion detection module after accelerometer measurements meet their respective threshold conditions over a specified number of samples. When the threshold conditions are met, the corresponding detection counter increments by 1. The user may control the rate at which the detection counter decrements when the threshold condition is not met by configuring MOT_COUNT. The decrement rate can be set according to the following table:</p> <p>When MOT_COUNT is configured to 0 (reset), any non-qualifying sample will reset the counter to 0. For further information on Motion detection, please refer to Registers 29 to 32. </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getmotiondetectionduration","title":"function mpu_getMotionDetectionDuration","text":"<pre><code>uint8_t mpu_getMotionDetectionDuration () </code></pre> <p>Get motion detection event duration threshold. This register configures the duration counter threshold for Motion interrupt generation. The duration counter ticks at 1 kHz, therefore MOT_DUR has a unit of 1LSB = 1ms. The Motion detection duration counter increments when the absolute value of any of the accelerometer measurements exceeds the Motion detection threshold (Register 31). The Motion detection interrupt is triggered when the Motion detection counter reaches the time count specified in this register.</p> <p>For more details on the Motion detection interrupt, see Section 8.3 of the MPU-6000/MPU-6050 Product Specification document.</p> <p>Returns:</p> <p>Current motion detection duration threshold value (LSB = 1ms) </p> <p>See also: mpu_RA_MOT_DUR </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getmotiondetectionthreshold","title":"function mpu_getMotionDetectionThreshold","text":"<pre><code>uint8_t mpu_getMotionDetectionThreshold () </code></pre> <p>Get motion detection event acceleration threshold. This register configures the detection threshold for Motion interrupt generation. The unit of MOT_THR is 1LSB = 2mg. Motion is detected when the absolute value of any of the accelerometer measurements exceeds this Motion detection threshold. This condition increments the Motion detection duration counter (Register 32). The Motion detection interrupt is triggered when the Motion Detection counter reaches the time count specified in MOT_DUR (Register 32).</p> <p>The Motion interrupt will indicate the axis and polarity of detected motion in MOT_DETECT_STATUS (Register 97).</p> <p>For more details on the Motion detection interrupt, see Section 8.3 of the MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and 58 of this document.</p> <p>Returns:</p> <p>Current motion detection acceleration threshold value (LSB = 2mg) </p> <p>See also: mpu_RA_MOT_THR </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getmultimasterenabled","title":"function mpu_getMultiMasterEnabled","text":"<pre><code>bool mpu_getMultiMasterEnabled () </code></pre> <p>Get multi-master enabled value. Multi-master capability allows multiple I2C masters to operate on the same bus. In circuits where multi-master capability is required, set MULT_MST_EN to 1. This will increase current drawn by approximately 30uA.</p> <p>In circuits where multi-master capability is required, the state of the I2C bus must always be monitored by each separate I2C Master. Before an I2C Master can assume arbitration of the bus, it must first confirm that no other I2C Master has arbitration of the bus. When MULT_MST_EN is set to 1, the MPU-60X0's bus arbitration detection logic is turned on, enabling it to detect when the bus is available.</p> <p>Returns:</p> <p>Current multi-master enabled value </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getotpbankvalid","title":"function mpu_getOTPBankValid","text":"<pre><code>uint8_t mpu_getOTPBankValid () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getpassthroughstatus","title":"function mpu_getPassthroughStatus","text":"<pre><code>bool mpu_getPassthroughStatus () </code></pre> <p>Get FSYNC interrupt status. This bit reflects the status of the FSYNC interrupt from an external device into the MPU-60X0. This is used as a way to pass an external interrupt through the MPU-60X0 to the host application processor. When set to 1, this bit will cause an interrupt if FSYNC_INT_EN is asserted in INT_PIN_CFG (Register 55). </p> <p>Returns:</p> <p>FSYNC interrupt status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getrate","title":"function mpu_getRate","text":"<pre><code>uint8_t mpu_getRate () </code></pre> <p>Get gyroscope output rate divider. The sensor register output, FIFO output, DMP sampling, Motion detection, Zero Motion detection, and Free Fall detection are all based on the Sample Rate. The Sample Rate is generated by dividing the gyroscope output rate by SMPLRT_DIV:</p> <p>Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)</p> <p>where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or 7), and 1kHz when the DLPF is enabled (see Register 26).</p> <p>Note: The accelerometer output rate is 1kHz. This means that for a Sample Rate greater than 1kHz, the same accelerometer sample may be output to the FIFO, DMP, and sensor registers more than once.</p> <p>For a diagram of the gyroscope and accelerometer signal paths, see Section 8 of the MPU-6000/MPU-6050 Product Specification document.</p> <p>Returns:</p> <p>Current sample rate </p> <p>See also: mpu_RA_SMPLRT_DIV </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getrotation","title":"function mpu_getRotation","text":"<pre><code>void mpu_getRotation (\nint16_t * x,\nint16_t * y,\nint16_t * z\n) </code></pre> <p>Get 3-axis gyroscope readings. These gyroscope measurement registers, along with the accelerometer measurement registers, temperature measurement registers, and external sensor data registers, are composed of two sets of registers: an internal register set and a user-facing read register set. The data within the gyroscope sensors' internal register set is always updated at the Sample Rate. Meanwhile, the user-facing read register set duplicates the internal register set's data values whenever the serial interface is idle. This guarantees that a burst read of sensor registers will read measurements from the same sampling instant. Note that if burst reads are not used, the user is responsible for ensuring a set of single byte reads correspond to a single sampling instant by checking the Data Ready interrupt.</p> <p>Each 16-bit gyroscope measurement has a full scale defined in FS_SEL (Register 27). For each full scale setting, the gyroscopes' sensitivity per LSB in GYRO_xOUT is shown in the table below:</p> <p>Parameters:</p> <ul> <li><code>x</code> 16-bit signed integer container for X-axis rotation </li> <li><code>y</code> 16-bit signed integer container for Y-axis rotation </li> <li><code>z</code> 16-bit signed integer container for Z-axis rotation </li> </ul> <p>See also: getMotion6() </p> <p>See also: mpu_RA_GYRO_XOUT_H </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getrotationx","title":"function mpu_getRotationX","text":"<pre><code>int16_t mpu_getRotationX () </code></pre> <p>Get X-axis gyroscope reading. </p> <p>Returns:</p> <p>X-axis rotation measurement in 16-bit 2's complement format </p> <p>See also: getMotion6() </p> <p>See also: mpu_RA_GYRO_XOUT_H </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getrotationy","title":"function mpu_getRotationY","text":"<pre><code>int16_t mpu_getRotationY () </code></pre> <p>Get Y-axis gyroscope reading. </p> <p>Returns:</p> <p>Y-axis rotation measurement in 16-bit 2's complement format </p> <p>See also: getMotion6() </p> <p>See also: mpu_RA_GYRO_YOUT_H </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getrotationz","title":"function mpu_getRotationZ","text":"<pre><code>int16_t mpu_getRotationZ () </code></pre> <p>Get Z-axis gyroscope reading. </p> <p>Returns:</p> <p>Z-axis rotation measurement in 16-bit 2's complement format </p> <p>See also: getMotion6() </p> <p>See also: mpu_RA_GYRO_ZOUT_H </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslate4inputbyte","title":"function mpu_getSlate4InputByte","text":"<pre><code>uint8_t mpu_getSlate4InputByte () </code></pre> <p>Get last available byte read from Slave 4. This register stores the data read from Slave 4. This field is populated after a read transaction. </p> <p>Returns:</p> <p>Last available byte read from to Slave 4 </p> <p>See also: mpu_RA_I2C_SLV4_DI </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslave0fifoenabled","title":"function mpu_getSlave0FIFOEnabled","text":"<pre><code>bool mpu_getSlave0FIFOEnabled () </code></pre> <p>Get Slave 0 FIFO enabled value. When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 0 to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current Slave 0 FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslave0nack","title":"function mpu_getSlave0Nack","text":"<pre><code>bool mpu_getSlave0Nack () </code></pre> <p>Get Slave 0 NACK status. This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 0. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted. </p> <p>Returns:</p> <p>Slave 0 NACK interrupt status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslave1fifoenabled","title":"function mpu_getSlave1FIFOEnabled","text":"<pre><code>bool mpu_getSlave1FIFOEnabled () </code></pre> <p>Get Slave 1 FIFO enabled value. When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 1 to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current Slave 1 FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslave1nack","title":"function mpu_getSlave1Nack","text":"<pre><code>bool mpu_getSlave1Nack () </code></pre> <p>Get Slave 1 NACK status. This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 1. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted. </p> <p>Returns:</p> <p>Slave 1 NACK interrupt status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslave2fifoenabled","title":"function mpu_getSlave2FIFOEnabled","text":"<pre><code>bool mpu_getSlave2FIFOEnabled () </code></pre> <p>Get Slave 2 FIFO enabled value. When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 2 to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current Slave 2 FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslave2nack","title":"function mpu_getSlave2Nack","text":"<pre><code>bool mpu_getSlave2Nack () </code></pre> <p>Get Slave 2 NACK status. This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 2. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted. </p> <p>Returns:</p> <p>Slave 2 NACK interrupt status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslave3fifoenabled","title":"function mpu_getSlave3FIFOEnabled","text":"<pre><code>bool mpu_getSlave3FIFOEnabled () </code></pre> <p>Get Slave 3 FIFO enabled value. When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 3 to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current Slave 3 FIFO enabled value </p> <p>See also: mpu_RA_MST_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslave3nack","title":"function mpu_getSlave3Nack","text":"<pre><code>bool mpu_getSlave3Nack () </code></pre> <p>Get Slave 3 NACK status. This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 3. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted. </p> <p>Returns:</p> <p>Slave 3 NACK interrupt status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslave4address","title":"function mpu_getSlave4Address","text":"<pre><code>uint8_t mpu_getSlave4Address () </code></pre> <p>Get the I2C address of Slave 4. Note that Bit 7 (MSB) controls read/write mode. If Bit 7 is set, it's a read operation, and if it is cleared, then it's a write operation. The remaining bits (6-0) are the 7-bit device address of the slave device.</p> <p>Returns:</p> <p>Current address for Slave 4 </p> <p>See also: getSlaveAddress() </p> <p>See also: mpu_RA_I2C_SLV4_ADDR </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslave4enabled","title":"function mpu_getSlave4Enabled","text":"<pre><code>bool mpu_getSlave4Enabled () </code></pre> <p>Get the enabled value for the Slave 4. When set to 1, this bit enables Slave 4 for data transfer operations. When cleared to 0, this bit disables Slave 4 from data transfer operations. </p> <p>Returns:</p> <p>Current enabled value for Slave 4 </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslave4interruptenabled","title":"function mpu_getSlave4InterruptEnabled","text":"<pre><code>bool mpu_getSlave4InterruptEnabled () </code></pre> <p>Get the enabled value for Slave 4 transaction interrupts. When set to 1, this bit enables the generation of an interrupt signal upon completion of a Slave 4 transaction. When cleared to 0, this bit disables the generation of an interrupt signal upon completion of a Slave 4 transaction. The interrupt status can be observed in Register 54.</p> <p>Returns:</p> <p>Current enabled value for Slave 4 transaction interrupts. </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslave4isdone","title":"function mpu_getSlave4IsDone","text":"<pre><code>bool mpu_getSlave4IsDone () </code></pre> <p>Get Slave 4 transaction done status. Automatically sets to 1 when a Slave 4 transaction has completed. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted and if the SLV_4_DONE_INT bit is asserted in the I2C_SLV4_CTRL register (Register 52). </p> <p>Returns:</p> <p>Slave 4 transaction done status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslave4masterdelay","title":"function mpu_getSlave4MasterDelay","text":"<pre><code>uint8_t mpu_getSlave4MasterDelay () </code></pre> <p>Get Slave 4 master delay value. This configures the reduced access rate of I2C slaves relative to the Sample Rate. When a slave's access rate is decreased relative to the Sample Rate, the slave is accessed every:  This base Sample Rate in turn is determined by SMPLRT_DIV (register 25) and DLPF_CFG (register 26). Whether a slave's access rate is reduced relative to the Sample Rate is determined by I2C_MST_DELAY_CTRL (register 103). For further information regarding the Sample Rate, please refer to register 25.</p> <p>Returns:</p> <p>Current Slave 4 master delay value </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslave4nack","title":"function mpu_getSlave4Nack","text":"<pre><code>bool mpu_getSlave4Nack () </code></pre> <p>Get Slave 4 NACK status. This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 4. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted. </p> <p>Returns:</p> <p>Slave 4 NACK interrupt status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslave4register","title":"function mpu_getSlave4Register","text":"<pre><code>uint8_t mpu_getSlave4Register () </code></pre> <p>Get the active internal register for the Slave 4. Read/write operations for this slave will be done to whatever internal register address is stored in this MPU register.</p> <p>Returns:</p> <p>Current active register for Slave 4 </p> <p>See also: mpu_RA_I2C_SLV4_REG </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslave4writemode","title":"function mpu_getSlave4WriteMode","text":"<pre><code>bool mpu_getSlave4WriteMode () </code></pre> <p>Get write mode for Slave 4. When set to 1, the transaction will read or write data only. When cleared to 0, the transaction will write a register address prior to reading or writing data. This should equal 0 when specifying the register address within the Slave device to/from which the ensuing data transaction will take place.</p> <p>Returns:</p> <p>Current write mode for Slave 4 (0 = register address + data, 1 = data only) </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslaveaddress","title":"function mpu_getSlaveAddress","text":"<pre><code>uint8_t mpu_getSlaveAddress (\nuint8_t num\n) </code></pre> <p>Get the I2C address of the specified slave (0-3). Note that Bit 7 (MSB) controls read/write mode. If Bit 7 is set, it's a read operation, and if it is cleared, then it's a write operation. The remaining bits (6-0) are the 7-bit device address of the slave device.</p> <p>In read mode, the result of the read is placed in the lowest available EXT_SENS_DATA register. For further information regarding the allocation of read results, please refer to the EXT_SENS_DATA register description (Registers 73 - 96).</p> <p>The MPU-6050 supports a total of five slaves, but Slave 4 has unique characteristics, and so it has its own functions (getSlave4* and setSlave4*).</p> <p>I2C data transactions are performed at the Sample Rate, as defined in Register 25. The user is responsible for ensuring that I2C data transactions to and from each enabled Slave can be completed within a single period of the Sample Rate.</p> <p>The I2C slave access rate can be reduced relative to the Sample Rate. This reduced access rate is determined by I2C_MST_DLY (Register 52). Whether a slave's access rate is reduced relative to the Sample Rate is determined by I2C_MST_DELAY_CTRL (Register 103).</p> <p>The processing order for the slaves is fixed. The sequence followed for processing the slaves is Slave 0, Slave 1, Slave 2, Slave 3 and Slave 4. If a particular Slave is disabled it will be skipped.</p> <p>Each slave can either be accessed at the sample rate or at a reduced sample rate. In a case where some slaves are accessed at the Sample Rate and some slaves are accessed at the reduced rate, the sequence of accessing the slaves (Slave 0 to Slave 4) is still followed. However, the reduced rate slaves will be skipped if their access rate dictates that they should not be accessed during that particular cycle. For further information regarding the reduced access rate, please refer to Register 52. Whether a slave is accessed at the Sample Rate or at the reduced rate is determined by the Delay Enable bits in Register 103.</p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Current address for specified slave </p> <p>See also: mpu_RA_I2C_SLV0_ADDR </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslavedatalength","title":"function mpu_getSlaveDataLength","text":"<pre><code>uint8_t mpu_getSlaveDataLength (\nuint8_t num\n) </code></pre> <p>Get number of bytes to read for the specified slave (0-3). Specifies the number of bytes transferred to and from Slave 0. Clearing this bit to 0 is equivalent to disabling the register by writing 0 to I2C_SLV0_EN. </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Number of bytes to read for specified slave </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslavedelayenabled","title":"function mpu_getSlaveDelayEnabled","text":"<pre><code>bool mpu_getSlaveDelayEnabled (\nuint8_t num\n) </code></pre> <p>Get slave delay enabled status. When a particular slave delay is enabled, the rate of access for the that slave device is reduced. When a slave's access rate is decreased relative to the Sample Rate, the slave is accessed every:  This base Sample Rate in turn is determined by SMPLRT_DIV (register * 25) and DLPF_CFG (register 26).</p> <p>For further information regarding I2C_MST_DLY, please refer to register 52. For further information regarding the Sample Rate, please refer to register 25.</p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-4) </li> </ul> <p>Returns:</p> <p>Current slave delay enabled status. </p> <p>See also: mpu_RA_I2C_MST_DELAY_CTRL </p> <p>See also: mpu_DELAYCTRL_I2C_SLV0_DLY_EN_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslaveenabled","title":"function mpu_getSlaveEnabled","text":"<pre><code>bool mpu_getSlaveEnabled (\nuint8_t num\n) </code></pre> <p>Get the enabled value for the specified slave (0-3). When set to 1, this bit enables Slave 0 for data transfer operations. When cleared to 0, this bit disables Slave 0 from data transfer operations. </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Current enabled value for specified slave </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslavereadwritetransitionenabled","title":"function mpu_getSlaveReadWriteTransitionEnabled","text":"<pre><code>bool mpu_getSlaveReadWriteTransitionEnabled () </code></pre> <p>Get slave read/write transition enabled value. The I2C_MST_P_NSR bit configures the I2C Master's transition from one slave read to the next slave read. If the bit equals 0, there will be a restart between reads. If the bit equals 1, there will be a stop followed by a start of the following read. When a write transaction follows a read transaction, the stop followed by a start of the successive write will be always used.</p> <p>Returns:</p> <p>Current slave read/write transition enabled value </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslaveregister","title":"function mpu_getSlaveRegister","text":"<pre><code>uint8_t mpu_getSlaveRegister (\nuint8_t num\n) </code></pre> <p>Get the active internal register for the specified slave (0-3). Read/write operations for this slave will be done to whatever internal register address is stored in this MPU register.</p> <p>The MPU-6050 supports a total of five slaves, but Slave 4 has unique characteristics, and so it has its own functions.</p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Current active register for specified slave </p> <p>See also: mpu_RA_I2C_SLV0_REG </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslavewordbyteswap","title":"function mpu_getSlaveWordByteSwap","text":"<pre><code>bool mpu_getSlaveWordByteSwap (\nuint8_t num\n) </code></pre> <p>Get word pair byte-swapping enabled for the specified slave (0-3). When set to 1, this bit enables byte swapping. When byte swapping is enabled, the high and low bytes of a word pair are swapped. Please refer to I2C_SLV0_GRP for the pairing convention of the word pairs. When cleared to 0, bytes transferred to and from Slave 0 will be written to EXT_SENS_DATA registers in the order they were transferred.</p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Current word pair byte-swapping enabled value for specified slave </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslavewordgroupoffset","title":"function mpu_getSlaveWordGroupOffset","text":"<pre><code>bool mpu_getSlaveWordGroupOffset (\nuint8_t num\n) </code></pre> <p>Get word pair grouping order offset for the specified slave (0-3). This sets specifies the grouping order of word pairs received from registers. When cleared to 0, bytes from register addresses 0 and 1, 2 and 3, etc (even, then odd register addresses) are paired to form a word. When set to 1, bytes from register addresses are paired 1 and 2, 3 and 4, etc. (odd, then even register addresses) are paired to form a word.</p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Current word pair grouping order offset for specified slave </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getslavewritemode","title":"function mpu_getSlaveWriteMode","text":"<pre><code>bool mpu_getSlaveWriteMode (\nuint8_t num\n) </code></pre> <p>Get write mode for the specified slave (0-3). When set to 1, the transaction will read or write data only. When cleared to 0, the transaction will write a register address prior to reading or writing data. This should equal 0 when specifying the register address within the Slave device to/from which the ensuing data transaction will take place.</p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Current write mode for specified slave (0 = register address + data, 1 = data only) </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getsleepenabled","title":"function mpu_getSleepEnabled","text":"<pre><code>bool mpu_getSleepEnabled () </code></pre> <p>Get sleep mode status. Setting the SLEEP bit in the register puts the device into very low power sleep mode. In this mode, only the serial interface and internal registers remain active, allowing for a very low standby current. Clearing this bit puts the device back into normal mode. To save power, the individual standby selections for each of the gyros should be used if any gyro axis is not used by the application. </p> <p>Returns:</p> <p>Current sleep mode enabled status </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_SLEEP_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getstandbyxaccelenabled","title":"function mpu_getStandbyXAccelEnabled","text":"<pre><code>bool mpu_getStandbyXAccelEnabled () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getstandbyxgyroenabled","title":"function mpu_getStandbyXGyroEnabled","text":"<pre><code>bool mpu_getStandbyXGyroEnabled () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getstandbyyaccelenabled","title":"function mpu_getStandbyYAccelEnabled","text":"<pre><code>bool mpu_getStandbyYAccelEnabled () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getstandbyygyroenabled","title":"function mpu_getStandbyYGyroEnabled","text":"<pre><code>bool mpu_getStandbyYGyroEnabled () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getstandbyzaccelenabled","title":"function mpu_getStandbyZAccelEnabled","text":"<pre><code>bool mpu_getStandbyZAccelEnabled () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getstandbyzgyroenabled","title":"function mpu_getStandbyZGyroEnabled","text":"<pre><code>bool mpu_getStandbyZGyroEnabled () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_gettempfifoenabled","title":"function mpu_getTempFIFOEnabled","text":"<pre><code>bool mpu_getTempFIFOEnabled () </code></pre> <p>Get temperature FIFO enabled value. When set to 1, this bit enables TEMP_OUT_H and TEMP_OUT_L (Registers 65 and 66) to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current temperature FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_gettempsensorenabled","title":"function mpu_getTempSensorEnabled","text":"<pre><code>bool mpu_getTempSensorEnabled () </code></pre> <p>Get temperature sensor enabled status. Control the usage of the internal temperature sensor.</p> <p>Note: this register stores the disabled value, but for consistency with the rest of the code, the function is named and used with standard true/false values to indicate whether the sensor is enabled or disabled, respectively.</p> <p>Returns:</p> <p>Current temperature sensor enabled status </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_TEMP_DIS_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_gettemperature","title":"function mpu_getTemperature","text":"<pre><code>int16_t mpu_getTemperature () </code></pre> <p>Get current internal temperature. </p> <p>Returns:</p> <p>Temperature reading in 16-bit 2's complement format </p> <p>See also: mpu_RA_TEMP_OUT_H </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getwaitforexternalsensorenabled","title":"function mpu_getWaitForExternalSensorEnabled","text":"<pre><code>bool mpu_getWaitForExternalSensorEnabled () </code></pre> <p>Get wait-for-external-sensor-data enabled value. When the WAIT_FOR_ES bit is set to 1, the Data Ready interrupt will be delayed until External Sensor data from the Slave Devices are loaded into the EXT_SENS_DATA registers. This is used to ensure that both the internal sensor data (i.e. from gyro and accel) and external sensor data have been loaded to their respective data registers (i.e. the data is synced) when the Data Ready interrupt is triggered.</p> <p>Returns:</p> <p>Current wait-for-external-sensor-data enabled value </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getwakecycleenabled","title":"function mpu_getWakeCycleEnabled","text":"<pre><code>bool mpu_getWakeCycleEnabled () </code></pre> <p>Get wake cycle enabled status. When this bit is set to 1 and SLEEP is disabled, the MPU-60X0 will cycle between sleep mode and waking up to take a single sample of data from active sensors at a rate determined by LP_WAKE_CTRL (register 108). </p> <p>Returns:</p> <p>Current sleep mode enabled status </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_CYCLE_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getwakefrequency","title":"function mpu_getWakeFrequency","text":"<pre><code>uint8_t mpu_getWakeFrequency () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getxacceloffset","title":"function mpu_getXAccelOffset","text":"<pre><code>int16_t mpu_getXAccelOffset () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getxgyrofifoenabled","title":"function mpu_getXGyroFIFOEnabled","text":"<pre><code>bool mpu_getXGyroFIFOEnabled () </code></pre> <p>Get gyroscope X-axis FIFO enabled value. When set to 1, this bit enables GYRO_XOUT_H and GYRO_XOUT_L (Registers 67 and 68) to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current gyroscope X-axis FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getxgyrooffset","title":"function mpu_getXGyroOffset","text":"<pre><code>int16_t mpu_getXGyroOffset () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getxnegmotiondetected","title":"function mpu_getXNegMotionDetected","text":"<pre><code>bool mpu_getXNegMotionDetected () </code></pre> <p>Get X-axis negative motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_XNEG_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getxposmotiondetected","title":"function mpu_getXPosMotionDetected","text":"<pre><code>bool mpu_getXPosMotionDetected () </code></pre> <p>Get X-axis positive motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_XPOS_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getyacceloffset","title":"function mpu_getYAccelOffset","text":"<pre><code>int16_t mpu_getYAccelOffset () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getygyrofifoenabled","title":"function mpu_getYGyroFIFOEnabled","text":"<pre><code>bool mpu_getYGyroFIFOEnabled () </code></pre> <p>Get gyroscope Y-axis FIFO enabled value. When set to 1, this bit enables GYRO_YOUT_H and GYRO_YOUT_L (Registers 69 and 70) to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current gyroscope Y-axis FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getygyrooffset","title":"function mpu_getYGyroOffset","text":"<pre><code>int16_t mpu_getYGyroOffset () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getynegmotiondetected","title":"function mpu_getYNegMotionDetected","text":"<pre><code>bool mpu_getYNegMotionDetected () </code></pre> <p>Get Y-axis negative motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_YNEG_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getyposmotiondetected","title":"function mpu_getYPosMotionDetected","text":"<pre><code>bool mpu_getYPosMotionDetected () </code></pre> <p>Get Y-axis positive motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_YPOS_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getzacceloffset","title":"function mpu_getZAccelOffset","text":"<pre><code>int16_t mpu_getZAccelOffset () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getzgyrofifoenabled","title":"function mpu_getZGyroFIFOEnabled","text":"<pre><code>bool mpu_getZGyroFIFOEnabled () </code></pre> <p>Get gyroscope Z-axis FIFO enabled value. When set to 1, this bit enables GYRO_ZOUT_H and GYRO_ZOUT_L (Registers 71 and 72) to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current gyroscope Z-axis FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getzgyrooffset","title":"function mpu_getZGyroOffset","text":"<pre><code>int16_t mpu_getZGyroOffset () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getznegmotiondetected","title":"function mpu_getZNegMotionDetected","text":"<pre><code>bool mpu_getZNegMotionDetected () </code></pre> <p>Get Z-axis negative motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_ZNEG_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getzposmotiondetected","title":"function mpu_getZPosMotionDetected","text":"<pre><code>bool mpu_getZPosMotionDetected () </code></pre> <p>Get Z-axis positive motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_ZPOS_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getzeromotiondetected","title":"function mpu_getZeroMotionDetected","text":"<pre><code>bool mpu_getZeroMotionDetected () </code></pre> <p>Get zero motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_ZRMOT_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getzeromotiondetectionduration","title":"function mpu_getZeroMotionDetectionDuration","text":"<pre><code>uint8_t mpu_getZeroMotionDetectionDuration () </code></pre> <p>Get zero motion detection event duration threshold. This register configures the duration counter threshold for Zero Motion interrupt generation. The duration counter ticks at 16 Hz, therefore ZRMOT_DUR has a unit of 1 LSB = 64 ms. The Zero Motion duration counter increments while the absolute value of the accelerometer measurements are each less than the detection threshold (Register 33). The Zero Motion interrupt is triggered when the Zero Motion duration counter reaches the time count specified in this register.</p> <p>For more details on the Zero Motion detection interrupt, see Section 8.4 of the MPU-6000/MPU-6050 Product Specification document, as well as Registers 56 and 58 of this document.</p> <p>Returns:</p> <p>Current zero motion detection duration threshold value (LSB = 64ms) </p> <p>See also: mpu_RA_ZRMOT_DUR </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_getzeromotiondetectionthreshold","title":"function mpu_getZeroMotionDetectionThreshold","text":"<pre><code>uint8_t mpu_getZeroMotionDetectionThreshold () </code></pre> <p>Get zero motion detection event acceleration threshold. This register configures the detection threshold for Zero Motion interrupt generation. The unit of ZRMOT_THR is 1LSB = 2mg. Zero Motion is detected when the absolute value of the accelerometer measurements for the 3 axes are each less than the detection threshold. This condition increments the Zero Motion duration counter (Register 34). The Zero Motion interrupt is triggered when the Zero Motion duration counter reaches the time count specified in ZRMOT_DUR (Register 34).</p> <p>Unlike Free Fall or Motion detection, Zero Motion detection triggers an interrupt both when Zero Motion is first detected and when Zero Motion is no longer detected.</p> <p>When a zero motion event is detected, a Zero Motion Status will be indicated in the MOT_DETECT_STATUS register (Register 97). When a motion-to-zero-motion condition is detected, the status bit is set to 1. When a zero-motion-to- motion condition is detected, the status bit is set to 0.</p> <p>For more details on the Zero Motion detection interrupt, see Section 8.4 of the MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and 58 of this document.</p> <p>Returns:</p> <p>Current zero motion detection acceleration threshold value (LSB = 2mg) </p> <p>See also: mpu_RA_ZRMOT_THR </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_readmemoryblock","title":"function mpu_readMemoryBlock","text":"<pre><code>void mpu_readMemoryBlock (\nuint8_t * data,\nuint16_t dataSize,\nuint8_t bank,\nuint8_t address\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_readmemorybyte","title":"function mpu_readMemoryByte","text":"<pre><code>uint8_t mpu_readMemoryByte () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_reset","title":"function mpu_reset","text":"<pre><code>void mpu_reset () </code></pre> <p>Trigger a full device reset. A small delay of ~50ms may be desirable after triggering a reset. </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_DEVICE_RESET_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_resetaccelerometerpath","title":"function mpu_resetAccelerometerPath","text":"<pre><code>void mpu_resetAccelerometerPath () </code></pre> <p>Reset accelerometer signal path. The reset will revert the signal path analog to digital converters and filters to their power up configurations. </p> <p>See also: mpu_RA_SIGNAL_PATH_RESET </p> <p>See also: mpu_PATHRESET_ACCEL_RESET_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_resetdmp","title":"function mpu_resetDMP","text":"<pre><code>void mpu_resetDMP () </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_resetfifo","title":"function mpu_resetFIFO","text":"<pre><code>void mpu_resetFIFO () </code></pre> <p>Reset the FIFO. This bit resets the FIFO mpu6050.buffer when set to 1 while FIFO_EN equals 0. This bit automatically clears to 0 after the reset has been triggered. </p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_FIFO_RESET_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_resetgyroscopepath","title":"function mpu_resetGyroscopePath","text":"<pre><code>void mpu_resetGyroscopePath () </code></pre> <p>Reset gyroscope signal path. The reset will revert the signal path analog to digital converters and filters to their power up configurations. </p> <p>See also: mpu_RA_SIGNAL_PATH_RESET </p> <p>See also: mpu_PATHRESET_GYRO_RESET_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_reseti2cmaster","title":"function mpu_resetI2CMaster","text":"<pre><code>void mpu_resetI2CMaster () </code></pre> <p>Reset the I2C Master. This bit resets the I2C Master when set to 1 while I2C_MST_EN equals 0. This bit automatically clears to 0 after the reset has been triggered. </p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_I2C_MST_RESET_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_resetsensors","title":"function mpu_resetSensors","text":"<pre><code>void mpu_resetSensors () </code></pre> <p>Reset all sensor registers and signal paths. When set to 1, this bit resets the signal paths for all sensors (gyroscopes, accelerometers, and temperature sensor). This operation will also clear the sensor registers. This bit automatically clears to 0 after the reset has been triggered.</p> <p>When resetting only the signal path (and not the sensor registers), please use Register 104, SIGNAL_PATH_RESET.</p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_SIG_COND_RESET_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_resettemperaturepath","title":"function mpu_resetTemperaturePath","text":"<pre><code>void mpu_resetTemperaturePath () </code></pre> <p>Reset temperature sensor signal path. The reset will revert the signal path analog to digital converters and filters to their power up configurations. </p> <p>See also: mpu_RA_SIGNAL_PATH_RESET </p> <p>See also: mpu_PATHRESET_TEMP_RESET_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setaccelfifoenabled","title":"function mpu_setAccelFIFOEnabled","text":"<pre><code>void mpu_setAccelFIFOEnabled (\nbool enabled\n) </code></pre> <p>Set accelerometer FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New accelerometer FIFO enabled value </li> </ul> <p>See also: getAccelFIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setaccelxselftest","title":"function mpu_setAccelXSelfTest","text":"<pre><code>void mpu_setAccelXSelfTest (\nbool enabled\n) </code></pre> <p>Get self-test enabled setting for accelerometer X axis. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> Self-test enabled value </li> </ul> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setaccelyselftest","title":"function mpu_setAccelYSelfTest","text":"<pre><code>void mpu_setAccelYSelfTest (\nbool enabled\n) </code></pre> <p>Get self-test enabled value for accelerometer Y axis. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> Self-test enabled value </li> </ul> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setaccelzselftest","title":"function mpu_setAccelZSelfTest","text":"<pre><code>void mpu_setAccelZSelfTest (\nbool enabled\n) </code></pre> <p>Set self-test enabled value for accelerometer Z axis. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> Self-test enabled value </li> </ul> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setaccelerometerpowerondelay","title":"function mpu_setAccelerometerPowerOnDelay","text":"<pre><code>void mpu_setAccelerometerPowerOnDelay (\nuint8_t delay\n) </code></pre> <p>Set accelerometer power-on delay. </p> <p>Parameters:</p> <ul> <li><code>delay</code> New accelerometer power-on delay (0-3) </li> </ul> <p>See also: getAccelerometerPowerOnDelay() </p> <p>See also: mpu_RA_MOT_DETECT_CTRL </p> <p>See also: mpu_DETECT_ACCEL_ON_DELAY_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setauxvddiolevel","title":"function mpu_setAuxVDDIOLevel","text":"<pre><code>void mpu_setAuxVDDIOLevel (\nuint8_t level\n) </code></pre> <p>Set the auxiliary I2C supply voltage level. When set to 1, the auxiliary I2C bus high logic level is VDD. When cleared to 0, the auxiliary I2C bus high logic level is VLOGIC. This does not apply to the MPU-6000, which does not have a VLOGIC pin. </p> <p>Parameters:</p> <ul> <li><code>level</code> I2C supply voltage level (0=VLOGIC, 1=VDD) </li> </ul>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setclockoutputenabled","title":"function mpu_setClockOutputEnabled","text":"<pre><code>void mpu_setClockOutputEnabled (\nbool enabled\n) </code></pre> <p>Set reference clock output enabled status. When this bit is equal to 1, a reference clock output is provided at the CLKOUT pin. When this bit is equal to 0, the clock output is disabled. For further information regarding CLKOUT, please refer to the MPU-60X0 Product Specification document. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New reference clock output enabled status </li> </ul> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_CLKOUT_EN_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setclocksource","title":"function mpu_setClockSource","text":"<pre><code>void mpu_setClockSource (\nuint8_t source\n) </code></pre> <p>Set clock source setting. An internal 8MHz oscillator, gyroscope based clock, or external sources can be selected as the MPU-60X0 clock source. When the internal 8 MHz oscillator or an external source is chosen as the clock source, the MPU-60X0 can operate in low power modes with the gyroscopes disabled.</p> <p>Upon power up, the MPU-60X0 clock source defaults to the internal oscillator. However, it is highly recommended that the device be configured to use one of the gyroscopes (or an external clock source) as the clock reference for improved stability. The clock source can be selected according to the following table:</p> <p>Parameters:</p> <ul> <li><code>source</code> New clock source setting </li> </ul> <p>See also: getClockSource() </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_CLKSEL_BIT </p> <p>See also: mpu_PWR1_CLKSEL_LENGTH </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setdhpfmode","title":"function mpu_setDHPFMode","text":"<pre><code>void mpu_setDHPFMode (\nuint8_t mode\n) </code></pre> <p>Set the high-pass filter configuration. </p> <p>Parameters:</p> <ul> <li><code>bandwidth</code> New high-pass filter configuration </li> </ul> <p>See also: setDHPFMode() </p> <p>See also: mpu_DHPF_RESET </p> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setdlpfmode","title":"function mpu_setDLPFMode","text":"<pre><code>void mpu_setDLPFMode (\nuint8_t bandwidth\n) </code></pre> <p>Set digital low-pass filter configuration. </p> <p>Parameters:</p> <ul> <li><code>mode</code> New DLFP configuration setting </li> </ul> <p>See also: getDLPFBandwidth() </p> <p>See also: mpu_DLPF_BW_256 </p> <p>See also: mpu_RA_CONFIG </p> <p>See also: mpu_CFG_DLPF_CFG_BIT </p> <p>See also: mpu_CFG_DLPF_CFG_LENGTH </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setdmpconfig1","title":"function mpu_setDMPConfig1","text":"<pre><code>void mpu_setDMPConfig1 (\nuint8_t config\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setdmpconfig2","title":"function mpu_setDMPConfig2","text":"<pre><code>void mpu_setDMPConfig2 (\nuint8_t config\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setdmpenabled","title":"function mpu_setDMPEnabled","text":"<pre><code>void mpu_setDMPEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setdeviceid","title":"function mpu_setDeviceID","text":"<pre><code>void mpu_setDeviceID (\nuint8_t id\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setexternalframesync","title":"function mpu_setExternalFrameSync","text":"<pre><code>void mpu_setExternalFrameSync (\nuint8_t sync\n) </code></pre> <p>Set external FSYNC configuration. </p> <p>See also: getExternalFrameSync() </p> <p>See also: mpu_RA_CONFIG </p> <p>Parameters:</p> <ul> <li><code>sync</code> New FSYNC configuration value </li> </ul>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setexternalshadowdelayenabled","title":"function mpu_setExternalShadowDelayEnabled","text":"<pre><code>void mpu_setExternalShadowDelayEnabled (\nbool enabled\n) </code></pre> <p>Set external data shadow delay enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New external data shadow delay enabled status. </li> </ul> <p>See also: getExternalShadowDelayEnabled() </p> <p>See also: mpu_RA_I2C_MST_DELAY_CTRL </p> <p>See also: mpu_DELAYCTRL_DELAY_ES_SHADOW_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setfifobyte","title":"function mpu_setFIFOByte","text":"<pre><code>void mpu_setFIFOByte (\nuint8_t data\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setfifoenabled","title":"function mpu_setFIFOEnabled","text":"<pre><code>void mpu_setFIFOEnabled (\nbool enabled\n) </code></pre> <p>Set FIFO enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New FIFO enabled status </li> </ul> <p>See also: getFIFOEnabled() </p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_FIFO_EN_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setfsyncinterruptenabled","title":"function mpu_setFSyncInterruptEnabled","text":"<pre><code>void mpu_setFSyncInterruptEnabled (\nbool enabled\n) </code></pre> <p>Set FSYNC pin interrupt enabled setting. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New FSYNC pin interrupt enabled setting </li> </ul> <p>See also: getFSyncInterruptEnabled() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_FSYNC_INT_EN_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setfsyncinterruptlevel","title":"function mpu_setFSyncInterruptLevel","text":"<pre><code>void mpu_setFSyncInterruptLevel (\nbool level\n) </code></pre> <p>Set FSYNC interrupt logic level mode. </p> <p>Parameters:</p> <ul> <li><code>mode</code> New FSYNC interrupt mode (0=active-high, 1=active-low) </li> </ul> <p>See also: getFSyncInterruptMode() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_FSYNC_INT_LEVEL_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setfreefalldetectioncounterdecrement","title":"function mpu_setFreefallDetectionCounterDecrement","text":"<pre><code>void mpu_setFreefallDetectionCounterDecrement (\nuint8_t decrement\n) </code></pre> <p>Set Free Fall detection counter decrement configuration. </p> <p>Parameters:</p> <ul> <li><code>decrement</code> New decrement configuration value </li> </ul> <p>See also: getFreefallDetectionCounterDecrement() </p> <p>See also: mpu_RA_MOT_DETECT_CTRL </p> <p>See also: mpu_DETECT_FF_COUNT_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setfreefalldetectionduration","title":"function mpu_setFreefallDetectionDuration","text":"<pre><code>void mpu_setFreefallDetectionDuration (\nuint8_t duration\n) </code></pre> <p>Get free-fall event duration threshold. </p> <p>Parameters:</p> <ul> <li><code>duration</code> New free-fall duration threshold value (LSB = 1ms) </li> </ul> <p>See also: getFreefallDetectionDuration() </p> <p>See also: mpu_RA_FF_DUR </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setfreefalldetectionthreshold","title":"function mpu_setFreefallDetectionThreshold","text":"<pre><code>void mpu_setFreefallDetectionThreshold (\nuint8_t threshold\n) </code></pre> <p>Get free-fall event acceleration threshold. </p> <p>Parameters:</p> <ul> <li><code>threshold</code> New free-fall acceleration threshold value (LSB = 2mg) </li> </ul> <p>See also: getFreefallDetectionThreshold() </p> <p>See also: mpu_RA_FF_THR </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setfullscaleaccelrange","title":"function mpu_setFullScaleAccelRange","text":"<pre><code>void mpu_setFullScaleAccelRange (\nuint8_t range\n) </code></pre> <p>Set full-scale accelerometer range. </p> <p>Parameters:</p> <ul> <li><code>range</code> New full-scale accelerometer range setting </li> </ul> <p>See also: getFullScaleAccelRange() </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setfullscalegyrorange","title":"function mpu_setFullScaleGyroRange","text":"<pre><code>void mpu_setFullScaleGyroRange (\nuint8_t range\n) </code></pre> <p>Set full-scale gyroscope range. </p> <p>Parameters:</p> <ul> <li><code>range</code> New full-scale gyroscope range value </li> </ul> <p>See also: getFullScaleRange() </p> <p>See also: mpu_GYRO_FS_250 </p> <p>See also: mpu_RA_GYRO_CONFIG </p> <p>See also: mpu_GCONFIG_FS_SEL_BIT </p> <p>See also: mpu_GCONFIG_FS_SEL_LENGTH </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_seti2cbypassenabled","title":"function mpu_setI2CBypassEnabled","text":"<pre><code>void mpu_setI2CBypassEnabled (\nbool enabled\n) </code></pre> <p>Set I2C bypass enabled status. When this bit is equal to 1 and I2C_MST_EN (Register 106 bit[5]) is equal to 0, the host application processor will be able to directly access the auxiliary I2C bus of the MPU-60X0. When this bit is equal to 0, the host application processor will not be able to directly access the auxiliary I2C bus of the MPU-60X0 regardless of the state of I2C_MST_EN (Register 106 bit[5]). </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New I2C bypass enabled status </li> </ul> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_I2C_BYPASS_EN_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_seti2cmastermodeenabled","title":"function mpu_setI2CMasterModeEnabled","text":"<pre><code>void mpu_setI2CMasterModeEnabled (\nbool enabled\n) </code></pre> <p>Set I2C Master Mode enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New I2C Master Mode enabled status </li> </ul> <p>See also: getI2CMasterModeEnabled() </p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_I2C_MST_EN_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setintdmpenabled","title":"function mpu_setIntDMPEnabled","text":"<pre><code>void mpu_setIntDMPEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setintdatareadyenabled","title":"function mpu_setIntDataReadyEnabled","text":"<pre><code>void mpu_setIntDataReadyEnabled (\nbool enabled\n) </code></pre> <p>Set Data Ready interrupt enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntDataReadyEnabled() </p> <p>See also: mpu_RA_INT_CFG </p> <p>See also: mpu_INTERRUPT_DATA_RDY_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setintenabled","title":"function mpu_setIntEnabled","text":"<pre><code>void mpu_setIntEnabled (\nuint8_t enabled\n) </code></pre> <p>Set full interrupt enabled status. Full register byte for all interrupts, for quick reading. Each bit should be set 0 for disabled, 1 for enabled. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntFreefallEnabled() </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_FF_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setintfifobufferoverflowenabled","title":"function mpu_setIntFIFOBufferOverflowEnabled","text":"<pre><code>void mpu_setIntFIFOBufferOverflowEnabled (\nbool enabled\n) </code></pre> <p>Set FIFO Buffer Overflow interrupt enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntFIFOBufferOverflowEnabled() </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_FIFO_OFLOW_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setintfreefallenabled","title":"function mpu_setIntFreefallEnabled","text":"<pre><code>void mpu_setIntFreefallEnabled (\nbool enabled\n) </code></pre> <p>Set Free Fall interrupt enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntFreefallEnabled() </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_FF_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setinti2cmasterenabled","title":"function mpu_setIntI2CMasterEnabled","text":"<pre><code>void mpu_setIntI2CMasterEnabled (\nbool enabled\n) </code></pre> <p>Set I2C Master interrupt enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntI2CMasterEnabled() </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_I2C_MST_INT_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setintmotionenabled","title":"function mpu_setIntMotionEnabled","text":"<pre><code>void mpu_setIntMotionEnabled (\nbool enabled\n) </code></pre> <p>Set Motion Detection interrupt enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntMotionEnabled() </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_MOT_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setintpllreadyenabled","title":"function mpu_setIntPLLReadyEnabled","text":"<pre><code>void mpu_setIntPLLReadyEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setintzeromotionenabled","title":"function mpu_setIntZeroMotionEnabled","text":"<pre><code>void mpu_setIntZeroMotionEnabled (\nbool enabled\n) </code></pre> <p>Set Zero Motion Detection interrupt enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntZeroMotionEnabled() </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_ZMOT_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setinterruptdrive","title":"function mpu_setInterruptDrive","text":"<pre><code>void mpu_setInterruptDrive (\nbool drive\n) </code></pre> <p>Set interrupt drive mode. </p> <p>Parameters:</p> <ul> <li><code>drive</code> New interrupt drive mode (0=push-pull, 1=open-drain) </li> </ul> <p>See also: getInterruptDrive() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_INT_OPEN_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setinterruptlatch","title":"function mpu_setInterruptLatch","text":"<pre><code>void mpu_setInterruptLatch (\nbool latch\n) </code></pre> <p>Set interrupt latch mode. </p> <p>Parameters:</p> <ul> <li><code>latch</code> New latch mode (0=50us-pulse, 1=latch-until-int-cleared) </li> </ul> <p>See also: getInterruptLatch() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_LATCH_INT_EN_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setinterruptlatchclear","title":"function mpu_setInterruptLatchClear","text":"<pre><code>void mpu_setInterruptLatchClear (\nbool clear\n) </code></pre> <p>Set interrupt latch clear mode. </p> <p>Parameters:</p> <ul> <li><code>clear</code> New latch clear mode (0=status-read-only, 1=any-register-read) </li> </ul> <p>See also: getInterruptLatchClear() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_INT_RD_CLEAR_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setinterruptmode","title":"function mpu_setInterruptMode","text":"<pre><code>void mpu_setInterruptMode (\nbool mode\n) </code></pre> <p>Set interrupt logic level mode. </p> <p>Parameters:</p> <ul> <li><code>mode</code> New interrupt mode (0=active-high, 1=active-low) </li> </ul> <p>See also: getInterruptMode() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_INT_LEVEL_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setmasterclockspeed","title":"function mpu_setMasterClockSpeed","text":"<pre><code>void mpu_setMasterClockSpeed (\nuint8_t speed\n) </code></pre> <p>Set I2C master clock speed. @reparam speed Current I2C master clock speed </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setmemorybank","title":"function mpu_setMemoryBank","text":"<pre><code>void mpu_setMemoryBank (\nuint8_t bank,\nbool prefetchEnabled,\nbool userBank\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setmemorystartaddress","title":"function mpu_setMemoryStartAddress","text":"<pre><code>void mpu_setMemoryStartAddress (\nuint8_t address\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setmotiondetectioncounterdecrement","title":"function mpu_setMotionDetectionCounterDecrement","text":"<pre><code>void mpu_setMotionDetectionCounterDecrement (\nuint8_t decrement\n) </code></pre> <p>Set Motion detection counter decrement configuration. </p> <p>Parameters:</p> <ul> <li><code>decrement</code> New decrement configuration value </li> </ul> <p>See also: getMotionDetectionCounterDecrement() </p> <p>See also: mpu_RA_MOT_DETECT_CTRL </p> <p>See also: mpu_DETECT_MOT_COUNT_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setmotiondetectionduration","title":"function mpu_setMotionDetectionDuration","text":"<pre><code>void mpu_setMotionDetectionDuration (\nuint8_t duration\n) </code></pre> <p>Set motion detection event duration threshold. </p> <p>Parameters:</p> <ul> <li><code>duration</code> New motion detection duration threshold value (LSB = 1ms) </li> </ul> <p>See also: getMotionDetectionDuration() </p> <p>See also: mpu_RA_MOT_DUR </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setmotiondetectionthreshold","title":"function mpu_setMotionDetectionThreshold","text":"<pre><code>void mpu_setMotionDetectionThreshold (\nuint8_t threshold\n) </code></pre> <p>Set free-fall event acceleration threshold. </p> <p>Parameters:</p> <ul> <li><code>threshold</code> New motion detection acceleration threshold value (LSB = 2mg) </li> </ul> <p>See also: getMotionDetectionThreshold() </p> <p>See also: mpu_RA_MOT_THR </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setmultimasterenabled","title":"function mpu_setMultiMasterEnabled","text":"<pre><code>void mpu_setMultiMasterEnabled (\nbool enabled\n) </code></pre> <p>Set multi-master enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New multi-master enabled value </li> </ul> <p>See also: getMultiMasterEnabled() </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setotpbankvalid","title":"function mpu_setOTPBankValid","text":"<pre><code>void mpu_setOTPBankValid (\nbool enabled\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setrate","title":"function mpu_setRate","text":"<pre><code>void mpu_setRate (\nuint8_t rate\n) </code></pre> <p>Set gyroscope sample rate divider. </p> <p>Parameters:</p> <ul> <li><code>rate</code> New sample rate divider </li> </ul> <p>See also: getRate() </p> <p>See also: mpu_RA_SMPLRT_DIV </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setslave0fifoenabled","title":"function mpu_setSlave0FIFOEnabled","text":"<pre><code>void mpu_setSlave0FIFOEnabled (\nbool enabled\n) </code></pre> <p>Set Slave 0 FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New Slave 0 FIFO enabled value </li> </ul> <p>See also: getSlave0FIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setslave1fifoenabled","title":"function mpu_setSlave1FIFOEnabled","text":"<pre><code>void mpu_setSlave1FIFOEnabled (\nbool enabled\n) </code></pre> <p>Set Slave 1 FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New Slave 1 FIFO enabled value </li> </ul> <p>See also: getSlave1FIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setslave2fifoenabled","title":"function mpu_setSlave2FIFOEnabled","text":"<pre><code>void mpu_setSlave2FIFOEnabled (\nbool enabled\n) </code></pre> <p>Set Slave 2 FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New Slave 2 FIFO enabled value </li> </ul> <p>See also: getSlave2FIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setslave3fifoenabled","title":"function mpu_setSlave3FIFOEnabled","text":"<pre><code>void mpu_setSlave3FIFOEnabled (\nbool enabled\n) </code></pre> <p>Set Slave 3 FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New Slave 3 FIFO enabled value </li> </ul> <p>See also: getSlave3FIFOEnabled() </p> <p>See also: mpu_RA_MST_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setslave4address","title":"function mpu_setSlave4Address","text":"<pre><code>void mpu_setSlave4Address (\nuint8_t address\n) </code></pre> <p>Set the I2C address of Slave 4. </p> <p>Parameters:</p> <ul> <li><code>address</code> New address for Slave 4 </li> </ul> <p>See also: getSlave4Address() </p> <p>See also: mpu_RA_I2C_SLV4_ADDR </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setslave4enabled","title":"function mpu_setSlave4Enabled","text":"<pre><code>void mpu_setSlave4Enabled (\nbool enabled\n) </code></pre> <p>Set the enabled value for Slave 4. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New enabled value for Slave 4 </li> </ul> <p>See also: getSlave4Enabled() </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setslave4interruptenabled","title":"function mpu_setSlave4InterruptEnabled","text":"<pre><code>void mpu_setSlave4InterruptEnabled (\nbool enabled\n) </code></pre> <p>Set the enabled value for Slave 4 transaction interrupts. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New enabled value for Slave 4 transaction interrupts. </li> </ul> <p>See also: getSlave4InterruptEnabled() </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setslave4masterdelay","title":"function mpu_setSlave4MasterDelay","text":"<pre><code>void mpu_setSlave4MasterDelay (\nuint8_t delay\n) </code></pre> <p>Set Slave 4 master delay value. </p> <p>Parameters:</p> <ul> <li><code>delay</code> New Slave 4 master delay value </li> </ul> <p>See also: getSlave4MasterDelay() </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setslave4outputbyte","title":"function mpu_setSlave4OutputByte","text":"<pre><code>void mpu_setSlave4OutputByte (\nuint8_t data\n) </code></pre> <p>Set new byte to write to Slave 4. This register stores the data to be written into the Slave 4. If I2C_SLV4_RW is set 1 (set to read), this register has no effect. </p> <p>Parameters:</p> <ul> <li><code>data</code> New byte to write to Slave 4 </li> </ul> <p>See also: mpu_RA_I2C_SLV4_DO </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setslave4register","title":"function mpu_setSlave4Register","text":"<pre><code>void mpu_setSlave4Register (\nuint8_t reg\n) </code></pre> <p>Set the active internal register for Slave 4. </p> <p>Parameters:</p> <ul> <li><code>reg</code> New active register for Slave 4 </li> </ul> <p>See also: getSlave4Register() </p> <p>See also: mpu_RA_I2C_SLV4_REG </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setslave4writemode","title":"function mpu_setSlave4WriteMode","text":"<pre><code>void mpu_setSlave4WriteMode (\nbool mode\n) </code></pre> <p>Set write mode for the Slave 4. </p> <p>Parameters:</p> <ul> <li><code>mode</code> New write mode for Slave 4 (0 = register address + data, 1 = data only) </li> </ul> <p>See also: getSlave4WriteMode() </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setslaveaddress","title":"function mpu_setSlaveAddress","text":"<pre><code>void mpu_setSlaveAddress (\nuint8_t num,\nuint8_t address\n) </code></pre> <p>Set the I2C address of the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>address</code> New address for specified slave </li> </ul> <p>See also: getSlaveAddress() </p> <p>See also: mpu_RA_I2C_SLV0_ADDR </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setslavedatalength","title":"function mpu_setSlaveDataLength","text":"<pre><code>void mpu_setSlaveDataLength (\nuint8_t num,\nuint8_t length\n) </code></pre> <p>Set number of bytes to read for the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>length</code> Number of bytes to read for specified slave </li> </ul> <p>See also: getSlaveDataLength() </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setslavedelayenabled","title":"function mpu_setSlaveDelayEnabled","text":"<pre><code>void mpu_setSlaveDelayEnabled (\nuint8_t num,\nbool enabled\n) </code></pre> <p>Set slave delay enabled status. </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-4) </li> <li><code>enabled</code> New slave delay enabled status. </li> </ul> <p>See also: mpu_RA_I2C_MST_DELAY_CTRL </p> <p>See also: mpu_DELAYCTRL_I2C_SLV0_DLY_EN_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setslaveenabled","title":"function mpu_setSlaveEnabled","text":"<pre><code>void mpu_setSlaveEnabled (\nuint8_t num,\nbool enabled\n) </code></pre> <p>Set the enabled value for the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>enabled</code> New enabled value for specified slave </li> </ul> <p>See also: getSlaveEnabled() </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setslaveoutputbyte","title":"function mpu_setSlaveOutputByte","text":"<pre><code>void mpu_setSlaveOutputByte (\nuint8_t num,\nuint8_t data\n) </code></pre> <p>Write byte to Data Output container for specified slave. This register holds the output data written into Slave when Slave is set to write mode. For further information regarding Slave control, please refer to Registers 37 to 39 and immediately following. </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>data</code> Byte to write </li> </ul> <p>See also: mpu_RA_I2C_SLV0_DO </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setslavereadwritetransitionenabled","title":"function mpu_setSlaveReadWriteTransitionEnabled","text":"<pre><code>void mpu_setSlaveReadWriteTransitionEnabled (\nbool enabled\n) </code></pre> <p>Set slave read/write transition enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New slave read/write transition enabled value </li> </ul> <p>See also: getSlaveReadWriteTransitionEnabled() </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setslaveregister","title":"function mpu_setSlaveRegister","text":"<pre><code>void mpu_setSlaveRegister (\nuint8_t num,\nuint8_t reg\n) </code></pre> <p>Set the active internal register for the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>reg</code> New active register for specified slave </li> </ul> <p>See also: getSlaveRegister() </p> <p>See also: mpu_RA_I2C_SLV0_REG </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setslavewordbyteswap","title":"function mpu_setSlaveWordByteSwap","text":"<pre><code>void mpu_setSlaveWordByteSwap (\nuint8_t num,\nbool enabled\n) </code></pre> <p>Set word pair byte-swapping enabled for the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>enabled</code> New word pair byte-swapping enabled value for specified slave </li> </ul> <p>See also: getSlaveWordByteSwap() </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setslavewordgroupoffset","title":"function mpu_setSlaveWordGroupOffset","text":"<pre><code>void mpu_setSlaveWordGroupOffset (\nuint8_t num,\nbool enabled\n) </code></pre> <p>Set word pair grouping order offset for the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>enabled</code> New word pair grouping order offset for specified slave </li> </ul> <p>See also: getSlaveWordGroupOffset() </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setslavewritemode","title":"function mpu_setSlaveWriteMode","text":"<pre><code>void mpu_setSlaveWriteMode (\nuint8_t num,\nbool mode\n) </code></pre> <p>Set write mode for the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>mode</code> New write mode for specified slave (0 = register address + data, 1 = data only) </li> </ul> <p>See also: getSlaveWriteMode() </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setsleepenabled","title":"function mpu_setSleepEnabled","text":"<pre><code>void mpu_setSleepEnabled (\nbool enabled\n) </code></pre> <p>Set sleep mode status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New sleep mode enabled status </li> </ul> <p>See also: getSleepEnabled() </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_SLEEP_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setstandbyxaccelenabled","title":"function mpu_setStandbyXAccelEnabled","text":"<pre><code>void mpu_setStandbyXAccelEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setstandbyxgyroenabled","title":"function mpu_setStandbyXGyroEnabled","text":"<pre><code>void mpu_setStandbyXGyroEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setstandbyyaccelenabled","title":"function mpu_setStandbyYAccelEnabled","text":"<pre><code>void mpu_setStandbyYAccelEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setstandbyygyroenabled","title":"function mpu_setStandbyYGyroEnabled","text":"<pre><code>void mpu_setStandbyYGyroEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setstandbyzaccelenabled","title":"function mpu_setStandbyZAccelEnabled","text":"<pre><code>void mpu_setStandbyZAccelEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setstandbyzgyroenabled","title":"function mpu_setStandbyZGyroEnabled","text":"<pre><code>void mpu_setStandbyZGyroEnabled (\nbool enabled\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_settempfifoenabled","title":"function mpu_setTempFIFOEnabled","text":"<pre><code>void mpu_setTempFIFOEnabled (\nbool enabled\n) </code></pre> <p>Set temperature FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New temperature FIFO enabled value </li> </ul> <p>See also: getTempFIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_settempsensorenabled","title":"function mpu_setTempSensorEnabled","text":"<pre><code>void mpu_setTempSensorEnabled (\nbool enabled\n) </code></pre> <p>Set temperature sensor enabled status. Note: this register stores the disabled value, but for consistency with the rest of the code, the function is named and used with standard true/false values to indicate whether the sensor is enabled or disabled, respectively.</p> <p>Parameters:</p> <ul> <li><code>enabled</code> New temperature sensor enabled status </li> </ul> <p>See also: getTempSensorEnabled() </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_TEMP_DIS_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setwaitforexternalsensorenabled","title":"function mpu_setWaitForExternalSensorEnabled","text":"<pre><code>void mpu_setWaitForExternalSensorEnabled (\nbool enabled\n) </code></pre> <p>Set wait-for-external-sensor-data enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New wait-for-external-sensor-data enabled value </li> </ul> <p>See also: getWaitForExternalSensorEnabled() </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setwakecycleenabled","title":"function mpu_setWakeCycleEnabled","text":"<pre><code>void mpu_setWakeCycleEnabled (\nbool enabled\n) </code></pre> <p>Set wake cycle enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New sleep mode enabled status </li> </ul> <p>See also: getWakeCycleEnabled() </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_CYCLE_BIT </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setwakefrequency","title":"function mpu_setWakeFrequency","text":"<pre><code>void mpu_setWakeFrequency (\nuint8_t frequency\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setxacceloffset","title":"function mpu_setXAccelOffset","text":"<pre><code>void mpu_setXAccelOffset (\nint16_t offset\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setxfinegain","title":"function mpu_setXFineGain","text":"<pre><code>void mpu_setXFineGain (\nint8_t gain\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setxgyrofifoenabled","title":"function mpu_setXGyroFIFOEnabled","text":"<pre><code>void mpu_setXGyroFIFOEnabled (\nbool enabled\n) </code></pre> <p>Set gyroscope X-axis FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New gyroscope X-axis FIFO enabled value </li> </ul> <p>See also: getXGyroFIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setxgyrooffset","title":"function mpu_setXGyroOffset","text":"<pre><code>void mpu_setXGyroOffset (\nint16_t offset\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setxgyrooffsettc","title":"function mpu_setXGyroOffsetTC","text":"<pre><code>void mpu_setXGyroOffsetTC (\nint8_t offset\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setyacceloffset","title":"function mpu_setYAccelOffset","text":"<pre><code>void mpu_setYAccelOffset (\nint16_t offset\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setyfinegain","title":"function mpu_setYFineGain","text":"<pre><code>void mpu_setYFineGain (\nint8_t gain\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setygyrofifoenabled","title":"function mpu_setYGyroFIFOEnabled","text":"<pre><code>void mpu_setYGyroFIFOEnabled (\nbool enabled\n) </code></pre> <p>Set gyroscope Y-axis FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New gyroscope Y-axis FIFO enabled value </li> </ul> <p>See also: getYGyroFIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setygyrooffset","title":"function mpu_setYGyroOffset","text":"<pre><code>void mpu_setYGyroOffset (\nint16_t offset\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setygyrooffsettc","title":"function mpu_setYGyroOffsetTC","text":"<pre><code>void mpu_setYGyroOffsetTC (\nint8_t offset\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setzacceloffset","title":"function mpu_setZAccelOffset","text":"<pre><code>void mpu_setZAccelOffset (\nint16_t offset\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setzfinegain","title":"function mpu_setZFineGain","text":"<pre><code>void mpu_setZFineGain (\nint8_t gain\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setzgyrofifoenabled","title":"function mpu_setZGyroFIFOEnabled","text":"<pre><code>void mpu_setZGyroFIFOEnabled (\nbool enabled\n) </code></pre> <p>Set gyroscope Z-axis FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New gyroscope Z-axis FIFO enabled value </li> </ul> <p>See also: getZGyroFIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setzgyrooffset","title":"function mpu_setZGyroOffset","text":"<pre><code>void mpu_setZGyroOffset (\nint16_t offset\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setzgyrooffsettc","title":"function mpu_setZGyroOffsetTC","text":"<pre><code>void mpu_setZGyroOffsetTC (\nint8_t offset\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setzeromotiondetectionduration","title":"function mpu_setZeroMotionDetectionDuration","text":"<pre><code>void mpu_setZeroMotionDetectionDuration (\nuint8_t duration\n) </code></pre> <p>Set zero motion detection event duration threshold. </p> <p>Parameters:</p> <ul> <li><code>duration</code> New zero motion detection duration threshold value (LSB = 1ms) </li> </ul> <p>See also: getZeroMotionDetectionDuration() </p> <p>See also: mpu_RA_ZRMOT_DUR </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_setzeromotiondetectionthreshold","title":"function mpu_setZeroMotionDetectionThreshold","text":"<pre><code>void mpu_setZeroMotionDetectionThreshold (\nuint8_t threshold\n) </code></pre> <p>Set zero motion detection event acceleration threshold. </p> <p>Parameters:</p> <ul> <li><code>threshold</code> New zero motion detection acceleration threshold value (LSB = 2mg) </li> </ul> <p>See also: getZeroMotionDetectionThreshold() </p> <p>See also: mpu_RA_ZRMOT_THR </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_switchspienabled","title":"function mpu_switchSPIEnabled","text":"<pre><code>void mpu_switchSPIEnabled (\nbool enabled\n) </code></pre> <p>Switch from I2C to SPI mode (MPU-6000 only) If this is set, the primary SPI interface will be enabled in place of the disabled primary I2C interface. </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_testconnection","title":"function mpu_testConnection","text":"<pre><code>bool mpu_testConnection () </code></pre> <p>Verify the I2C connection. Make sure the device is connected and responds as expected. </p> <p>Returns:</p> <p>True if connection is valid, false otherwise </p>"},{"location":"apiStm/MpuController_8hpp/#function-mpu_writememorybyte","title":"function mpu_writeMemoryByte","text":"<pre><code>void mpu_writeMemoryByte (\nuint8_t data\n) </code></pre>"},{"location":"apiStm/MpuController_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/MpuController_8hpp/#define-mpu_accel_fifo_en_bit","title":"define mpu_ACCEL_FIFO_EN_BIT","text":"<pre><code>#define mpu_ACCEL_FIFO_EN_BIT 3\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_accel_fs_16","title":"define mpu_ACCEL_FS_16","text":"<pre><code>#define mpu_ACCEL_FS_16 0x03\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_accel_fs_2","title":"define mpu_ACCEL_FS_2","text":"<pre><code>#define mpu_ACCEL_FS_2 0x00\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_accel_fs_4","title":"define mpu_ACCEL_FS_4","text":"<pre><code>#define mpu_ACCEL_FS_4 0x01\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_accel_fs_8","title":"define mpu_ACCEL_FS_8","text":"<pre><code>#define mpu_ACCEL_FS_8 0x02\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_aconfig_accel_hpf_bit","title":"define mpu_ACONFIG_ACCEL_HPF_BIT","text":"<pre><code>#define mpu_ACONFIG_ACCEL_HPF_BIT 2\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_aconfig_accel_hpf_length","title":"define mpu_ACONFIG_ACCEL_HPF_LENGTH","text":"<pre><code>#define mpu_ACONFIG_ACCEL_HPF_LENGTH 3\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_aconfig_afs_sel_bit","title":"define mpu_ACONFIG_AFS_SEL_BIT","text":"<pre><code>#define mpu_ACONFIG_AFS_SEL_BIT 4\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_aconfig_afs_sel_length","title":"define mpu_ACONFIG_AFS_SEL_LENGTH","text":"<pre><code>#define mpu_ACONFIG_AFS_SEL_LENGTH 2\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_aconfig_xa_st_bit","title":"define mpu_ACONFIG_XA_ST_BIT","text":"<pre><code>#define mpu_ACONFIG_XA_ST_BIT 7\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_aconfig_ya_st_bit","title":"define mpu_ACONFIG_YA_ST_BIT","text":"<pre><code>#define mpu_ACONFIG_YA_ST_BIT 6\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_aconfig_za_st_bit","title":"define mpu_ACONFIG_ZA_ST_BIT","text":"<pre><code>#define mpu_ACONFIG_ZA_ST_BIT 5\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_address_ad0_high","title":"define mpu_ADDRESS_AD0_HIGH","text":"<pre><code>#define mpu_ADDRESS_AD0_HIGH 0x69\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_address_ad0_low","title":"define mpu_ADDRESS_AD0_LOW","text":"<pre><code>#define mpu_ADDRESS_AD0_LOW 0x68\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_banksel_cfg_user_bank_bit","title":"define mpu_BANKSEL_CFG_USER_BANK_BIT","text":"<pre><code>#define mpu_BANKSEL_CFG_USER_BANK_BIT 5\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_banksel_mem_sel_bit","title":"define mpu_BANKSEL_MEM_SEL_BIT","text":"<pre><code>#define mpu_BANKSEL_MEM_SEL_BIT 4\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_banksel_mem_sel_length","title":"define mpu_BANKSEL_MEM_SEL_LENGTH","text":"<pre><code>#define mpu_BANKSEL_MEM_SEL_LENGTH 5\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_banksel_prftch_en_bit","title":"define mpu_BANKSEL_PRFTCH_EN_BIT","text":"<pre><code>#define mpu_BANKSEL_PRFTCH_EN_BIT 6\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_cfg_dlpf_cfg_bit","title":"define mpu_CFG_DLPF_CFG_BIT","text":"<pre><code>#define mpu_CFG_DLPF_CFG_BIT 2\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_cfg_dlpf_cfg_length","title":"define mpu_CFG_DLPF_CFG_LENGTH","text":"<pre><code>#define mpu_CFG_DLPF_CFG_LENGTH 3\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_cfg_ext_sync_set_bit","title":"define mpu_CFG_EXT_SYNC_SET_BIT","text":"<pre><code>#define mpu_CFG_EXT_SYNC_SET_BIT 5\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_cfg_ext_sync_set_length","title":"define mpu_CFG_EXT_SYNC_SET_LENGTH","text":"<pre><code>#define mpu_CFG_EXT_SYNC_SET_LENGTH 3\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_clock_div_258","title":"define mpu_CLOCK_DIV_258","text":"<pre><code>#define mpu_CLOCK_DIV_258 0x8\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_clock_div_267","title":"define mpu_CLOCK_DIV_267","text":"<pre><code>#define mpu_CLOCK_DIV_267 0x7\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_clock_div_276","title":"define mpu_CLOCK_DIV_276","text":"<pre><code>#define mpu_CLOCK_DIV_276 0x6\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_clock_div_286","title":"define mpu_CLOCK_DIV_286","text":"<pre><code>#define mpu_CLOCK_DIV_286 0x5\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_clock_div_296","title":"define mpu_CLOCK_DIV_296","text":"<pre><code>#define mpu_CLOCK_DIV_296 0x4\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_clock_div_308","title":"define mpu_CLOCK_DIV_308","text":"<pre><code>#define mpu_CLOCK_DIV_308 0x3\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_clock_div_320","title":"define mpu_CLOCK_DIV_320","text":"<pre><code>#define mpu_CLOCK_DIV_320 0x2\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_clock_div_333","title":"define mpu_CLOCK_DIV_333","text":"<pre><code>#define mpu_CLOCK_DIV_333 0x1\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_clock_div_348","title":"define mpu_CLOCK_DIV_348","text":"<pre><code>#define mpu_CLOCK_DIV_348 0x0\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_clock_div_364","title":"define mpu_CLOCK_DIV_364","text":"<pre><code>#define mpu_CLOCK_DIV_364 0xF\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_clock_div_381","title":"define mpu_CLOCK_DIV_381","text":"<pre><code>#define mpu_CLOCK_DIV_381 0xE\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_clock_div_400","title":"define mpu_CLOCK_DIV_400","text":"<pre><code>#define mpu_CLOCK_DIV_400 0xD\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_clock_div_421","title":"define mpu_CLOCK_DIV_421","text":"<pre><code>#define mpu_CLOCK_DIV_421 0xC\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_clock_div_444","title":"define mpu_CLOCK_DIV_444","text":"<pre><code>#define mpu_CLOCK_DIV_444 0xB\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_clock_div_471","title":"define mpu_CLOCK_DIV_471","text":"<pre><code>#define mpu_CLOCK_DIV_471 0xA\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_clock_div_500","title":"define mpu_CLOCK_DIV_500","text":"<pre><code>#define mpu_CLOCK_DIV_500 0x9\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_clock_internal","title":"define mpu_CLOCK_INTERNAL","text":"<pre><code>#define mpu_CLOCK_INTERNAL 0x00\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_clock_keep_reset","title":"define mpu_CLOCK_KEEP_RESET","text":"<pre><code>#define mpu_CLOCK_KEEP_RESET 0x07\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_clock_pll_ext19m","title":"define mpu_CLOCK_PLL_EXT19M","text":"<pre><code>#define mpu_CLOCK_PLL_EXT19M 0x05\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_clock_pll_ext32k","title":"define mpu_CLOCK_PLL_EXT32K","text":"<pre><code>#define mpu_CLOCK_PLL_EXT32K 0x04\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_clock_pll_xgyro","title":"define mpu_CLOCK_PLL_XGYRO","text":"<pre><code>#define mpu_CLOCK_PLL_XGYRO 0x01\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_clock_pll_ygyro","title":"define mpu_CLOCK_PLL_YGYRO","text":"<pre><code>#define mpu_CLOCK_PLL_YGYRO 0x02\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_clock_pll_zgyro","title":"define mpu_CLOCK_PLL_ZGYRO","text":"<pre><code>#define mpu_CLOCK_PLL_ZGYRO 0x03\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_default_address","title":"define mpu_DEFAULT_ADDRESS","text":"<pre><code>#define mpu_DEFAULT_ADDRESS mpu_ADDRESS_AD0_LOW\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_delayctrl_delay_es_shadow_bit","title":"define mpu_DELAYCTRL_DELAY_ES_SHADOW_BIT","text":"<pre><code>#define mpu_DELAYCTRL_DELAY_ES_SHADOW_BIT 7\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_delayctrl_i2c_slv0_dly_en_bit","title":"define mpu_DELAYCTRL_I2C_SLV0_DLY_EN_BIT","text":"<pre><code>#define mpu_DELAYCTRL_I2C_SLV0_DLY_EN_BIT 0\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_delayctrl_i2c_slv1_dly_en_bit","title":"define mpu_DELAYCTRL_I2C_SLV1_DLY_EN_BIT","text":"<pre><code>#define mpu_DELAYCTRL_I2C_SLV1_DLY_EN_BIT 1\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_delayctrl_i2c_slv2_dly_en_bit","title":"define mpu_DELAYCTRL_I2C_SLV2_DLY_EN_BIT","text":"<pre><code>#define mpu_DELAYCTRL_I2C_SLV2_DLY_EN_BIT 2\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_delayctrl_i2c_slv3_dly_en_bit","title":"define mpu_DELAYCTRL_I2C_SLV3_DLY_EN_BIT","text":"<pre><code>#define mpu_DELAYCTRL_I2C_SLV3_DLY_EN_BIT 3\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_delayctrl_i2c_slv4_dly_en_bit","title":"define mpu_DELAYCTRL_I2C_SLV4_DLY_EN_BIT","text":"<pre><code>#define mpu_DELAYCTRL_I2C_SLV4_DLY_EN_BIT 4\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_detect_accel_on_delay_bit","title":"define mpu_DETECT_ACCEL_ON_DELAY_BIT","text":"<pre><code>#define mpu_DETECT_ACCEL_ON_DELAY_BIT 5\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_detect_accel_on_delay_length","title":"define mpu_DETECT_ACCEL_ON_DELAY_LENGTH","text":"<pre><code>#define mpu_DETECT_ACCEL_ON_DELAY_LENGTH 2\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_detect_decrement_1","title":"define mpu_DETECT_DECREMENT_1","text":"<pre><code>#define mpu_DETECT_DECREMENT_1 0x1\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_detect_decrement_2","title":"define mpu_DETECT_DECREMENT_2","text":"<pre><code>#define mpu_DETECT_DECREMENT_2 0x2\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_detect_decrement_4","title":"define mpu_DETECT_DECREMENT_4","text":"<pre><code>#define mpu_DETECT_DECREMENT_4 0x3\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_detect_decrement_reset","title":"define mpu_DETECT_DECREMENT_RESET","text":"<pre><code>#define mpu_DETECT_DECREMENT_RESET 0x0\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_detect_ff_count_bit","title":"define mpu_DETECT_FF_COUNT_BIT","text":"<pre><code>#define mpu_DETECT_FF_COUNT_BIT 3\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_detect_ff_count_length","title":"define mpu_DETECT_FF_COUNT_LENGTH","text":"<pre><code>#define mpu_DETECT_FF_COUNT_LENGTH 2\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_detect_mot_count_bit","title":"define mpu_DETECT_MOT_COUNT_BIT","text":"<pre><code>#define mpu_DETECT_MOT_COUNT_BIT 1\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_detect_mot_count_length","title":"define mpu_DETECT_MOT_COUNT_LENGTH","text":"<pre><code>#define mpu_DETECT_MOT_COUNT_LENGTH 2\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_dhpf_0p63","title":"define mpu_DHPF_0P63","text":"<pre><code>#define mpu_DHPF_0P63 0x04\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_dhpf_1p25","title":"define mpu_DHPF_1P25","text":"<pre><code>#define mpu_DHPF_1P25 0x03\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_dhpf_2p5","title":"define mpu_DHPF_2P5","text":"<pre><code>#define mpu_DHPF_2P5 0x02\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_dhpf_5","title":"define mpu_DHPF_5","text":"<pre><code>#define mpu_DHPF_5 0x01\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_dhpf_hold","title":"define mpu_DHPF_HOLD","text":"<pre><code>#define mpu_DHPF_HOLD 0x07\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_dhpf_reset","title":"define mpu_DHPF_RESET","text":"<pre><code>#define mpu_DHPF_RESET 0x00\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_dlpf_bw_10","title":"define mpu_DLPF_BW_10","text":"<pre><code>#define mpu_DLPF_BW_10 0x05\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_dlpf_bw_188","title":"define mpu_DLPF_BW_188","text":"<pre><code>#define mpu_DLPF_BW_188 0x01\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_dlpf_bw_20","title":"define mpu_DLPF_BW_20","text":"<pre><code>#define mpu_DLPF_BW_20 0x04\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_dlpf_bw_256","title":"define mpu_DLPF_BW_256","text":"<pre><code>#define mpu_DLPF_BW_256 0x00\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_dlpf_bw_42","title":"define mpu_DLPF_BW_42","text":"<pre><code>#define mpu_DLPF_BW_42 0x03\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_dlpf_bw_5","title":"define mpu_DLPF_BW_5","text":"<pre><code>#define mpu_DLPF_BW_5 0x06\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_dlpf_bw_98","title":"define mpu_DLPF_BW_98","text":"<pre><code>#define mpu_DLPF_BW_98 0x02\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_dmpint_0_bit","title":"define mpu_DMPINT_0_BIT","text":"<pre><code>#define mpu_DMPINT_0_BIT 0\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_dmpint_1_bit","title":"define mpu_DMPINT_1_BIT","text":"<pre><code>#define mpu_DMPINT_1_BIT 1\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_dmpint_2_bit","title":"define mpu_DMPINT_2_BIT","text":"<pre><code>#define mpu_DMPINT_2_BIT 2\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_dmpint_3_bit","title":"define mpu_DMPINT_3_BIT","text":"<pre><code>#define mpu_DMPINT_3_BIT 3\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_dmpint_4_bit","title":"define mpu_DMPINT_4_BIT","text":"<pre><code>#define mpu_DMPINT_4_BIT 4\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_dmpint_5_bit","title":"define mpu_DMPINT_5_BIT","text":"<pre><code>#define mpu_DMPINT_5_BIT 5\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_dmp_memory_banks","title":"define mpu_DMP_MEMORY_BANKS","text":"<pre><code>#define mpu_DMP_MEMORY_BANKS 8\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_dmp_memory_bank_size","title":"define mpu_DMP_MEMORY_BANK_SIZE","text":"<pre><code>#define mpu_DMP_MEMORY_BANK_SIZE 256\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_dmp_memory_chunk_size","title":"define mpu_DMP_MEMORY_CHUNK_SIZE","text":"<pre><code>#define mpu_DMP_MEMORY_CHUNK_SIZE 16\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ext_sync_accel_xout_l","title":"define mpu_EXT_SYNC_ACCEL_XOUT_L","text":"<pre><code>#define mpu_EXT_SYNC_ACCEL_XOUT_L 0x5\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ext_sync_accel_yout_l","title":"define mpu_EXT_SYNC_ACCEL_YOUT_L","text":"<pre><code>#define mpu_EXT_SYNC_ACCEL_YOUT_L 0x6\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ext_sync_accel_zout_l","title":"define mpu_EXT_SYNC_ACCEL_ZOUT_L","text":"<pre><code>#define mpu_EXT_SYNC_ACCEL_ZOUT_L 0x7\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ext_sync_disabled","title":"define mpu_EXT_SYNC_DISABLED","text":"<pre><code>#define mpu_EXT_SYNC_DISABLED 0x0\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ext_sync_gyro_xout_l","title":"define mpu_EXT_SYNC_GYRO_XOUT_L","text":"<pre><code>#define mpu_EXT_SYNC_GYRO_XOUT_L 0x2\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ext_sync_gyro_yout_l","title":"define mpu_EXT_SYNC_GYRO_YOUT_L","text":"<pre><code>#define mpu_EXT_SYNC_GYRO_YOUT_L 0x3\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ext_sync_gyro_zout_l","title":"define mpu_EXT_SYNC_GYRO_ZOUT_L","text":"<pre><code>#define mpu_EXT_SYNC_GYRO_ZOUT_L 0x4\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ext_sync_temp_out_l","title":"define mpu_EXT_SYNC_TEMP_OUT_L","text":"<pre><code>#define mpu_EXT_SYNC_TEMP_OUT_L 0x1\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_gconfig_fs_sel_bit","title":"define mpu_GCONFIG_FS_SEL_BIT","text":"<pre><code>#define mpu_GCONFIG_FS_SEL_BIT 4\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_gconfig_fs_sel_length","title":"define mpu_GCONFIG_FS_SEL_LENGTH","text":"<pre><code>#define mpu_GCONFIG_FS_SEL_LENGTH 2\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_gyro_fs_1000","title":"define mpu_GYRO_FS_1000","text":"<pre><code>#define mpu_GYRO_FS_1000 0x02\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_gyro_fs_2000","title":"define mpu_GYRO_FS_2000","text":"<pre><code>#define mpu_GYRO_FS_2000 0x03\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_gyro_fs_250","title":"define mpu_GYRO_FS_250","text":"<pre><code>#define mpu_GYRO_FS_250 0x00\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_gyro_fs_500","title":"define mpu_GYRO_FS_500","text":"<pre><code>#define mpu_GYRO_FS_500 0x01\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_i2c_mst_clk_bit","title":"define mpu_I2C_MST_CLK_BIT","text":"<pre><code>#define mpu_I2C_MST_CLK_BIT 3\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_i2c_mst_clk_length","title":"define mpu_I2C_MST_CLK_LENGTH","text":"<pre><code>#define mpu_I2C_MST_CLK_LENGTH 4\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_i2c_mst_p_nsr_bit","title":"define mpu_I2C_MST_P_NSR_BIT","text":"<pre><code>#define mpu_I2C_MST_P_NSR_BIT 4\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_i2c_slv4_addr_bit","title":"define mpu_I2C_SLV4_ADDR_BIT","text":"<pre><code>#define mpu_I2C_SLV4_ADDR_BIT 6\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_i2c_slv4_addr_length","title":"define mpu_I2C_SLV4_ADDR_LENGTH","text":"<pre><code>#define mpu_I2C_SLV4_ADDR_LENGTH 7\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_i2c_slv4_en_bit","title":"define mpu_I2C_SLV4_EN_BIT","text":"<pre><code>#define mpu_I2C_SLV4_EN_BIT 7\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_i2c_slv4_int_en_bit","title":"define mpu_I2C_SLV4_INT_EN_BIT","text":"<pre><code>#define mpu_I2C_SLV4_INT_EN_BIT 6\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_i2c_slv4_mst_dly_bit","title":"define mpu_I2C_SLV4_MST_DLY_BIT","text":"<pre><code>#define mpu_I2C_SLV4_MST_DLY_BIT 4\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_i2c_slv4_mst_dly_length","title":"define mpu_I2C_SLV4_MST_DLY_LENGTH","text":"<pre><code>#define mpu_I2C_SLV4_MST_DLY_LENGTH 5\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_i2c_slv4_reg_dis_bit","title":"define mpu_I2C_SLV4_REG_DIS_BIT","text":"<pre><code>#define mpu_I2C_SLV4_REG_DIS_BIT 5\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_i2c_slv4_rw_bit","title":"define mpu_I2C_SLV4_RW_BIT","text":"<pre><code>#define mpu_I2C_SLV4_RW_BIT 7\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_i2c_slv_addr_bit","title":"define mpu_I2C_SLV_ADDR_BIT","text":"<pre><code>#define mpu_I2C_SLV_ADDR_BIT 6\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_i2c_slv_addr_length","title":"define mpu_I2C_SLV_ADDR_LENGTH","text":"<pre><code>#define mpu_I2C_SLV_ADDR_LENGTH 7\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_i2c_slv_byte_sw_bit","title":"define mpu_I2C_SLV_BYTE_SW_BIT","text":"<pre><code>#define mpu_I2C_SLV_BYTE_SW_BIT 6\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_i2c_slv_en_bit","title":"define mpu_I2C_SLV_EN_BIT","text":"<pre><code>#define mpu_I2C_SLV_EN_BIT 7\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_i2c_slv_grp_bit","title":"define mpu_I2C_SLV_GRP_BIT","text":"<pre><code>#define mpu_I2C_SLV_GRP_BIT 4\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_i2c_slv_len_bit","title":"define mpu_I2C_SLV_LEN_BIT","text":"<pre><code>#define mpu_I2C_SLV_LEN_BIT 3\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_i2c_slv_len_length","title":"define mpu_I2C_SLV_LEN_LENGTH","text":"<pre><code>#define mpu_I2C_SLV_LEN_LENGTH 4\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_i2c_slv_reg_dis_bit","title":"define mpu_I2C_SLV_REG_DIS_BIT","text":"<pre><code>#define mpu_I2C_SLV_REG_DIS_BIT 5\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_i2c_slv_rw_bit","title":"define mpu_I2C_SLV_RW_BIT","text":"<pre><code>#define mpu_I2C_SLV_RW_BIT 7\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_intcfg_clkout_en_bit","title":"define mpu_INTCFG_CLKOUT_EN_BIT","text":"<pre><code>#define mpu_INTCFG_CLKOUT_EN_BIT 0\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_intcfg_fsync_int_en_bit","title":"define mpu_INTCFG_FSYNC_INT_EN_BIT","text":"<pre><code>#define mpu_INTCFG_FSYNC_INT_EN_BIT 2\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_intcfg_fsync_int_level_bit","title":"define mpu_INTCFG_FSYNC_INT_LEVEL_BIT","text":"<pre><code>#define mpu_INTCFG_FSYNC_INT_LEVEL_BIT 3\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_intcfg_i2c_bypass_en_bit","title":"define mpu_INTCFG_I2C_BYPASS_EN_BIT","text":"<pre><code>#define mpu_INTCFG_I2C_BYPASS_EN_BIT 1\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_intcfg_int_level_bit","title":"define mpu_INTCFG_INT_LEVEL_BIT","text":"<pre><code>#define mpu_INTCFG_INT_LEVEL_BIT 7\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_intcfg_int_open_bit","title":"define mpu_INTCFG_INT_OPEN_BIT","text":"<pre><code>#define mpu_INTCFG_INT_OPEN_BIT 6\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_intcfg_int_rd_clear_bit","title":"define mpu_INTCFG_INT_RD_CLEAR_BIT","text":"<pre><code>#define mpu_INTCFG_INT_RD_CLEAR_BIT 4\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_intcfg_latch_int_en_bit","title":"define mpu_INTCFG_LATCH_INT_EN_BIT","text":"<pre><code>#define mpu_INTCFG_LATCH_INT_EN_BIT 5\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_intclear_anyread","title":"define mpu_INTCLEAR_ANYREAD","text":"<pre><code>#define mpu_INTCLEAR_ANYREAD 0x01\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_intclear_statusread","title":"define mpu_INTCLEAR_STATUSREAD","text":"<pre><code>#define mpu_INTCLEAR_STATUSREAD 0x00\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_intdrv_opendrain","title":"define mpu_INTDRV_OPENDRAIN","text":"<pre><code>#define mpu_INTDRV_OPENDRAIN 0x01\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_intdrv_pushpull","title":"define mpu_INTDRV_PUSHPULL","text":"<pre><code>#define mpu_INTDRV_PUSHPULL 0x00\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_interrupt_data_rdy_bit","title":"define mpu_INTERRUPT_DATA_RDY_BIT","text":"<pre><code>#define mpu_INTERRUPT_DATA_RDY_BIT 0\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_interrupt_dmp_int_bit","title":"define mpu_INTERRUPT_DMP_INT_BIT","text":"<pre><code>#define mpu_INTERRUPT_DMP_INT_BIT 1\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_interrupt_ff_bit","title":"define mpu_INTERRUPT_FF_BIT","text":"<pre><code>#define mpu_INTERRUPT_FF_BIT 7\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_interrupt_fifo_oflow_bit","title":"define mpu_INTERRUPT_FIFO_OFLOW_BIT","text":"<pre><code>#define mpu_INTERRUPT_FIFO_OFLOW_BIT 4\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_interrupt_i2c_mst_int_bit","title":"define mpu_INTERRUPT_I2C_MST_INT_BIT","text":"<pre><code>#define mpu_INTERRUPT_I2C_MST_INT_BIT 3\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_interrupt_mot_bit","title":"define mpu_INTERRUPT_MOT_BIT","text":"<pre><code>#define mpu_INTERRUPT_MOT_BIT 6\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_interrupt_pll_rdy_int_bit","title":"define mpu_INTERRUPT_PLL_RDY_INT_BIT","text":"<pre><code>#define mpu_INTERRUPT_PLL_RDY_INT_BIT 2\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_interrupt_zmot_bit","title":"define mpu_INTERRUPT_ZMOT_BIT","text":"<pre><code>#define mpu_INTERRUPT_ZMOT_BIT 5\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_intlatch_50uspulse","title":"define mpu_INTLATCH_50USPULSE","text":"<pre><code>#define mpu_INTLATCH_50USPULSE 0x00\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_intlatch_waitclear","title":"define mpu_INTLATCH_WAITCLEAR","text":"<pre><code>#define mpu_INTLATCH_WAITCLEAR 0x01\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_intmode_activehigh","title":"define mpu_INTMODE_ACTIVEHIGH","text":"<pre><code>#define mpu_INTMODE_ACTIVEHIGH 0x00\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_intmode_activelow","title":"define mpu_INTMODE_ACTIVELOW","text":"<pre><code>#define mpu_INTMODE_ACTIVELOW 0x01\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_motion_mot_xneg_bit","title":"define mpu_MOTION_MOT_XNEG_BIT","text":"<pre><code>#define mpu_MOTION_MOT_XNEG_BIT 7\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_motion_mot_xpos_bit","title":"define mpu_MOTION_MOT_XPOS_BIT","text":"<pre><code>#define mpu_MOTION_MOT_XPOS_BIT 6\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_motion_mot_yneg_bit","title":"define mpu_MOTION_MOT_YNEG_BIT","text":"<pre><code>#define mpu_MOTION_MOT_YNEG_BIT 5\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_motion_mot_ypos_bit","title":"define mpu_MOTION_MOT_YPOS_BIT","text":"<pre><code>#define mpu_MOTION_MOT_YPOS_BIT 4\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_motion_mot_zneg_bit","title":"define mpu_MOTION_MOT_ZNEG_BIT","text":"<pre><code>#define mpu_MOTION_MOT_ZNEG_BIT 3\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_motion_mot_zpos_bit","title":"define mpu_MOTION_MOT_ZPOS_BIT","text":"<pre><code>#define mpu_MOTION_MOT_ZPOS_BIT 2\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_motion_mot_zrmot_bit","title":"define mpu_MOTION_MOT_ZRMOT_BIT","text":"<pre><code>#define mpu_MOTION_MOT_ZRMOT_BIT 0\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_mst_i2c_lost_arb_bit","title":"define mpu_MST_I2C_LOST_ARB_BIT","text":"<pre><code>#define mpu_MST_I2C_LOST_ARB_BIT 5\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_mst_i2c_slv0_nack_bit","title":"define mpu_MST_I2C_SLV0_NACK_BIT","text":"<pre><code>#define mpu_MST_I2C_SLV0_NACK_BIT 0\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_mst_i2c_slv1_nack_bit","title":"define mpu_MST_I2C_SLV1_NACK_BIT","text":"<pre><code>#define mpu_MST_I2C_SLV1_NACK_BIT 1\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_mst_i2c_slv2_nack_bit","title":"define mpu_MST_I2C_SLV2_NACK_BIT","text":"<pre><code>#define mpu_MST_I2C_SLV2_NACK_BIT 2\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_mst_i2c_slv3_nack_bit","title":"define mpu_MST_I2C_SLV3_NACK_BIT","text":"<pre><code>#define mpu_MST_I2C_SLV3_NACK_BIT 3\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_mst_i2c_slv4_done_bit","title":"define mpu_MST_I2C_SLV4_DONE_BIT","text":"<pre><code>#define mpu_MST_I2C_SLV4_DONE_BIT 6\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_mst_i2c_slv4_nack_bit","title":"define mpu_MST_I2C_SLV4_NACK_BIT","text":"<pre><code>#define mpu_MST_I2C_SLV4_NACK_BIT 4\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_mst_pass_through_bit","title":"define mpu_MST_PASS_THROUGH_BIT","text":"<pre><code>#define mpu_MST_PASS_THROUGH_BIT 7\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_mult_mst_en_bit","title":"define mpu_MULT_MST_EN_BIT","text":"<pre><code>#define mpu_MULT_MST_EN_BIT 7\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_pathreset_accel_reset_bit","title":"define mpu_PATHRESET_ACCEL_RESET_BIT","text":"<pre><code>#define mpu_PATHRESET_ACCEL_RESET_BIT 1\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_pathreset_gyro_reset_bit","title":"define mpu_PATHRESET_GYRO_RESET_BIT","text":"<pre><code>#define mpu_PATHRESET_GYRO_RESET_BIT 2\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_pathreset_temp_reset_bit","title":"define mpu_PATHRESET_TEMP_RESET_BIT","text":"<pre><code>#define mpu_PATHRESET_TEMP_RESET_BIT 0\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_pwr1_clksel_bit","title":"define mpu_PWR1_CLKSEL_BIT","text":"<pre><code>#define mpu_PWR1_CLKSEL_BIT 2\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_pwr1_clksel_length","title":"define mpu_PWR1_CLKSEL_LENGTH","text":"<pre><code>#define mpu_PWR1_CLKSEL_LENGTH 3\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_pwr1_cycle_bit","title":"define mpu_PWR1_CYCLE_BIT","text":"<pre><code>#define mpu_PWR1_CYCLE_BIT 5\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_pwr1_device_reset_bit","title":"define mpu_PWR1_DEVICE_RESET_BIT","text":"<pre><code>#define mpu_PWR1_DEVICE_RESET_BIT 7\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_pwr1_sleep_bit","title":"define mpu_PWR1_SLEEP_BIT","text":"<pre><code>#define mpu_PWR1_SLEEP_BIT 6\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_pwr1_temp_dis_bit","title":"define mpu_PWR1_TEMP_DIS_BIT","text":"<pre><code>#define mpu_PWR1_TEMP_DIS_BIT 3\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_pwr2_lp_wake_ctrl_bit","title":"define mpu_PWR2_LP_WAKE_CTRL_BIT","text":"<pre><code>#define mpu_PWR2_LP_WAKE_CTRL_BIT 7\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_pwr2_lp_wake_ctrl_length","title":"define mpu_PWR2_LP_WAKE_CTRL_LENGTH","text":"<pre><code>#define mpu_PWR2_LP_WAKE_CTRL_LENGTH 2\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_pwr2_stby_xa_bit","title":"define mpu_PWR2_STBY_XA_BIT","text":"<pre><code>#define mpu_PWR2_STBY_XA_BIT 5\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_pwr2_stby_xg_bit","title":"define mpu_PWR2_STBY_XG_BIT","text":"<pre><code>#define mpu_PWR2_STBY_XG_BIT 2\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_pwr2_stby_ya_bit","title":"define mpu_PWR2_STBY_YA_BIT","text":"<pre><code>#define mpu_PWR2_STBY_YA_BIT 4\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_pwr2_stby_yg_bit","title":"define mpu_PWR2_STBY_YG_BIT","text":"<pre><code>#define mpu_PWR2_STBY_YG_BIT 1\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_pwr2_stby_za_bit","title":"define mpu_PWR2_STBY_ZA_BIT","text":"<pre><code>#define mpu_PWR2_STBY_ZA_BIT 3\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_pwr2_stby_zg_bit","title":"define mpu_PWR2_STBY_ZG_BIT","text":"<pre><code>#define mpu_PWR2_STBY_ZG_BIT 0\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_accel_config","title":"define mpu_RA_ACCEL_CONFIG","text":"<pre><code>#define mpu_RA_ACCEL_CONFIG 0x1C\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_accel_xout_h","title":"define mpu_RA_ACCEL_XOUT_H","text":"<pre><code>#define mpu_RA_ACCEL_XOUT_H 0x3B\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_accel_xout_l","title":"define mpu_RA_ACCEL_XOUT_L","text":"<pre><code>#define mpu_RA_ACCEL_XOUT_L 0x3C\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_accel_yout_h","title":"define mpu_RA_ACCEL_YOUT_H","text":"<pre><code>#define mpu_RA_ACCEL_YOUT_H 0x3D\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_accel_yout_l","title":"define mpu_RA_ACCEL_YOUT_L","text":"<pre><code>#define mpu_RA_ACCEL_YOUT_L 0x3E\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_accel_zout_h","title":"define mpu_RA_ACCEL_ZOUT_H","text":"<pre><code>#define mpu_RA_ACCEL_ZOUT_H 0x3F\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_accel_zout_l","title":"define mpu_RA_ACCEL_ZOUT_L","text":"<pre><code>#define mpu_RA_ACCEL_ZOUT_L 0x40\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_bank_sel","title":"define mpu_RA_BANK_SEL","text":"<pre><code>#define mpu_RA_BANK_SEL 0x6D\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_config","title":"define mpu_RA_CONFIG","text":"<pre><code>#define mpu_RA_CONFIG 0x1A\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_dmp_cfg_1","title":"define mpu_RA_DMP_CFG_1","text":"<pre><code>#define mpu_RA_DMP_CFG_1 0x70\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_dmp_cfg_2","title":"define mpu_RA_DMP_CFG_2","text":"<pre><code>#define mpu_RA_DMP_CFG_2 0x71\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_dmp_int_status","title":"define mpu_RA_DMP_INT_STATUS","text":"<pre><code>#define mpu_RA_DMP_INT_STATUS 0x39\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_00","title":"define mpu_RA_EXT_SENS_DATA_00","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_00 0x49\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_01","title":"define mpu_RA_EXT_SENS_DATA_01","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_01 0x4A\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_02","title":"define mpu_RA_EXT_SENS_DATA_02","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_02 0x4B\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_03","title":"define mpu_RA_EXT_SENS_DATA_03","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_03 0x4C\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_04","title":"define mpu_RA_EXT_SENS_DATA_04","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_04 0x4D\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_05","title":"define mpu_RA_EXT_SENS_DATA_05","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_05 0x4E\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_06","title":"define mpu_RA_EXT_SENS_DATA_06","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_06 0x4F\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_07","title":"define mpu_RA_EXT_SENS_DATA_07","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_07 0x50\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_08","title":"define mpu_RA_EXT_SENS_DATA_08","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_08 0x51\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_09","title":"define mpu_RA_EXT_SENS_DATA_09","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_09 0x52\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_10","title":"define mpu_RA_EXT_SENS_DATA_10","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_10 0x53\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_11","title":"define mpu_RA_EXT_SENS_DATA_11","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_11 0x54\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_12","title":"define mpu_RA_EXT_SENS_DATA_12","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_12 0x55\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_13","title":"define mpu_RA_EXT_SENS_DATA_13","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_13 0x56\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_14","title":"define mpu_RA_EXT_SENS_DATA_14","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_14 0x57\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_15","title":"define mpu_RA_EXT_SENS_DATA_15","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_15 0x58\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_16","title":"define mpu_RA_EXT_SENS_DATA_16","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_16 0x59\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_17","title":"define mpu_RA_EXT_SENS_DATA_17","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_17 0x5A\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_18","title":"define mpu_RA_EXT_SENS_DATA_18","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_18 0x5B\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_19","title":"define mpu_RA_EXT_SENS_DATA_19","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_19 0x5C\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_20","title":"define mpu_RA_EXT_SENS_DATA_20","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_20 0x5D\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_21","title":"define mpu_RA_EXT_SENS_DATA_21","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_21 0x5E\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_22","title":"define mpu_RA_EXT_SENS_DATA_22","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_22 0x5F\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ext_sens_data_23","title":"define mpu_RA_EXT_SENS_DATA_23","text":"<pre><code>#define mpu_RA_EXT_SENS_DATA_23 0x60\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ff_dur","title":"define mpu_RA_FF_DUR","text":"<pre><code>#define mpu_RA_FF_DUR 0x1E\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ff_thr","title":"define mpu_RA_FF_THR","text":"<pre><code>#define mpu_RA_FF_THR 0x1D\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_fifo_counth","title":"define mpu_RA_FIFO_COUNTH","text":"<pre><code>#define mpu_RA_FIFO_COUNTH 0x72\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_fifo_countl","title":"define mpu_RA_FIFO_COUNTL","text":"<pre><code>#define mpu_RA_FIFO_COUNTL 0x73\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_fifo_en","title":"define mpu_RA_FIFO_EN","text":"<pre><code>#define mpu_RA_FIFO_EN 0x23\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_fifo_r_w","title":"define mpu_RA_FIFO_R_W","text":"<pre><code>#define mpu_RA_FIFO_R_W 0x74\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_gyro_config","title":"define mpu_RA_GYRO_CONFIG","text":"<pre><code>#define mpu_RA_GYRO_CONFIG 0x1B\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_gyro_xout_h","title":"define mpu_RA_GYRO_XOUT_H","text":"<pre><code>#define mpu_RA_GYRO_XOUT_H 0x43\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_gyro_xout_l","title":"define mpu_RA_GYRO_XOUT_L","text":"<pre><code>#define mpu_RA_GYRO_XOUT_L 0x44\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_gyro_yout_h","title":"define mpu_RA_GYRO_YOUT_H","text":"<pre><code>#define mpu_RA_GYRO_YOUT_H 0x45\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_gyro_yout_l","title":"define mpu_RA_GYRO_YOUT_L","text":"<pre><code>#define mpu_RA_GYRO_YOUT_L 0x46\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_gyro_zout_h","title":"define mpu_RA_GYRO_ZOUT_H","text":"<pre><code>#define mpu_RA_GYRO_ZOUT_H 0x47\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_gyro_zout_l","title":"define mpu_RA_GYRO_ZOUT_L","text":"<pre><code>#define mpu_RA_GYRO_ZOUT_L 0x48\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_i2c_mst_ctrl","title":"define mpu_RA_I2C_MST_CTRL","text":"<pre><code>#define mpu_RA_I2C_MST_CTRL 0x24\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_i2c_mst_delay_ctrl","title":"define mpu_RA_I2C_MST_DELAY_CTRL","text":"<pre><code>#define mpu_RA_I2C_MST_DELAY_CTRL 0x67\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_i2c_mst_status","title":"define mpu_RA_I2C_MST_STATUS","text":"<pre><code>#define mpu_RA_I2C_MST_STATUS 0x36\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_i2c_slv0_addr","title":"define mpu_RA_I2C_SLV0_ADDR","text":"<pre><code>#define mpu_RA_I2C_SLV0_ADDR 0x25\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_i2c_slv0_ctrl","title":"define mpu_RA_I2C_SLV0_CTRL","text":"<pre><code>#define mpu_RA_I2C_SLV0_CTRL 0x27\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_i2c_slv0_do","title":"define mpu_RA_I2C_SLV0_DO","text":"<pre><code>#define mpu_RA_I2C_SLV0_DO 0x63\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_i2c_slv0_reg","title":"define mpu_RA_I2C_SLV0_REG","text":"<pre><code>#define mpu_RA_I2C_SLV0_REG 0x26\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_i2c_slv1_addr","title":"define mpu_RA_I2C_SLV1_ADDR","text":"<pre><code>#define mpu_RA_I2C_SLV1_ADDR 0x28\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_i2c_slv1_ctrl","title":"define mpu_RA_I2C_SLV1_CTRL","text":"<pre><code>#define mpu_RA_I2C_SLV1_CTRL 0x2A\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_i2c_slv1_do","title":"define mpu_RA_I2C_SLV1_DO","text":"<pre><code>#define mpu_RA_I2C_SLV1_DO 0x64\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_i2c_slv1_reg","title":"define mpu_RA_I2C_SLV1_REG","text":"<pre><code>#define mpu_RA_I2C_SLV1_REG 0x29\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_i2c_slv2_addr","title":"define mpu_RA_I2C_SLV2_ADDR","text":"<pre><code>#define mpu_RA_I2C_SLV2_ADDR 0x2B\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_i2c_slv2_ctrl","title":"define mpu_RA_I2C_SLV2_CTRL","text":"<pre><code>#define mpu_RA_I2C_SLV2_CTRL 0x2D\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_i2c_slv2_do","title":"define mpu_RA_I2C_SLV2_DO","text":"<pre><code>#define mpu_RA_I2C_SLV2_DO 0x65\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_i2c_slv2_reg","title":"define mpu_RA_I2C_SLV2_REG","text":"<pre><code>#define mpu_RA_I2C_SLV2_REG 0x2C\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_i2c_slv3_addr","title":"define mpu_RA_I2C_SLV3_ADDR","text":"<pre><code>#define mpu_RA_I2C_SLV3_ADDR 0x2E\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_i2c_slv3_ctrl","title":"define mpu_RA_I2C_SLV3_CTRL","text":"<pre><code>#define mpu_RA_I2C_SLV3_CTRL 0x30\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_i2c_slv3_do","title":"define mpu_RA_I2C_SLV3_DO","text":"<pre><code>#define mpu_RA_I2C_SLV3_DO 0x66\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_i2c_slv3_reg","title":"define mpu_RA_I2C_SLV3_REG","text":"<pre><code>#define mpu_RA_I2C_SLV3_REG 0x2F\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_i2c_slv4_addr","title":"define mpu_RA_I2C_SLV4_ADDR","text":"<pre><code>#define mpu_RA_I2C_SLV4_ADDR 0x31\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_i2c_slv4_ctrl","title":"define mpu_RA_I2C_SLV4_CTRL","text":"<pre><code>#define mpu_RA_I2C_SLV4_CTRL 0x34\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_i2c_slv4_di","title":"define mpu_RA_I2C_SLV4_DI","text":"<pre><code>#define mpu_RA_I2C_SLV4_DI 0x35\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_i2c_slv4_do","title":"define mpu_RA_I2C_SLV4_DO","text":"<pre><code>#define mpu_RA_I2C_SLV4_DO 0x33\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_i2c_slv4_reg","title":"define mpu_RA_I2C_SLV4_REG","text":"<pre><code>#define mpu_RA_I2C_SLV4_REG 0x32\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_int_enable","title":"define mpu_RA_INT_ENABLE","text":"<pre><code>#define mpu_RA_INT_ENABLE 0x38\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_int_pin_cfg","title":"define mpu_RA_INT_PIN_CFG","text":"<pre><code>#define mpu_RA_INT_PIN_CFG 0x37\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_int_status","title":"define mpu_RA_INT_STATUS","text":"<pre><code>#define mpu_RA_INT_STATUS 0x3A\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_mem_r_w","title":"define mpu_RA_MEM_R_W","text":"<pre><code>#define mpu_RA_MEM_R_W 0x6F\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_mem_start_addr","title":"define mpu_RA_MEM_START_ADDR","text":"<pre><code>#define mpu_RA_MEM_START_ADDR 0x6E\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_mot_detect_ctrl","title":"define mpu_RA_MOT_DETECT_CTRL","text":"<pre><code>#define mpu_RA_MOT_DETECT_CTRL 0x69\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_mot_detect_status","title":"define mpu_RA_MOT_DETECT_STATUS","text":"<pre><code>#define mpu_RA_MOT_DETECT_STATUS 0x61\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_mot_dur","title":"define mpu_RA_MOT_DUR","text":"<pre><code>#define mpu_RA_MOT_DUR 0x20\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_mot_thr","title":"define mpu_RA_MOT_THR","text":"<pre><code>#define mpu_RA_MOT_THR 0x1F\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_pwr_mgmt_1","title":"define mpu_RA_PWR_MGMT_1","text":"<pre><code>#define mpu_RA_PWR_MGMT_1 0x6B\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_pwr_mgmt_2","title":"define mpu_RA_PWR_MGMT_2","text":"<pre><code>#define mpu_RA_PWR_MGMT_2 0x6C\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_signal_path_reset","title":"define mpu_RA_SIGNAL_PATH_RESET","text":"<pre><code>#define mpu_RA_SIGNAL_PATH_RESET 0x68\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_smplrt_div","title":"define mpu_RA_SMPLRT_DIV","text":"<pre><code>#define mpu_RA_SMPLRT_DIV 0x19\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_temp_out_h","title":"define mpu_RA_TEMP_OUT_H","text":"<pre><code>#define mpu_RA_TEMP_OUT_H 0x41\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_temp_out_l","title":"define mpu_RA_TEMP_OUT_L","text":"<pre><code>#define mpu_RA_TEMP_OUT_L 0x42\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_user_ctrl","title":"define mpu_RA_USER_CTRL","text":"<pre><code>#define mpu_RA_USER_CTRL 0x6A\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_who_am_i","title":"define mpu_RA_WHO_AM_I","text":"<pre><code>#define mpu_RA_WHO_AM_I 0x75\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_xa_offs_h","title":"define mpu_RA_XA_OFFS_H","text":"<pre><code>#define mpu_RA_XA_OFFS_H 0x06\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_xa_offs_l_tc","title":"define mpu_RA_XA_OFFS_L_TC","text":"<pre><code>#define mpu_RA_XA_OFFS_L_TC 0x07\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_xg_offs_tc","title":"define mpu_RA_XG_OFFS_TC","text":"<pre><code>#define mpu_RA_XG_OFFS_TC 0x00\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_xg_offs_usrh","title":"define mpu_RA_XG_OFFS_USRH","text":"<pre><code>#define mpu_RA_XG_OFFS_USRH 0x13\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_xg_offs_usrl","title":"define mpu_RA_XG_OFFS_USRL","text":"<pre><code>#define mpu_RA_XG_OFFS_USRL 0x14\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_x_fine_gain","title":"define mpu_RA_X_FINE_GAIN","text":"<pre><code>#define mpu_RA_X_FINE_GAIN 0x03\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ya_offs_h","title":"define mpu_RA_YA_OFFS_H","text":"<pre><code>#define mpu_RA_YA_OFFS_H 0x08\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_ya_offs_l_tc","title":"define mpu_RA_YA_OFFS_L_TC","text":"<pre><code>#define mpu_RA_YA_OFFS_L_TC 0x09\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_yg_offs_tc","title":"define mpu_RA_YG_OFFS_TC","text":"<pre><code>#define mpu_RA_YG_OFFS_TC 0x01\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_yg_offs_usrh","title":"define mpu_RA_YG_OFFS_USRH","text":"<pre><code>#define mpu_RA_YG_OFFS_USRH 0x15\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_yg_offs_usrl","title":"define mpu_RA_YG_OFFS_USRL","text":"<pre><code>#define mpu_RA_YG_OFFS_USRL 0x16\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_y_fine_gain","title":"define mpu_RA_Y_FINE_GAIN","text":"<pre><code>#define mpu_RA_Y_FINE_GAIN 0x04\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_za_offs_h","title":"define mpu_RA_ZA_OFFS_H","text":"<pre><code>#define mpu_RA_ZA_OFFS_H 0x0A\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_za_offs_l_tc","title":"define mpu_RA_ZA_OFFS_L_TC","text":"<pre><code>#define mpu_RA_ZA_OFFS_L_TC 0x0B\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_zg_offs_tc","title":"define mpu_RA_ZG_OFFS_TC","text":"<pre><code>#define mpu_RA_ZG_OFFS_TC 0x02\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_zg_offs_usrh","title":"define mpu_RA_ZG_OFFS_USRH","text":"<pre><code>#define mpu_RA_ZG_OFFS_USRH 0x17\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_zg_offs_usrl","title":"define mpu_RA_ZG_OFFS_USRL","text":"<pre><code>#define mpu_RA_ZG_OFFS_USRL 0x18\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_zrmot_dur","title":"define mpu_RA_ZRMOT_DUR","text":"<pre><code>#define mpu_RA_ZRMOT_DUR 0x22\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_zrmot_thr","title":"define mpu_RA_ZRMOT_THR","text":"<pre><code>#define mpu_RA_ZRMOT_THR 0x21\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_ra_z_fine_gain","title":"define mpu_RA_Z_FINE_GAIN","text":"<pre><code>#define mpu_RA_Z_FINE_GAIN 0x05\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_slv0_fifo_en_bit","title":"define mpu_SLV0_FIFO_EN_BIT","text":"<pre><code>#define mpu_SLV0_FIFO_EN_BIT 0\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_slv1_fifo_en_bit","title":"define mpu_SLV1_FIFO_EN_BIT","text":"<pre><code>#define mpu_SLV1_FIFO_EN_BIT 1\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_slv2_fifo_en_bit","title":"define mpu_SLV2_FIFO_EN_BIT","text":"<pre><code>#define mpu_SLV2_FIFO_EN_BIT 2\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_slv_3_fifo_en_bit","title":"define mpu_SLV_3_FIFO_EN_BIT","text":"<pre><code>#define mpu_SLV_3_FIFO_EN_BIT 5\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_tc_offset_bit","title":"define mpu_TC_OFFSET_BIT","text":"<pre><code>#define mpu_TC_OFFSET_BIT 6\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_tc_offset_length","title":"define mpu_TC_OFFSET_LENGTH","text":"<pre><code>#define mpu_TC_OFFSET_LENGTH 6\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_tc_otp_bnk_vld_bit","title":"define mpu_TC_OTP_BNK_VLD_BIT","text":"<pre><code>#define mpu_TC_OTP_BNK_VLD_BIT 0\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_tc_pwr_mode_bit","title":"define mpu_TC_PWR_MODE_BIT","text":"<pre><code>#define mpu_TC_PWR_MODE_BIT 7\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_temp_fifo_en_bit","title":"define mpu_TEMP_FIFO_EN_BIT","text":"<pre><code>#define mpu_TEMP_FIFO_EN_BIT 7\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_userctrl_dmp_en_bit","title":"define mpu_USERCTRL_DMP_EN_BIT","text":"<pre><code>#define mpu_USERCTRL_DMP_EN_BIT 7\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_userctrl_dmp_reset_bit","title":"define mpu_USERCTRL_DMP_RESET_BIT","text":"<pre><code>#define mpu_USERCTRL_DMP_RESET_BIT 3\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_userctrl_fifo_en_bit","title":"define mpu_USERCTRL_FIFO_EN_BIT","text":"<pre><code>#define mpu_USERCTRL_FIFO_EN_BIT 6\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_userctrl_fifo_reset_bit","title":"define mpu_USERCTRL_FIFO_RESET_BIT","text":"<pre><code>#define mpu_USERCTRL_FIFO_RESET_BIT 2\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_userctrl_i2c_if_dis_bit","title":"define mpu_USERCTRL_I2C_IF_DIS_BIT","text":"<pre><code>#define mpu_USERCTRL_I2C_IF_DIS_BIT 4\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_userctrl_i2c_mst_en_bit","title":"define mpu_USERCTRL_I2C_MST_EN_BIT","text":"<pre><code>#define mpu_USERCTRL_I2C_MST_EN_BIT 5\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_userctrl_i2c_mst_reset_bit","title":"define mpu_USERCTRL_I2C_MST_RESET_BIT","text":"<pre><code>#define mpu_USERCTRL_I2C_MST_RESET_BIT 1\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_userctrl_sig_cond_reset_bit","title":"define mpu_USERCTRL_SIG_COND_RESET_BIT","text":"<pre><code>#define mpu_USERCTRL_SIG_COND_RESET_BIT 0\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_vddio_level_vdd","title":"define mpu_VDDIO_LEVEL_VDD","text":"<pre><code>#define mpu_VDDIO_LEVEL_VDD 1\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_vddio_level_vlogic","title":"define mpu_VDDIO_LEVEL_VLOGIC","text":"<pre><code>#define mpu_VDDIO_LEVEL_VLOGIC 0\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_wait_for_es_bit","title":"define mpu_WAIT_FOR_ES_BIT","text":"<pre><code>#define mpu_WAIT_FOR_ES_BIT 6\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_wake_freq_10","title":"define mpu_WAKE_FREQ_10","text":"<pre><code>#define mpu_WAKE_FREQ_10 0x3\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_wake_freq_1p25","title":"define mpu_WAKE_FREQ_1P25","text":"<pre><code>#define mpu_WAKE_FREQ_1P25 0x0\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_wake_freq_2p5","title":"define mpu_WAKE_FREQ_2P5","text":"<pre><code>#define mpu_WAKE_FREQ_2P5 0x1\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_wake_freq_5","title":"define mpu_WAKE_FREQ_5","text":"<pre><code>#define mpu_WAKE_FREQ_5 0x2\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_who_am_i_bit","title":"define mpu_WHO_AM_I_BIT","text":"<pre><code>#define mpu_WHO_AM_I_BIT 6\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_who_am_i_length","title":"define mpu_WHO_AM_I_LENGTH","text":"<pre><code>#define mpu_WHO_AM_I_LENGTH 6\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_xg_fifo_en_bit","title":"define mpu_XG_FIFO_EN_BIT","text":"<pre><code>#define mpu_XG_FIFO_EN_BIT 6\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_yg_fifo_en_bit","title":"define mpu_YG_FIFO_EN_BIT","text":"<pre><code>#define mpu_YG_FIFO_EN_BIT 5\n</code></pre>"},{"location":"apiStm/MpuController_8hpp/#define-mpu_zg_fifo_en_bit","title":"define mpu_ZG_FIFO_EN_BIT","text":"<pre><code>#define mpu_ZG_FIFO_EN_BIT 4\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/MpuController.hpp</code></p>"},{"location":"apiStm/MpuController_8hpp_source/","title":"File MpuController.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; MpuController.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>// I2Cdev library collection - mpu I2C device class\n// Based on InvenSense MPU-6050 register map document rev. 2.0, 5/19/2011 (RM-MPU-6000A-00)\n// 10/3/2011 by Jeff Rowberg &lt;jeff@rowberg.net&gt;\n// 11/28/2014 by Marton Sebok &lt;sebokmarton@gmail.com&gt;\n//\n// Updates should (hopefully) always be available at https://github.com/jrowberg/i2cdevlib\n//\n// Changelog:\n//     ...        - ongoing debug release\n//     2014-11-28 - ported to PIC18 peripheral library from Arduino code\n//     2017-03-11 - tested basic functions on STM32\n\n// NOTE: THIS IS ONLY A PARIAL RELEASE. THIS DEVICE CLASS IS CURRENTLY UNDERGOING ACTIVE\n// DEVELOPMENT AND IS STILL MISSING SOME IMPORTANT FEATURES. PLEASE KEEP THIS IN MIND IF\n// YOU DECIDE TO USE THIS PARTICULAR CODE FOR ANYTHING.\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2012 Jeff Rowberg\nCopyright (c) 2014 Marton Sebok\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n\n#ifndef _mpu_H_\n#define _mpu_H_\n\n#include \"I2cController.hpp\"\n#include \"rbcx.pb.h\"\n#include &lt;stdbool.h&gt;\n\n#if ((defined mpu_INCLUDE_DMP_MOTIONAPPS20)                                    \\\n    || (defined mpu_INCLUDE_DMP_MOTIONAPPS41))\n#error DMP is not supported yet\n#endif\n\n#define mpu_ADDRESS_AD0_LOW                                                    \\\n    0x68 // address pin low (GND), default for InvenSense evaluation board\n#define mpu_ADDRESS_AD0_HIGH 0x69 // address pin high (VCC)\n#define mpu_DEFAULT_ADDRESS mpu_ADDRESS_AD0_LOW\n\n#define mpu_RA_XG_OFFS_TC 0x00 //[7] PWR_MODE, [6:1] XG_OFFS_TC, [0] OTP_BNK_VLD\n#define mpu_RA_YG_OFFS_TC 0x01 //[7] PWR_MODE, [6:1] YG_OFFS_TC, [0] OTP_BNK_VLD\n#define mpu_RA_ZG_OFFS_TC 0x02 //[7] PWR_MODE, [6:1] ZG_OFFS_TC, [0] OTP_BNK_VLD\n#define mpu_RA_X_FINE_GAIN 0x03 //[7:0] X_FINE_GAIN\n#define mpu_RA_Y_FINE_GAIN 0x04 //[7:0] Y_FINE_GAIN\n#define mpu_RA_Z_FINE_GAIN 0x05 //[7:0] Z_FINE_GAIN\n#define mpu_RA_XA_OFFS_H 0x06 //[15:0] XA_OFFS\n#define mpu_RA_XA_OFFS_L_TC 0x07\n#define mpu_RA_YA_OFFS_H 0x08 //[15:0] YA_OFFS\n#define mpu_RA_YA_OFFS_L_TC 0x09\n#define mpu_RA_ZA_OFFS_H 0x0A //[15:0] ZA_OFFS\n#define mpu_RA_ZA_OFFS_L_TC 0x0B\n#define mpu_RA_XG_OFFS_USRH 0x13 //[15:0] XG_OFFS_USR\n#define mpu_RA_XG_OFFS_USRL 0x14\n#define mpu_RA_YG_OFFS_USRH 0x15 //[15:0] YG_OFFS_USR\n#define mpu_RA_YG_OFFS_USRL 0x16\n#define mpu_RA_ZG_OFFS_USRH 0x17 //[15:0] ZG_OFFS_USR\n#define mpu_RA_ZG_OFFS_USRL 0x18\n#define mpu_RA_SMPLRT_DIV 0x19\n#define mpu_RA_CONFIG 0x1A\n#define mpu_RA_GYRO_CONFIG 0x1B\n#define mpu_RA_ACCEL_CONFIG 0x1C\n#define mpu_RA_FF_THR 0x1D\n#define mpu_RA_FF_DUR 0x1E\n#define mpu_RA_MOT_THR 0x1F\n#define mpu_RA_MOT_DUR 0x20\n#define mpu_RA_ZRMOT_THR 0x21\n#define mpu_RA_ZRMOT_DUR 0x22\n#define mpu_RA_FIFO_EN 0x23\n#define mpu_RA_I2C_MST_CTRL 0x24\n#define mpu_RA_I2C_SLV0_ADDR 0x25\n#define mpu_RA_I2C_SLV0_REG 0x26\n#define mpu_RA_I2C_SLV0_CTRL 0x27\n#define mpu_RA_I2C_SLV1_ADDR 0x28\n#define mpu_RA_I2C_SLV1_REG 0x29\n#define mpu_RA_I2C_SLV1_CTRL 0x2A\n#define mpu_RA_I2C_SLV2_ADDR 0x2B\n#define mpu_RA_I2C_SLV2_REG 0x2C\n#define mpu_RA_I2C_SLV2_CTRL 0x2D\n#define mpu_RA_I2C_SLV3_ADDR 0x2E\n#define mpu_RA_I2C_SLV3_REG 0x2F\n#define mpu_RA_I2C_SLV3_CTRL 0x30\n#define mpu_RA_I2C_SLV4_ADDR 0x31\n#define mpu_RA_I2C_SLV4_REG 0x32\n#define mpu_RA_I2C_SLV4_DO 0x33\n#define mpu_RA_I2C_SLV4_CTRL 0x34\n#define mpu_RA_I2C_SLV4_DI 0x35\n#define mpu_RA_I2C_MST_STATUS 0x36\n#define mpu_RA_INT_PIN_CFG 0x37\n#define mpu_RA_INT_ENABLE 0x38\n#define mpu_RA_DMP_INT_STATUS 0x39\n#define mpu_RA_INT_STATUS 0x3A\n#define mpu_RA_ACCEL_XOUT_H 0x3B\n#define mpu_RA_ACCEL_XOUT_L 0x3C\n#define mpu_RA_ACCEL_YOUT_H 0x3D\n#define mpu_RA_ACCEL_YOUT_L 0x3E\n#define mpu_RA_ACCEL_ZOUT_H 0x3F\n#define mpu_RA_ACCEL_ZOUT_L 0x40\n#define mpu_RA_TEMP_OUT_H 0x41\n#define mpu_RA_TEMP_OUT_L 0x42\n#define mpu_RA_GYRO_XOUT_H 0x43\n#define mpu_RA_GYRO_XOUT_L 0x44\n#define mpu_RA_GYRO_YOUT_H 0x45\n#define mpu_RA_GYRO_YOUT_L 0x46\n#define mpu_RA_GYRO_ZOUT_H 0x47\n#define mpu_RA_GYRO_ZOUT_L 0x48\n#define mpu_RA_EXT_SENS_DATA_00 0x49\n#define mpu_RA_EXT_SENS_DATA_01 0x4A\n#define mpu_RA_EXT_SENS_DATA_02 0x4B\n#define mpu_RA_EXT_SENS_DATA_03 0x4C\n#define mpu_RA_EXT_SENS_DATA_04 0x4D\n#define mpu_RA_EXT_SENS_DATA_05 0x4E\n#define mpu_RA_EXT_SENS_DATA_06 0x4F\n#define mpu_RA_EXT_SENS_DATA_07 0x50\n#define mpu_RA_EXT_SENS_DATA_08 0x51\n#define mpu_RA_EXT_SENS_DATA_09 0x52\n#define mpu_RA_EXT_SENS_DATA_10 0x53\n#define mpu_RA_EXT_SENS_DATA_11 0x54\n#define mpu_RA_EXT_SENS_DATA_12 0x55\n#define mpu_RA_EXT_SENS_DATA_13 0x56\n#define mpu_RA_EXT_SENS_DATA_14 0x57\n#define mpu_RA_EXT_SENS_DATA_15 0x58\n#define mpu_RA_EXT_SENS_DATA_16 0x59\n#define mpu_RA_EXT_SENS_DATA_17 0x5A\n#define mpu_RA_EXT_SENS_DATA_18 0x5B\n#define mpu_RA_EXT_SENS_DATA_19 0x5C\n#define mpu_RA_EXT_SENS_DATA_20 0x5D\n#define mpu_RA_EXT_SENS_DATA_21 0x5E\n#define mpu_RA_EXT_SENS_DATA_22 0x5F\n#define mpu_RA_EXT_SENS_DATA_23 0x60\n#define mpu_RA_MOT_DETECT_STATUS 0x61\n#define mpu_RA_I2C_SLV0_DO 0x63\n#define mpu_RA_I2C_SLV1_DO 0x64\n#define mpu_RA_I2C_SLV2_DO 0x65\n#define mpu_RA_I2C_SLV3_DO 0x66\n#define mpu_RA_I2C_MST_DELAY_CTRL 0x67\n#define mpu_RA_SIGNAL_PATH_RESET 0x68\n#define mpu_RA_MOT_DETECT_CTRL 0x69\n#define mpu_RA_USER_CTRL 0x6A\n#define mpu_RA_PWR_MGMT_1 0x6B\n#define mpu_RA_PWR_MGMT_2 0x6C\n#define mpu_RA_BANK_SEL 0x6D\n#define mpu_RA_MEM_START_ADDR 0x6E\n#define mpu_RA_MEM_R_W 0x6F\n#define mpu_RA_DMP_CFG_1 0x70\n#define mpu_RA_DMP_CFG_2 0x71\n#define mpu_RA_FIFO_COUNTH 0x72\n#define mpu_RA_FIFO_COUNTL 0x73\n#define mpu_RA_FIFO_R_W 0x74\n#define mpu_RA_WHO_AM_I 0x75\n\n#define mpu_TC_PWR_MODE_BIT 7\n#define mpu_TC_OFFSET_BIT 6\n#define mpu_TC_OFFSET_LENGTH 6\n#define mpu_TC_OTP_BNK_VLD_BIT 0\n\n#define mpu_VDDIO_LEVEL_VLOGIC 0\n#define mpu_VDDIO_LEVEL_VDD 1\n\n#define mpu_CFG_EXT_SYNC_SET_BIT 5\n#define mpu_CFG_EXT_SYNC_SET_LENGTH 3\n#define mpu_CFG_DLPF_CFG_BIT 2\n#define mpu_CFG_DLPF_CFG_LENGTH 3\n\n#define mpu_EXT_SYNC_DISABLED 0x0\n#define mpu_EXT_SYNC_TEMP_OUT_L 0x1\n#define mpu_EXT_SYNC_GYRO_XOUT_L 0x2\n#define mpu_EXT_SYNC_GYRO_YOUT_L 0x3\n#define mpu_EXT_SYNC_GYRO_ZOUT_L 0x4\n#define mpu_EXT_SYNC_ACCEL_XOUT_L 0x5\n#define mpu_EXT_SYNC_ACCEL_YOUT_L 0x6\n#define mpu_EXT_SYNC_ACCEL_ZOUT_L 0x7\n\n#define mpu_DLPF_BW_256 0x00\n#define mpu_DLPF_BW_188 0x01\n#define mpu_DLPF_BW_98 0x02\n#define mpu_DLPF_BW_42 0x03\n#define mpu_DLPF_BW_20 0x04\n#define mpu_DLPF_BW_10 0x05\n#define mpu_DLPF_BW_5 0x06\n\n#define mpu_GCONFIG_FS_SEL_BIT 4\n#define mpu_GCONFIG_FS_SEL_LENGTH 2\n\n#define mpu_GYRO_FS_250 0x00\n#define mpu_GYRO_FS_500 0x01\n#define mpu_GYRO_FS_1000 0x02\n#define mpu_GYRO_FS_2000 0x03\n\n#define mpu_ACONFIG_XA_ST_BIT 7\n#define mpu_ACONFIG_YA_ST_BIT 6\n#define mpu_ACONFIG_ZA_ST_BIT 5\n#define mpu_ACONFIG_AFS_SEL_BIT 4\n#define mpu_ACONFIG_AFS_SEL_LENGTH 2\n#define mpu_ACONFIG_ACCEL_HPF_BIT 2\n#define mpu_ACONFIG_ACCEL_HPF_LENGTH 3\n\n#define mpu_ACCEL_FS_2 0x00\n#define mpu_ACCEL_FS_4 0x01\n#define mpu_ACCEL_FS_8 0x02\n#define mpu_ACCEL_FS_16 0x03\n\n#define mpu_DHPF_RESET 0x00\n#define mpu_DHPF_5 0x01\n#define mpu_DHPF_2P5 0x02\n#define mpu_DHPF_1P25 0x03\n#define mpu_DHPF_0P63 0x04\n#define mpu_DHPF_HOLD 0x07\n\n#define mpu_TEMP_FIFO_EN_BIT 7\n#define mpu_XG_FIFO_EN_BIT 6\n#define mpu_YG_FIFO_EN_BIT 5\n#define mpu_ZG_FIFO_EN_BIT 4\n#define mpu_ACCEL_FIFO_EN_BIT 3\n#define mpu_SLV2_FIFO_EN_BIT 2\n#define mpu_SLV1_FIFO_EN_BIT 1\n#define mpu_SLV0_FIFO_EN_BIT 0\n\n#define mpu_MULT_MST_EN_BIT 7\n#define mpu_WAIT_FOR_ES_BIT 6\n#define mpu_SLV_3_FIFO_EN_BIT 5\n#define mpu_I2C_MST_P_NSR_BIT 4\n#define mpu_I2C_MST_CLK_BIT 3\n#define mpu_I2C_MST_CLK_LENGTH 4\n\n#define mpu_CLOCK_DIV_348 0x0\n#define mpu_CLOCK_DIV_333 0x1\n#define mpu_CLOCK_DIV_320 0x2\n#define mpu_CLOCK_DIV_308 0x3\n#define mpu_CLOCK_DIV_296 0x4\n#define mpu_CLOCK_DIV_286 0x5\n#define mpu_CLOCK_DIV_276 0x6\n#define mpu_CLOCK_DIV_267 0x7\n#define mpu_CLOCK_DIV_258 0x8\n#define mpu_CLOCK_DIV_500 0x9\n#define mpu_CLOCK_DIV_471 0xA\n#define mpu_CLOCK_DIV_444 0xB\n#define mpu_CLOCK_DIV_421 0xC\n#define mpu_CLOCK_DIV_400 0xD\n#define mpu_CLOCK_DIV_381 0xE\n#define mpu_CLOCK_DIV_364 0xF\n\n#define mpu_I2C_SLV_RW_BIT 7\n#define mpu_I2C_SLV_ADDR_BIT 6\n#define mpu_I2C_SLV_ADDR_LENGTH 7\n#define mpu_I2C_SLV_EN_BIT 7\n#define mpu_I2C_SLV_BYTE_SW_BIT 6\n#define mpu_I2C_SLV_REG_DIS_BIT 5\n#define mpu_I2C_SLV_GRP_BIT 4\n#define mpu_I2C_SLV_LEN_BIT 3\n#define mpu_I2C_SLV_LEN_LENGTH 4\n\n#define mpu_I2C_SLV4_RW_BIT 7\n#define mpu_I2C_SLV4_ADDR_BIT 6\n#define mpu_I2C_SLV4_ADDR_LENGTH 7\n#define mpu_I2C_SLV4_EN_BIT 7\n#define mpu_I2C_SLV4_INT_EN_BIT 6\n#define mpu_I2C_SLV4_REG_DIS_BIT 5\n#define mpu_I2C_SLV4_MST_DLY_BIT 4\n#define mpu_I2C_SLV4_MST_DLY_LENGTH 5\n\n#define mpu_MST_PASS_THROUGH_BIT 7\n#define mpu_MST_I2C_SLV4_DONE_BIT 6\n#define mpu_MST_I2C_LOST_ARB_BIT 5\n#define mpu_MST_I2C_SLV4_NACK_BIT 4\n#define mpu_MST_I2C_SLV3_NACK_BIT 3\n#define mpu_MST_I2C_SLV2_NACK_BIT 2\n#define mpu_MST_I2C_SLV1_NACK_BIT 1\n#define mpu_MST_I2C_SLV0_NACK_BIT 0\n\n#define mpu_INTCFG_INT_LEVEL_BIT 7\n#define mpu_INTCFG_INT_OPEN_BIT 6\n#define mpu_INTCFG_LATCH_INT_EN_BIT 5\n#define mpu_INTCFG_INT_RD_CLEAR_BIT 4\n#define mpu_INTCFG_FSYNC_INT_LEVEL_BIT 3\n#define mpu_INTCFG_FSYNC_INT_EN_BIT 2\n#define mpu_INTCFG_I2C_BYPASS_EN_BIT 1\n#define mpu_INTCFG_CLKOUT_EN_BIT 0\n\n#define mpu_INTMODE_ACTIVEHIGH 0x00\n#define mpu_INTMODE_ACTIVELOW 0x01\n\n#define mpu_INTDRV_PUSHPULL 0x00\n#define mpu_INTDRV_OPENDRAIN 0x01\n\n#define mpu_INTLATCH_50USPULSE 0x00\n#define mpu_INTLATCH_WAITCLEAR 0x01\n\n#define mpu_INTCLEAR_STATUSREAD 0x00\n#define mpu_INTCLEAR_ANYREAD 0x01\n\n#define mpu_INTERRUPT_FF_BIT 7\n#define mpu_INTERRUPT_MOT_BIT 6\n#define mpu_INTERRUPT_ZMOT_BIT 5\n#define mpu_INTERRUPT_FIFO_OFLOW_BIT 4\n#define mpu_INTERRUPT_I2C_MST_INT_BIT 3\n#define mpu_INTERRUPT_PLL_RDY_INT_BIT 2\n#define mpu_INTERRUPT_DMP_INT_BIT 1\n#define mpu_INTERRUPT_DATA_RDY_BIT 0\n\n// TODO: figure out what these actually do\n// UMPL source code is not very obivous\n#define mpu_DMPINT_5_BIT 5\n#define mpu_DMPINT_4_BIT 4\n#define mpu_DMPINT_3_BIT 3\n#define mpu_DMPINT_2_BIT 2\n#define mpu_DMPINT_1_BIT 1\n#define mpu_DMPINT_0_BIT 0\n\n#define mpu_MOTION_MOT_XNEG_BIT 7\n#define mpu_MOTION_MOT_XPOS_BIT 6\n#define mpu_MOTION_MOT_YNEG_BIT 5\n#define mpu_MOTION_MOT_YPOS_BIT 4\n#define mpu_MOTION_MOT_ZNEG_BIT 3\n#define mpu_MOTION_MOT_ZPOS_BIT 2\n#define mpu_MOTION_MOT_ZRMOT_BIT 0\n\n#define mpu_DELAYCTRL_DELAY_ES_SHADOW_BIT 7\n#define mpu_DELAYCTRL_I2C_SLV4_DLY_EN_BIT 4\n#define mpu_DELAYCTRL_I2C_SLV3_DLY_EN_BIT 3\n#define mpu_DELAYCTRL_I2C_SLV2_DLY_EN_BIT 2\n#define mpu_DELAYCTRL_I2C_SLV1_DLY_EN_BIT 1\n#define mpu_DELAYCTRL_I2C_SLV0_DLY_EN_BIT 0\n\n#define mpu_PATHRESET_GYRO_RESET_BIT 2\n#define mpu_PATHRESET_ACCEL_RESET_BIT 1\n#define mpu_PATHRESET_TEMP_RESET_BIT 0\n\n#define mpu_DETECT_ACCEL_ON_DELAY_BIT 5\n#define mpu_DETECT_ACCEL_ON_DELAY_LENGTH 2\n#define mpu_DETECT_FF_COUNT_BIT 3\n#define mpu_DETECT_FF_COUNT_LENGTH 2\n#define mpu_DETECT_MOT_COUNT_BIT 1\n#define mpu_DETECT_MOT_COUNT_LENGTH 2\n\n#define mpu_DETECT_DECREMENT_RESET 0x0\n#define mpu_DETECT_DECREMENT_1 0x1\n#define mpu_DETECT_DECREMENT_2 0x2\n#define mpu_DETECT_DECREMENT_4 0x3\n\n#define mpu_USERCTRL_DMP_EN_BIT 7\n#define mpu_USERCTRL_FIFO_EN_BIT 6\n#define mpu_USERCTRL_I2C_MST_EN_BIT 5\n#define mpu_USERCTRL_I2C_IF_DIS_BIT 4\n#define mpu_USERCTRL_DMP_RESET_BIT 3\n#define mpu_USERCTRL_FIFO_RESET_BIT 2\n#define mpu_USERCTRL_I2C_MST_RESET_BIT 1\n#define mpu_USERCTRL_SIG_COND_RESET_BIT 0\n\n#define mpu_PWR1_DEVICE_RESET_BIT 7\n#define mpu_PWR1_SLEEP_BIT 6\n#define mpu_PWR1_CYCLE_BIT 5\n#define mpu_PWR1_TEMP_DIS_BIT 3\n#define mpu_PWR1_CLKSEL_BIT 2\n#define mpu_PWR1_CLKSEL_LENGTH 3\n\n#define mpu_CLOCK_INTERNAL 0x00\n#define mpu_CLOCK_PLL_XGYRO 0x01\n#define mpu_CLOCK_PLL_YGYRO 0x02\n#define mpu_CLOCK_PLL_ZGYRO 0x03\n#define mpu_CLOCK_PLL_EXT32K 0x04\n#define mpu_CLOCK_PLL_EXT19M 0x05\n#define mpu_CLOCK_KEEP_RESET 0x07\n\n#define mpu_PWR2_LP_WAKE_CTRL_BIT 7\n#define mpu_PWR2_LP_WAKE_CTRL_LENGTH 2\n#define mpu_PWR2_STBY_XA_BIT 5\n#define mpu_PWR2_STBY_YA_BIT 4\n#define mpu_PWR2_STBY_ZA_BIT 3\n#define mpu_PWR2_STBY_XG_BIT 2\n#define mpu_PWR2_STBY_YG_BIT 1\n#define mpu_PWR2_STBY_ZG_BIT 0\n\n#define mpu_WAKE_FREQ_1P25 0x0\n#define mpu_WAKE_FREQ_2P5 0x1\n#define mpu_WAKE_FREQ_5 0x2\n#define mpu_WAKE_FREQ_10 0x3\n\n#define mpu_BANKSEL_PRFTCH_EN_BIT 6\n#define mpu_BANKSEL_CFG_USER_BANK_BIT 5\n#define mpu_BANKSEL_MEM_SEL_BIT 4\n#define mpu_BANKSEL_MEM_SEL_LENGTH 5\n\n#define mpu_WHO_AM_I_BIT 6\n#define mpu_WHO_AM_I_LENGTH 6\n\n#define mpu_DMP_MEMORY_BANKS 8\n#define mpu_DMP_MEMORY_BANK_SIZE 256\n#define mpu_DMP_MEMORY_CHUNK_SIZE 16\n\n// note: DMP code memory blocks defined at end of header file\n\n// #define COMPRESS_COEF 4\n\ntypedef struct mpu_t {\nuint8_t devAddr;\nuint8_t buffer[14];\n} mpu_t;\n\nvoid mpuDispatch(const CoprocReq_MpuReq&amp; request);\nvoid mpuTick();\n\nvoid mpuCreate();\nvoid mpuInitialize();\nvoid mpuReset();\nbool mpu_testConnection();\n\n// AUX_VDDIO register\nuint8_t mpu_getAuxVDDIOLevel();\nvoid mpu_setAuxVDDIOLevel(uint8_t level);\n\n// SMPLRT_DIV register\nuint8_t mpu_getRate();\nvoid mpu_setRate(uint8_t rate);\n\n// CONFIG register\nuint8_t mpu_getExternalFrameSync();\nvoid mpu_setExternalFrameSync(uint8_t sync);\nuint8_t mpu_getDLPFMode();\nvoid mpu_setDLPFMode(uint8_t bandwidth);\n\n// GYRO_CONFIG register\nuint8_t mpu_getFullScaleGyroRange();\nvoid mpu_setFullScaleGyroRange(uint8_t range);\n\n// ACCEL_CONFIG register\nbool mpu_getAccelXSelfTest();\nvoid mpu_setAccelXSelfTest(bool enabled);\nbool mpu_getAccelYSelfTest();\nvoid mpu_setAccelYSelfTest(bool enabled);\nbool mpu_getAccelZSelfTest();\nvoid mpu_setAccelZSelfTest(bool enabled);\nuint8_t mpu_getFullScaleAccelRange();\nvoid mpu_setFullScaleAccelRange(uint8_t range);\nuint8_t mpu_getDHPFMode();\nvoid mpu_setDHPFMode(uint8_t mode);\n\n// FF_THR register\nuint8_t mpu_getFreefallDetectionThreshold();\nvoid mpu_setFreefallDetectionThreshold(uint8_t threshold);\n\n// FF_DUR register\nuint8_t mpu_getFreefallDetectionDuration();\nvoid mpu_setFreefallDetectionDuration(uint8_t duration);\n\n// MOT_THR register\nuint8_t mpu_getMotionDetectionThreshold();\nvoid mpu_setMotionDetectionThreshold(uint8_t threshold);\n\n// MOT_DUR register\nuint8_t mpu_getMotionDetectionDuration();\nvoid mpu_setMotionDetectionDuration(uint8_t duration);\n\n// ZRMOT_THR register\nuint8_t mpu_getZeroMotionDetectionThreshold();\nvoid mpu_setZeroMotionDetectionThreshold(uint8_t threshold);\n\n// ZRMOT_DUR register\nuint8_t mpu_getZeroMotionDetectionDuration();\nvoid mpu_setZeroMotionDetectionDuration(uint8_t duration);\n\n// FIFO_EN register\nbool mpu_getTempFIFOEnabled();\nvoid mpu_setTempFIFOEnabled(bool enabled);\nbool mpu_getXGyroFIFOEnabled();\nvoid mpu_setXGyroFIFOEnabled(bool enabled);\nbool mpu_getYGyroFIFOEnabled();\nvoid mpu_setYGyroFIFOEnabled(bool enabled);\nbool mpu_getZGyroFIFOEnabled();\nvoid mpu_setZGyroFIFOEnabled(bool enabled);\nbool mpu_getAccelFIFOEnabled();\nvoid mpu_setAccelFIFOEnabled(bool enabled);\nbool mpu_getSlave2FIFOEnabled();\nvoid mpu_setSlave2FIFOEnabled(bool enabled);\nbool mpu_getSlave1FIFOEnabled();\nvoid mpu_setSlave1FIFOEnabled(bool enabled);\nbool mpu_getSlave0FIFOEnabled();\nvoid mpu_setSlave0FIFOEnabled(bool enabled);\n\n// I2C_MST_CTRL register\nbool mpu_getMultiMasterEnabled();\nvoid mpu_setMultiMasterEnabled(bool enabled);\nbool mpu_getWaitForExternalSensorEnabled();\nvoid mpu_setWaitForExternalSensorEnabled(bool enabled);\nbool mpu_getSlave3FIFOEnabled();\nvoid mpu_setSlave3FIFOEnabled(bool enabled);\nbool mpu_getSlaveReadWriteTransitionEnabled();\nvoid mpu_setSlaveReadWriteTransitionEnabled(bool enabled);\nuint8_t mpu_getMasterClockSpeed();\nvoid mpu_setMasterClockSpeed(uint8_t speed);\n\n// I2C_SLV* registers (Slave 0-3)\nuint8_t mpu_getSlaveAddress(uint8_t num);\nvoid mpu_setSlaveAddress(uint8_t num, uint8_t address);\nuint8_t mpu_getSlaveRegister(uint8_t num);\nvoid mpu_setSlaveRegister(uint8_t num, uint8_t reg);\nbool mpu_getSlaveEnabled(uint8_t num);\nvoid mpu_setSlaveEnabled(uint8_t num, bool enabled);\nbool mpu_getSlaveWordByteSwap(uint8_t num);\nvoid mpu_setSlaveWordByteSwap(uint8_t num, bool enabled);\nbool mpu_getSlaveWriteMode(uint8_t num);\nvoid mpu_setSlaveWriteMode(uint8_t num, bool mode);\nbool mpu_getSlaveWordGroupOffset(uint8_t num);\nvoid mpu_setSlaveWordGroupOffset(uint8_t num, bool enabled);\nuint8_t mpu_getSlaveDataLength(uint8_t num);\nvoid mpu_setSlaveDataLength(uint8_t num, uint8_t length);\n\n// I2C_SLV* registers (Slave 4)\nuint8_t mpu_getSlave4Address();\nvoid mpu_setSlave4Address(uint8_t address);\nuint8_t mpu_getSlave4Register();\nvoid mpu_setSlave4Register(uint8_t reg);\nvoid mpu_setSlave4OutputByte(uint8_t data);\nbool mpu_getSlave4Enabled();\nvoid mpu_setSlave4Enabled(bool enabled);\nbool mpu_getSlave4InterruptEnabled();\nvoid mpu_setSlave4InterruptEnabled(bool enabled);\nbool mpu_getSlave4WriteMode();\nvoid mpu_setSlave4WriteMode(bool mode);\nuint8_t mpu_getSlave4MasterDelay();\nvoid mpu_setSlave4MasterDelay(uint8_t delay);\nuint8_t mpu_getSlate4InputByte();\n\n// I2C_MST_STATUS register\nbool mpu_getPassthroughStatus();\nbool mpu_getSlave4IsDone();\nbool mpu_getLostArbitration();\nbool mpu_getSlave4Nack();\nbool mpu_getSlave3Nack();\nbool mpu_getSlave2Nack();\nbool mpu_getSlave1Nack();\nbool mpu_getSlave0Nack();\n\n// INT_PIN_CFG register\nbool mpu_getInterruptMode();\nvoid mpu_setInterruptMode(bool mode);\nbool mpu_getInterruptDrive();\nvoid mpu_setInterruptDrive(bool drive);\nbool mpu_getInterruptLatch();\nvoid mpu_setInterruptLatch(bool latch);\nbool mpu_getInterruptLatchClear();\nvoid mpu_setInterruptLatchClear(bool clear);\nbool mpu_getFSyncInterruptLevel();\nvoid mpu_setFSyncInterruptLevel(bool level);\nbool mpu_getFSyncInterruptEnabled();\nvoid mpu_setFSyncInterruptEnabled(bool enabled);\nbool mpu_getI2CBypassEnabled();\nvoid mpu_setI2CBypassEnabled(bool enabled);\nbool mpu_getClockOutputEnabled();\nvoid mpu_setClockOutputEnabled(bool enabled);\n\n// INT_ENABLE register\nuint8_t mpu_getIntEnabled();\nvoid mpu_setIntEnabled(uint8_t enabled);\nbool mpu_getIntFreefallEnabled();\nvoid mpu_setIntFreefallEnabled(bool enabled);\nbool mpu_getIntMotionEnabled();\nvoid mpu_setIntMotionEnabled(bool enabled);\nbool mpu_getIntZeroMotionEnabled();\nvoid mpu_setIntZeroMotionEnabled(bool enabled);\nbool mpu_getIntFIFOBufferOverflowEnabled();\nvoid mpu_setIntFIFOBufferOverflowEnabled(bool enabled);\nbool mpu_getIntI2CMasterEnabled();\nvoid mpu_setIntI2CMasterEnabled(bool enabled);\nbool mpu_getIntDataReadyEnabled();\nvoid mpu_setIntDataReadyEnabled(bool enabled);\n\n// INT_STATUS register\nuint8_t mpu_getIntStatus();\nbool mpu_getIntFreefallStatus();\nbool mpu_getIntMotionStatus();\nbool mpu_getIntZeroMotionStatus();\nbool mpu_getIntFIFOBufferOverflowStatus();\nbool mpu_getIntI2CMasterStatus();\nbool mpu_getIntDataReadyStatus();\n\n// ACCEL_*OUT_* registers\nvoid mpu_getMotion9(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx,\nint16_t* gy, int16_t* gz, int16_t* mx, int16_t* my, int16_t* mz);\nvoid mpu_getMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx,\nint16_t* gy, int16_t* gz);\nvoid mpu_getAcceleration(int16_t* x, int16_t* y, int16_t* z);\n// void mpu_getAcceleration(int32_t* x, int32_t* y, int32_t* z);\nint16_t mpu_getAccelerationX();\nint16_t mpu_getAccelerationY();\nint16_t mpu_getAccelerationZ();\n\n// TEMP_OUT_* registers\nint16_t mpu_getTemperature();\n\n// GYRO_*OUT_* registers\nvoid mpu_getRotation(int16_t* x, int16_t* y, int16_t* z);\n// void mpu_getRotation(int32_t* x, int32_t* y, int32_t* z);\nint16_t mpu_getRotationX();\nint16_t mpu_getRotationY();\nint16_t mpu_getRotationZ();\n\n// EXT_SENS_DATA_* registers\nuint8_t mpu_getExternalSensorByte(int position);\nuint16_t mpu_getExternalSensorWord(int position);\nuint32_t getExternalSensorDWord(int position);\n\n// MOT_DETECT_STATUS register\nbool mpu_getXNegMotionDetected();\nbool mpu_getXPosMotionDetected();\nbool mpu_getYNegMotionDetected();\nbool mpu_getYPosMotionDetected();\nbool mpu_getZNegMotionDetected();\nbool mpu_getZPosMotionDetected();\nbool mpu_getZeroMotionDetected();\n\n// I2C_SLV*_DO register\nvoid mpu_setSlaveOutputByte(uint8_t num, uint8_t data);\n\n// I2C_MST_DELAY_CTRL register\nbool mpu_getExternalShadowDelayEnabled();\nvoid mpu_setExternalShadowDelayEnabled(bool enabled);\nbool mpu_getSlaveDelayEnabled(uint8_t num);\nvoid mpu_setSlaveDelayEnabled(uint8_t num, bool enabled);\n\n// SIGNAL_PATH_RESET register\nvoid mpu_resetGyroscopePath();\nvoid mpu_resetAccelerometerPath();\nvoid mpu_resetTemperaturePath();\n\n// MOT_DETECT_CTRL register\nuint8_t mpu_getAccelerometerPowerOnDelay();\nvoid mpu_setAccelerometerPowerOnDelay(uint8_t delay);\nuint8_t mpu_getFreefallDetectionCounterDecrement();\nvoid mpu_setFreefallDetectionCounterDecrement(uint8_t decrement);\nuint8_t mpu_getMotionDetectionCounterDecrement();\nvoid mpu_setMotionDetectionCounterDecrement(uint8_t decrement);\n\n// USER_CTRL register\nbool mpu_getFIFOEnabled();\nvoid mpu_setFIFOEnabled(bool enabled);\nbool mpu_getI2CMasterModeEnabled();\nvoid mpu_setI2CMasterModeEnabled(bool enabled);\nvoid mpu_switchSPIEnabled(bool enabled);\nvoid mpu_resetFIFO();\nvoid mpu_resetI2CMaster();\nvoid mpu_resetSensors();\n\n// PWR_MGMT_1 register\nvoid mpu_reset();\nbool mpu_getSleepEnabled();\nvoid mpu_setSleepEnabled(bool enabled);\nbool mpu_getWakeCycleEnabled();\nvoid mpu_setWakeCycleEnabled(bool enabled);\nbool mpu_getTempSensorEnabled();\nvoid mpu_setTempSensorEnabled(bool enabled);\nuint8_t mpu_getClockSource();\nvoid mpu_setClockSource(uint8_t source);\n\n// PWR_MGMT_2 register\nuint8_t mpu_getWakeFrequency();\nvoid mpu_setWakeFrequency(uint8_t frequency);\nbool mpu_getStandbyXAccelEnabled();\nvoid mpu_setStandbyXAccelEnabled(bool enabled);\nbool mpu_getStandbyYAccelEnabled();\nvoid mpu_setStandbyYAccelEnabled(bool enabled);\nbool mpu_getStandbyZAccelEnabled();\nvoid mpu_setStandbyZAccelEnabled(bool enabled);\nbool mpu_getStandbyXGyroEnabled();\nvoid mpu_setStandbyXGyroEnabled(bool enabled);\nbool mpu_getStandbyYGyroEnabled();\nvoid mpu_setStandbyYGyroEnabled(bool enabled);\nbool mpu_getStandbyZGyroEnabled();\nvoid mpu_setStandbyZGyroEnabled(bool enabled);\n\n// FIFO_COUNT_* registers\nuint16_t mpu_getFIFOCount();\n\n// FIFO_R_W register\nuint8_t mpu_getFIFOByte();\nvoid mpu_setFIFOByte(uint8_t data);\nvoid mpu_getFIFOBytes(uint8_t* data, uint8_t length);\n\n// WHO_AM_I register\nuint8_t mpu_getDeviceID();\nvoid mpu_setDeviceID(uint8_t id);\n\n// ======== UNDOCUMENTED/DMP REGISTERS/METHODS ========\n\n// XG_OFFS_TC register\nuint8_t mpu_getOTPBankValid();\nvoid mpu_setOTPBankValid(bool enabled);\nint8_t getXGyroOffsetTC();\nvoid mpu_setXGyroOffsetTC(int8_t offset);\n\n// YG_OFFS_TC register\nint8_t getYGyroOffsetTC();\nvoid mpu_setYGyroOffsetTC(int8_t offset);\n\n// ZG_OFFS_TC register\nint8_t getZGyroOffsetTC();\nvoid mpu_setZGyroOffsetTC(int8_t offset);\n\n// X_FINE_GAIN register\nint8_t getXFineGain();\nvoid mpu_setXFineGain(int8_t gain);\n\n// Y_FINE_GAIN register\nint8_t getYFineGain();\nvoid mpu_setYFineGain(int8_t gain);\n\n// Z_FINE_GAIN register\nint8_t getZFineGain();\nvoid mpu_setZFineGain(int8_t gain);\n\n// XA_OFFS_* registers\nint16_t mpu_getXAccelOffset();\nvoid mpu_setXAccelOffset(int16_t offset);\n\n// YA_OFFS_* register\nint16_t mpu_getYAccelOffset();\nvoid mpu_setYAccelOffset(int16_t offset);\n\n// ZA_OFFS_* register\nint16_t mpu_getZAccelOffset();\nvoid mpu_setZAccelOffset(int16_t offset);\n\n// XG_OFFS_USR* registers\nint16_t mpu_getXGyroOffset();\nvoid mpu_setXGyroOffset(int16_t offset);\n\n// YG_OFFS_USR* register\nint16_t mpu_getYGyroOffset();\nvoid mpu_setYGyroOffset(int16_t offset);\n\n// ZG_OFFS_USR* register\nint16_t mpu_getZGyroOffset();\nvoid mpu_setZGyroOffset(int16_t offset);\n\n// INT_ENABLE register (DMP functions)\nbool mpu_getIntPLLReadyEnabled();\nvoid mpu_setIntPLLReadyEnabled(bool enabled);\nbool mpu_getIntDMPEnabled();\nvoid mpu_setIntDMPEnabled(bool enabled);\n\n// DMP_INT_STATUS\nbool mpu_getDMPInt5Status();\nbool mpu_getDMPInt4Status();\nbool mpu_getDMPInt3Status();\nbool mpu_getDMPInt2Status();\nbool mpu_getDMPInt1Status();\nbool mpu_getDMPInt0Status();\n\n// INT_STATUS register (DMP functions)\nbool mpu_getIntPLLReadyStatus();\nbool mpu_getIntDMPStatus();\n\n// USER_CTRL register (DMP functions)\nbool mpu_getDMPEnabled();\nvoid mpu_setDMPEnabled(bool enabled);\nvoid mpu_resetDMP();\n\n// BANK_SEL register\nvoid mpu_setMemoryBank(uint8_t bank, bool prefetchEnabled, bool userBank);\n\n// MEM_START_ADDR register\nvoid mpu_setMemoryStartAddress(uint8_t address);\n\n// MEM_R_W register\nuint8_t mpu_readMemoryByte();\nvoid mpu_writeMemoryByte(uint8_t data);\nvoid mpu_readMemoryBlock(\nuint8_t* data, uint16_t dataSize, uint8_t bank, uint8_t address);\n//bool mpu_writeMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify, bool useProgMem);\n//bool mpu_writeProgMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify);\n\n//bool mpu_writeDMPConfigurationSet(const uint8_t *data, uint16_t dataSize, bool useProgMem);\n//bool mpu_writeProgDMPConfigurationSet(const uint8_t *data, uint16_t dataSize);\n\n// DMP_CFG_1 register\nuint8_t mpu_getDMPConfig1();\nvoid mpu_setDMPConfig1(uint8_t config);\n\n// DMP_CFG_2 register\nuint8_t mpu_getDMPConfig2();\nvoid mpu_setDMPConfig2(uint8_t config);\n\n#endif /* _mpu_H_ */\n</code></pre>"},{"location":"apiStm/OledController_8hpp/","title":"File OledController.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; OledController.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stddef.h&gt;</code></li> <li><code>#include \"I2cController.hpp\"</code></li> <li><code>#include \"rbcx.pb.h\"</code></li> <li><code>#include \"OledController_fonts.hpp\"</code></li> </ul>"},{"location":"apiStm/OledController_8hpp/#classes","title":"Classes","text":"Type Name struct OLED_VERTEX struct OLED_t"},{"location":"apiStm/OledController_8hpp/#public-types","title":"Public Types","text":"Type Name enum OLED_COLOR enum OLED_Error_t"},{"location":"apiStm/OledController_8hpp/#public-functions","title":"Public Functions","text":"Type Name void oledDispatch (const CoprocReq_OledReq &amp; request)  void oledDrawArc (uint8_t x, uint8_t y, uint8_t radius, uint16_t start_angle, uint16_t sweep, OLED_COLOR color)  void oledDrawCircle (uint8_t par_x, uint8_t par_y, uint8_t par_r, OLED_COLOR color)  void oledDrawLine (uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, OLED_COLOR color)  void oledDrawPixel (uint8_t x, uint8_t y, OLED_COLOR color)  void oledDrawRectangle (uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, OLED_COLOR color)  void oledFill (OLED_COLOR color)  OLED_Error_t oledFillBuffer (uint8_t * buf, uint32_t len)  bool oledGetDisplayOn () Reads DisplayOn state. void oledInit (const CoprocReq_OledInit &amp; init)  void oledInitOld (void)  void oledInitStm ()  void oledPolyline (const OLED_VERTEX * par_vertex, uint16_t par_size, OLED_COLOR color)  void oledSetContrast (const uint8_t value) Sets the contrast of the display. void oledSetCursor (uint8_t x, uint8_t y)  void oledSetDisplayOn (const bool on) Set Display ON/OFF. bool oledTestConnection ()  void oledUpdateScreen (void)  char oledWriteChar (char ch, FontDef Font, OLED_COLOR color)  void oledWriteCommand (uint8_t byte)  void oledWriteData (uint8_t * buffer, size_t buff_size)  char oledWriteString (const char * str, FontDef Font, OLED_COLOR color)"},{"location":"apiStm/OledController_8hpp/#macros","title":"Macros","text":"Type Name define OLED_BUFFER_SIZE  1024 define OLED_I2C_ADDR  0x3C"},{"location":"apiStm/OledController_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/OledController_8hpp/#enum-oled_color","title":"enum OLED_COLOR","text":"<pre><code>enum OLED_COLOR {\nBlack = 0x00,\nWhite = 0x01\n};\n</code></pre>"},{"location":"apiStm/OledController_8hpp/#enum-oled_error_t","title":"enum OLED_Error_t","text":"<pre><code>enum OLED_Error_t {\nOLED_OK = 0x00,\nOLED_ERR = 0x01\n};\n</code></pre>"},{"location":"apiStm/OledController_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/OledController_8hpp/#function-oleddispatch","title":"function oledDispatch","text":"<pre><code>void oledDispatch (\nconst CoprocReq_OledReq &amp; request\n) </code></pre>"},{"location":"apiStm/OledController_8hpp/#function-oleddrawarc","title":"function oledDrawArc","text":"<pre><code>void oledDrawArc (\nuint8_t x,\nuint8_t y,\nuint8_t radius,\nuint16_t start_angle,\nuint16_t sweep,\nOLED_COLOR color\n) </code></pre>"},{"location":"apiStm/OledController_8hpp/#function-oleddrawcircle","title":"function oledDrawCircle","text":"<pre><code>void oledDrawCircle (\nuint8_t par_x,\nuint8_t par_y,\nuint8_t par_r,\nOLED_COLOR color\n) </code></pre>"},{"location":"apiStm/OledController_8hpp/#function-oleddrawline","title":"function oledDrawLine","text":"<pre><code>void oledDrawLine (\nuint8_t x1,\nuint8_t y1,\nuint8_t x2,\nuint8_t y2,\nOLED_COLOR color\n) </code></pre>"},{"location":"apiStm/OledController_8hpp/#function-oleddrawpixel","title":"function oledDrawPixel","text":"<pre><code>void oledDrawPixel (\nuint8_t x,\nuint8_t y,\nOLED_COLOR color\n) </code></pre>"},{"location":"apiStm/OledController_8hpp/#function-oleddrawrectangle","title":"function oledDrawRectangle","text":"<pre><code>void oledDrawRectangle (\nuint8_t x1,\nuint8_t y1,\nuint8_t x2,\nuint8_t y2,\nOLED_COLOR color\n) </code></pre>"},{"location":"apiStm/OledController_8hpp/#function-oledfill","title":"function oledFill","text":"<pre><code>void oledFill (\nOLED_COLOR color\n) </code></pre>"},{"location":"apiStm/OledController_8hpp/#function-oledfillbuffer","title":"function oledFillBuffer","text":"<pre><code>OLED_Error_t oledFillBuffer (\nuint8_t * buf,\nuint32_t len\n) </code></pre>"},{"location":"apiStm/OledController_8hpp/#function-oledgetdisplayon","title":"function oledGetDisplayOn","text":"<p>Reads DisplayOn state. <pre><code>bool oledGetDisplayOn () </code></pre></p> <p>Returns:</p> <p>0: OFF. 1: ON. </p>"},{"location":"apiStm/OledController_8hpp/#function-oledinit","title":"function oledInit","text":"<pre><code>void oledInit (\nconst CoprocReq_OledInit &amp; init\n) </code></pre>"},{"location":"apiStm/OledController_8hpp/#function-oledinitold","title":"function oledInitOld","text":"<pre><code>void oledInitOld (\nvoid\n) </code></pre>"},{"location":"apiStm/OledController_8hpp/#function-oledinitstm","title":"function oledInitStm","text":"<pre><code>void oledInitStm () </code></pre>"},{"location":"apiStm/OledController_8hpp/#function-oledpolyline","title":"function oledPolyline","text":"<pre><code>void oledPolyline (\nconst OLED_VERTEX * par_vertex,\nuint16_t par_size,\nOLED_COLOR color\n) </code></pre>"},{"location":"apiStm/OledController_8hpp/#function-oledsetcontrast","title":"function oledSetContrast","text":"<p>Sets the contrast of the display. <pre><code>void oledSetContrast (\nconst uint8_t value\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>value</code> contrast to set. </li> </ul> <p>Note:</p> <p>Contrast increases as the value increases. </p> <p>Note:</p> <p>RESET = 7Fh. </p>"},{"location":"apiStm/OledController_8hpp/#function-oledsetcursor","title":"function oledSetCursor","text":"<pre><code>void oledSetCursor (\nuint8_t x,\nuint8_t y\n) </code></pre>"},{"location":"apiStm/OledController_8hpp/#function-oledsetdisplayon","title":"function oledSetDisplayOn","text":"<p>Set Display ON/OFF. <pre><code>void oledSetDisplayOn (\nconst bool on\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>on</code> 0 for OFF, any for ON. </li> </ul>"},{"location":"apiStm/OledController_8hpp/#function-oledtestconnection","title":"function oledTestConnection","text":"<pre><code>bool oledTestConnection () </code></pre>"},{"location":"apiStm/OledController_8hpp/#function-oledupdatescreen","title":"function oledUpdateScreen","text":"<pre><code>void oledUpdateScreen (\nvoid\n) </code></pre>"},{"location":"apiStm/OledController_8hpp/#function-oledwritechar","title":"function oledWriteChar","text":"<pre><code>char oledWriteChar (\nchar ch,\nFontDef Font,\nOLED_COLOR color\n) </code></pre>"},{"location":"apiStm/OledController_8hpp/#function-oledwritecommand","title":"function oledWriteCommand","text":"<pre><code>void oledWriteCommand (\nuint8_t byte\n) </code></pre>"},{"location":"apiStm/OledController_8hpp/#function-oledwritedata","title":"function oledWriteData","text":"<pre><code>void oledWriteData (\nuint8_t * buffer,\nsize_t buff_size\n) </code></pre>"},{"location":"apiStm/OledController_8hpp/#function-oledwritestring","title":"function oledWriteString","text":"<pre><code>char oledWriteString (\nconst char * str,\nFontDef Font,\nOLED_COLOR color\n) </code></pre>"},{"location":"apiStm/OledController_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/OledController_8hpp/#define-oled_buffer_size","title":"define OLED_BUFFER_SIZE","text":"<pre><code>#define OLED_BUFFER_SIZE 1024\n</code></pre>"},{"location":"apiStm/OledController_8hpp/#define-oled_i2c_addr","title":"define OLED_I2C_ADDR","text":"<pre><code>#define OLED_I2C_ADDR 0x3C\n</code></pre> <p>This Library was originally written by Olivier Van den Eede (4ilo) in 2016. Some refactoring was done and SPI support was added by Aleksander Alekseev (afiskon) in 2018.</p> <p>https://github.com/afiskon/stm32-oled </p> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/OledController.hpp</code></p>"},{"location":"apiStm/OledController_8hpp_source/","title":"File OledController.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; OledController.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;stddef.h&gt;\n\n#include \"I2cController.hpp\"\n#include \"rbcx.pb.h\"\n\n#include \"OledController_fonts.hpp\"\n\n#define OLED_I2C_ADDR 0x3C\n#define OLED_BUFFER_SIZE 1024\n\n// Enumeration for screen colors\ntypedef enum {\nBlack = 0x00, // Black color, no pixel\nWhite = 0x01 // Pixel is set. Color depends on OLED\n} OLED_COLOR;\n\ntypedef enum {\nOLED_OK = 0x00,\nOLED_ERR = 0x01 // Generic error.\n} OLED_Error_t;\n\n// Struct to store transformations\ntypedef struct {\nuint16_t CurrentX;\nuint16_t CurrentY;\nuint8_t Inverted;\nbool DisplayOn;\n} OLED_t;\ntypedef struct {\nuint8_t x;\nuint8_t y;\n} OLED_VERTEX;\n\nvoid oledDispatch(const CoprocReq_OledReq&amp; request);\n\nbool oledTestConnection();\nvoid oledInitStm();\nvoid oledInit(const CoprocReq_OledInit&amp; init);\n\n// Procedure definitions\nvoid oledInitOld(void);\nvoid oledFill(OLED_COLOR color);\nvoid oledUpdateScreen(void);\nvoid oledDrawPixel(uint8_t x, uint8_t y, OLED_COLOR color);\nchar oledWriteChar(char ch, FontDef Font, OLED_COLOR color);\nchar oledWriteString(const char* str, FontDef Font, OLED_COLOR color);\nvoid oledSetCursor(uint8_t x, uint8_t y);\nvoid oledDrawLine(\nuint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, OLED_COLOR color);\nvoid oledDrawArc(uint8_t x, uint8_t y, uint8_t radius, uint16_t start_angle,\nuint16_t sweep, OLED_COLOR color);\nvoid oledDrawCircle(\nuint8_t par_x, uint8_t par_y, uint8_t par_r, OLED_COLOR color);\nvoid oledPolyline(\nconst OLED_VERTEX* par_vertex, uint16_t par_size, OLED_COLOR color);\nvoid oledDrawRectangle(\nuint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, OLED_COLOR color);\nvoid oledSetContrast(const uint8_t value);\nvoid oledSetDisplayOn(const bool on);\nbool oledGetDisplayOn();\n\n// Low-level procedures\nvoid oledWriteCommand(uint8_t byte);\nvoid oledWriteData(uint8_t* buffer, size_t buff_size);\nOLED_Error_t oledFillBuffer(uint8_t* buf, uint32_t len);\n</code></pre>"},{"location":"apiStm/OledController__fonts_8hpp/","title":"File OledController_fonts.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; OledController_fonts.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"apiStm/OledController__fonts_8hpp/#classes","title":"Classes","text":"Type Name struct FontDef"},{"location":"apiStm/OledController__fonts_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name FontDef Font_11x18 FontDef Font_16x26 FontDef Font_6x8 FontDef Font_7x10"},{"location":"apiStm/OledController__fonts_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/OledController__fonts_8hpp/#variable-font_11x18","title":"variable Font_11x18","text":"<pre><code>FontDef Font_11x18;\n</code></pre>"},{"location":"apiStm/OledController__fonts_8hpp/#variable-font_16x26","title":"variable Font_16x26","text":"<pre><code>FontDef Font_16x26;\n</code></pre>"},{"location":"apiStm/OledController__fonts_8hpp/#variable-font_6x8","title":"variable Font_6x8","text":"<pre><code>FontDef Font_6x8;\n</code></pre>"},{"location":"apiStm/OledController__fonts_8hpp/#variable-font_7x10","title":"variable Font_7x10","text":"<pre><code>FontDef Font_7x10;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/OledController_fonts.hpp</code></p>"},{"location":"apiStm/OledController__fonts_8hpp_source/","title":"File OledController_fonts.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; OledController_fonts.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;stdint.h&gt;\n\ntypedef struct {\nconst uint8_t FontWidth; uint8_t FontHeight; const uint16_t* data; } FontDef;\n\nextern FontDef Font_6x8;\nextern FontDef Font_7x10;\nextern FontDef Font_11x18;\nextern FontDef Font_16x26;\n</code></pre>"},{"location":"apiStm/Power_8hpp/","title":"File Power.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; Power.hpp</p> <p>Go to the source code of this file.</p>"},{"location":"apiStm/Power_8hpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr uint16_t POWER_CALIBRATE_DEFAULT   = = 0 constexpr uint16_t POWER_CALIBRATE_NO_CHANGE   = = 0xFFFF"},{"location":"apiStm/Power_8hpp/#public-functions","title":"Public Functions","text":"Type Name uint16_t powerBatteryMidMv ()  uint16_t powerBatteryMv ()  void powerCalibrate (uint16_t vccMv, uint16_t bMidMv, uint16_t vref33Mv, uint16_t currentTemperatureC)  void powerInit ()  void powerPoll ()  void powerShutDown ()  uint16_t powerTemperatureC ()  uint16_t powerVrefMv ()"},{"location":"apiStm/Power_8hpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"apiStm/Power_8hpp/#variable-power_calibrate_default","title":"variable POWER_CALIBRATE_DEFAULT","text":"<pre><code>constexpr uint16_t POWER_CALIBRATE_DEFAULT;\n</code></pre>"},{"location":"apiStm/Power_8hpp/#variable-power_calibrate_no_change","title":"variable POWER_CALIBRATE_NO_CHANGE","text":"<pre><code>constexpr uint16_t POWER_CALIBRATE_NO_CHANGE;\n</code></pre>"},{"location":"apiStm/Power_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/Power_8hpp/#function-powerbatterymidmv","title":"function powerBatteryMidMv","text":"<pre><code>uint16_t powerBatteryMidMv () </code></pre>"},{"location":"apiStm/Power_8hpp/#function-powerbatterymv","title":"function powerBatteryMv","text":"<pre><code>uint16_t powerBatteryMv () </code></pre>"},{"location":"apiStm/Power_8hpp/#function-powercalibrate","title":"function powerCalibrate","text":"<pre><code>void powerCalibrate (\nuint16_t vccMv,\nuint16_t bMidMv,\nuint16_t vref33Mv,\nuint16_t currentTemperatureC\n) </code></pre>"},{"location":"apiStm/Power_8hpp/#function-powerinit","title":"function powerInit","text":"<pre><code>void powerInit () </code></pre>"},{"location":"apiStm/Power_8hpp/#function-powerpoll","title":"function powerPoll","text":"<pre><code>void powerPoll () </code></pre>"},{"location":"apiStm/Power_8hpp/#function-powershutdown","title":"function powerShutDown","text":"<pre><code>void powerShutDown () </code></pre>"},{"location":"apiStm/Power_8hpp/#function-powertemperaturec","title":"function powerTemperatureC","text":"<pre><code>uint16_t powerTemperatureC () </code></pre>"},{"location":"apiStm/Power_8hpp/#function-powervrefmv","title":"function powerVrefMv","text":"<pre><code>uint16_t powerVrefMv () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/Power.hpp</code></p>"},{"location":"apiStm/Power_8hpp_source/","title":"File Power.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; Power.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\nvoid powerInit();\nvoid powerPoll();\n\nuint16_t powerBatteryMv();\nuint16_t powerBatteryMidMv();\nuint16_t powerTemperatureC();\nuint16_t powerVrefMv();\n\nstatic constexpr uint16_t POWER_CALIBRATE_DEFAULT = 0;\nstatic constexpr uint16_t POWER_CALIBRATE_NO_CHANGE = 0xFFFF;\nvoid powerCalibrate(uint16_t vccMv, uint16_t bMidMv, uint16_t vref33Mv,\nuint16_t currentTemperatureC);\n\nvoid powerShutDown();\n</code></pre>"},{"location":"apiStm/SmartServoController_8hpp/","title":"File SmartServoController.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; SmartServoController.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"rbcx.pb.h\"</code></li> </ul>"},{"location":"apiStm/SmartServoController_8hpp/#public-functions","title":"Public Functions","text":"Type Name void smartServoInit ()  void smartServoPoll ()  void smartServoSendRequest (const CoprocReq_SmartServoReq &amp; req)"},{"location":"apiStm/SmartServoController_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/SmartServoController_8hpp/#function-smartservoinit","title":"function smartServoInit","text":"<pre><code>void smartServoInit () </code></pre>"},{"location":"apiStm/SmartServoController_8hpp/#function-smartservopoll","title":"function smartServoPoll","text":"<pre><code>void smartServoPoll () </code></pre>"},{"location":"apiStm/SmartServoController_8hpp/#function-smartservosendrequest","title":"function smartServoSendRequest","text":"<pre><code>void smartServoSendRequest (\nconst CoprocReq_SmartServoReq &amp; req\n) </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/SmartServoController.hpp</code></p>"},{"location":"apiStm/SmartServoController_8hpp_source/","title":"File SmartServoController.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; SmartServoController.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"rbcx.pb.h\"\n\nvoid smartServoInit();\nvoid smartServoSendRequest(const CoprocReq_SmartServoReq&amp; req);\nvoid smartServoPoll();\n</code></pre>"},{"location":"apiStm/StupidServoController_8hpp/","title":"File StupidServoController.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; StupidServoController.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"rbcx.pb.h\"</code></li> </ul>"},{"location":"apiStm/StupidServoController_8hpp/#public-functions","title":"Public Functions","text":"Type Name void stupidServoDispatch (const CoprocReq_SetStupidServo &amp; request)  void stupidServoInit ()  void stupidServoReset ()"},{"location":"apiStm/StupidServoController_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/StupidServoController_8hpp/#function-stupidservodispatch","title":"function stupidServoDispatch","text":"<pre><code>void stupidServoDispatch (\nconst CoprocReq_SetStupidServo &amp; request\n) </code></pre>"},{"location":"apiStm/StupidServoController_8hpp/#function-stupidservoinit","title":"function stupidServoInit","text":"<pre><code>void stupidServoInit () </code></pre>"},{"location":"apiStm/StupidServoController_8hpp/#function-stupidservoreset","title":"function stupidServoReset","text":"<pre><code>void stupidServoReset () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/StupidServoController.hpp</code></p>"},{"location":"apiStm/StupidServoController_8hpp_source/","title":"File StupidServoController.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; StupidServoController.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"rbcx.pb.h\"\n\nvoid stupidServoInit();\nvoid stupidServoDispatch(const CoprocReq_SetStupidServo&amp; request);\nvoid stupidServoReset();\n</code></pre>"},{"location":"apiStm/UltrasoundController_8hpp/","title":"File UltrasoundController.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; UltrasoundController.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"rbcx.pb.h\"</code></li> </ul>"},{"location":"apiStm/UltrasoundController_8hpp/#public-functions","title":"Public Functions","text":"Type Name void ultrasoundDispatch (const CoprocReq_UltrasoundReq &amp; request)  void ultrasoundInit ()  void ultrasoundOnEchoEdge ()  void ultrasoundReset ()"},{"location":"apiStm/UltrasoundController_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/UltrasoundController_8hpp/#function-ultrasounddispatch","title":"function ultrasoundDispatch","text":"<pre><code>void ultrasoundDispatch (\nconst CoprocReq_UltrasoundReq &amp; request\n) </code></pre>"},{"location":"apiStm/UltrasoundController_8hpp/#function-ultrasoundinit","title":"function ultrasoundInit","text":"<pre><code>void ultrasoundInit () </code></pre>"},{"location":"apiStm/UltrasoundController_8hpp/#function-ultrasoundonechoedge","title":"function ultrasoundOnEchoEdge","text":"<pre><code>void ultrasoundOnEchoEdge () </code></pre>"},{"location":"apiStm/UltrasoundController_8hpp/#function-ultrasoundreset","title":"function ultrasoundReset","text":"<pre><code>void ultrasoundReset () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/UltrasoundController.hpp</code></p>"},{"location":"apiStm/UltrasoundController_8hpp_source/","title":"File UltrasoundController.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; UltrasoundController.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"rbcx.pb.h\"\n\nvoid ultrasoundInit();\nvoid ultrasoundDispatch(const CoprocReq_UltrasoundReq&amp; request);\nvoid ultrasoundOnEchoEdge();\nvoid ultrasoundReset();\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8h/","title":"File UsbCdcLink.h","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; UsbCdcLink.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"stm32.h\"</code></li> <li><code>#include \"usb.h\"</code></li> </ul>"},{"location":"apiStm/UsbCdcLink_8h/#public-attributes","title":"Public Attributes","text":"Type Name usbd_device udev"},{"location":"apiStm/UsbCdcLink_8h/#public-functions","title":"Public Functions","text":"Type Name void cdcLinkInit ()  bool cdcLinkIsDebugEpEnabled ()"},{"location":"apiStm/UsbCdcLink_8h/#macros","title":"Macros","text":"Type Name define CDC_DATA_SZ  0x40 define CDC_DEBUG_NTF_EP  0x84 define CDC_DEBUG_RXD_EP  0x02 define CDC_DEBUG_TXD_EP  0x83 define CDC_EP0_SIZE  0x08 define CDC_NTF_SZ  0x08 define CDC_TUNNEL_NTF_EP  0x82 define CDC_TUNNEL_RXD_EP  0x01 define CDC_TUNNEL_TXD_EP  0x81"},{"location":"apiStm/UsbCdcLink_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/UsbCdcLink_8h/#variable-udev","title":"variable udev","text":"<pre><code>usbd_device udev;\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/UsbCdcLink_8h/#function-cdclinkinit","title":"function cdcLinkInit","text":"<pre><code>void cdcLinkInit () </code></pre>"},{"location":"apiStm/UsbCdcLink_8h/#function-cdclinkisdebugepenabled","title":"function cdcLinkIsDebugEpEnabled","text":"<pre><code>bool cdcLinkIsDebugEpEnabled () </code></pre>"},{"location":"apiStm/UsbCdcLink_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/UsbCdcLink_8h/#define-cdc_data_sz","title":"define CDC_DATA_SZ","text":"<pre><code>#define CDC_DATA_SZ 0x40\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8h/#define-cdc_debug_ntf_ep","title":"define CDC_DEBUG_NTF_EP","text":"<pre><code>#define CDC_DEBUG_NTF_EP 0x84\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8h/#define-cdc_debug_rxd_ep","title":"define CDC_DEBUG_RXD_EP","text":"<pre><code>#define CDC_DEBUG_RXD_EP 0x02\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8h/#define-cdc_debug_txd_ep","title":"define CDC_DEBUG_TXD_EP","text":"<pre><code>#define CDC_DEBUG_TXD_EP 0x83\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8h/#define-cdc_ep0_size","title":"define CDC_EP0_SIZE","text":"<pre><code>#define CDC_EP0_SIZE 0x08\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8h/#define-cdc_ntf_sz","title":"define CDC_NTF_SZ","text":"<pre><code>#define CDC_NTF_SZ 0x08\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8h/#define-cdc_tunnel_ntf_ep","title":"define CDC_TUNNEL_NTF_EP","text":"<pre><code>#define CDC_TUNNEL_NTF_EP 0x82\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8h/#define-cdc_tunnel_rxd_ep","title":"define CDC_TUNNEL_RXD_EP","text":"<pre><code>#define CDC_TUNNEL_RXD_EP 0x01\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8h/#define-cdc_tunnel_txd_ep","title":"define CDC_TUNNEL_TXD_EP","text":"<pre><code>#define CDC_TUNNEL_TXD_EP 0x81\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/UsbCdcLink.h</code></p>"},{"location":"apiStm/UsbCdcLink_8h_source/","title":"File UsbCdcLink.h","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; UsbCdcLink.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"stm32.h\"\n#include \"usb.h\"\n\n#define CDC_EP0_SIZE 0x08\n#define CDC_TUNNEL_RXD_EP 0x01\n#define CDC_TUNNEL_TXD_EP 0x81\n#define CDC_TUNNEL_NTF_EP 0x82\n#define CDC_DEBUG_RXD_EP 0x02\n#define CDC_DEBUG_TXD_EP 0x83\n#define CDC_DEBUG_NTF_EP 0x84\n\n#define CDC_DATA_SZ 0x40\n#define CDC_NTF_SZ 0x08\n\nextern usbd_device udev;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid cdcLinkInit();\nbool cdcLinkIsDebugEpEnabled();\n\n#ifdef __cplusplus\n}\n#endif\n</code></pre>"},{"location":"apiStm/dir_14b67ff52aaa9e86c6081715d0ccdb64/","title":"Dir fw/rbcx-coprocessor/include/utils","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils</p>"},{"location":"apiStm/dir_14b67ff52aaa9e86c6081715d0ccdb64/#files","title":"Files","text":"Type Name file BasePriorityRaiser.hpp file ByteFifo.hpp file Debug.hpp file Flash.hpp file HalDma.hpp file MessageBufferWrapper.hpp file MutexWrapper.hpp file QueueWrapper.hpp file Regulator.hpp file StreamBufferWrapper.hpp file TaskWrapper.hpp file TickTimer.hpp file XorShift.hpp <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/utils/</code></p>"},{"location":"apiStm/BasePriorityRaiser_8hpp/","title":"File BasePriorityRaiser.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; BasePriorityRaiser.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"FreeRTOS.h\"</code></li> </ul>"},{"location":"apiStm/BasePriorityRaiser_8hpp/#classes","title":"Classes","text":"Type Name class BasePriorityRaiser &lt;TargetIrqPriority&gt; <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/utils/BasePriorityRaiser.hpp</code></p>"},{"location":"apiStm/BasePriorityRaiser_8hpp_source/","title":"File BasePriorityRaiser.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; BasePriorityRaiser.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"FreeRTOS.h\"\n\ntemplate &lt;uint32_t TargetIrqPriority&gt; class BasePriorityRaiser {\nstatic_assert(\nTargetIrqPriority &gt;= configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY,\n\"The TargetIrqPriority is too high, expected \"\n\"configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY and lower.\");\nstatic_assert(TargetIrqPriority &lt; configLIBRARY_LOWEST_INTERRUPT_PRIORITY,\n\"The TargetIrqPriority is too low, expected \"\n\"configLIBRARY_LOWEST_INTERRUPT_PRIORITY and higher.\");\n\npublic:\nBasePriorityRaiser() {}\n~BasePriorityRaiser() {}\n\nvoid lock() {\nvPortSetBASEPRI(TargetIrqPriority &lt;&lt; 4);\n__asm volatile(\"dsb\" ::: \"memory\");\n__asm volatile(\"isb\");\n}\n\nvoid unlock() { vPortSetBASEPRI(0); }\n\nprivate:\nBasePriorityRaiser(const BasePriorityRaiser&amp;) = delete;\n};\n</code></pre>"},{"location":"apiStm/ByteFifo_8hpp/","title":"File ByteFifo.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; ByteFifo.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"apiStm/ByteFifo_8hpp/#classes","title":"Classes","text":"Type Name class ByteFifo &lt;Size&gt; <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/utils/ByteFifo.hpp</code></p>"},{"location":"apiStm/ByteFifo_8hpp_source/","title":"File ByteFifo.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; ByteFifo.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;algorithm&gt;\n#include &lt;array&gt;\n#include &lt;optional&gt;\n#include &lt;stdint.h&gt;\n\ntemplate &lt;int Size&gt; class ByteFifo {\nstd::array&lt;uint8_t, Size&gt; m_fifo;\nint m_head, m_tail;\n\nint static adjust(int index, int delta) {\nindex += delta;\nif (index &gt;= Size) {\nindex -= Size;\n}\nif (index &lt; 0) {\nindex += Size;\n}\nreturn index;\n}\n\npublic:\nByteFifo()\n: m_head(0)\n, m_tail(0) {}\n\nuint8_t* data() const { return (uint8_t*)m_fifo.data(); }\n\nconstexpr size_t size() const { return m_fifo.size(); }\n\nsize_t available() const {\nif (m_head &gt;= m_tail) {\nreturn m_head - m_tail;\n} else {\nreturn Size - m_tail + m_head;\n}\n}\n\nbool hasData() const { return m_head != m_tail; }\n\nvoid setHead(int newHead) { m_head = newHead; }\n\nvoid clear() { m_tail = m_head; }\n\nvoid writeSpan(uint8_t* data, size_t len) {\nif (len &gt; Size) {\ndata += len - Size;\nlen = Size;\n}\n\nconst size_t chunk = std::min(size_t(Size - m_head), len);\nstd::copy_n(data, chunk, this-&gt;data() + m_head);\nif (len &gt; chunk) {\nstd::copy_n(data + chunk, len - chunk, this-&gt;data());\n}\nnotifyWritten(len);\n}\n\nstd::pair&lt;uint8_t*, size_t&gt; writeableSpan() const {\nint preTail = adjust(m_tail, -1);\nreturn m_head &gt;= preTail\n? std::make_pair(data() + m_head, std::max(0, int(size()) - m_head))\n: std::make_pair(data() + m_head, std::max(0, preTail - m_head));\n}\n\nvoid notifyWritten(size_t len) { m_head = adjust(m_head, len); }\n\nuint8_t pop() {\nauto value = m_fifo[m_tail];\nm_tail = adjust(m_tail, 1);\nreturn value;\n}\n\nvoid push(uint8_t b) {\nm_fifo[m_head] = b;\nnotifyWritten(1);\n}\n\nvoid peekSpan(uint8_t* data, size_t len) {\nconst size_t chunk = std::min(size_t(Size - m_tail), len);\nmemcpy(data, this-&gt;data() + m_tail, chunk);\nif (chunk &lt; len) {\nmemcpy(data + chunk, this-&gt;data(), len - chunk);\n}\n}\n\nstd::pair&lt;uint8_t*, size_t&gt; readableSpan() const {\nreturn m_head &gt;= m_tail\n? std::make_pair(data() + m_tail, m_head - m_tail)\n: std::make_pair(data() + m_tail, int(size()) - m_tail);\n}\n\nvoid notifyRead(size_t len) { m_tail = adjust(m_tail, len); }\n};\n</code></pre>"},{"location":"apiStm/Debug_8hpp/","title":"File Debug.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; Debug.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"task.h\"</code></li> </ul>"},{"location":"apiStm/Debug_8hpp/#public-functions","title":"Public Functions","text":"Type Name void DEBUG_HEX (const uint8_t * data, size_t len)  bool isInInterrupt ()  void printTaskInfo ()  void rebootToDfu ()"},{"location":"apiStm/Debug_8hpp/#macros","title":"Macros","text":"Type Name define DEBUG (fmt, ...)  define DEBUGLN (fmt, ...)  define STRINGIFY (x) #x define TOSTRING (x) STRINGIFY(x)"},{"location":"apiStm/Debug_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/Debug_8hpp/#function-debug_hex","title":"function DEBUG_HEX","text":"<pre><code>inline void DEBUG_HEX (\nconst uint8_t * data,\nsize_t len\n) </code></pre>"},{"location":"apiStm/Debug_8hpp/#function-isininterrupt","title":"function isInInterrupt","text":"<pre><code>inline bool isInInterrupt () </code></pre>"},{"location":"apiStm/Debug_8hpp/#function-printtaskinfo","title":"function printTaskInfo","text":"<pre><code>inline void printTaskInfo () </code></pre>"},{"location":"apiStm/Debug_8hpp/#function-reboottodfu","title":"function rebootToDfu","text":"<pre><code>void rebootToDfu () </code></pre>"},{"location":"apiStm/Debug_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/Debug_8hpp/#define-debug","title":"define DEBUG","text":"<pre><code>#define DEBUG (\nfmt,\n...\n) printf(\"[%10lu][\" __FILE__ \":\" TOSTRING(__LINE__) \"]: \" fmt,               \\\n        xTaskGetTickCount(), ##__VA_ARGS__)\n</code></pre>"},{"location":"apiStm/Debug_8hpp/#define-debugln","title":"define DEBUGLN","text":"<pre><code>#define DEBUGLN (\nfmt,\n...\n) DEBUG(fmt, ##__VA_ARGS__);                                                 \\\n    printf(\"\\n\");\n</code></pre>"},{"location":"apiStm/Debug_8hpp/#define-stringify","title":"define STRINGIFY","text":"<pre><code>#define STRINGIFY (\nx\n) #x\n</code></pre>"},{"location":"apiStm/Debug_8hpp/#define-tostring","title":"define TOSTRING","text":"<pre><code>#define TOSTRING (\nx\n) STRINGIFY(x)\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/utils/Debug.hpp</code></p>"},{"location":"apiStm/Debug_8hpp_source/","title":"File Debug.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; Debug.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;array&gt;\n\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n\n#define STRINGIFY(x) #x\n#define TOSTRING(x) STRINGIFY(x)\n\n#ifndef NDEBUG\n\n#define DEBUG(fmt, ...)                                                        \\\n    printf(\"[%10lu][\" __FILE__ \":\" TOSTRING(__LINE__) \"]: \" fmt,               \\\n        xTaskGetTickCount(), ##__VA_ARGS__)\n\ninline void DEBUG_HEX(const uint8_t* data, size_t len) {\nstatic const char* hex = \"0123456789ABCDEF\";\nchar buf[] = { '0', '0', ' ' };\n\nfor (size_t i = 0; i &lt; len; ++i) {\nbuf[0] = hex[data[i] &gt;&gt; 4];\nbuf[1] = hex[data[i] &amp; 0xF];\nfwrite(buf, sizeof(buf), 1, stdout);\n}\nputchar('\\n');\n}\n\n#define DEBUGLN(fmt, ...)                                                      \\\n    DEBUG(fmt, ##__VA_ARGS__);                                                 \\\n    printf(\"\\n\");\n\n#else\n\n#define DEBUG(fmt, ...)                                                        \\\n    do {                                                                       \\\n    } while (0);\n\ninline void DEBUG_HEX(const uint8_t* data, size_t len) {}\n#endif\n\ninline void printTaskInfo() {\nstd::array&lt;TaskStatus_t, 10&gt; statuses;\n\nunsigned taskNum\n= uxTaskGetSystemState(statuses.data(), statuses.size(), nullptr);\n\nprintf(\"Task stacks:\\n\");\nfor (unsigned i = 0; i &lt; taskNum; i++) {\nauto&amp; status = statuses[i];\n\n// Thanks FreeRTOS, because you don't allow reading pxEndOfStack\n// to obtain the total stack size of a task,\n// I have to use your stupid Dummy fields.\nauto stupidTask = (StaticTask_t*)(status.xHandle);\nunsigned bytesTotal\n= uintptr_t(stupidTask-&gt;pxDummy8) - uintptr_t(stupidTask-&gt;pxDummy6);\n\nunsigned bytesFree = status.usStackHighWaterMark * sizeof(StackType_t);\n\nprintf(\"#%d %s: %u bytes untouched (of %u)\\n\", status.xTaskNumber,\nstatus.pcTaskName, bytesFree, bytesTotal);\n}\n}\n\ninline bool isInInterrupt() {\nreturn (SCB-&gt;ICSR &amp; SCB_ICSR_VECTACTIVE_Msk) != 0;\n}\n\nvoid rebootToDfu();\n</code></pre>"},{"location":"apiStm/Flash_8hpp/","title":"File Flash.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; Flash.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include \"stm32f1xx_hal.h\"</code></li> <li><code>#include \"stm32f1xx_hal_flash.h\"</code></li> </ul>"},{"location":"apiStm/Flash_8hpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr uint32_t FLASH_PAGE_POWER_CALIBRATION   = = FLASH_BANK1_END + 1 - FLASH_PAGE_SIZE"},{"location":"apiStm/Flash_8hpp/#public-functions","title":"Public Functions","text":"Type Name void flashWritePage (uint32_t pageAddress, uint8_t * data, size_t size)"},{"location":"apiStm/Flash_8hpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"apiStm/Flash_8hpp/#variable-flash_page_power_calibration","title":"variable FLASH_PAGE_POWER_CALIBRATION","text":"<pre><code>constexpr uint32_t FLASH_PAGE_POWER_CALIBRATION;\n</code></pre>"},{"location":"apiStm/Flash_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/Flash_8hpp/#function-flashwritepage","title":"function flashWritePage","text":"<pre><code>inline void flashWritePage (\nuint32_t pageAddress,\nuint8_t * data,\nsize_t size\n) </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/utils/Flash.hpp</code></p>"},{"location":"apiStm/Flash_8hpp_source/","title":"File Flash.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; Flash.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;stdlib.h&gt;\n\n#include \"stm32f1xx_hal.h\"\n#include \"stm32f1xx_hal_flash.h\"\n\nstatic constexpr uint32_t FLASH_PAGE_POWER_CALIBRATION\n= FLASH_BANK1_END + 1 - FLASH_PAGE_SIZE;\n\ninline void flashWritePage(uint32_t pageAddress, uint8_t* data, size_t size) {\nif (pageAddress % FLASH_PAGE_SIZE != 0 || pageAddress &lt; FLASH_BASE\n|| pageAddress &gt;= FLASH_BANK1_END) {\nabort();\n}\n\nif (size &gt; FLASH_PAGE_SIZE || size % 2 != 0) {\nabort();\n}\n\nif (HAL_FLASH_Unlock() != HAL_OK)\nabort();\n\nFLASH_EraseInitTypeDef eraseCfg = {\n.TypeErase = FLASH_TYPEERASE_PAGES,\n.Banks = FLASH_BANK_1,\n.PageAddress = pageAddress,\n.NbPages = 1,\n};\nuint32_t pageError = 0;\nif (HAL_FLASHEx_Erase(&amp;eraseCfg, &amp;pageError) != HAL_OK)\nabort();\n\nuint32_t address = pageAddress;\nuint8_t* end = data + size;\n\nwhile (end - data &gt;= 8) {\nif (HAL_FLASH_Program(\nFLASH_TYPEPROGRAM_DOUBLEWORD, address, *(uint64_t*)data)\n!= HAL_OK)\nabort();\naddress += 8;\ndata += 8;\n}\n\nwhile (end - data &gt;= 2) {\nif (HAL_FLASH_Program(\nFLASH_TYPEPROGRAM_DOUBLEWORD, address, *(uint16_t*)data)\n!= HAL_OK)\nabort();\naddress += 2;\ndata += 2;\n}\n\nif (HAL_FLASH_Lock() != HAL_OK)\nabort();\n}\n</code></pre>"},{"location":"apiStm/HalDma_8hpp/","title":"File HalDma.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; HalDma.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"stm32f1xx_hal_dma.h\"</code></li> </ul>"},{"location":"apiStm/HalDma_8hpp/#public-functions","title":"Public Functions","text":"Type Name HAL_StatusTypeDef HAL_DMA_PollForTransfer_Really (DMA_HandleTypeDef * hdma, uint32_t CompleteLevel, uint32_t Timeout)"},{"location":"apiStm/HalDma_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/HalDma_8hpp/#function-hal_dma_pollfortransfer_really","title":"function HAL_DMA_PollForTransfer_Really","text":"<pre><code>inline HAL_StatusTypeDef HAL_DMA_PollForTransfer_Really (\nDMA_HandleTypeDef * hdma,\nuint32_t CompleteLevel,\nuint32_t Timeout\n) </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/utils/HalDma.hpp</code></p>"},{"location":"apiStm/HalDma_8hpp_source/","title":"File HalDma.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; HalDma.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"stm32f1xx_hal_dma.h\"\n\n// HAL_DMA_PollForTransfer, despite its name, can't be used\n// for polling. When it hits timeout (even the 0 one), HAL_DMA_STATE_READY is set\n// into the State member, regardless of whether the transfer is actually done or not.\n// So you can't poll for whether the transfer is done. With the Poll function. What the fuck.\n//\n// This version will never set the State to HAL_DMA_STATE_READY on Timeout,\n// only on error or when it is really done.\n//\n// Countless hours were wasted because of this garbage.\n//\n// Copied from https://github.com/STMicroelectronics/STM32CubeF1/blob/441b2cbdc25aa50437a59c4bffe22b88e78942c9/Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_dma.c\ninline HAL_StatusTypeDef HAL_DMA_PollForTransfer_Really(\nDMA_HandleTypeDef* hdma, uint32_t CompleteLevel, uint32_t Timeout) {\nuint32_t temp;\nuint32_t tickstart = 0U;\n\nif (HAL_DMA_STATE_BUSY != hdma-&gt;State) {\n/* no transfer ongoing */\nhdma-&gt;ErrorCode = HAL_DMA_ERROR_NO_XFER;\n__HAL_UNLOCK(hdma);\nreturn HAL_ERROR;\n}\n\n/* Polling mode not supported in circular mode */\nif (RESET != (hdma-&gt;Instance-&gt;CCR &amp; DMA_CCR_CIRC)) {\nhdma-&gt;ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;\nreturn HAL_ERROR;\n}\n\n/* Get the level transfer complete flag */\nif (CompleteLevel == HAL_DMA_FULL_TRANSFER) {\n/* Transfer Complete flag */\ntemp = __HAL_DMA_GET_TC_FLAG_INDEX(hdma);\n} else {\n/* Half Transfer Complete flag */\ntemp = __HAL_DMA_GET_HT_FLAG_INDEX(hdma);\n}\n\n/* Get tick */\ntickstart = HAL_GetTick();\n\nwhile (__HAL_DMA_GET_FLAG(hdma, temp) == RESET) {\nif ((__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma))\n!= RESET)) {\n/* When a DMA transfer error occurs */\n/* A hardware clear of its EN bits is performed */\n/* Clear all flags */\nhdma-&gt;DmaBaseAddress-&gt;IFCR = (DMA_ISR_GIF1 &lt;&lt; hdma-&gt;ChannelIndex);\n\n/* Update error code */\nSET_BIT(hdma-&gt;ErrorCode, HAL_DMA_ERROR_TE);\n\n/* Change the DMA state */\nhdma-&gt;State = HAL_DMA_STATE_READY;\n\n/* Process Unlocked */\n__HAL_UNLOCK(hdma);\n\nreturn HAL_ERROR;\n}\n/* Check for the Timeout */\nif (Timeout != HAL_MAX_DELAY) {\nif ((Timeout == 0U) || ((HAL_GetTick() - tickstart) &gt; Timeout)) {\n/* Update error code */\nSET_BIT(hdma-&gt;ErrorCode, HAL_DMA_ERROR_TIMEOUT);\n\n/* Change the DMA state */\n// Disabled, because it makes no fucking sense.\n//hdma-&gt;State = HAL_DMA_STATE_READY;\n\n/* Process Unlocked */\n\n// Don't unlock until transfer done.\n//__HAL_UNLOCK(hdma);\n\nreturn HAL_ERROR;\n}\n}\n}\n\nif (CompleteLevel == HAL_DMA_FULL_TRANSFER) {\n/* Clear the transfer complete flag */\n__HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));\n\n/* The selected Channelx EN bit is cleared (DMA is disabled and\n    all transfers are complete) */\nhdma-&gt;State = HAL_DMA_STATE_READY;\n} else {\n/* Clear the half transfer complete flag */\n__HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));\n}\n\n/* Process unlocked */\n__HAL_UNLOCK(hdma);\n\nreturn HAL_OK;\n}\n</code></pre>"},{"location":"apiStm/MessageBufferWrapper_8hpp/","title":"File MessageBufferWrapper.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; MessageBufferWrapper.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"message_buffer.h\"</code></li> <li><code>#include \"Debug.hpp\"</code></li> </ul>"},{"location":"apiStm/MessageBufferWrapper_8hpp/#classes","title":"Classes","text":"Type Name class MessageBufferWrapper &lt;SizeInBytes&gt; <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/utils/MessageBufferWrapper.hpp</code></p>"},{"location":"apiStm/MessageBufferWrapper_8hpp_source/","title":"File MessageBufferWrapper.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; MessageBufferWrapper.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;stdint.h&gt;\n\n#include \"FreeRTOS.h\"\n#include \"message_buffer.h\"\n\n#include \"Debug.hpp\"\n\ntemplate &lt;size_t SizeInBytes&gt; class MessageBufferWrapper {\npublic:\nMessageBufferWrapper()\n: m_handle(nullptr) {}\n\n~MessageBufferWrapper() {\nif (m_handle)\nvMessageBufferDelete(m_handle);\n}\n\nvoid create() {\nif (m_handle)\nabort();\nm_handle = xMessageBufferCreateStatic(\nSizeInBytes, m_buffer, &amp;m_bufferStruct);\n}\n\nMessageBufferHandle_t handle() const { return m_handle; }\n\nbool reset() { return xMessageBufferReset(m_handle) == pdPASS; }\n\nbool push_back(uint8_t* data, size_t len, TickType_t ticks_to_wait,\nBaseType_t* pxHigherPriorityTaskWoken = nullptr) {\nsize_t res;\nif (isInInterrupt()) {\nres = xMessageBufferSendFromISR(\nm_handle, (void*)data, len, pxHigherPriorityTaskWoken);\n} else {\nres = xMessageBufferSend(m_handle, (void*)data, len, ticks_to_wait);\n}\nreturn res == len;\n}\n\ntemplate &lt;typename T&gt;\nbool push_back(const T&amp; val, TickType_t ticks_to_wait,\nBaseType_t* pxHigherPriorityTaskWoken = nullptr) {\nstatic_assert(std::is_trivial&lt;T&gt;::value);\nreturn push_back((uint8_t*)&amp;val, sizeof(T), ticks_to_wait,\npxHigherPriorityTaskWoken);\n}\n\nsize_t pop_front(uint8_t* dst, size_t maxLen, TickType_t ticks_to_wait,\nBaseType_t* pxHigherPriorityTaskWoken = nullptr) {\nsize_t res;\nif (isInInterrupt()) {\nres = xMessageBufferReceiveFromISR(\nm_handle, (void*)dst, maxLen, pxHigherPriorityTaskWoken);\n} else {\nres = xMessageBufferReceive(\nm_handle, (void*)dst, maxLen, ticks_to_wait);\n}\nreturn res;\n}\n\ntemplate &lt;typename T&gt;\nbool pop_front(T&amp; dst, TickType_t ticks_to_wait,\nBaseType_t* pxHigherPriorityTaskWoken = nullptr) {\nstatic_assert(std::is_trivial&lt;T&gt;::value);\n\nconst auto res = pop_front(\n(uint8_t*)dst, sizeof(T), ticks_to_wait, pxHigherPriorityTaskWoken);\nif (res &gt; 0 &amp;&amp; res != sizeof(T))\nabort();\nreturn res != 0;\n}\n\nprivate:\nuint8_t m_buffer[SizeInBytes];\nStaticMessageBuffer_t m_bufferStruct;\nMessageBufferHandle_t m_handle;\n};\n</code></pre>"},{"location":"apiStm/MutexWrapper_8hpp/","title":"File MutexWrapper.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; MutexWrapper.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"semphr.h\"</code></li> </ul>"},{"location":"apiStm/MutexWrapper_8hpp/#classes","title":"Classes","text":"Type Name class MutexWrapper <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/utils/MutexWrapper.hpp</code></p>"},{"location":"apiStm/MutexWrapper_8hpp_source/","title":"File MutexWrapper.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; MutexWrapper.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"FreeRTOS.h\"\n#include \"semphr.h\"\n\nclass MutexWrapper {\npublic:\nMutexWrapper()\n: m_handle(nullptr) {}\n\n~MutexWrapper() {\nif (m_handle)\nvSemaphoreDelete(m_handle);\n}\n\nvoid create() {\nif (m_handle)\nabort();\n\nm_handle = xSemaphoreCreateMutexStatic(&amp;m_buffer);\n}\n\nSemaphoreHandle_t native_handle() const { return m_handle; }\n\nvoid lock() { xSemaphoreTake(m_handle, portMAX_DELAY); }\nvoid unlock() { xSemaphoreGive(m_handle); }\n\nprivate:\nSemaphoreHandle_t m_handle;\nStaticSemaphore_t m_buffer;\n};\n</code></pre>"},{"location":"apiStm/QueueWrapper_8hpp/","title":"File QueueWrapper.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; QueueWrapper.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include \"Debug.hpp\"</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"queue.h\"</code></li> </ul>"},{"location":"apiStm/QueueWrapper_8hpp/#classes","title":"Classes","text":"Type Name class QueueWrapper &lt;typename T, Length&gt; <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/utils/QueueWrapper.hpp</code></p>"},{"location":"apiStm/QueueWrapper_8hpp_source/","title":"File QueueWrapper.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; QueueWrapper.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;type_traits&gt;\n\n#include \"Debug.hpp\"\n#include \"FreeRTOS.h\"\n#include \"queue.h\"\n\ntemplate &lt;typename T, UBaseType_t Length&gt; class QueueWrapper {\nstatic_assert(std::is_trivial&lt;T&gt;::value);\n\npublic:\nQueueWrapper()\n: m_handle(nullptr) {}\n\n~QueueWrapper() {\nif (m_handle)\nvQueueDelete(m_handle);\n}\n\nvoid create() {\nm_handle\n= xQueueCreateStatic(Length, sizeof(T), m_buffer, &amp;m_queueStruct);\n}\n\nQueueHandle_t handle() const { return m_handle; }\n\nvoid reset() { xQueueReset(m_handle); }\n\nbool push_back(const T&amp; val, TickType_t ticks_to_wait = portMAX_DELAY,\nBaseType_t* pxHigherPriorityTaskWoken = nullptr) {\nBaseType_t res;\nif (isInInterrupt()) {\nres = xQueueSendToBackFromISR(\nm_handle, &amp;val, pxHigherPriorityTaskWoken);\n} else {\nres = xQueueSendToBack(m_handle, &amp;val, ticks_to_wait);\n}\nreturn res == pdPASS;\n}\n\nbool overwrite(\nconst T&amp; val, BaseType_t* pxHigherPriorityTaskWoken = nullptr) {\nBaseType_t res;\nif (isInInterrupt()) {\nres = xQueueOverwriteFromISR(\nm_handle, &amp;val, pxHigherPriorityTaskWoken);\n} else {\nres = xQueueOverwrite(m_handle, &amp;val);\n}\nreturn res == pdPASS;\n}\n\nbool push_front(const T&amp; val, TickType_t ticks_to_wait = portMAX_DELAY,\nBaseType_t* pxHigherPriorityTaskWoken = nullptr) {\nBaseType_t res;\nif (isInInterrupt()) {\nres = xQueueSendToFrontFromISR(\nm_handle, &amp;val, pxHigherPriorityTaskWoken);\n} else {\nres = xQueueSendToFront(m_handle, &amp;val, ticks_to_wait);\n}\nreturn res == pdPASS;\n}\n\nbool pop_front(T&amp; result, TickType_t ticks_to_wait = portMAX_DELAY,\nBaseType_t* pxHigherPriorityTaskWoken = nullptr) {\nBaseType_t res;\nif (isInInterrupt()) {\nres = xQueueReceiveFromISR(\nm_handle, &amp;result, pxHigherPriorityTaskWoken);\n} else {\nres = xQueueReceive(m_handle, &amp;result, ticks_to_wait);\n}\nreturn res == pdTRUE;\n}\n\nprivate:\nQueueWrapper(const QueueWrapper&amp;) = delete;\n\nuint8_t m_buffer[sizeof(T) * Length];\nStaticQueue_t m_queueStruct;\nQueueHandle_t m_handle;\n};\n</code></pre>"},{"location":"apiStm/Regulator_8hpp/","title":"File Regulator.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; Regulator.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"apiStm/Regulator_8hpp/#classes","title":"Classes","text":"Type Name struct Regulator <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/utils/Regulator.hpp</code></p>"},{"location":"apiStm/Regulator_8hpp_source/","title":"File Regulator.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; Regulator.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;stdint.h&gt;\n\nstruct Regulator {\ntypedef uint32_t coef_type;\ntypedef int32_t value_type;\n\nconstexpr Regulator&amp; operator=(Regulator&amp;&amp; other) = default;\n\nRegulator() = default;\nRegulator(value_type max_output, coef_type p, coef_type i, coef_type d)\n: m_stop(false)\n, m_p(p)\n, m_i(i)\n, m_d(d)\n, m_e(0)\n, m_le(0)\n, m_de(0)\n, m_output(0)\n, m_integrator(0)\n, m_max_output(max_output) {}\n\nvoid setP(const coef_type&amp; v) { m_p = v; }\ncoef_type P() const { return m_p; }\nvoid setI(const coef_type&amp; v) { m_i = v; }\ncoef_type I() const { return m_i; }\nvoid setD(const coef_type&amp; v) { m_d = v; }\ncoef_type D() const { return m_d; }\nvoid setMaxOutput(value_type max_output) { m_max_output = max_output; }\nvalue_type maxOutput() { return m_max_output; }\n\nvoid stop(bool s = true) {\nm_stop = s;\nm_e = 0;\nm_le = 0;\nm_de = 0;\nm_integrator = 0;\n}\n\nvalue_type process(value_type target, value_type actual) {\nif (m_stop)\nreturn 0;\nm_e = target - actual;\n\nvalue_type integrator = m_integrator;\n\nif (m_i != 0)\nintegrator += m_e;\n\nm_de = m_e - m_le;\n\nvalue_type x = ((value_type(m_p) * m_e) &gt;&gt; 8)\n+ ((value_type(m_d) * m_de) &gt;&gt; 8)\n+ ((value_type(m_i) * integrator) &gt;&gt; 8);\n\nif (x &gt; m_max_output) {\nm_output = m_max_output;\nif (integrator &lt; 0)\nm_integrator = integrator;\n} else if (x &lt; -m_max_output) {\nm_output = -m_max_output;\nif (integrator &gt; 0)\nm_integrator = integrator;\n} else {\nm_output = x;\nm_integrator = integrator;\n}\nm_le = m_e;\nreturn m_output;\n}\n\nvoid clear() {\nm_integrator = 0;\nm_le = m_e;\n}\n\nvalue_type e() const { return m_e; }\nvalue_type de() const { return m_de; }\nvalue_type output() const { return m_output; }\nvalue_type integrator() const { return m_integrator; }\n\nprivate:\nbool m_stop;\ncoef_type m_p;\ncoef_type m_i;\ncoef_type m_d;\nvalue_type m_e;\nvalue_type m_le;\nvalue_type m_de;\nvalue_type m_output;\nvalue_type m_integrator;\nvalue_type m_max_output; //crop output, absolute value\n};\n</code></pre>"},{"location":"apiStm/StreamBufferWrapper_8hpp/","title":"File StreamBufferWrapper.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; StreamBufferWrapper.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"stream_buffer.h\"</code></li> <li><code>#include \"Debug.hpp\"</code></li> </ul>"},{"location":"apiStm/StreamBufferWrapper_8hpp/#classes","title":"Classes","text":"Type Name class StreamBufferWrapper &lt;SizeInBytes&gt; <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/utils/StreamBufferWrapper.hpp</code></p>"},{"location":"apiStm/StreamBufferWrapper_8hpp_source/","title":"File StreamBufferWrapper.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; StreamBufferWrapper.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;stdint.h&gt;\n\n#include \"FreeRTOS.h\"\n#include \"stream_buffer.h\"\n\n#include \"Debug.hpp\"\n\ntemplate &lt;size_t SizeInBytes&gt; class StreamBufferWrapper {\npublic:\nStreamBufferWrapper()\n: m_handle(nullptr) {}\n\n~StreamBufferWrapper() {\nif (m_handle)\nvStreamBufferDelete(m_handle);\n}\n\nvoid create(size_t xTriggerLevelBytes = 1) {\nif (m_handle)\nabort();\nif (xTriggerLevelBytes &gt; SizeInBytes)\nabort();\n\nm_handle = xStreamBufferCreateStatic(\nSizeInBytes, xTriggerLevelBytes, m_buffer, &amp;m_bufferStruct);\n}\n\nStreamBufferHandle_t handle() const { return m_handle; }\n\nbool reset() { return xStreamBufferReset(m_handle) == pdPASS; }\n\nsize_t freeSpace() const { return xStreamBufferSpacesAvailable(m_handle); }\nsize_t available() const { return xStreamBufferBytesAvailable(m_handle); }\n\nsize_t write(const uint8_t* const data, size_t len,\nTickType_t ticks_to_wait,\nBaseType_t* pxHigherPriorityTaskWoken = nullptr) {\nsize_t res;\nif (isInInterrupt()) {\nres = xStreamBufferSendFromISR(\nm_handle, (void*)data, len, pxHigherPriorityTaskWoken);\n} else {\nres = xStreamBufferSend(m_handle, (void*)data, len, ticks_to_wait);\n}\nreturn res;\n}\n\nsize_t read(uint8_t* dst, size_t maxLen, TickType_t ticks_to_wait,\nBaseType_t* pxHigherPriorityTaskWoken = nullptr) {\nsize_t res;\nif (isInInterrupt()) {\nres = xStreamBufferReceiveFromISR(\nm_handle, (void*)dst, maxLen, pxHigherPriorityTaskWoken);\n} else {\nres = xStreamBufferReceive(\nm_handle, (void*)dst, maxLen, ticks_to_wait);\n}\nreturn res;\n}\n\nprivate:\nuint8_t m_buffer[SizeInBytes];\nStaticStreamBuffer_t m_bufferStruct;\nStreamBufferHandle_t m_handle;\n};\n</code></pre>"},{"location":"apiStm/TaskWrapper_8hpp/","title":"File TaskWrapper.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; TaskWrapper.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"task.h\"</code></li> </ul>"},{"location":"apiStm/TaskWrapper_8hpp/#classes","title":"Classes","text":"Type Name class TaskWrapper &lt;StackSizeBytes&gt; <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/utils/TaskWrapper.hpp</code></p>"},{"location":"apiStm/TaskWrapper_8hpp_source/","title":"File TaskWrapper.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; TaskWrapper.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;functional&gt;\n\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n\ntemplate &lt;int StackSizeBytes&gt; class TaskWrapper {\npublic:\nTaskWrapper()\n: m_handle(nullptr) {}\n\n~TaskWrapper() { abort(); }\n\nbool start(\nconst char* name, UBaseType_t priority, std::function&lt;void()&gt;&amp;&amp; func) {\nif (m_handle)\nreturn false;\nm_func = std::move(func);\nm_handle = xTaskCreateStatic(&amp;trampoline, name,\nStackSizeBytes / sizeof(StackType_t), &amp;m_func, priority, m_stack,\n&amp;m_taskStruct);\nreturn m_handle != nullptr;\n}\n\nTaskHandle_t handle() const { return m_handle; }\n\nprivate:\nTaskWrapper(const TaskWrapper&amp;) = delete;\n\nstatic void trampoline(void* arg) {\nconst auto* func = (std::function&lt;void()&gt;*)arg;\n(*func)();\n}\n\nStackType_t m_stack[StackSizeBytes / sizeof(StackType_t)];\nStaticTask_t m_taskStruct;\nstd::function&lt;void()&gt; m_func;\nTaskHandle_t m_handle;\n};\n</code></pre>"},{"location":"apiStm/TickTimer_8hpp/","title":"File TickTimer.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; TickTimer.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"task.h\"</code></li> </ul>"},{"location":"apiStm/TickTimer_8hpp/#classes","title":"Classes","text":"Type Name class TickTimer <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/utils/TickTimer.hpp</code></p>"},{"location":"apiStm/TickTimer_8hpp_source/","title":"File TickTimer.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; TickTimer.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;stdint.h&gt;\n#include &lt;stdlib.h&gt;\n\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n\nclass TickTimer {\nstatic constexpr uint32_t MaxDelay = UINT32_MAX / 2;\n\npublic:\nTickTimer()\n: m_timeoutAt(0) {}\n~TickTimer() {}\n\nbool isActive() const { return m_timeoutAt != 0; }\n\nvoid stop() { m_timeoutAt = 0; }\n\nvoid restart(uint32_t delayMs) {\nif (pdMS_TO_TICKS(delayMs) &gt; MaxDelay) {\nabort();\n}\n\nconst auto now = xTaskGetTickCount();\nm_timeoutAt = now + pdMS_TO_TICKS(delayMs);\nif (m_timeoutAt == 0)\n++m_timeoutAt;\n}\n\nbool poll() {\nif (m_timeoutAt == 0)\nreturn false;\n\nconst uint32_t now = xTaskGetTickCount();\nif (now &lt; m_timeoutAt)\nreturn false;\n\n// m_timeoutAt wrapped around, but xTaskGetTickCount didn't yet\nif (now - m_timeoutAt &gt; MaxDelay)\nreturn false;\nm_timeoutAt = 0;\nreturn true;\n}\n\nprivate:\nuint32_t m_timeoutAt;\n};\n</code></pre>"},{"location":"apiStm/XorShift_8hpp/","title":"File XorShift.hpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; XorShift.hpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"apiStm/XorShift_8hpp/#classes","title":"Classes","text":"Type Name class XorShift Fast deterministic PRNG - https://en.wikipedia.org/wiki/Xorshift . <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/include/utils/XorShift.hpp</code></p>"},{"location":"apiStm/XorShift_8hpp_source/","title":"File XorShift.hpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; include &gt; utils &gt; XorShift.hpp</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;stdint.h&gt;\n\nclass XorShift {\nuint32_t m_state;\n\npublic:\nXorShift(uint32_t seed = 0xb45d9453)\n: m_state(seed) {}\n\nuint32_t next() {\nuint32_t x = m_state;\nx ^= x &lt;&lt; 13;\nx ^= x &gt;&gt; 17;\nx ^= x &lt;&lt; 5;\nreturn m_state = x;\n}\n};\n</code></pre>"},{"location":"apiStm/dir_1f351607af1ca5dc8115007d2c3c4559/","title":"Dir fw/rbcx-coprocessor/lib","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; lib</p>"},{"location":"apiStm/dir_1f351607af1ca5dc8115007d2c3c4559/#directories","title":"Directories","text":"Type Name dir FreeRTOS dir libusb_stm32 <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/</code></p>"},{"location":"apiStm/dir_6728f3a9088eeb382ccd8bff3a2a4804/","title":"Dir fw/rbcx-coprocessor/lib/FreeRTOS","text":"<p>FileList &gt; FreeRTOS</p>"},{"location":"apiStm/dir_6728f3a9088eeb382ccd8bff3a2a4804/#directories","title":"Directories","text":"Type Name dir include dir src <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/</code></p>"},{"location":"apiStm/dir_e69eea06f0148442287c48e06ff575f4/","title":"Dir fw/rbcx-coprocessor/lib/FreeRTOS/include","text":"<p>FileList &gt; FreeRTOS &gt; include</p>"},{"location":"apiStm/dir_e69eea06f0148442287c48e06ff575f4/#files","title":"Files","text":"Type Name file FreeRTOS.h file atomic.h FreeRTOS atomic operation support. file croutine.h file deprecated_definitions.h file event_groups.h file list.h file message_buffer.h file mpu_prototypes.h file mpu_wrappers.h file portable.h file projdefs.h file queue.h file semphr.h file stack_macros.h file stream_buffer.h file task.h file timers.h <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/</code></p>"},{"location":"apiStm/FreeRTOS_8h/","title":"File FreeRTOS.h","text":"<p>FileList &gt; FreeRTOS &gt; include &gt; FreeRTOS.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stddef.h&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include \"FreeRTOSConfig.h\"</code></li> <li><code>#include \"projdefs.h\"</code></li> <li><code>#include \"portable.h\"</code></li> </ul>"},{"location":"apiStm/FreeRTOS_8h/#classes","title":"Classes","text":"Type Name struct xSTATIC_EVENT_GROUP struct xSTATIC_LIST struct xSTATIC_LIST_ITEM struct xSTATIC_MINI_LIST_ITEM struct xSTATIC_QUEUE struct xSTATIC_STREAM_BUFFER struct xSTATIC_TCB struct xSTATIC_TIMER"},{"location":"apiStm/FreeRTOS_8h/#public-types","title":"Public Types","text":"Type Name typedef struct xSTATIC_EVENT_GROUP StaticEventGroup_t typedef struct xSTATIC_LIST_ITEM StaticListItem_t typedef struct xSTATIC_LIST StaticList_t typedef StaticStreamBuffer_t StaticMessageBuffer_t typedef struct xSTATIC_MINI_LIST_ITEM StaticMiniListItem_t typedef struct xSTATIC_QUEUE StaticQueue_t typedef StaticQueue_t StaticSemaphore_t typedef struct xSTATIC_STREAM_BUFFER StaticStreamBuffer_t typedef struct xSTATIC_TCB StaticTask_t typedef struct xSTATIC_TIMER StaticTimer_t"},{"location":"apiStm/FreeRTOS_8h/#macros","title":"Macros","text":"Type Name define INCLUDE_eTaskGetState  0 define INCLUDE_uxTaskGetStackHighWaterMark  0 define INCLUDE_uxTaskGetStackHighWaterMark2  0 define INCLUDE_uxTaskPriorityGet  0 define INCLUDE_vTaskDelay  0 define INCLUDE_vTaskDelayUntil  0 define INCLUDE_vTaskDelete  0 define INCLUDE_vTaskPrioritySet  0 define INCLUDE_vTaskSuspend  0 define INCLUDE_xQueueGetMutexHolder  0 define INCLUDE_xSemaphoreGetMutexHolder  INCLUDE_xQueueGetMutexHolder define INCLUDE_xTaskAbortDelay  0 define INCLUDE_xTaskGetCurrentTaskHandle  0 define INCLUDE_xTaskGetHandle  0 define INCLUDE_xTaskGetIdleTaskHandle  0 define INCLUDE_xTaskGetSchedulerState  0 define INCLUDE_xTaskResumeFromISR  1 define INCLUDE_xTimerPendFunctionCall  0 define configAPPLICATION_ALLOCATED_HEAP  0 define configASSERT (x)  define configASSERT_DEFINED  0 define configCHECK_FOR_STACK_OVERFLOW  0 define configENABLE_BACKWARD_COMPATIBILITY  1 define configENABLE_FPU  1 define configENABLE_MPU  0 define configENABLE_TRUSTZONE  1 define configEXPECTED_IDLE_TIME_BEFORE_SLEEP  2 define configGENERATE_RUN_TIME_STATS  0 define configIDLE_SHOULD_YIELD  1 define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS  0 define configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H  0 define configINITIAL_TICK_COUNT  0 define configMAX (a, b) ( ( ( a ) &gt; ( b ) ) ? ( a ) : ( b ) ) define configMAX_TASK_NAME_LEN  16 define configMESSAGE_BUFFER_LENGTH_TYPE  size_t define configMIN (a, b) ( ( ( a ) &lt; ( b ) ) ? ( a ) : ( b ) ) define configNUM_THREAD_LOCAL_STORAGE_POINTERS  0 define configPOST_SLEEP_PROCESSING (x)  define configPRECONDITION (X) configASSERT(X) define configPRECONDITION_DEFINED  0 define configPRE_SLEEP_PROCESSING (x)  define configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING (x)  define configPRINTF (X)  define configQUEUE_REGISTRY_SIZE  0U define configRECORD_STACK_HIGH_ADDRESS  0 define configRUN_FREERTOS_SECURE_ONLY  0 define configSTACK_DEPTH_TYPE  uint16_t define configSUPPORT_DYNAMIC_ALLOCATION  1 define configSUPPORT_STATIC_ALLOCATION  0 define configUSE_ALTERNATIVE_API  0 define configUSE_APPLICATION_TASK_TAG  0 define configUSE_COUNTING_SEMAPHORES  0 define configUSE_CO_ROUTINES  0 define configUSE_DAEMON_TASK_STARTUP_HOOK  0 define configUSE_MALLOC_FAILED_HOOK  0 define configUSE_MUTEXES  0 define configUSE_NEWLIB_REENTRANT  0 define configUSE_PORT_OPTIMISED_TASK_SELECTION  0 define configUSE_POSIX_ERRNO  0 define configUSE_QUEUE_SETS  0 define configUSE_RECURSIVE_MUTEXES  0 define configUSE_STATS_FORMATTING_FUNCTIONS  0 define configUSE_TASK_FPU_SUPPORT  1 define configUSE_TASK_NOTIFICATIONS  1 define configUSE_TICKLESS_IDLE  0 define configUSE_TIMERS  0 define configUSE_TIME_SLICING  1 define configUSE_TRACE_FACILITY  0 define eTaskStateGet  eTaskGetState define mtCOVERAGE_TEST_DELAY ()  define mtCOVERAGE_TEST_MARKER ()  define pcQueueGetName (xQueue)  define pcQueueGetQueueName  pcQueueGetName define pcTaskGetTaskName  pcTaskGetName define pcTimerGetTimerName  pcTimerGetName define pdTASK_CODE  TaskFunction_t define pdTASK_HOOK_CODE  TaskHookFunction_t define portALLOCATE_SECURE_CONTEXT (ulSecureStackSize)  define portASSERT_IF_INTERRUPT_PRIORITY_INVALID ()  define portASSERT_IF_IN_ISR ()  define portCLEAN_UP_TCB (pxTCB) ( void ) pxTCB define portCLEAR_INTERRUPT_MASK_FROM_ISR (uxSavedStatusValue) ( void ) uxSavedStatusValue define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS ()  define portCRITICAL_NESTING_IN_TCB  0 define portDONT_DISCARD define portMEMORY_BARRIER ()  define portPOINTER_SIZE_TYPE  uint32_t define portPRE_TASK_DELETE_HOOK (pvTaskToDelete, pxYieldPending)  define portPRIVILEGE_BIT  ( ( UBaseType_t ) 0x00 ) define portSETUP_TCB (pxTCB) ( void ) pxTCB define portSET_INTERRUPT_MASK_FROM_ISR () 0 define portSOFTWARE_BARRIER ()  define portSUPPRESS_TICKS_AND_SLEEP (xExpectedIdleTime)  define portTASK_USES_FLOATING_POINT ()  define portTICK_RATE_MS  portTICK_PERIOD_MS define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR (x) portCLEAR_INTERRUPT_MASK_FROM_ISR( ( x ) ) define portTICK_TYPE_ENTER_CRITICAL () portENTER_CRITICAL() define portTICK_TYPE_EXIT_CRITICAL () portEXIT_CRITICAL() define portTICK_TYPE_IS_ATOMIC  0 define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR () portSET_INTERRUPT_MASK_FROM_ISR() define portTickType  TickType_t define portYIELD_WITHIN_API  portYIELD define pxContainer  pvContainer define tmrTIMER_CALLBACK  TimerCallbackFunction_t define traceBLOCKING_ON_QUEUE_PEEK (pxQueue)  define traceBLOCKING_ON_QUEUE_RECEIVE (pxQueue)  define traceBLOCKING_ON_QUEUE_SEND (pxQueue)  define traceBLOCKING_ON_STREAM_BUFFER_RECEIVE (xStreamBuffer)  define traceBLOCKING_ON_STREAM_BUFFER_SEND (xStreamBuffer)  define traceCREATE_COUNTING_SEMAPHORE ()  define traceCREATE_COUNTING_SEMAPHORE_FAILED ()  define traceCREATE_MUTEX (pxNewQueue)  define traceCREATE_MUTEX_FAILED ()  define traceEND ()  define traceEVENT_GROUP_CLEAR_BITS (xEventGroup, uxBitsToClear)  define traceEVENT_GROUP_CLEAR_BITS_FROM_ISR (xEventGroup, uxBitsToClear)  define traceEVENT_GROUP_CREATE (xEventGroup)  define traceEVENT_GROUP_CREATE_FAILED ()  define traceEVENT_GROUP_DELETE (xEventGroup)  define traceEVENT_GROUP_SET_BITS (xEventGroup, uxBitsToSet)  define traceEVENT_GROUP_SET_BITS_FROM_ISR (xEventGroup, uxBitsToSet)  define traceEVENT_GROUP_SYNC_BLOCK (xEventGroup, uxBitsToSet, uxBitsToWaitFor)  define traceEVENT_GROUP_SYNC_END (xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred) ( void ) xTimeoutOccurred define traceEVENT_GROUP_WAIT_BITS_BLOCK (xEventGroup, uxBitsToWaitFor)  define traceEVENT_GROUP_WAIT_BITS_END (xEventGroup, uxBitsToWaitFor, xTimeoutOccurred) ( void ) xTimeoutOccurred define traceFREE (pvAddress, uiSize)  define traceGIVE_MUTEX_RECURSIVE (pxMutex)  define traceGIVE_MUTEX_RECURSIVE_FAILED (pxMutex)  define traceINCREASE_TICK_COUNT (x)  define traceLOW_POWER_IDLE_BEGIN ()  define traceLOW_POWER_IDLE_END ()  define traceMALLOC (pvAddress, uiSize)  define traceMOVED_TASK_TO_READY_STATE (pxTCB)  define tracePEND_FUNC_CALL (xFunctionToPend, pvParameter1, ulParameter2, ret)  define tracePEND_FUNC_CALL_FROM_ISR (xFunctionToPend, pvParameter1, ulParameter2, ret)  define tracePOST_MOVED_TASK_TO_READY_STATE (pxTCB)  define traceQUEUE_CREATE (pxNewQueue)  define traceQUEUE_CREATE_FAILED (ucQueueType)  define traceQUEUE_DELETE (pxQueue)  define traceQUEUE_PEEK (pxQueue)  define traceQUEUE_PEEK_FAILED (pxQueue)  define traceQUEUE_PEEK_FROM_ISR (pxQueue)  define traceQUEUE_PEEK_FROM_ISR_FAILED (pxQueue)  define traceQUEUE_RECEIVE (pxQueue)  define traceQUEUE_RECEIVE_FAILED (pxQueue)  define traceQUEUE_RECEIVE_FROM_ISR (pxQueue)  define traceQUEUE_RECEIVE_FROM_ISR_FAILED (pxQueue)  define traceQUEUE_REGISTRY_ADD (xQueue, pcQueueName)  define traceQUEUE_SEND (pxQueue)  define traceQUEUE_SEND_FAILED (pxQueue)  define traceQUEUE_SEND_FROM_ISR (pxQueue)  define traceQUEUE_SEND_FROM_ISR_FAILED (pxQueue)  define traceSTART ()  define traceSTREAM_BUFFER_CREATE (pxStreamBuffer, xIsMessageBuffer)  define traceSTREAM_BUFFER_CREATE_FAILED (xIsMessageBuffer)  define traceSTREAM_BUFFER_CREATE_STATIC_FAILED (xReturn, xIsMessageBuffer)  define traceSTREAM_BUFFER_DELETE (xStreamBuffer)  define traceSTREAM_BUFFER_RECEIVE (xStreamBuffer, xReceivedLength)  define traceSTREAM_BUFFER_RECEIVE_FAILED (xStreamBuffer)  define traceSTREAM_BUFFER_RECEIVE_FROM_ISR (xStreamBuffer, xReceivedLength)  define traceSTREAM_BUFFER_RESET (xStreamBuffer)  define traceSTREAM_BUFFER_SEND (xStreamBuffer, xBytesSent)  define traceSTREAM_BUFFER_SEND_FAILED (xStreamBuffer)  define traceSTREAM_BUFFER_SEND_FROM_ISR (xStreamBuffer, xBytesSent)  define traceTAKE_MUTEX_RECURSIVE (pxMutex)  define traceTAKE_MUTEX_RECURSIVE_FAILED (pxMutex)  define traceTASK_CREATE (pxNewTCB)  define traceTASK_CREATE_FAILED ()  define traceTASK_DELAY ()  define traceTASK_DELAY_UNTIL (x)  define traceTASK_DELETE (pxTaskToDelete)  define traceTASK_INCREMENT_TICK (xTickCount)  define traceTASK_NOTIFY ()  define traceTASK_NOTIFY_FROM_ISR ()  define traceTASK_NOTIFY_GIVE_FROM_ISR ()  define traceTASK_NOTIFY_TAKE ()  define traceTASK_NOTIFY_TAKE_BLOCK ()  define traceTASK_NOTIFY_WAIT ()  define traceTASK_NOTIFY_WAIT_BLOCK ()  define traceTASK_PRIORITY_DISINHERIT (pxTCBOfMutexHolder, uxOriginalPriority)  define traceTASK_PRIORITY_INHERIT (pxTCBOfMutexHolder, uxInheritedPriority)  define traceTASK_PRIORITY_SET (pxTask, uxNewPriority)  define traceTASK_RESUME (pxTaskToResume)  define traceTASK_RESUME_FROM_ISR (pxTaskToResume)  define traceTASK_SUSPEND (pxTaskToSuspend)  define traceTASK_SWITCHED_IN ()  define traceTASK_SWITCHED_OUT ()  define traceTIMER_COMMAND_RECEIVED (pxTimer, xMessageID, xMessageValue)  define traceTIMER_COMMAND_SEND (xTimer, xMessageID, xMessageValueValue, xReturn)  define traceTIMER_CREATE (pxNewTimer)  define traceTIMER_CREATE_FAILED ()  define traceTIMER_EXPIRED (pxTimer)  define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE define vQueueAddToRegistry (xQueue, pcName)  define vQueueUnregisterQueue (xQueue)  define vTaskGetTaskInfo  vTaskGetInfo define xCoRoutineHandle  CoRoutineHandle_t define xList List_t define xListItem ListItem_t define xMemoryRegion MemoryRegion_t define xQueueHandle QueueHandle_t define xQueueSetHandle QueueSetHandle_t define xQueueSetMemberHandle QueueSetMemberHandle_t define xSemaphoreHandle SemaphoreHandle_t define xTaskGetIdleRunTimeCounter  ulTaskGetIdleRunTimeCounter define xTaskHandle TaskHandle_t define xTaskParameters TaskParameters_t define xTaskStatusType TaskStatus_t define xTimeOutType TimeOut_t define xTimerHandle  TimerHandle_t"},{"location":"apiStm/FreeRTOS_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/FreeRTOS_8h/#typedef-staticeventgroup_t","title":"typedef StaticEventGroup_t","text":"<pre><code>typedef struct xSTATIC_EVENT_GROUP StaticEventGroup_t;\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#typedef-staticlistitem_t","title":"typedef StaticListItem_t","text":"<pre><code>typedef struct xSTATIC_LIST_ITEM StaticListItem_t;\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#typedef-staticlist_t","title":"typedef StaticList_t","text":"<pre><code>typedef struct xSTATIC_LIST StaticList_t;\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#typedef-staticmessagebuffer_t","title":"typedef StaticMessageBuffer_t","text":"<pre><code>typedef StaticStreamBuffer_t StaticMessageBuffer_t;\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#typedef-staticminilistitem_t","title":"typedef StaticMiniListItem_t","text":"<pre><code>typedef struct xSTATIC_MINI_LIST_ITEM StaticMiniListItem_t;\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#typedef-staticqueue_t","title":"typedef StaticQueue_t","text":"<pre><code>typedef struct xSTATIC_QUEUE StaticQueue_t;\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#typedef-staticsemaphore_t","title":"typedef StaticSemaphore_t","text":"<pre><code>typedef StaticQueue_t StaticSemaphore_t;\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#typedef-staticstreambuffer_t","title":"typedef StaticStreamBuffer_t","text":"<pre><code>typedef struct xSTATIC_STREAM_BUFFER StaticStreamBuffer_t;\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#typedef-statictask_t","title":"typedef StaticTask_t","text":"<pre><code>typedef struct xSTATIC_TCB StaticTask_t;\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#typedef-statictimer_t","title":"typedef StaticTimer_t","text":"<pre><code>typedef struct xSTATIC_TIMER StaticTimer_t;\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/FreeRTOS_8h/#define-include_etaskgetstate","title":"define INCLUDE_eTaskGetState","text":"<pre><code>#define INCLUDE_eTaskGetState 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-include_uxtaskgetstackhighwatermark","title":"define INCLUDE_uxTaskGetStackHighWaterMark","text":"<pre><code>#define INCLUDE_uxTaskGetStackHighWaterMark 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-include_uxtaskgetstackhighwatermark2","title":"define INCLUDE_uxTaskGetStackHighWaterMark2","text":"<pre><code>#define INCLUDE_uxTaskGetStackHighWaterMark2 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-include_uxtaskpriorityget","title":"define INCLUDE_uxTaskPriorityGet","text":"<pre><code>#define INCLUDE_uxTaskPriorityGet 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-include_vtaskdelay","title":"define INCLUDE_vTaskDelay","text":"<pre><code>#define INCLUDE_vTaskDelay 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-include_vtaskdelayuntil","title":"define INCLUDE_vTaskDelayUntil","text":"<pre><code>#define INCLUDE_vTaskDelayUntil 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-include_vtaskdelete","title":"define INCLUDE_vTaskDelete","text":"<pre><code>#define INCLUDE_vTaskDelete 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-include_vtaskpriorityset","title":"define INCLUDE_vTaskPrioritySet","text":"<pre><code>#define INCLUDE_vTaskPrioritySet 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-include_vtasksuspend","title":"define INCLUDE_vTaskSuspend","text":"<pre><code>#define INCLUDE_vTaskSuspend 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-include_xqueuegetmutexholder","title":"define INCLUDE_xQueueGetMutexHolder","text":"<pre><code>#define INCLUDE_xQueueGetMutexHolder 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-include_xsemaphoregetmutexholder","title":"define INCLUDE_xSemaphoreGetMutexHolder","text":"<pre><code>#define INCLUDE_xSemaphoreGetMutexHolder INCLUDE_xQueueGetMutexHolder\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-include_xtaskabortdelay","title":"define INCLUDE_xTaskAbortDelay","text":"<pre><code>#define INCLUDE_xTaskAbortDelay 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-include_xtaskgetcurrenttaskhandle","title":"define INCLUDE_xTaskGetCurrentTaskHandle","text":"<pre><code>#define INCLUDE_xTaskGetCurrentTaskHandle 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-include_xtaskgethandle","title":"define INCLUDE_xTaskGetHandle","text":"<pre><code>#define INCLUDE_xTaskGetHandle 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-include_xtaskgetidletaskhandle","title":"define INCLUDE_xTaskGetIdleTaskHandle","text":"<pre><code>#define INCLUDE_xTaskGetIdleTaskHandle 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-include_xtaskgetschedulerstate","title":"define INCLUDE_xTaskGetSchedulerState","text":"<pre><code>#define INCLUDE_xTaskGetSchedulerState 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-include_xtaskresumefromisr","title":"define INCLUDE_xTaskResumeFromISR","text":"<pre><code>#define INCLUDE_xTaskResumeFromISR 1\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-include_xtimerpendfunctioncall","title":"define INCLUDE_xTimerPendFunctionCall","text":"<pre><code>#define INCLUDE_xTimerPendFunctionCall 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configapplication_allocated_heap","title":"define configAPPLICATION_ALLOCATED_HEAP","text":"<pre><code>#define configAPPLICATION_ALLOCATED_HEAP 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configassert","title":"define configASSERT","text":"<pre><code>#define configASSERT (\nx\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configassert_defined","title":"define configASSERT_DEFINED","text":"<pre><code>#define configASSERT_DEFINED 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configcheck_for_stack_overflow","title":"define configCHECK_FOR_STACK_OVERFLOW","text":"<pre><code>#define configCHECK_FOR_STACK_OVERFLOW 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configenable_backward_compatibility","title":"define configENABLE_BACKWARD_COMPATIBILITY","text":"<pre><code>#define configENABLE_BACKWARD_COMPATIBILITY 1\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configenable_fpu","title":"define configENABLE_FPU","text":"<pre><code>#define configENABLE_FPU 1\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configenable_mpu","title":"define configENABLE_MPU","text":"<pre><code>#define configENABLE_MPU 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configenable_trustzone","title":"define configENABLE_TRUSTZONE","text":"<pre><code>#define configENABLE_TRUSTZONE 1\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configexpected_idle_time_before_sleep","title":"define configEXPECTED_IDLE_TIME_BEFORE_SLEEP","text":"<pre><code>#define configEXPECTED_IDLE_TIME_BEFORE_SLEEP 2\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configgenerate_run_time_stats","title":"define configGENERATE_RUN_TIME_STATS","text":"<pre><code>#define configGENERATE_RUN_TIME_STATS 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configidle_should_yield","title":"define configIDLE_SHOULD_YIELD","text":"<pre><code>#define configIDLE_SHOULD_YIELD 1\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configinclude_application_defined_privileged_functions","title":"define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS","text":"<pre><code>#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configinclude_freertos_task_c_additions_h","title":"define configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H","text":"<pre><code>#define configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configinitial_tick_count","title":"define configINITIAL_TICK_COUNT","text":"<pre><code>#define configINITIAL_TICK_COUNT 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configmax","title":"define configMAX","text":"<pre><code>#define configMAX (\na,\nb\n) ( ( ( a ) &gt; ( b ) ) ? ( a ) : ( b ) )\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configmax_task_name_len","title":"define configMAX_TASK_NAME_LEN","text":"<pre><code>#define configMAX_TASK_NAME_LEN 16\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configmessage_buffer_length_type","title":"define configMESSAGE_BUFFER_LENGTH_TYPE","text":"<pre><code>#define configMESSAGE_BUFFER_LENGTH_TYPE size_t\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configmin","title":"define configMIN","text":"<pre><code>#define configMIN (\na,\nb\n) ( ( ( a ) &lt; ( b ) ) ? ( a ) : ( b ) )\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-confignum_thread_local_storage_pointers","title":"define configNUM_THREAD_LOCAL_STORAGE_POINTERS","text":"<pre><code>#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configpost_sleep_processing","title":"define configPOST_SLEEP_PROCESSING","text":"<pre><code>#define configPOST_SLEEP_PROCESSING (\nx\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configprecondition","title":"define configPRECONDITION","text":"<pre><code>#define configPRECONDITION (\nX\n) configASSERT(X)\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configprecondition_defined","title":"define configPRECONDITION_DEFINED","text":"<pre><code>#define configPRECONDITION_DEFINED 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configpre_sleep_processing","title":"define configPRE_SLEEP_PROCESSING","text":"<pre><code>#define configPRE_SLEEP_PROCESSING (\nx\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configpre_suppress_ticks_and_sleep_processing","title":"define configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING","text":"<pre><code>#define configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING (\nx\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configprintf","title":"define configPRINTF","text":"<pre><code>#define configPRINTF (\nX\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configqueue_registry_size","title":"define configQUEUE_REGISTRY_SIZE","text":"<pre><code>#define configQUEUE_REGISTRY_SIZE 0U\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configrecord_stack_high_address","title":"define configRECORD_STACK_HIGH_ADDRESS","text":"<pre><code>#define configRECORD_STACK_HIGH_ADDRESS 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configrun_freertos_secure_only","title":"define configRUN_FREERTOS_SECURE_ONLY","text":"<pre><code>#define configRUN_FREERTOS_SECURE_ONLY 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configstack_depth_type","title":"define configSTACK_DEPTH_TYPE","text":"<pre><code>#define configSTACK_DEPTH_TYPE uint16_t\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configsupport_dynamic_allocation","title":"define configSUPPORT_DYNAMIC_ALLOCATION","text":"<pre><code>#define configSUPPORT_DYNAMIC_ALLOCATION 1\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configsupport_static_allocation","title":"define configSUPPORT_STATIC_ALLOCATION","text":"<pre><code>#define configSUPPORT_STATIC_ALLOCATION 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configuse_alternative_api","title":"define configUSE_ALTERNATIVE_API","text":"<pre><code>#define configUSE_ALTERNATIVE_API 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configuse_application_task_tag","title":"define configUSE_APPLICATION_TASK_TAG","text":"<pre><code>#define configUSE_APPLICATION_TASK_TAG 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configuse_counting_semaphores","title":"define configUSE_COUNTING_SEMAPHORES","text":"<pre><code>#define configUSE_COUNTING_SEMAPHORES 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configuse_co_routines","title":"define configUSE_CO_ROUTINES","text":"<pre><code>#define configUSE_CO_ROUTINES 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configuse_daemon_task_startup_hook","title":"define configUSE_DAEMON_TASK_STARTUP_HOOK","text":"<pre><code>#define configUSE_DAEMON_TASK_STARTUP_HOOK 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configuse_malloc_failed_hook","title":"define configUSE_MALLOC_FAILED_HOOK","text":"<pre><code>#define configUSE_MALLOC_FAILED_HOOK 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configuse_mutexes","title":"define configUSE_MUTEXES","text":"<pre><code>#define configUSE_MUTEXES 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configuse_newlib_reentrant","title":"define configUSE_NEWLIB_REENTRANT","text":"<pre><code>#define configUSE_NEWLIB_REENTRANT 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configuse_port_optimised_task_selection","title":"define configUSE_PORT_OPTIMISED_TASK_SELECTION","text":"<pre><code>#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configuse_posix_errno","title":"define configUSE_POSIX_ERRNO","text":"<pre><code>#define configUSE_POSIX_ERRNO 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configuse_queue_sets","title":"define configUSE_QUEUE_SETS","text":"<pre><code>#define configUSE_QUEUE_SETS 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configuse_recursive_mutexes","title":"define configUSE_RECURSIVE_MUTEXES","text":"<pre><code>#define configUSE_RECURSIVE_MUTEXES 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configuse_stats_formatting_functions","title":"define configUSE_STATS_FORMATTING_FUNCTIONS","text":"<pre><code>#define configUSE_STATS_FORMATTING_FUNCTIONS 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configuse_task_fpu_support","title":"define configUSE_TASK_FPU_SUPPORT","text":"<pre><code>#define configUSE_TASK_FPU_SUPPORT 1\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configuse_task_notifications","title":"define configUSE_TASK_NOTIFICATIONS","text":"<pre><code>#define configUSE_TASK_NOTIFICATIONS 1\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configuse_tickless_idle","title":"define configUSE_TICKLESS_IDLE","text":"<pre><code>#define configUSE_TICKLESS_IDLE 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configuse_timers","title":"define configUSE_TIMERS","text":"<pre><code>#define configUSE_TIMERS 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configuse_time_slicing","title":"define configUSE_TIME_SLICING","text":"<pre><code>#define configUSE_TIME_SLICING 1\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-configuse_trace_facility","title":"define configUSE_TRACE_FACILITY","text":"<pre><code>#define configUSE_TRACE_FACILITY 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-etaskstateget","title":"define eTaskStateGet","text":"<pre><code>#define eTaskStateGet eTaskGetState\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-mtcoverage_test_delay","title":"define mtCOVERAGE_TEST_DELAY","text":"<pre><code>#define mtCOVERAGE_TEST_DELAY (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-mtcoverage_test_marker","title":"define mtCOVERAGE_TEST_MARKER","text":"<pre><code>#define mtCOVERAGE_TEST_MARKER (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-pcqueuegetname","title":"define pcQueueGetName","text":"<pre><code>#define pcQueueGetName (\nxQueue\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-pcqueuegetqueuename","title":"define pcQueueGetQueueName","text":"<pre><code>#define pcQueueGetQueueName pcQueueGetName\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-pctaskgettaskname","title":"define pcTaskGetTaskName","text":"<pre><code>#define pcTaskGetTaskName pcTaskGetName\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-pctimergettimername","title":"define pcTimerGetTimerName","text":"<pre><code>#define pcTimerGetTimerName pcTimerGetName\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-pdtask_code","title":"define pdTASK_CODE","text":"<pre><code>#define pdTASK_CODE TaskFunction_t\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-pdtask_hook_code","title":"define pdTASK_HOOK_CODE","text":"<pre><code>#define pdTASK_HOOK_CODE TaskHookFunction_t\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-portallocate_secure_context","title":"define portALLOCATE_SECURE_CONTEXT","text":"<pre><code>#define portALLOCATE_SECURE_CONTEXT (\nulSecureStackSize\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-portassert_if_interrupt_priority_invalid","title":"define portASSERT_IF_INTERRUPT_PRIORITY_INVALID","text":"<pre><code>#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-portassert_if_in_isr","title":"define portASSERT_IF_IN_ISR","text":"<pre><code>#define portASSERT_IF_IN_ISR (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-portclean_up_tcb","title":"define portCLEAN_UP_TCB","text":"<pre><code>#define portCLEAN_UP_TCB (\npxTCB\n) ( void ) pxTCB\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-portclear_interrupt_mask_from_isr","title":"define portCLEAR_INTERRUPT_MASK_FROM_ISR","text":"<pre><code>#define portCLEAR_INTERRUPT_MASK_FROM_ISR (\nuxSavedStatusValue\n) ( void ) uxSavedStatusValue\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-portconfigure_timer_for_run_time_stats","title":"define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS","text":"<pre><code>#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-portcritical_nesting_in_tcb","title":"define portCRITICAL_NESTING_IN_TCB","text":"<pre><code>#define portCRITICAL_NESTING_IN_TCB 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-portdont_discard","title":"define portDONT_DISCARD","text":"<pre><code>#define portDONT_DISCARD \n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-portmemory_barrier","title":"define portMEMORY_BARRIER","text":"<pre><code>#define portMEMORY_BARRIER (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-portpointer_size_type","title":"define portPOINTER_SIZE_TYPE","text":"<pre><code>#define portPOINTER_SIZE_TYPE uint32_t\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-portpre_task_delete_hook","title":"define portPRE_TASK_DELETE_HOOK","text":"<pre><code>#define portPRE_TASK_DELETE_HOOK (\npvTaskToDelete,\npxYieldPending\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-portprivilege_bit","title":"define portPRIVILEGE_BIT","text":"<pre><code>#define portPRIVILEGE_BIT ( ( UBaseType_t ) 0x00 )\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-portsetup_tcb","title":"define portSETUP_TCB","text":"<pre><code>#define portSETUP_TCB (\npxTCB\n) ( void ) pxTCB\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-portset_interrupt_mask_from_isr","title":"define portSET_INTERRUPT_MASK_FROM_ISR","text":"<pre><code>#define portSET_INTERRUPT_MASK_FROM_ISR (\n\n) 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-portsoftware_barrier","title":"define portSOFTWARE_BARRIER","text":"<pre><code>#define portSOFTWARE_BARRIER (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-portsuppress_ticks_and_sleep","title":"define portSUPPRESS_TICKS_AND_SLEEP","text":"<pre><code>#define portSUPPRESS_TICKS_AND_SLEEP (\nxExpectedIdleTime\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-porttask_uses_floating_point","title":"define portTASK_USES_FLOATING_POINT","text":"<pre><code>#define portTASK_USES_FLOATING_POINT (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-porttick_rate_ms","title":"define portTICK_RATE_MS","text":"<pre><code>#define portTICK_RATE_MS portTICK_PERIOD_MS\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-porttick_type_clear_interrupt_mask_from_isr","title":"define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR","text":"<pre><code>#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR (\nx\n) portCLEAR_INTERRUPT_MASK_FROM_ISR( ( x ) )\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-porttick_type_enter_critical","title":"define portTICK_TYPE_ENTER_CRITICAL","text":"<pre><code>#define portTICK_TYPE_ENTER_CRITICAL (\n\n) portENTER_CRITICAL()\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-porttick_type_exit_critical","title":"define portTICK_TYPE_EXIT_CRITICAL","text":"<pre><code>#define portTICK_TYPE_EXIT_CRITICAL (\n\n) portEXIT_CRITICAL()\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-porttick_type_is_atomic","title":"define portTICK_TYPE_IS_ATOMIC","text":"<pre><code>#define portTICK_TYPE_IS_ATOMIC 0\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-porttick_type_set_interrupt_mask_from_isr","title":"define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR","text":"<pre><code>#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR (\n\n) portSET_INTERRUPT_MASK_FROM_ISR()\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-portticktype","title":"define portTickType","text":"<pre><code>#define portTickType TickType_t\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-portyield_within_api","title":"define portYIELD_WITHIN_API","text":"<pre><code>#define portYIELD_WITHIN_API portYIELD\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-pxcontainer","title":"define pxContainer","text":"<pre><code>#define pxContainer pvContainer\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tmrtimer_callback","title":"define tmrTIMER_CALLBACK","text":"<pre><code>#define tmrTIMER_CALLBACK TimerCallbackFunction_t\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-traceblocking_on_queue_peek","title":"define traceBLOCKING_ON_QUEUE_PEEK","text":"<pre><code>#define traceBLOCKING_ON_QUEUE_PEEK (\npxQueue\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-traceblocking_on_queue_receive","title":"define traceBLOCKING_ON_QUEUE_RECEIVE","text":"<pre><code>#define traceBLOCKING_ON_QUEUE_RECEIVE (\npxQueue\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-traceblocking_on_queue_send","title":"define traceBLOCKING_ON_QUEUE_SEND","text":"<pre><code>#define traceBLOCKING_ON_QUEUE_SEND (\npxQueue\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-traceblocking_on_stream_buffer_receive","title":"define traceBLOCKING_ON_STREAM_BUFFER_RECEIVE","text":"<pre><code>#define traceBLOCKING_ON_STREAM_BUFFER_RECEIVE (\nxStreamBuffer\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-traceblocking_on_stream_buffer_send","title":"define traceBLOCKING_ON_STREAM_BUFFER_SEND","text":"<pre><code>#define traceBLOCKING_ON_STREAM_BUFFER_SEND (\nxStreamBuffer\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracecreate_counting_semaphore","title":"define traceCREATE_COUNTING_SEMAPHORE","text":"<pre><code>#define traceCREATE_COUNTING_SEMAPHORE (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracecreate_counting_semaphore_failed","title":"define traceCREATE_COUNTING_SEMAPHORE_FAILED","text":"<pre><code>#define traceCREATE_COUNTING_SEMAPHORE_FAILED (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracecreate_mutex","title":"define traceCREATE_MUTEX","text":"<pre><code>#define traceCREATE_MUTEX (\npxNewQueue\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracecreate_mutex_failed","title":"define traceCREATE_MUTEX_FAILED","text":"<pre><code>#define traceCREATE_MUTEX_FAILED (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-traceend","title":"define traceEND","text":"<pre><code>#define traceEND (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-traceevent_group_clear_bits","title":"define traceEVENT_GROUP_CLEAR_BITS","text":"<pre><code>#define traceEVENT_GROUP_CLEAR_BITS (\nxEventGroup,\nuxBitsToClear\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-traceevent_group_clear_bits_from_isr","title":"define traceEVENT_GROUP_CLEAR_BITS_FROM_ISR","text":"<pre><code>#define traceEVENT_GROUP_CLEAR_BITS_FROM_ISR (\nxEventGroup,\nuxBitsToClear\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-traceevent_group_create","title":"define traceEVENT_GROUP_CREATE","text":"<pre><code>#define traceEVENT_GROUP_CREATE (\nxEventGroup\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-traceevent_group_create_failed","title":"define traceEVENT_GROUP_CREATE_FAILED","text":"<pre><code>#define traceEVENT_GROUP_CREATE_FAILED (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-traceevent_group_delete","title":"define traceEVENT_GROUP_DELETE","text":"<pre><code>#define traceEVENT_GROUP_DELETE (\nxEventGroup\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-traceevent_group_set_bits","title":"define traceEVENT_GROUP_SET_BITS","text":"<pre><code>#define traceEVENT_GROUP_SET_BITS (\nxEventGroup,\nuxBitsToSet\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-traceevent_group_set_bits_from_isr","title":"define traceEVENT_GROUP_SET_BITS_FROM_ISR","text":"<pre><code>#define traceEVENT_GROUP_SET_BITS_FROM_ISR (\nxEventGroup,\nuxBitsToSet\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-traceevent_group_sync_block","title":"define traceEVENT_GROUP_SYNC_BLOCK","text":"<pre><code>#define traceEVENT_GROUP_SYNC_BLOCK (\nxEventGroup,\nuxBitsToSet,\nuxBitsToWaitFor\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-traceevent_group_sync_end","title":"define traceEVENT_GROUP_SYNC_END","text":"<pre><code>#define traceEVENT_GROUP_SYNC_END (\nxEventGroup,\nuxBitsToSet,\nuxBitsToWaitFor,\nxTimeoutOccurred\n) ( void ) xTimeoutOccurred\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-traceevent_group_wait_bits_block","title":"define traceEVENT_GROUP_WAIT_BITS_BLOCK","text":"<pre><code>#define traceEVENT_GROUP_WAIT_BITS_BLOCK (\nxEventGroup,\nuxBitsToWaitFor\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-traceevent_group_wait_bits_end","title":"define traceEVENT_GROUP_WAIT_BITS_END","text":"<pre><code>#define traceEVENT_GROUP_WAIT_BITS_END (\nxEventGroup,\nuxBitsToWaitFor,\nxTimeoutOccurred\n) ( void ) xTimeoutOccurred\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracefree","title":"define traceFREE","text":"<pre><code>#define traceFREE (\npvAddress,\nuiSize\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracegive_mutex_recursive","title":"define traceGIVE_MUTEX_RECURSIVE","text":"<pre><code>#define traceGIVE_MUTEX_RECURSIVE (\npxMutex\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracegive_mutex_recursive_failed","title":"define traceGIVE_MUTEX_RECURSIVE_FAILED","text":"<pre><code>#define traceGIVE_MUTEX_RECURSIVE_FAILED (\npxMutex\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-traceincrease_tick_count","title":"define traceINCREASE_TICK_COUNT","text":"<pre><code>#define traceINCREASE_TICK_COUNT (\nx\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracelow_power_idle_begin","title":"define traceLOW_POWER_IDLE_BEGIN","text":"<pre><code>#define traceLOW_POWER_IDLE_BEGIN (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracelow_power_idle_end","title":"define traceLOW_POWER_IDLE_END","text":"<pre><code>#define traceLOW_POWER_IDLE_END (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracemalloc","title":"define traceMALLOC","text":"<pre><code>#define traceMALLOC (\npvAddress,\nuiSize\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracemoved_task_to_ready_state","title":"define traceMOVED_TASK_TO_READY_STATE","text":"<pre><code>#define traceMOVED_TASK_TO_READY_STATE (\npxTCB\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracepend_func_call","title":"define tracePEND_FUNC_CALL","text":"<pre><code>#define tracePEND_FUNC_CALL (\nxFunctionToPend,\npvParameter1,\nulParameter2,\nret\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracepend_func_call_from_isr","title":"define tracePEND_FUNC_CALL_FROM_ISR","text":"<pre><code>#define tracePEND_FUNC_CALL_FROM_ISR (\nxFunctionToPend,\npvParameter1,\nulParameter2,\nret\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracepost_moved_task_to_ready_state","title":"define tracePOST_MOVED_TASK_TO_READY_STATE","text":"<pre><code>#define tracePOST_MOVED_TASK_TO_READY_STATE (\npxTCB\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracequeue_create","title":"define traceQUEUE_CREATE","text":"<pre><code>#define traceQUEUE_CREATE (\npxNewQueue\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracequeue_create_failed","title":"define traceQUEUE_CREATE_FAILED","text":"<pre><code>#define traceQUEUE_CREATE_FAILED (\nucQueueType\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracequeue_delete","title":"define traceQUEUE_DELETE","text":"<pre><code>#define traceQUEUE_DELETE (\npxQueue\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracequeue_peek","title":"define traceQUEUE_PEEK","text":"<pre><code>#define traceQUEUE_PEEK (\npxQueue\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracequeue_peek_failed","title":"define traceQUEUE_PEEK_FAILED","text":"<pre><code>#define traceQUEUE_PEEK_FAILED (\npxQueue\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracequeue_peek_from_isr","title":"define traceQUEUE_PEEK_FROM_ISR","text":"<pre><code>#define traceQUEUE_PEEK_FROM_ISR (\npxQueue\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracequeue_peek_from_isr_failed","title":"define traceQUEUE_PEEK_FROM_ISR_FAILED","text":"<pre><code>#define traceQUEUE_PEEK_FROM_ISR_FAILED (\npxQueue\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracequeue_receive","title":"define traceQUEUE_RECEIVE","text":"<pre><code>#define traceQUEUE_RECEIVE (\npxQueue\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracequeue_receive_failed","title":"define traceQUEUE_RECEIVE_FAILED","text":"<pre><code>#define traceQUEUE_RECEIVE_FAILED (\npxQueue\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracequeue_receive_from_isr","title":"define traceQUEUE_RECEIVE_FROM_ISR","text":"<pre><code>#define traceQUEUE_RECEIVE_FROM_ISR (\npxQueue\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracequeue_receive_from_isr_failed","title":"define traceQUEUE_RECEIVE_FROM_ISR_FAILED","text":"<pre><code>#define traceQUEUE_RECEIVE_FROM_ISR_FAILED (\npxQueue\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracequeue_registry_add","title":"define traceQUEUE_REGISTRY_ADD","text":"<pre><code>#define traceQUEUE_REGISTRY_ADD (\nxQueue,\npcQueueName\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracequeue_send","title":"define traceQUEUE_SEND","text":"<pre><code>#define traceQUEUE_SEND (\npxQueue\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracequeue_send_failed","title":"define traceQUEUE_SEND_FAILED","text":"<pre><code>#define traceQUEUE_SEND_FAILED (\npxQueue\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracequeue_send_from_isr","title":"define traceQUEUE_SEND_FROM_ISR","text":"<pre><code>#define traceQUEUE_SEND_FROM_ISR (\npxQueue\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracequeue_send_from_isr_failed","title":"define traceQUEUE_SEND_FROM_ISR_FAILED","text":"<pre><code>#define traceQUEUE_SEND_FROM_ISR_FAILED (\npxQueue\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracestart","title":"define traceSTART","text":"<pre><code>#define traceSTART (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracestream_buffer_create","title":"define traceSTREAM_BUFFER_CREATE","text":"<pre><code>#define traceSTREAM_BUFFER_CREATE (\npxStreamBuffer,\nxIsMessageBuffer\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracestream_buffer_create_failed","title":"define traceSTREAM_BUFFER_CREATE_FAILED","text":"<pre><code>#define traceSTREAM_BUFFER_CREATE_FAILED (\nxIsMessageBuffer\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracestream_buffer_create_static_failed","title":"define traceSTREAM_BUFFER_CREATE_STATIC_FAILED","text":"<pre><code>#define traceSTREAM_BUFFER_CREATE_STATIC_FAILED (\nxReturn,\nxIsMessageBuffer\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracestream_buffer_delete","title":"define traceSTREAM_BUFFER_DELETE","text":"<pre><code>#define traceSTREAM_BUFFER_DELETE (\nxStreamBuffer\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracestream_buffer_receive","title":"define traceSTREAM_BUFFER_RECEIVE","text":"<pre><code>#define traceSTREAM_BUFFER_RECEIVE (\nxStreamBuffer,\nxReceivedLength\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracestream_buffer_receive_failed","title":"define traceSTREAM_BUFFER_RECEIVE_FAILED","text":"<pre><code>#define traceSTREAM_BUFFER_RECEIVE_FAILED (\nxStreamBuffer\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracestream_buffer_receive_from_isr","title":"define traceSTREAM_BUFFER_RECEIVE_FROM_ISR","text":"<pre><code>#define traceSTREAM_BUFFER_RECEIVE_FROM_ISR (\nxStreamBuffer,\nxReceivedLength\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracestream_buffer_reset","title":"define traceSTREAM_BUFFER_RESET","text":"<pre><code>#define traceSTREAM_BUFFER_RESET (\nxStreamBuffer\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracestream_buffer_send","title":"define traceSTREAM_BUFFER_SEND","text":"<pre><code>#define traceSTREAM_BUFFER_SEND (\nxStreamBuffer,\nxBytesSent\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracestream_buffer_send_failed","title":"define traceSTREAM_BUFFER_SEND_FAILED","text":"<pre><code>#define traceSTREAM_BUFFER_SEND_FAILED (\nxStreamBuffer\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracestream_buffer_send_from_isr","title":"define traceSTREAM_BUFFER_SEND_FROM_ISR","text":"<pre><code>#define traceSTREAM_BUFFER_SEND_FROM_ISR (\nxStreamBuffer,\nxBytesSent\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetake_mutex_recursive","title":"define traceTAKE_MUTEX_RECURSIVE","text":"<pre><code>#define traceTAKE_MUTEX_RECURSIVE (\npxMutex\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetake_mutex_recursive_failed","title":"define traceTAKE_MUTEX_RECURSIVE_FAILED","text":"<pre><code>#define traceTAKE_MUTEX_RECURSIVE_FAILED (\npxMutex\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetask_create","title":"define traceTASK_CREATE","text":"<pre><code>#define traceTASK_CREATE (\npxNewTCB\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetask_create_failed","title":"define traceTASK_CREATE_FAILED","text":"<pre><code>#define traceTASK_CREATE_FAILED (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetask_delay","title":"define traceTASK_DELAY","text":"<pre><code>#define traceTASK_DELAY (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetask_delay_until","title":"define traceTASK_DELAY_UNTIL","text":"<pre><code>#define traceTASK_DELAY_UNTIL (\nx\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetask_delete","title":"define traceTASK_DELETE","text":"<pre><code>#define traceTASK_DELETE (\npxTaskToDelete\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetask_increment_tick","title":"define traceTASK_INCREMENT_TICK","text":"<pre><code>#define traceTASK_INCREMENT_TICK (\nxTickCount\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetask_notify","title":"define traceTASK_NOTIFY","text":"<pre><code>#define traceTASK_NOTIFY (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetask_notify_from_isr","title":"define traceTASK_NOTIFY_FROM_ISR","text":"<pre><code>#define traceTASK_NOTIFY_FROM_ISR (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetask_notify_give_from_isr","title":"define traceTASK_NOTIFY_GIVE_FROM_ISR","text":"<pre><code>#define traceTASK_NOTIFY_GIVE_FROM_ISR (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetask_notify_take","title":"define traceTASK_NOTIFY_TAKE","text":"<pre><code>#define traceTASK_NOTIFY_TAKE (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetask_notify_take_block","title":"define traceTASK_NOTIFY_TAKE_BLOCK","text":"<pre><code>#define traceTASK_NOTIFY_TAKE_BLOCK (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetask_notify_wait","title":"define traceTASK_NOTIFY_WAIT","text":"<pre><code>#define traceTASK_NOTIFY_WAIT (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetask_notify_wait_block","title":"define traceTASK_NOTIFY_WAIT_BLOCK","text":"<pre><code>#define traceTASK_NOTIFY_WAIT_BLOCK (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetask_priority_disinherit","title":"define traceTASK_PRIORITY_DISINHERIT","text":"<pre><code>#define traceTASK_PRIORITY_DISINHERIT (\npxTCBOfMutexHolder,\nuxOriginalPriority\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetask_priority_inherit","title":"define traceTASK_PRIORITY_INHERIT","text":"<pre><code>#define traceTASK_PRIORITY_INHERIT (\npxTCBOfMutexHolder,\nuxInheritedPriority\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetask_priority_set","title":"define traceTASK_PRIORITY_SET","text":"<pre><code>#define traceTASK_PRIORITY_SET (\npxTask,\nuxNewPriority\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetask_resume","title":"define traceTASK_RESUME","text":"<pre><code>#define traceTASK_RESUME (\npxTaskToResume\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetask_resume_from_isr","title":"define traceTASK_RESUME_FROM_ISR","text":"<pre><code>#define traceTASK_RESUME_FROM_ISR (\npxTaskToResume\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetask_suspend","title":"define traceTASK_SUSPEND","text":"<pre><code>#define traceTASK_SUSPEND (\npxTaskToSuspend\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetask_switched_in","title":"define traceTASK_SWITCHED_IN","text":"<pre><code>#define traceTASK_SWITCHED_IN (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetask_switched_out","title":"define traceTASK_SWITCHED_OUT","text":"<pre><code>#define traceTASK_SWITCHED_OUT (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetimer_command_received","title":"define traceTIMER_COMMAND_RECEIVED","text":"<pre><code>#define traceTIMER_COMMAND_RECEIVED (\npxTimer,\nxMessageID,\nxMessageValue\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetimer_command_send","title":"define traceTIMER_COMMAND_SEND","text":"<pre><code>#define traceTIMER_COMMAND_SEND (\nxTimer,\nxMessageID,\nxMessageValueValue,\nxReturn\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetimer_create","title":"define traceTIMER_CREATE","text":"<pre><code>#define traceTIMER_CREATE (\npxNewTimer\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetimer_create_failed","title":"define traceTIMER_CREATE_FAILED","text":"<pre><code>#define traceTIMER_CREATE_FAILED (\n\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tracetimer_expired","title":"define traceTIMER_EXPIRED","text":"<pre><code>#define traceTIMER_EXPIRED (\npxTimer\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-tskstatic_and_dynamic_allocation_possible","title":"define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE","text":"<pre><code>#define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE ( ( ( portUSING_MPU_WRAPPERS == 0 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) || \\\n                                                      ( ( portUSING_MPU_WRAPPERS == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) )\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-vqueueaddtoregistry","title":"define vQueueAddToRegistry","text":"<pre><code>#define vQueueAddToRegistry (\nxQueue,\npcName\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-vqueueunregisterqueue","title":"define vQueueUnregisterQueue","text":"<pre><code>#define vQueueUnregisterQueue (\nxQueue\n) </code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-vtaskgettaskinfo","title":"define vTaskGetTaskInfo","text":"<pre><code>#define vTaskGetTaskInfo vTaskGetInfo\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-xcoroutinehandle","title":"define xCoRoutineHandle","text":"<pre><code>#define xCoRoutineHandle CoRoutineHandle_t\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-xlist","title":"define xList","text":"<pre><code>#define xList List_t\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-xlistitem","title":"define xListItem","text":"<pre><code>#define xListItem ListItem_t\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-xmemoryregion","title":"define xMemoryRegion","text":"<pre><code>#define xMemoryRegion MemoryRegion_t\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-xqueuehandle","title":"define xQueueHandle","text":"<pre><code>#define xQueueHandle QueueHandle_t\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-xqueuesethandle","title":"define xQueueSetHandle","text":"<pre><code>#define xQueueSetHandle QueueSetHandle_t\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-xqueuesetmemberhandle","title":"define xQueueSetMemberHandle","text":"<pre><code>#define xQueueSetMemberHandle QueueSetMemberHandle_t\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-xsemaphorehandle","title":"define xSemaphoreHandle","text":"<pre><code>#define xSemaphoreHandle SemaphoreHandle_t\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-xtaskgetidleruntimecounter","title":"define xTaskGetIdleRunTimeCounter","text":"<pre><code>#define xTaskGetIdleRunTimeCounter ulTaskGetIdleRunTimeCounter\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-xtaskhandle","title":"define xTaskHandle","text":"<pre><code>#define xTaskHandle TaskHandle_t\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-xtaskparameters","title":"define xTaskParameters","text":"<pre><code>#define xTaskParameters TaskParameters_t\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-xtaskstatustype","title":"define xTaskStatusType","text":"<pre><code>#define xTaskStatusType TaskStatus_t\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-xtimeouttype","title":"define xTimeOutType","text":"<pre><code>#define xTimeOutType TimeOut_t\n</code></pre>"},{"location":"apiStm/FreeRTOS_8h/#define-xtimerhandle","title":"define xTimerHandle","text":"<pre><code>#define xTimerHandle TimerHandle_t\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/FreeRTOS.h</code></p>"},{"location":"apiStm/FreeRTOS_8h_source/","title":"File FreeRTOS.h","text":"<p>File List &gt; FreeRTOS &gt; include &gt; FreeRTOS.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n#ifndef INC_FREERTOS_H\n#define INC_FREERTOS_H\n\n/*\n * Include the generic headers required for the FreeRTOS port being used.\n */\n#include &lt;stddef.h&gt;\n\n/*\n * If stdint.h cannot be located then:\n *   + If using GCC ensure the -nostdint options is *not* being used.\n *   + Ensure the project's include path includes the directory in which your\n *     compiler stores stdint.h.\n *   + Set any compiler options necessary for it to support C99, as technically\n *     stdint.h is only mandatory with C99 (FreeRTOS does not require C99 in any\n *     other way).\n *   + The FreeRTOS download includes a simple stdint.h definition that can be\n *     used in cases where none is provided by the compiler.  The files only\n *     contains the typedefs required to build FreeRTOS.  Read the instructions\n *     in FreeRTOS/source/stdint.readme for more information.\n */\n#include &lt;stdint.h&gt; /* READ COMMENT ABOVE. */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Application specific configuration options. */\n#include \"FreeRTOSConfig.h\"\n\n/* Basic FreeRTOS definitions. */\n#include \"projdefs.h\"\n\n/* Definitions specific to the port being used. */\n#include \"portable.h\"\n\n/* Must be defaulted before configUSE_NEWLIB_REENTRANT is used below. */\n#ifndef configUSE_NEWLIB_REENTRANT\n#define configUSE_NEWLIB_REENTRANT 0\n#endif\n\n/* Required if struct _reent is used. */\n#if ( configUSE_NEWLIB_REENTRANT == 1 )\n#include &lt;reent.h&gt;\n#endif\n/*\n * Check all the required application specific macros have been defined.\n * These macros are application specific and (as downloaded) are defined\n * within FreeRTOSConfig.h.\n */\n\n#ifndef configMINIMAL_STACK_SIZE\n#error Missing definition:  configMINIMAL_STACK_SIZE must be defined in FreeRTOSConfig.h.  configMINIMAL_STACK_SIZE defines the size (in words) of the stack allocated to the idle task.  Refer to the demo project provided for your port for a suitable value.\n#endif\n\n#ifndef configMAX_PRIORITIES\n#error Missing definition:  configMAX_PRIORITIES must be defined in FreeRTOSConfig.h.  See the Configuration section of the FreeRTOS API documentation for details.\n#endif\n\n#if configMAX_PRIORITIES &lt; 1\n#error configMAX_PRIORITIES must be defined to be greater than or equal to 1.\n#endif\n\n#ifndef configUSE_PREEMPTION\n#error Missing definition:  configUSE_PREEMPTION must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.\n#endif\n\n#ifndef configUSE_IDLE_HOOK\n#error Missing definition:  configUSE_IDLE_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.\n#endif\n\n#ifndef configUSE_TICK_HOOK\n#error Missing definition:  configUSE_TICK_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.\n#endif\n\n#ifndef configUSE_16_BIT_TICKS\n#error Missing definition:  configUSE_16_BIT_TICKS must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.\n#endif\n\n#ifndef configUSE_CO_ROUTINES\n#define configUSE_CO_ROUTINES 0\n#endif\n\n#ifndef INCLUDE_vTaskPrioritySet\n#define INCLUDE_vTaskPrioritySet 0\n#endif\n\n#ifndef INCLUDE_uxTaskPriorityGet\n#define INCLUDE_uxTaskPriorityGet 0\n#endif\n\n#ifndef INCLUDE_vTaskDelete\n#define INCLUDE_vTaskDelete 0\n#endif\n\n#ifndef INCLUDE_vTaskSuspend\n#define INCLUDE_vTaskSuspend 0\n#endif\n\n#ifndef INCLUDE_vTaskDelayUntil\n#define INCLUDE_vTaskDelayUntil 0\n#endif\n\n#ifndef INCLUDE_vTaskDelay\n#define INCLUDE_vTaskDelay 0\n#endif\n\n#ifndef INCLUDE_xTaskGetIdleTaskHandle\n#define INCLUDE_xTaskGetIdleTaskHandle 0\n#endif\n\n#ifndef INCLUDE_xTaskAbortDelay\n#define INCLUDE_xTaskAbortDelay 0\n#endif\n\n#ifndef INCLUDE_xQueueGetMutexHolder\n#define INCLUDE_xQueueGetMutexHolder 0\n#endif\n\n#ifndef INCLUDE_xSemaphoreGetMutexHolder\n#define INCLUDE_xSemaphoreGetMutexHolder INCLUDE_xQueueGetMutexHolder\n#endif\n\n#ifndef INCLUDE_xTaskGetHandle\n#define INCLUDE_xTaskGetHandle 0\n#endif\n\n#ifndef INCLUDE_uxTaskGetStackHighWaterMark\n#define INCLUDE_uxTaskGetStackHighWaterMark 0\n#endif\n\n#ifndef INCLUDE_uxTaskGetStackHighWaterMark2\n#define INCLUDE_uxTaskGetStackHighWaterMark2 0\n#endif\n\n#ifndef INCLUDE_eTaskGetState\n#define INCLUDE_eTaskGetState 0\n#endif\n\n#ifndef INCLUDE_xTaskResumeFromISR\n#define INCLUDE_xTaskResumeFromISR 1\n#endif\n\n#ifndef INCLUDE_xTimerPendFunctionCall\n#define INCLUDE_xTimerPendFunctionCall 0\n#endif\n\n#ifndef INCLUDE_xTaskGetSchedulerState\n#define INCLUDE_xTaskGetSchedulerState 0\n#endif\n\n#ifndef INCLUDE_xTaskGetCurrentTaskHandle\n#define INCLUDE_xTaskGetCurrentTaskHandle 0\n#endif\n\n#if configUSE_CO_ROUTINES != 0\n#ifndef configMAX_CO_ROUTINE_PRIORITIES\n#error configMAX_CO_ROUTINE_PRIORITIES must be greater than or equal to 1.\n#endif\n#endif\n\n#ifndef configUSE_DAEMON_TASK_STARTUP_HOOK\n#define configUSE_DAEMON_TASK_STARTUP_HOOK 0\n#endif\n\n#ifndef configUSE_APPLICATION_TASK_TAG\n#define configUSE_APPLICATION_TASK_TAG 0\n#endif\n\n#ifndef configNUM_THREAD_LOCAL_STORAGE_POINTERS\n#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 0\n#endif\n\n#ifndef configUSE_RECURSIVE_MUTEXES\n#define configUSE_RECURSIVE_MUTEXES 0\n#endif\n\n#ifndef configUSE_MUTEXES\n#define configUSE_MUTEXES 0\n#endif\n\n#ifndef configUSE_TIMERS\n#define configUSE_TIMERS 0\n#endif\n\n#ifndef configUSE_COUNTING_SEMAPHORES\n#define configUSE_COUNTING_SEMAPHORES 0\n#endif\n\n#ifndef configUSE_ALTERNATIVE_API\n#define configUSE_ALTERNATIVE_API 0\n#endif\n\n#ifndef portCRITICAL_NESTING_IN_TCB\n#define portCRITICAL_NESTING_IN_TCB 0\n#endif\n\n#ifndef configMAX_TASK_NAME_LEN\n#define configMAX_TASK_NAME_LEN 16\n#endif\n\n#ifndef configIDLE_SHOULD_YIELD\n#define configIDLE_SHOULD_YIELD     1\n#endif\n\n#if configMAX_TASK_NAME_LEN &lt; 1\n#error configMAX_TASK_NAME_LEN must be set to a minimum of 1 in FreeRTOSConfig.h\n#endif\n\n#ifndef configASSERT\n#define configASSERT( x )\n#define configASSERT_DEFINED 0\n#else\n#define configASSERT_DEFINED 1\n#endif\n\n/* configPRECONDITION should be defined as configASSERT.\nThe CBMC proofs need a way to track assumptions and assertions.\nA configPRECONDITION statement should express an implicit invariant or\nassumption made.  A configASSERT statement should express an invariant that must\nhold explicit before calling the code. */\n#ifndef configPRECONDITION\n#define configPRECONDITION( X ) configASSERT(X)\n#define configPRECONDITION_DEFINED 0\n#else\n#define configPRECONDITION_DEFINED 1\n#endif\n\n#ifndef portMEMORY_BARRIER\n#define portMEMORY_BARRIER()\n#endif\n\n#ifndef portSOFTWARE_BARRIER\n#define portSOFTWARE_BARRIER()\n#endif\n\n/* The timers module relies on xTaskGetSchedulerState(). */\n#if configUSE_TIMERS == 1\n\n#ifndef configTIMER_TASK_PRIORITY\n#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_PRIORITY must also be defined.\n#endif /* configTIMER_TASK_PRIORITY */\n\n#ifndef configTIMER_QUEUE_LENGTH\n#error If configUSE_TIMERS is set to 1 then configTIMER_QUEUE_LENGTH must also be defined.\n#endif /* configTIMER_QUEUE_LENGTH */\n\n#ifndef configTIMER_TASK_STACK_DEPTH\n#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_STACK_DEPTH must also be defined.\n#endif /* configTIMER_TASK_STACK_DEPTH */\n\n#endif /* configUSE_TIMERS */\n\n#ifndef portSET_INTERRUPT_MASK_FROM_ISR\n#define portSET_INTERRUPT_MASK_FROM_ISR() 0\n#endif\n\n#ifndef portCLEAR_INTERRUPT_MASK_FROM_ISR\n#define portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedStatusValue ) ( void ) uxSavedStatusValue\n#endif\n\n#ifndef portCLEAN_UP_TCB\n#define portCLEAN_UP_TCB( pxTCB ) ( void ) pxTCB\n#endif\n\n#ifndef portPRE_TASK_DELETE_HOOK\n#define portPRE_TASK_DELETE_HOOK( pvTaskToDelete, pxYieldPending )\n#endif\n\n#ifndef portSETUP_TCB\n#define portSETUP_TCB( pxTCB ) ( void ) pxTCB\n#endif\n\n#ifndef configQUEUE_REGISTRY_SIZE\n#define configQUEUE_REGISTRY_SIZE 0U\n#endif\n\n#if ( configQUEUE_REGISTRY_SIZE &lt; 1 )\n#define vQueueAddToRegistry( xQueue, pcName )\n#define vQueueUnregisterQueue( xQueue )\n#define pcQueueGetName( xQueue )\n#endif\n\n#ifndef portPOINTER_SIZE_TYPE\n#define portPOINTER_SIZE_TYPE uint32_t\n#endif\n\n/* Remove any unused trace macros. */\n#ifndef traceSTART\n/* Used to perform any necessary initialisation - for example, open a file\n    into which trace is to be written. */\n#define traceSTART()\n#endif\n\n#ifndef traceEND\n/* Use to close a trace, for example close a file into which trace has been\n    written. */\n#define traceEND()\n#endif\n\n#ifndef traceTASK_SWITCHED_IN\n/* Called after a task has been selected to run.  pxCurrentTCB holds a pointer\n    to the task control block of the selected task. */\n#define traceTASK_SWITCHED_IN()\n#endif\n\n#ifndef traceINCREASE_TICK_COUNT\n/* Called before stepping the tick count after waking from tickless idle\n    sleep. */\n#define traceINCREASE_TICK_COUNT( x )\n#endif\n\n#ifndef traceLOW_POWER_IDLE_BEGIN\n/* Called immediately before entering tickless idle. */\n#define traceLOW_POWER_IDLE_BEGIN()\n#endif\n\n#ifndef traceLOW_POWER_IDLE_END\n/* Called when returning to the Idle task after a tickless idle. */\n#define traceLOW_POWER_IDLE_END()\n#endif\n\n#ifndef traceTASK_SWITCHED_OUT\n/* Called before a task has been selected to run.  pxCurrentTCB holds a pointer\n    to the task control block of the task being switched out. */\n#define traceTASK_SWITCHED_OUT()\n#endif\n\n#ifndef traceTASK_PRIORITY_INHERIT\n/* Called when a task attempts to take a mutex that is already held by a\n    lower priority task.  pxTCBOfMutexHolder is a pointer to the TCB of the task\n    that holds the mutex.  uxInheritedPriority is the priority the mutex holder\n    will inherit (the priority of the task that is attempting to obtain the\n    muted. */\n#define traceTASK_PRIORITY_INHERIT( pxTCBOfMutexHolder, uxInheritedPriority )\n#endif\n\n#ifndef traceTASK_PRIORITY_DISINHERIT\n/* Called when a task releases a mutex, the holding of which had resulted in\n    the task inheriting the priority of a higher priority task.\n    pxTCBOfMutexHolder is a pointer to the TCB of the task that is releasing the\n    mutex.  uxOriginalPriority is the task's configured (base) priority. */\n#define traceTASK_PRIORITY_DISINHERIT( pxTCBOfMutexHolder, uxOriginalPriority )\n#endif\n\n#ifndef traceBLOCKING_ON_QUEUE_RECEIVE\n/* Task is about to block because it cannot read from a\n    queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore\n    upon which the read was attempted.  pxCurrentTCB points to the TCB of the\n    task that attempted the read. */\n#define traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue )\n#endif\n\n#ifndef traceBLOCKING_ON_QUEUE_PEEK\n/* Task is about to block because it cannot read from a\n    queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore\n    upon which the read was attempted.  pxCurrentTCB points to the TCB of the\n    task that attempted the read. */\n#define traceBLOCKING_ON_QUEUE_PEEK( pxQueue )\n#endif\n\n#ifndef traceBLOCKING_ON_QUEUE_SEND\n/* Task is about to block because it cannot write to a\n    queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore\n    upon which the write was attempted.  pxCurrentTCB points to the TCB of the\n    task that attempted the write. */\n#define traceBLOCKING_ON_QUEUE_SEND( pxQueue )\n#endif\n\n#ifndef configCHECK_FOR_STACK_OVERFLOW\n#define configCHECK_FOR_STACK_OVERFLOW 0\n#endif\n\n#ifndef configRECORD_STACK_HIGH_ADDRESS\n#define configRECORD_STACK_HIGH_ADDRESS 0\n#endif\n\n#ifndef configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H\n#define configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H 0\n#endif\n\n/* The following event macros are embedded in the kernel API calls. */\n\n#ifndef traceMOVED_TASK_TO_READY_STATE\n#define traceMOVED_TASK_TO_READY_STATE( pxTCB )\n#endif\n\n#ifndef tracePOST_MOVED_TASK_TO_READY_STATE\n#define tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )\n#endif\n\n#ifndef traceQUEUE_CREATE\n#define traceQUEUE_CREATE( pxNewQueue )\n#endif\n\n#ifndef traceQUEUE_CREATE_FAILED\n#define traceQUEUE_CREATE_FAILED( ucQueueType )\n#endif\n\n#ifndef traceCREATE_MUTEX\n#define traceCREATE_MUTEX( pxNewQueue )\n#endif\n\n#ifndef traceCREATE_MUTEX_FAILED\n#define traceCREATE_MUTEX_FAILED()\n#endif\n\n#ifndef traceGIVE_MUTEX_RECURSIVE\n#define traceGIVE_MUTEX_RECURSIVE( pxMutex )\n#endif\n\n#ifndef traceGIVE_MUTEX_RECURSIVE_FAILED\n#define traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex )\n#endif\n\n#ifndef traceTAKE_MUTEX_RECURSIVE\n#define traceTAKE_MUTEX_RECURSIVE( pxMutex )\n#endif\n\n#ifndef traceTAKE_MUTEX_RECURSIVE_FAILED\n#define traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex )\n#endif\n\n#ifndef traceCREATE_COUNTING_SEMAPHORE\n#define traceCREATE_COUNTING_SEMAPHORE()\n#endif\n\n#ifndef traceCREATE_COUNTING_SEMAPHORE_FAILED\n#define traceCREATE_COUNTING_SEMAPHORE_FAILED()\n#endif\n\n#ifndef traceQUEUE_SEND\n#define traceQUEUE_SEND( pxQueue )\n#endif\n\n#ifndef traceQUEUE_SEND_FAILED\n#define traceQUEUE_SEND_FAILED( pxQueue )\n#endif\n\n#ifndef traceQUEUE_RECEIVE\n#define traceQUEUE_RECEIVE( pxQueue )\n#endif\n\n#ifndef traceQUEUE_PEEK\n#define traceQUEUE_PEEK( pxQueue )\n#endif\n\n#ifndef traceQUEUE_PEEK_FAILED\n#define traceQUEUE_PEEK_FAILED( pxQueue )\n#endif\n\n#ifndef traceQUEUE_PEEK_FROM_ISR\n#define traceQUEUE_PEEK_FROM_ISR( pxQueue )\n#endif\n\n#ifndef traceQUEUE_RECEIVE_FAILED\n#define traceQUEUE_RECEIVE_FAILED( pxQueue )\n#endif\n\n#ifndef traceQUEUE_SEND_FROM_ISR\n#define traceQUEUE_SEND_FROM_ISR( pxQueue )\n#endif\n\n#ifndef traceQUEUE_SEND_FROM_ISR_FAILED\n#define traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue )\n#endif\n\n#ifndef traceQUEUE_RECEIVE_FROM_ISR\n#define traceQUEUE_RECEIVE_FROM_ISR( pxQueue )\n#endif\n\n#ifndef traceQUEUE_RECEIVE_FROM_ISR_FAILED\n#define traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue )\n#endif\n\n#ifndef traceQUEUE_PEEK_FROM_ISR_FAILED\n#define traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue )\n#endif\n\n#ifndef traceQUEUE_DELETE\n#define traceQUEUE_DELETE( pxQueue )\n#endif\n\n#ifndef traceTASK_CREATE\n#define traceTASK_CREATE( pxNewTCB )\n#endif\n\n#ifndef traceTASK_CREATE_FAILED\n#define traceTASK_CREATE_FAILED()\n#endif\n\n#ifndef traceTASK_DELETE\n#define traceTASK_DELETE( pxTaskToDelete )\n#endif\n\n#ifndef traceTASK_DELAY_UNTIL\n#define traceTASK_DELAY_UNTIL( x )\n#endif\n\n#ifndef traceTASK_DELAY\n#define traceTASK_DELAY()\n#endif\n\n#ifndef traceTASK_PRIORITY_SET\n#define traceTASK_PRIORITY_SET( pxTask, uxNewPriority )\n#endif\n\n#ifndef traceTASK_SUSPEND\n#define traceTASK_SUSPEND( pxTaskToSuspend )\n#endif\n\n#ifndef traceTASK_RESUME\n#define traceTASK_RESUME( pxTaskToResume )\n#endif\n\n#ifndef traceTASK_RESUME_FROM_ISR\n#define traceTASK_RESUME_FROM_ISR( pxTaskToResume )\n#endif\n\n#ifndef traceTASK_INCREMENT_TICK\n#define traceTASK_INCREMENT_TICK( xTickCount )\n#endif\n\n#ifndef traceTIMER_CREATE\n#define traceTIMER_CREATE( pxNewTimer )\n#endif\n\n#ifndef traceTIMER_CREATE_FAILED\n#define traceTIMER_CREATE_FAILED()\n#endif\n\n#ifndef traceTIMER_COMMAND_SEND\n#define traceTIMER_COMMAND_SEND( xTimer, xMessageID, xMessageValueValue, xReturn )\n#endif\n\n#ifndef traceTIMER_EXPIRED\n#define traceTIMER_EXPIRED( pxTimer )\n#endif\n\n#ifndef traceTIMER_COMMAND_RECEIVED\n#define traceTIMER_COMMAND_RECEIVED( pxTimer, xMessageID, xMessageValue )\n#endif\n\n#ifndef traceMALLOC\n#define traceMALLOC( pvAddress, uiSize )\n#endif\n\n#ifndef traceFREE\n#define traceFREE( pvAddress, uiSize )\n#endif\n\n#ifndef traceEVENT_GROUP_CREATE\n#define traceEVENT_GROUP_CREATE( xEventGroup )\n#endif\n\n#ifndef traceEVENT_GROUP_CREATE_FAILED\n#define traceEVENT_GROUP_CREATE_FAILED()\n#endif\n\n#ifndef traceEVENT_GROUP_SYNC_BLOCK\n#define traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor )\n#endif\n\n#ifndef traceEVENT_GROUP_SYNC_END\n#define traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred\n#endif\n\n#ifndef traceEVENT_GROUP_WAIT_BITS_BLOCK\n#define traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor )\n#endif\n\n#ifndef traceEVENT_GROUP_WAIT_BITS_END\n#define traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred\n#endif\n\n#ifndef traceEVENT_GROUP_CLEAR_BITS\n#define traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear )\n#endif\n\n#ifndef traceEVENT_GROUP_CLEAR_BITS_FROM_ISR\n#define traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear )\n#endif\n\n#ifndef traceEVENT_GROUP_SET_BITS\n#define traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet )\n#endif\n\n#ifndef traceEVENT_GROUP_SET_BITS_FROM_ISR\n#define traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet )\n#endif\n\n#ifndef traceEVENT_GROUP_DELETE\n#define traceEVENT_GROUP_DELETE( xEventGroup )\n#endif\n\n#ifndef tracePEND_FUNC_CALL\n#define tracePEND_FUNC_CALL(xFunctionToPend, pvParameter1, ulParameter2, ret)\n#endif\n\n#ifndef tracePEND_FUNC_CALL_FROM_ISR\n#define tracePEND_FUNC_CALL_FROM_ISR(xFunctionToPend, pvParameter1, ulParameter2, ret)\n#endif\n\n#ifndef traceQUEUE_REGISTRY_ADD\n#define traceQUEUE_REGISTRY_ADD(xQueue, pcQueueName)\n#endif\n\n#ifndef traceTASK_NOTIFY_TAKE_BLOCK\n#define traceTASK_NOTIFY_TAKE_BLOCK()\n#endif\n\n#ifndef traceTASK_NOTIFY_TAKE\n#define traceTASK_NOTIFY_TAKE()\n#endif\n\n#ifndef traceTASK_NOTIFY_WAIT_BLOCK\n#define traceTASK_NOTIFY_WAIT_BLOCK()\n#endif\n\n#ifndef traceTASK_NOTIFY_WAIT\n#define traceTASK_NOTIFY_WAIT()\n#endif\n\n#ifndef traceTASK_NOTIFY\n#define traceTASK_NOTIFY()\n#endif\n\n#ifndef traceTASK_NOTIFY_FROM_ISR\n#define traceTASK_NOTIFY_FROM_ISR()\n#endif\n\n#ifndef traceTASK_NOTIFY_GIVE_FROM_ISR\n#define traceTASK_NOTIFY_GIVE_FROM_ISR()\n#endif\n\n#ifndef traceSTREAM_BUFFER_CREATE_FAILED\n#define traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer )\n#endif\n\n#ifndef traceSTREAM_BUFFER_CREATE_STATIC_FAILED\n#define traceSTREAM_BUFFER_CREATE_STATIC_FAILED( xReturn, xIsMessageBuffer )\n#endif\n\n#ifndef traceSTREAM_BUFFER_CREATE\n#define traceSTREAM_BUFFER_CREATE( pxStreamBuffer, xIsMessageBuffer )\n#endif\n\n#ifndef traceSTREAM_BUFFER_DELETE\n#define traceSTREAM_BUFFER_DELETE( xStreamBuffer )\n#endif\n\n#ifndef traceSTREAM_BUFFER_RESET\n#define traceSTREAM_BUFFER_RESET( xStreamBuffer )\n#endif\n\n#ifndef traceBLOCKING_ON_STREAM_BUFFER_SEND\n#define traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer )\n#endif\n\n#ifndef traceSTREAM_BUFFER_SEND\n#define traceSTREAM_BUFFER_SEND( xStreamBuffer, xBytesSent )\n#endif\n\n#ifndef traceSTREAM_BUFFER_SEND_FAILED\n#define traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer )\n#endif\n\n#ifndef traceSTREAM_BUFFER_SEND_FROM_ISR\n#define traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xBytesSent )\n#endif\n\n#ifndef traceBLOCKING_ON_STREAM_BUFFER_RECEIVE\n#define traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer )\n#endif\n\n#ifndef traceSTREAM_BUFFER_RECEIVE\n#define traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength )\n#endif\n\n#ifndef traceSTREAM_BUFFER_RECEIVE_FAILED\n#define traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer )\n#endif\n\n#ifndef traceSTREAM_BUFFER_RECEIVE_FROM_ISR\n#define traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength )\n#endif\n\n#ifndef configGENERATE_RUN_TIME_STATS\n#define configGENERATE_RUN_TIME_STATS 0\n#endif\n\n#if ( configGENERATE_RUN_TIME_STATS == 1 )\n\n#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS\n#error If configGENERATE_RUN_TIME_STATS is defined then portCONFIGURE_TIMER_FOR_RUN_TIME_STATS must also be defined.  portCONFIGURE_TIMER_FOR_RUN_TIME_STATS should call a port layer function to setup a peripheral timer/counter that can then be used as the run time counter time base.\n#endif /* portCONFIGURE_TIMER_FOR_RUN_TIME_STATS */\n\n#ifndef portGET_RUN_TIME_COUNTER_VALUE\n#ifndef portALT_GET_RUN_TIME_COUNTER_VALUE\n#error If configGENERATE_RUN_TIME_STATS is defined then either portGET_RUN_TIME_COUNTER_VALUE or portALT_GET_RUN_TIME_COUNTER_VALUE must also be defined.  See the examples provided and the FreeRTOS web site for more information.\n#endif /* portALT_GET_RUN_TIME_COUNTER_VALUE */\n#endif /* portGET_RUN_TIME_COUNTER_VALUE */\n\n#endif /* configGENERATE_RUN_TIME_STATS */\n\n#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS\n#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()\n#endif\n\n#ifndef configUSE_MALLOC_FAILED_HOOK\n#define configUSE_MALLOC_FAILED_HOOK 0\n#endif\n\n#ifndef portPRIVILEGE_BIT\n#define portPRIVILEGE_BIT ( ( UBaseType_t ) 0x00 )\n#endif\n\n#ifndef portYIELD_WITHIN_API\n#define portYIELD_WITHIN_API portYIELD\n#endif\n\n#ifndef portSUPPRESS_TICKS_AND_SLEEP\n#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )\n#endif\n\n#ifndef configEXPECTED_IDLE_TIME_BEFORE_SLEEP\n#define configEXPECTED_IDLE_TIME_BEFORE_SLEEP 2\n#endif\n\n#if configEXPECTED_IDLE_TIME_BEFORE_SLEEP &lt; 2\n#error configEXPECTED_IDLE_TIME_BEFORE_SLEEP must not be less than 2\n#endif\n\n#ifndef configUSE_TICKLESS_IDLE\n#define configUSE_TICKLESS_IDLE 0\n#endif\n\n#ifndef configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING\n#define configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( x )\n#endif\n\n#ifndef configPRE_SLEEP_PROCESSING\n#define configPRE_SLEEP_PROCESSING( x )\n#endif\n\n#ifndef configPOST_SLEEP_PROCESSING\n#define configPOST_SLEEP_PROCESSING( x )\n#endif\n\n#ifndef configUSE_QUEUE_SETS\n#define configUSE_QUEUE_SETS 0\n#endif\n\n#ifndef portTASK_USES_FLOATING_POINT\n#define portTASK_USES_FLOATING_POINT()\n#endif\n\n#ifndef portALLOCATE_SECURE_CONTEXT\n#define portALLOCATE_SECURE_CONTEXT( ulSecureStackSize )\n#endif\n\n#ifndef portDONT_DISCARD\n#define portDONT_DISCARD\n#endif\n\n#ifndef configUSE_TIME_SLICING\n#define configUSE_TIME_SLICING 1\n#endif\n\n#ifndef configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS\n#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0\n#endif\n\n#ifndef configUSE_STATS_FORMATTING_FUNCTIONS\n#define configUSE_STATS_FORMATTING_FUNCTIONS 0\n#endif\n\n#ifndef portASSERT_IF_INTERRUPT_PRIORITY_INVALID\n#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()\n#endif\n\n#ifndef configUSE_TRACE_FACILITY\n#define configUSE_TRACE_FACILITY 0\n#endif\n\n#ifndef mtCOVERAGE_TEST_MARKER\n#define mtCOVERAGE_TEST_MARKER()\n#endif\n\n#ifndef mtCOVERAGE_TEST_DELAY\n#define mtCOVERAGE_TEST_DELAY()\n#endif\n\n#ifndef portASSERT_IF_IN_ISR\n#define portASSERT_IF_IN_ISR()\n#endif\n\n#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION\n#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0\n#endif\n\n#ifndef configAPPLICATION_ALLOCATED_HEAP\n#define configAPPLICATION_ALLOCATED_HEAP 0\n#endif\n\n#ifndef configUSE_TASK_NOTIFICATIONS\n#define configUSE_TASK_NOTIFICATIONS 1\n#endif\n\n#ifndef configUSE_POSIX_ERRNO\n#define configUSE_POSIX_ERRNO 0\n#endif\n\n#ifndef portTICK_TYPE_IS_ATOMIC\n#define portTICK_TYPE_IS_ATOMIC 0\n#endif\n\n#ifndef configSUPPORT_STATIC_ALLOCATION\n/* Defaults to 0 for backward compatibility. */\n#define configSUPPORT_STATIC_ALLOCATION 0\n#endif\n\n#ifndef configSUPPORT_DYNAMIC_ALLOCATION\n/* Defaults to 1 for backward compatibility. */\n#define configSUPPORT_DYNAMIC_ALLOCATION 1\n#endif\n\n#ifndef configSTACK_DEPTH_TYPE\n/* Defaults to uint16_t for backward compatibility, but can be overridden\n    in FreeRTOSConfig.h if uint16_t is too restrictive. */\n#define configSTACK_DEPTH_TYPE uint16_t\n#endif\n\n#ifndef configMESSAGE_BUFFER_LENGTH_TYPE\n/* Defaults to size_t for backward compatibility, but can be overridden\n    in FreeRTOSConfig.h if lengths will always be less than the number of bytes\n    in a size_t. */\n#define configMESSAGE_BUFFER_LENGTH_TYPE size_t\n#endif\n\n/* Sanity check the configuration. */\n#if( configUSE_TICKLESS_IDLE != 0 )\n#if( INCLUDE_vTaskSuspend != 1 )\n#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0\n#endif /* INCLUDE_vTaskSuspend */\n#endif /* configUSE_TICKLESS_IDLE */\n\n#if( ( configSUPPORT_STATIC_ALLOCATION == 0 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 0 ) )\n#error configSUPPORT_STATIC_ALLOCATION and configSUPPORT_DYNAMIC_ALLOCATION cannot both be 0, but can both be 1.\n#endif\n\n#if( ( configUSE_RECURSIVE_MUTEXES == 1 ) &amp;&amp; ( configUSE_MUTEXES != 1 ) )\n#error configUSE_MUTEXES must be set to 1 to use recursive mutexes\n#endif\n\n#ifndef configINITIAL_TICK_COUNT\n#define configINITIAL_TICK_COUNT 0\n#endif\n\n#if( portTICK_TYPE_IS_ATOMIC == 0 )\n/* Either variables of tick type cannot be read atomically, or\n    portTICK_TYPE_IS_ATOMIC was not set - map the critical sections used when\n    the tick count is returned to the standard critical section macros. */\n#define portTICK_TYPE_ENTER_CRITICAL() portENTER_CRITICAL()\n#define portTICK_TYPE_EXIT_CRITICAL() portEXIT_CRITICAL()\n#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()\n#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( ( x ) )\n#else\n/* The tick type can be read atomically, so critical sections used when the\n    tick count is returned can be defined away. */\n#define portTICK_TYPE_ENTER_CRITICAL()\n#define portTICK_TYPE_EXIT_CRITICAL()\n#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() 0\n#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) ( void ) x\n#endif\n\n/* Definitions to allow backward compatibility with FreeRTOS versions prior to\nV8 if desired. */\n#ifndef configENABLE_BACKWARD_COMPATIBILITY\n#define configENABLE_BACKWARD_COMPATIBILITY 1\n#endif\n\n#ifndef configPRINTF\n/* configPRINTF() was not defined, so define it away to nothing.  To use\n    configPRINTF() then define it as follows (where MyPrintFunction() is\n    provided by the application writer):\n\n    void MyPrintFunction(const char *pcFormat, ... );\n    #define configPRINTF( X )   MyPrintFunction X\n\n    Then call like a standard printf() function, but placing brackets around\n    all parameters so they are passed as a single parameter.  For example:\n    configPRINTF( (\"Value = %d\", MyVariable) ); */\n#define configPRINTF( X )\n#endif\n\n#ifndef configMAX\n/* The application writer has not provided their own MAX macro, so define\n    the following generic implementation. */\n#define configMAX( a, b ) ( ( ( a ) &gt; ( b ) ) ? ( a ) : ( b ) )\n#endif\n\n#ifndef configMIN\n/* The application writer has not provided their own MAX macro, so define\n    the following generic implementation. */\n#define configMIN( a, b ) ( ( ( a ) &lt; ( b ) ) ? ( a ) : ( b ) )\n#endif\n\n#if configENABLE_BACKWARD_COMPATIBILITY == 1\n#define eTaskStateGet eTaskGetState\n#define portTickType TickType_t\n#define xTaskHandle TaskHandle_t\n#define xQueueHandle QueueHandle_t\n#define xSemaphoreHandle SemaphoreHandle_t\n#define xQueueSetHandle QueueSetHandle_t\n#define xQueueSetMemberHandle QueueSetMemberHandle_t\n#define xTimeOutType TimeOut_t\n#define xMemoryRegion MemoryRegion_t\n#define xTaskParameters TaskParameters_t\n#define xTaskStatusType TaskStatus_t\n#define xTimerHandle TimerHandle_t\n#define xCoRoutineHandle CoRoutineHandle_t\n#define pdTASK_HOOK_CODE TaskHookFunction_t\n#define portTICK_RATE_MS portTICK_PERIOD_MS\n#define pcTaskGetTaskName pcTaskGetName\n#define pcTimerGetTimerName pcTimerGetName\n#define pcQueueGetQueueName pcQueueGetName\n#define vTaskGetTaskInfo vTaskGetInfo\n#define xTaskGetIdleRunTimeCounter ulTaskGetIdleRunTimeCounter\n\n/* Backward compatibility within the scheduler code only - these definitions\n    are not really required but are included for completeness. */\n#define tmrTIMER_CALLBACK TimerCallbackFunction_t\n#define pdTASK_CODE TaskFunction_t\n#define xListItem ListItem_t\n#define xList List_t\n\n/* For libraries that break the list data hiding, and access list structure\n    members directly (which is not supposed to be done). */\n#define pxContainer pvContainer\n#endif /* configENABLE_BACKWARD_COMPATIBILITY */\n\n#if( configUSE_ALTERNATIVE_API != 0 )\n#error The alternative API was deprecated some time ago, and was removed in FreeRTOS V9.0 0\n#endif\n\n/* Set configUSE_TASK_FPU_SUPPORT to 0 to omit floating point support even\nif floating point hardware is otherwise supported by the FreeRTOS port in use.\nThis constant is not supported by all FreeRTOS ports that include floating\npoint support. */\n#ifndef configUSE_TASK_FPU_SUPPORT\n#define configUSE_TASK_FPU_SUPPORT 1\n#endif\n\n/* Set configENABLE_MPU to 1 to enable MPU support and 0 to disable it. This is\ncurrently used in ARMv8M ports. */\n#ifndef configENABLE_MPU\n#define configENABLE_MPU 0\n#endif\n\n/* Set configENABLE_FPU to 1 to enable FPU support and 0 to disable it. This is\ncurrently used in ARMv8M ports. */\n#ifndef configENABLE_FPU\n#define configENABLE_FPU 1\n#endif\n\n/* Set configENABLE_TRUSTZONE to 1 enable TrustZone support and 0 to disable it.\nThis is currently used in ARMv8M ports. */\n#ifndef configENABLE_TRUSTZONE\n#define configENABLE_TRUSTZONE 1\n#endif\n\n/* Set configRUN_FREERTOS_SECURE_ONLY to 1 to run the FreeRTOS ARMv8M port on\nthe Secure Side only. */\n#ifndef configRUN_FREERTOS_SECURE_ONLY\n#define configRUN_FREERTOS_SECURE_ONLY 0\n#endif\n\n/* Sometimes the FreeRTOSConfig.h settings only allow a task to be created using\n * dynamically allocated RAM, in which case when any task is deleted it is known\n * that both the task's stack and TCB need to be freed.  Sometimes the\n * FreeRTOSConfig.h settings only allow a task to be created using statically\n * allocated RAM, in which case when any task is deleted it is known that neither\n * the task's stack or TCB should be freed.  Sometimes the FreeRTOSConfig.h\n * settings allow a task to be created using either statically or dynamically\n * allocated RAM, in which case a member of the TCB is used to record whether the\n * stack and/or TCB were allocated statically or dynamically, so when a task is\n * deleted the RAM that was allocated dynamically is freed again and no attempt is\n * made to free the RAM that was allocated statically.\n * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is only true if it is possible for a\n * task to be created using either statically or dynamically allocated RAM.  Note\n * that if portUSING_MPU_WRAPPERS is 1 then a protected task can be created with\n * a statically allocated stack and a dynamically allocated TCB.\n *\n * The following table lists various combinations of portUSING_MPU_WRAPPERS,\n * configSUPPORT_DYNAMIC_ALLOCATION and configSUPPORT_STATIC_ALLOCATION and\n * when it is possible to have both static and dynamic allocation:\n *  +-----+---------+--------+-----------------------------+-----------------------------------+------------------+-----------+\n * | MPU | Dynamic | Static |     Available Functions     |       Possible Allocations        | Both Dynamic and | Need Free |\n * |     |         |        |                             |                                   | Static Possible  |           |\n * +-----+---------+--------+-----------------------------+-----------------------------------+------------------+-----------+\n * | 0   | 0       | 1      | xTaskCreateStatic           | TCB - Static, Stack - Static      | No               | No        |\n * +-----|---------|--------|-----------------------------|-----------------------------------|------------------|-----------|\n * | 0   | 1       | 0      | xTaskCreate                 | TCB - Dynamic, Stack - Dynamic    | No               | Yes       |\n * +-----|---------|--------|-----------------------------|-----------------------------------|------------------|-----------|\n * | 0   | 1       | 1      | xTaskCreate,                | 1. TCB - Dynamic, Stack - Dynamic | Yes              | Yes       |\n * |     |         |        | xTaskCreateStatic           | 2. TCB - Static, Stack - Static   |                  |           |\n * +-----|---------|--------|-----------------------------|-----------------------------------|------------------|-----------|\n * | 1   | 0       | 1      | xTaskCreateStatic,          | TCB - Static, Stack - Static      | No               | No        |\n * |     |         |        | xTaskCreateRestrictedStatic |                                   |                  |           |\n * +-----|---------|--------|-----------------------------|-----------------------------------|------------------|-----------|\n * | 1   | 1       | 0      | xTaskCreate,                | 1. TCB - Dynamic, Stack - Dynamic | Yes              | Yes       |\n * |     |         |        | xTaskCreateRestricted       | 2. TCB - Dynamic, Stack - Static  |                  |           |\n * +-----|---------|--------|-----------------------------|-----------------------------------|------------------|-----------|\n * | 1   | 1       | 1      | xTaskCreate,                | 1. TCB - Dynamic, Stack - Dynamic | Yes              | Yes       |\n * |     |         |        | xTaskCreateStatic,          | 2. TCB - Dynamic, Stack - Static  |                  |           |\n * |     |         |        | xTaskCreateRestricted,      | 3. TCB - Static, Stack - Static   |                  |           |\n * |     |         |        | xTaskCreateRestrictedStatic |                                   |                  |           |\n * +-----+---------+--------+-----------------------------+-----------------------------------+------------------+-----------+\n */\n#define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE   ( ( ( portUSING_MPU_WRAPPERS == 0 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) || \\\n                                                      ( ( portUSING_MPU_WRAPPERS == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) )\n\n/*\n * In line with software engineering best practice, FreeRTOS implements a strict\n * data hiding policy, so the real structures used by FreeRTOS to maintain the\n * state of tasks, queues, semaphores, etc. are not accessible to the application\n * code.  However, if the application writer wants to statically allocate such\n * an object then the size of the object needs to be know.  Dummy structures\n * that are guaranteed to have the same size and alignment requirements of the\n * real objects are used for this purpose.  The dummy list and list item\n * structures below are used for inclusion in such a dummy structure.\n */\nstruct xSTATIC_LIST_ITEM\n{\n#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 1 )\nTickType_t xDummy1;\n#endif\nTickType_t xDummy2;\nvoid *pvDummy3[ 4 ];\n#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 1 )\nTickType_t xDummy4;\n#endif\n};\ntypedef struct xSTATIC_LIST_ITEM StaticListItem_t;\n\n/* See the comments above the struct xSTATIC_LIST_ITEM definition. */\nstruct xSTATIC_MINI_LIST_ITEM\n{\n#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 1 )\nTickType_t xDummy1;\n#endif\nTickType_t xDummy2;\nvoid *pvDummy3[ 2 ];\n};\ntypedef struct xSTATIC_MINI_LIST_ITEM StaticMiniListItem_t;\n\n/* See the comments above the struct xSTATIC_LIST_ITEM definition. */\ntypedef struct xSTATIC_LIST\n{\n#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 1 )\nTickType_t xDummy1;\n#endif\nUBaseType_t uxDummy2;\nvoid *pvDummy3;\nStaticMiniListItem_t xDummy4;\n#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 1 )\nTickType_t xDummy5;\n#endif\n} StaticList_t;\n\n/*\n * In line with software engineering best practice, especially when supplying a\n * library that is likely to change in future versions, FreeRTOS implements a\n * strict data hiding policy.  This means the Task structure used internally by\n * FreeRTOS is not accessible to application code.  However, if the application\n * writer wants to statically allocate the memory required to create a task then\n * the size of the task object needs to be know.  The StaticTask_t structure\n * below is provided for this purpose.  Its sizes and alignment requirements are\n * guaranteed to match those of the genuine structure, no matter which\n * architecture is being used, and no matter how the values in FreeRTOSConfig.h\n * are set.  Its contents are somewhat obfuscated in the hope users will\n * recognise that it would be unwise to make direct use of the structure members.\n */\ntypedef struct xSTATIC_TCB\n{\nvoid                *pxDummy1;\n#if ( portUSING_MPU_WRAPPERS == 1 )\nxMPU_SETTINGS   xDummy2;\n#endif\nStaticListItem_t    xDummy3[ 2 ];\nUBaseType_t         uxDummy5;\nvoid                *pxDummy6;\nuint8_t             ucDummy7[ configMAX_TASK_NAME_LEN ];\n#if ( ( portSTACK_GROWTH &gt; 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )\nvoid            *pxDummy8;\n#endif\n#if ( portCRITICAL_NESTING_IN_TCB == 1 )\nUBaseType_t     uxDummy9;\n#endif\n#if ( configUSE_TRACE_FACILITY == 1 )\nUBaseType_t     uxDummy10[ 2 ];\n#endif\n#if ( configUSE_MUTEXES == 1 )\nUBaseType_t     uxDummy12[ 2 ];\n#endif\n#if ( configUSE_APPLICATION_TASK_TAG == 1 )\nvoid            *pxDummy14;\n#endif\n#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 )\nvoid            *pvDummy15[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];\n#endif\n#if ( configGENERATE_RUN_TIME_STATS == 1 )\nuint32_t        ulDummy16;\n#endif\n#if ( configUSE_NEWLIB_REENTRANT == 1 )\nstruct  _reent  xDummy17;\n#endif\n#if ( configUSE_TASK_NOTIFICATIONS == 1 )\nuint32_t        ulDummy18;\nuint8_t         ucDummy19;\n#endif\n#if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )\nuint8_t         uxDummy20;\n#endif\n\n#if( INCLUDE_xTaskAbortDelay == 1 )\nuint8_t ucDummy21;\n#endif\n#if ( configUSE_POSIX_ERRNO == 1 )\nint             iDummy22;\n#endif\n} StaticTask_t;\n\n/*\n * In line with software engineering best practice, especially when supplying a\n * library that is likely to change in future versions, FreeRTOS implements a\n * strict data hiding policy.  This means the Queue structure used internally by\n * FreeRTOS is not accessible to application code.  However, if the application\n * writer wants to statically allocate the memory required to create a queue\n * then the size of the queue object needs to be know.  The StaticQueue_t\n * structure below is provided for this purpose.  Its sizes and alignment\n * requirements are guaranteed to match those of the genuine structure, no\n * matter which architecture is being used, and no matter how the values in\n * FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in the hope\n * users will recognise that it would be unwise to make direct use of the\n * structure members.\n */\ntypedef struct xSTATIC_QUEUE\n{\nvoid *pvDummy1[ 3 ];\n\nunion\n{\nvoid *pvDummy2;\nUBaseType_t uxDummy2;\n} u;\n\nStaticList_t xDummy3[ 2 ];\nUBaseType_t uxDummy4[ 3 ];\nuint8_t ucDummy5[ 2 ];\n\n#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )\nuint8_t ucDummy6;\n#endif\n\n#if ( configUSE_QUEUE_SETS == 1 )\nvoid *pvDummy7;\n#endif\n\n#if ( configUSE_TRACE_FACILITY == 1 )\nUBaseType_t uxDummy8;\nuint8_t ucDummy9;\n#endif\n\n} StaticQueue_t;\ntypedef StaticQueue_t StaticSemaphore_t;\n\n/*\n * In line with software engineering best practice, especially when supplying a\n * library that is likely to change in future versions, FreeRTOS implements a\n * strict data hiding policy.  This means the event group structure used\n * internally by FreeRTOS is not accessible to application code.  However, if\n * the application writer wants to statically allocate the memory required to\n * create an event group then the size of the event group object needs to be\n * know.  The StaticEventGroup_t structure below is provided for this purpose.\n * Its sizes and alignment requirements are guaranteed to match those of the\n * genuine structure, no matter which architecture is being used, and no matter\n * how the values in FreeRTOSConfig.h are set.  Its contents are somewhat\n * obfuscated in the hope users will recognise that it would be unwise to make\n * direct use of the structure members.\n */\ntypedef struct xSTATIC_EVENT_GROUP\n{\nTickType_t xDummy1;\nStaticList_t xDummy2;\n\n#if( configUSE_TRACE_FACILITY == 1 )\nUBaseType_t uxDummy3;\n#endif\n\n#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )\nuint8_t ucDummy4;\n#endif\n\n} StaticEventGroup_t;\n\n/*\n * In line with software engineering best practice, especially when supplying a\n * library that is likely to change in future versions, FreeRTOS implements a\n * strict data hiding policy.  This means the software timer structure used\n * internally by FreeRTOS is not accessible to application code.  However, if\n * the application writer wants to statically allocate the memory required to\n * create a software timer then the size of the queue object needs to be know.\n * The StaticTimer_t structure below is provided for this purpose.  Its sizes\n * and alignment requirements are guaranteed to match those of the genuine\n * structure, no matter which architecture is being used, and no matter how the\n * values in FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in\n * the hope users will recognise that it would be unwise to make direct use of\n * the structure members.\n */\ntypedef struct xSTATIC_TIMER\n{\nvoid                *pvDummy1;\nStaticListItem_t    xDummy2;\nTickType_t          xDummy3;\nvoid                *pvDummy5;\nTaskFunction_t      pvDummy6;\n#if( configUSE_TRACE_FACILITY == 1 )\nUBaseType_t     uxDummy7;\n#endif\nuint8_t             ucDummy8;\n\n} StaticTimer_t;\n\n/*\n* In line with software engineering best practice, especially when supplying a\n* library that is likely to change in future versions, FreeRTOS implements a\n* strict data hiding policy.  This means the stream buffer structure used\n* internally by FreeRTOS is not accessible to application code.  However, if\n* the application writer wants to statically allocate the memory required to\n* create a stream buffer then the size of the stream buffer object needs to be\n* know.  The StaticStreamBuffer_t structure below is provided for this purpose.\n* Its size and alignment requirements are guaranteed to match those of the\n* genuine structure, no matter which architecture is being used, and no matter\n* how the values in FreeRTOSConfig.h are set.  Its contents are somewhat\n* obfuscated in the hope users will recognise that it would be unwise to make\n* direct use of the structure members.\n*/\ntypedef struct xSTATIC_STREAM_BUFFER\n{\nsize_t uxDummy1[ 4 ];\nvoid * pvDummy2[ 3 ];\nuint8_t ucDummy3;\n#if ( configUSE_TRACE_FACILITY == 1 )\nUBaseType_t uxDummy4;\n#endif\n} StaticStreamBuffer_t;\n\n/* Message buffers are built on stream buffers. */\ntypedef StaticStreamBuffer_t StaticMessageBuffer_t;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* INC_FREERTOS_H */\n</code></pre>"},{"location":"apiStm/atomic_8h/","title":"File atomic.h","text":"<p>FileList &gt; FreeRTOS &gt; include &gt; atomic.h</p> <p>Go to the source code of this file.</p> <p>FreeRTOS atomic operation support. More...</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"apiStm/atomic_8h/#public-static-functions","title":"Public Static Functions","text":"Type Name portFORCE_INLINE uint32_t Atomic_AND_u32 (uint32_t volatile * pulDestination, uint32_t ulValue) Performs an atomic AND operation on the specified values. portFORCE_INLINE uint32_t Atomic_Add_u32 (uint32_t volatile * pulAddend, uint32_t ulCount) Atomically adds count to the value of the specified pointer points to. portFORCE_INLINE uint32_t Atomic_CompareAndSwapPointers_p32 (void *volatile * ppvDestination, void * pvExchange, void * pvComparand) Performs an atomic compare-and-swap operation on the specified pointer values. portFORCE_INLINE uint32_t Atomic_CompareAndSwap_u32 (uint32_t volatile * pulDestination, uint32_t ulExchange, uint32_t ulComparand) Performs an atomic compare-and-swap operation on the specified values. portFORCE_INLINE uint32_t Atomic_Decrement_u32 (uint32_t volatile * pulAddend) Atomically decrements the value of the specified pointer points to. portFORCE_INLINE uint32_t Atomic_Increment_u32 (uint32_t volatile * pulAddend) Atomically increments the value of the specified pointer points to. portFORCE_INLINE uint32_t Atomic_NAND_u32 (uint32_t volatile * pulDestination, uint32_t ulValue) Performs an atomic NAND operation on the specified values. portFORCE_INLINE uint32_t Atomic_OR_u32 (uint32_t volatile * pulDestination, uint32_t ulValue) Performs an atomic OR operation on the specified values. portFORCE_INLINE uint32_t Atomic_Subtract_u32 (uint32_t volatile * pulAddend, uint32_t ulCount) Atomically subtracts count from the value of the specified pointer pointers to. portFORCE_INLINE void * Atomic_SwapPointers_p32 (void *volatile * ppvDestination, void * pvExchange) Atomically sets the address pointed to by *ppvDestination to the value of *pvExchange. portFORCE_INLINE uint32_t Atomic_XOR_u32 (uint32_t volatile * pulDestination, uint32_t ulValue) Performs an atomic XOR operation on the specified values."},{"location":"apiStm/atomic_8h/#macros","title":"Macros","text":"Type Name define ATOMIC_COMPARE_AND_SWAP_FAILURE  0x0U define ATOMIC_COMPARE_AND_SWAP_SUCCESS  0x1U define ATOMIC_ENTER_CRITICAL () portENTER_CRITICAL() define ATOMIC_EXIT_CRITICAL () portEXIT_CRITICAL() define portFORCE_INLINE"},{"location":"apiStm/atomic_8h/#detailed-description","title":"Detailed Description","text":"<p>This file implements atomic functions by disabling interrupts globally. Implementations with architecture specific atomic instructions can be provided under each compiler directory. </p>"},{"location":"apiStm/atomic_8h/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"apiStm/atomic_8h/#function-atomic_and_u32","title":"function Atomic_AND_u32","text":"<p>Performs an atomic AND operation on the specified values. <pre><code>static portFORCE_INLINE uint32_t Atomic_AND_u32 (\nuint32_t volatile * pulDestination,\nuint32_t ulValue\n) </code></pre></p> <p>Atomic AND</p> <p>Parameters:</p> <ul> <li><code>pulDestination</code> Pointer to memory location from where value is to be loaded and written back to. </li> <li><code>ulValue</code> Value to be ANDed with *pulDestination.</li> </ul> <p>Returns:</p> <p>The original value of *pulDestination. </p>"},{"location":"apiStm/atomic_8h/#function-atomic_add_u32","title":"function Atomic_Add_u32","text":"<p>Atomically adds count to the value of the specified pointer points to. <pre><code>static portFORCE_INLINE uint32_t Atomic_Add_u32 (\nuint32_t volatile * pulAddend,\nuint32_t ulCount\n) </code></pre></p> <p>Atomic add</p> <p>Parameters:</p> <ul> <li><code>pulAddend</code> Pointer to memory location from where value is to be loaded and written back to. </li> <li><code>ulCount</code> Value to be added to *pulAddend.</li> </ul> <p>Returns:</p> <p>previous *pulAddend value. </p>"},{"location":"apiStm/atomic_8h/#function-atomic_compareandswappointers_p32","title":"function Atomic_CompareAndSwapPointers_p32","text":"<p>Performs an atomic compare-and-swap operation on the specified pointer values. <pre><code>static portFORCE_INLINE uint32_t Atomic_CompareAndSwapPointers_p32 (\nvoid *volatile * ppvDestination,\nvoid * pvExchange,\nvoid * pvComparand\n) </code></pre></p> <p>Atomic compare-and-swap (pointers)</p> <p>Parameters:</p> <ul> <li><code>ppvDestination</code> Pointer to memory location from where a pointer value is to be loaded and checked. </li> <li><code>pvExchange</code> If condition meets, write this value to memory. </li> <li><code>pvComparand</code> Swap condition.</li> </ul> <p>Returns:</p> <p>Unsigned integer of value 1 or 0. 1 for swapped, 0 for not swapped.</p> <p>Note:</p> <p>This function only swaps *ppvDestination with pvExchange, if previous *ppvDestination value equals pvComparand. </p>"},{"location":"apiStm/atomic_8h/#function-atomic_compareandswap_u32","title":"function Atomic_CompareAndSwap_u32","text":"<p>Performs an atomic compare-and-swap operation on the specified values. <pre><code>static portFORCE_INLINE uint32_t Atomic_CompareAndSwap_u32 (\nuint32_t volatile * pulDestination,\nuint32_t ulExchange,\nuint32_t ulComparand\n) </code></pre></p> <p>Atomic compare-and-swap</p> <p>Parameters:</p> <ul> <li><code>pulDestination</code> Pointer to memory location from where value is to be loaded and checked. </li> <li><code>ulExchange</code> If condition meets, write this value to memory. </li> <li><code>ulComparand</code> Swap condition.</li> </ul> <p>Returns:</p> <p>Unsigned integer of value 1 or 0. 1 for swapped, 0 for not swapped.</p> <p>Note:</p> <p>This function only swaps *pulDestination with ulExchange, if previous *pulDestination value equals ulComparand. </p>"},{"location":"apiStm/atomic_8h/#function-atomic_decrement_u32","title":"function Atomic_Decrement_u32","text":"<p>Atomically decrements the value of the specified pointer points to. <pre><code>static portFORCE_INLINE uint32_t Atomic_Decrement_u32 (\nuint32_t volatile * pulAddend\n) </code></pre></p> <p>Atomic decrement</p> <p>Parameters:</p> <ul> <li><code>pulAddend</code> Pointer to memory location from where value is to be loaded and written back to.</li> </ul> <p>Returns:</p> <p>*pulAddend value before decrement. </p>"},{"location":"apiStm/atomic_8h/#function-atomic_increment_u32","title":"function Atomic_Increment_u32","text":"<p>Atomically increments the value of the specified pointer points to. <pre><code>static portFORCE_INLINE uint32_t Atomic_Increment_u32 (\nuint32_t volatile * pulAddend\n) </code></pre></p> <p>Atomic increment</p> <p>Parameters:</p> <ul> <li><code>pulAddend</code> Pointer to memory location from where value is to be loaded and written back to.</li> </ul> <p>Returns:</p> <p>*pulAddend value before increment. </p>"},{"location":"apiStm/atomic_8h/#function-atomic_nand_u32","title":"function Atomic_NAND_u32","text":"<p>Performs an atomic NAND operation on the specified values. <pre><code>static portFORCE_INLINE uint32_t Atomic_NAND_u32 (\nuint32_t volatile * pulDestination,\nuint32_t ulValue\n) </code></pre></p> <p>Atomic NAND</p> <p>Parameters:</p> <ul> <li><code>pulDestination</code> Pointer to memory location from where value is to be loaded and written back to. </li> <li><code>ulValue</code> Value to be NANDed with *pulDestination.</li> </ul> <p>Returns:</p> <p>The original value of *pulDestination. </p>"},{"location":"apiStm/atomic_8h/#function-atomic_or_u32","title":"function Atomic_OR_u32","text":"<p>Performs an atomic OR operation on the specified values. <pre><code>static portFORCE_INLINE uint32_t Atomic_OR_u32 (\nuint32_t volatile * pulDestination,\nuint32_t ulValue\n) </code></pre></p> <p>Atomic OR</p> <p>Parameters:</p> <ul> <li><code>pulDestination</code> Pointer to memory location from where value is to be loaded and written back to. </li> <li><code>ulValue</code> Value to be ORed with *pulDestination.</li> </ul> <p>Returns:</p> <p>The original value of *pulDestination. </p>"},{"location":"apiStm/atomic_8h/#function-atomic_subtract_u32","title":"function Atomic_Subtract_u32","text":"<p>Atomically subtracts count from the value of the specified pointer pointers to. <pre><code>static portFORCE_INLINE uint32_t Atomic_Subtract_u32 (\nuint32_t volatile * pulAddend,\nuint32_t ulCount\n) </code></pre></p> <p>Atomic subtract</p> <p>Parameters:</p> <ul> <li><code>pulAddend</code> Pointer to memory location from where value is to be loaded and written back to. </li> <li><code>ulCount</code> Value to be subtract from *pulAddend.</li> </ul> <p>Returns:</p> <p>previous *pulAddend value. </p>"},{"location":"apiStm/atomic_8h/#function-atomic_swappointers_p32","title":"function Atomic_SwapPointers_p32","text":"<p>Atomically sets the address pointed to by *ppvDestination to the value of *pvExchange. <pre><code>static portFORCE_INLINE void * Atomic_SwapPointers_p32 (\nvoid *volatile * ppvDestination,\nvoid * pvExchange\n) </code></pre></p> <p>Atomic swap (pointers)</p> <p>Parameters:</p> <ul> <li><code>ppvDestination</code> Pointer to memory location from where a pointer value is to be loaded and written back to. </li> <li><code>pvExchange</code> Pointer value to be written to *ppvDestination.</li> </ul> <p>Returns:</p> <p>The initial value of *ppvDestination. </p>"},{"location":"apiStm/atomic_8h/#function-atomic_xor_u32","title":"function Atomic_XOR_u32","text":"<p>Performs an atomic XOR operation on the specified values. <pre><code>static portFORCE_INLINE uint32_t Atomic_XOR_u32 (\nuint32_t volatile * pulDestination,\nuint32_t ulValue\n) </code></pre></p> <p>Atomic XOR</p> <p>Parameters:</p> <ul> <li><code>pulDestination</code> Pointer to memory location from where value is to be loaded and written back to. </li> <li><code>ulValue</code> Value to be XORed with *pulDestination.</li> </ul> <p>Returns:</p> <p>The original value of *pulDestination. </p>"},{"location":"apiStm/atomic_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/atomic_8h/#define-atomic_compare_and_swap_failure","title":"define ATOMIC_COMPARE_AND_SWAP_FAILURE","text":"<pre><code>#define ATOMIC_COMPARE_AND_SWAP_FAILURE 0x0U\n</code></pre> <p>Compare and swap failed, did not swap. </p>"},{"location":"apiStm/atomic_8h/#define-atomic_compare_and_swap_success","title":"define ATOMIC_COMPARE_AND_SWAP_SUCCESS","text":"<pre><code>#define ATOMIC_COMPARE_AND_SWAP_SUCCESS 0x1U\n</code></pre> <p>Compare and swap succeeded, swapped. </p>"},{"location":"apiStm/atomic_8h/#define-atomic_enter_critical","title":"define ATOMIC_ENTER_CRITICAL","text":"<pre><code>#define ATOMIC_ENTER_CRITICAL (\n\n) portENTER_CRITICAL()\n</code></pre>"},{"location":"apiStm/atomic_8h/#define-atomic_exit_critical","title":"define ATOMIC_EXIT_CRITICAL","text":"<pre><code>#define ATOMIC_EXIT_CRITICAL (\n\n) portEXIT_CRITICAL()\n</code></pre>"},{"location":"apiStm/atomic_8h/#define-portforce_inline","title":"define portFORCE_INLINE","text":"<pre><code>#define portFORCE_INLINE \n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/atomic.h</code></p>"},{"location":"apiStm/atomic_8h_source/","title":"File atomic.h","text":"<p>File List &gt; FreeRTOS &gt; include &gt; atomic.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n#ifndef ATOMIC_H\n#define ATOMIC_H\n\n#ifndef INC_FREERTOS_H\n#error \"include FreeRTOS.h must appear in source files before include atomic.h\"\n#endif\n\n/* Standard includes. */\n#include &lt;stdint.h&gt;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * Port specific definitions -- entering/exiting critical section.\n * Refer template -- ./lib/FreeRTOS/portable/Compiler/Arch/portmacro.h\n *\n * Every call to ATOMIC_EXIT_CRITICAL() must be closely paired with\n * ATOMIC_ENTER_CRITICAL().\n *\n */\n#if defined( portSET_INTERRUPT_MASK_FROM_ISR )\n\n/* Nested interrupt scheme is supported in this port. */\n#define ATOMIC_ENTER_CRITICAL()  \\\n        UBaseType_t uxCriticalSectionType = portSET_INTERRUPT_MASK_FROM_ISR()\n\n#define ATOMIC_EXIT_CRITICAL()    \\\n        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxCriticalSectionType )\n\n#else\n\n/* Nested interrupt scheme is NOT supported in this port. */\n#define ATOMIC_ENTER_CRITICAL()  portENTER_CRITICAL()\n#define ATOMIC_EXIT_CRITICAL()    portEXIT_CRITICAL()\n\n#endif /* portSET_INTERRUPT_MASK_FROM_ISR() */\n\n/*\n * Port specific definition -- \"always inline\".\n * Inline is compiler specific, and may not always get inlined depending on your\n * optimization level.  Also, inline is considered as performance optimization\n * for atomic.  Thus, if portFORCE_INLINE is not provided by portmacro.h,\n * instead of resulting error, simply define it away.\n */\n#ifndef portFORCE_INLINE\n#define portFORCE_INLINE\n#endif\n\n#define ATOMIC_COMPARE_AND_SWAP_SUCCESS  0x1U       \n#define ATOMIC_COMPARE_AND_SWAP_FAILURE  0x0U       \n/*----------------------------- Swap &amp;&amp; CAS ------------------------------*/\n\nstatic portFORCE_INLINE uint32_t Atomic_CompareAndSwap_u32( uint32_t volatile * pulDestination,\nuint32_t ulExchange,\nuint32_t ulComparand )\n{\nuint32_t ulReturnValue;\n\nATOMIC_ENTER_CRITICAL();\n{\nif( *pulDestination == ulComparand )\n{\n*pulDestination = ulExchange;\nulReturnValue = ATOMIC_COMPARE_AND_SWAP_SUCCESS;\n}\nelse\n{\nulReturnValue = ATOMIC_COMPARE_AND_SWAP_FAILURE;\n}\n}\nATOMIC_EXIT_CRITICAL();\n\nreturn ulReturnValue;\n}\n/*-----------------------------------------------------------*/\n\nstatic portFORCE_INLINE void * Atomic_SwapPointers_p32( void * volatile * ppvDestination,\nvoid * pvExchange )\n{\nvoid * pReturnValue;\n\nATOMIC_ENTER_CRITICAL();\n{\npReturnValue = *ppvDestination;\n*ppvDestination = pvExchange;\n}\nATOMIC_EXIT_CRITICAL();\n\nreturn pReturnValue;\n}\n/*-----------------------------------------------------------*/\n\nstatic portFORCE_INLINE uint32_t Atomic_CompareAndSwapPointers_p32( void * volatile * ppvDestination,\nvoid * pvExchange,\nvoid * pvComparand )\n{\nuint32_t ulReturnValue = ATOMIC_COMPARE_AND_SWAP_FAILURE;\n\nATOMIC_ENTER_CRITICAL();\n{\nif( *ppvDestination == pvComparand )\n{\n*ppvDestination = pvExchange;\nulReturnValue = ATOMIC_COMPARE_AND_SWAP_SUCCESS;\n}\n}\nATOMIC_EXIT_CRITICAL();\n\nreturn ulReturnValue;\n}\n\n\n/*----------------------------- Arithmetic ------------------------------*/\n\nstatic portFORCE_INLINE uint32_t Atomic_Add_u32( uint32_t volatile * pulAddend,\nuint32_t ulCount )\n{\nuint32_t ulCurrent;\n\nATOMIC_ENTER_CRITICAL();\n{\nulCurrent = *pulAddend;\n*pulAddend += ulCount;\n}\nATOMIC_EXIT_CRITICAL();\n\nreturn ulCurrent;\n}\n/*-----------------------------------------------------------*/\n\nstatic portFORCE_INLINE uint32_t Atomic_Subtract_u32( uint32_t volatile * pulAddend,\nuint32_t ulCount )\n{\nuint32_t ulCurrent;\n\nATOMIC_ENTER_CRITICAL();\n{\nulCurrent = *pulAddend;\n*pulAddend -= ulCount;\n}\nATOMIC_EXIT_CRITICAL();\n\nreturn ulCurrent;\n}\n/*-----------------------------------------------------------*/\n\nstatic portFORCE_INLINE uint32_t Atomic_Increment_u32( uint32_t volatile * pulAddend )\n{\nuint32_t ulCurrent;\n\nATOMIC_ENTER_CRITICAL();\n{\nulCurrent = *pulAddend;\n*pulAddend += 1;\n}\nATOMIC_EXIT_CRITICAL();\n\nreturn ulCurrent;\n}\n/*-----------------------------------------------------------*/\n\nstatic portFORCE_INLINE uint32_t Atomic_Decrement_u32( uint32_t volatile * pulAddend )\n{\nuint32_t ulCurrent;\n\nATOMIC_ENTER_CRITICAL();\n{\nulCurrent = *pulAddend;\n*pulAddend -= 1;\n}\nATOMIC_EXIT_CRITICAL();\n\nreturn ulCurrent;\n}\n\n/*----------------------------- Bitwise Logical ------------------------------*/\n\nstatic portFORCE_INLINE uint32_t Atomic_OR_u32( uint32_t volatile * pulDestination,\nuint32_t ulValue )\n{\nuint32_t ulCurrent;\n\nATOMIC_ENTER_CRITICAL();\n{\nulCurrent = *pulDestination;\n*pulDestination |= ulValue;\n}\nATOMIC_EXIT_CRITICAL();\n\nreturn ulCurrent;\n}\n/*-----------------------------------------------------------*/\n\nstatic portFORCE_INLINE uint32_t Atomic_AND_u32( uint32_t volatile * pulDestination,\nuint32_t ulValue )\n{\nuint32_t ulCurrent;\n\nATOMIC_ENTER_CRITICAL();\n{\nulCurrent = *pulDestination;\n*pulDestination &amp;= ulValue;\n}\nATOMIC_EXIT_CRITICAL();\n\nreturn ulCurrent;\n}\n/*-----------------------------------------------------------*/\n\nstatic portFORCE_INLINE uint32_t Atomic_NAND_u32( uint32_t volatile * pulDestination,\nuint32_t ulValue )\n{\nuint32_t ulCurrent;\n\nATOMIC_ENTER_CRITICAL();\n{\nulCurrent = *pulDestination;\n*pulDestination = ~( ulCurrent &amp; ulValue );\n}\nATOMIC_EXIT_CRITICAL();\n\nreturn ulCurrent;\n}\n/*-----------------------------------------------------------*/\n\nstatic portFORCE_INLINE uint32_t Atomic_XOR_u32( uint32_t volatile * pulDestination,\nuint32_t ulValue )\n{\nuint32_t ulCurrent;\n\nATOMIC_ENTER_CRITICAL();\n{\nulCurrent = *pulDestination;\n*pulDestination ^= ulValue;\n}\nATOMIC_EXIT_CRITICAL();\n\nreturn ulCurrent;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* ATOMIC_H */\n</code></pre>"},{"location":"apiStm/croutine_8h/","title":"File croutine.h","text":"<p>FileList &gt; FreeRTOS &gt; include &gt; croutine.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"list.h\"</code></li> </ul>"},{"location":"apiStm/croutine_8h/#classes","title":"Classes","text":"Type Name struct corCoRoutineControlBlock"},{"location":"apiStm/croutine_8h/#public-types","title":"Public Types","text":"Type Name typedef struct corCoRoutineControlBlock CRCB_t typedef void * CoRoutineHandle_t typedef void(* crCOROUTINE_CODE"},{"location":"apiStm/croutine_8h/#public-functions","title":"Public Functions","text":"Type Name void vCoRoutineAddToDelayedList (TickType_t xTicksToDelay, List_t * pxEventList)  void vCoRoutineSchedule (void)  BaseType_t xCoRoutineCreate (crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex)  BaseType_t xCoRoutineRemoveFromEventList (const List_t * pxEventList)"},{"location":"apiStm/croutine_8h/#macros","title":"Macros","text":"Type Name define crDELAY (xHandle, xTicksToDelay)  define crEND () } define crQUEUE_RECEIVE (xHandle, pxQueue, pvBuffer, xTicksToWait, pxResult)  define crQUEUE_RECEIVE_FROM_ISR (pxQueue, pvBuffer, pxCoRoutineWoken) xQueueCRReceiveFromISR( ( pxQueue ), ( pvBuffer ), ( pxCoRoutineWoken ) ) define crQUEUE_SEND (xHandle, pxQueue, pvItemToQueue, xTicksToWait, pxResult)  define crQUEUE_SEND_FROM_ISR (pxQueue, pvItemToQueue, xCoRoutinePreviouslyWoken) xQueueCRSendFromISR( ( pxQueue ), ( pvItemToQueue ), ( xCoRoutinePreviouslyWoken ) ) define crSET_STATE0 (xHandle) ( ( CRCB_t * )( xHandle ) )-&gt;uxState = (__LINE__ * 2); return; case (__LINE__ * 2): define crSET_STATE1 (xHandle) ( ( CRCB_t * )( xHandle ) )-&gt;uxState = ((__LINE__ * 2)+1); return; case ((__LINE__ * 2)+1): define crSTART (pxCRCB) switch( ( ( CRCB_t * )( pxCRCB ) )-&gt;uxState ) { case 0:"},{"location":"apiStm/croutine_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/croutine_8h/#typedef-crcb_t","title":"typedef CRCB_t","text":"<pre><code>typedef struct corCoRoutineControlBlock CRCB_t;\n</code></pre>"},{"location":"apiStm/croutine_8h/#typedef-coroutinehandle_t","title":"typedef CoRoutineHandle_t","text":"<pre><code>typedef void* CoRoutineHandle_t;\n</code></pre>"},{"location":"apiStm/croutine_8h/#typedef-crcoroutine_code","title":"typedef crCOROUTINE_CODE","text":"<pre><code>typedef void(* crCOROUTINE_CODE) (CoRoutineHandle_t, UBaseType_t);\n</code></pre>"},{"location":"apiStm/croutine_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/croutine_8h/#function-vcoroutineaddtodelayedlist","title":"function vCoRoutineAddToDelayedList","text":"<pre><code>void vCoRoutineAddToDelayedList (\nTickType_t xTicksToDelay,\nList_t * pxEventList\n) </code></pre>"},{"location":"apiStm/croutine_8h/#function-vcoroutineschedule","title":"function vCoRoutineSchedule","text":"<pre><code>void vCoRoutineSchedule (\nvoid\n) </code></pre>"},{"location":"apiStm/croutine_8h/#function-xcoroutinecreate","title":"function xCoRoutineCreate","text":"<pre><code>BaseType_t xCoRoutineCreate (\ncrCOROUTINE_CODE pxCoRoutineCode,\nUBaseType_t uxPriority,\nUBaseType_t uxIndex\n) </code></pre>"},{"location":"apiStm/croutine_8h/#function-xcoroutineremovefromeventlist","title":"function xCoRoutineRemoveFromEventList","text":"<pre><code>BaseType_t xCoRoutineRemoveFromEventList (\nconst List_t * pxEventList\n) </code></pre>"},{"location":"apiStm/croutine_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/croutine_8h/#define-crdelay","title":"define crDELAY","text":"<pre><code>#define crDELAY (\nxHandle,\nxTicksToDelay\n) if( ( xTicksToDelay ) &gt; 0 )                                                           \\\n    {                                                                                   \\\n        vCoRoutineAddToDelayedList( ( xTicksToDelay ), NULL );                          \\\n    }                                                                                   \\\n    crSET_STATE0( ( xHandle ) );\n</code></pre>"},{"location":"apiStm/croutine_8h/#define-crend","title":"define crEND","text":"<pre><code>#define crEND (\n\n) }\n</code></pre>"},{"location":"apiStm/croutine_8h/#define-crqueue_receive","title":"define crQUEUE_RECEIVE","text":"<pre><code>#define crQUEUE_RECEIVE (\nxHandle,\npxQueue,\npvBuffer,\nxTicksToWait,\npxResult\n) {                                                                                     \\\n    *( pxResult ) = xQueueCRReceive( ( pxQueue) , ( pvBuffer ), ( xTicksToWait ) );     \\\n    if( *( pxResult ) == errQUEUE_BLOCKED )                                             \\\n    {                                                                                   \\\n        crSET_STATE0( ( xHandle ) );                                                    \\\n        *( pxResult ) = xQueueCRReceive( ( pxQueue) , ( pvBuffer ), 0 );                \\\n    }                                                                                   \\\n    if( *( pxResult ) == errQUEUE_YIELD )                                               \\\n    {                                                                                   \\\n        crSET_STATE1( ( xHandle ) );                                                    \\\n        *( pxResult ) = pdPASS;                                                         \\\n    }                                                                                   \\\n}\n</code></pre>"},{"location":"apiStm/croutine_8h/#define-crqueue_receive_from_isr","title":"define crQUEUE_RECEIVE_FROM_ISR","text":"<pre><code>#define crQUEUE_RECEIVE_FROM_ISR (\npxQueue,\npvBuffer,\npxCoRoutineWoken\n) xQueueCRReceiveFromISR( ( pxQueue ), ( pvBuffer ), ( pxCoRoutineWoken ) )\n</code></pre>"},{"location":"apiStm/croutine_8h/#define-crqueue_send","title":"define crQUEUE_SEND","text":"<pre><code>#define crQUEUE_SEND (\nxHandle,\npxQueue,\npvItemToQueue,\nxTicksToWait,\npxResult\n) {                                                                                     \\\n    *( pxResult ) = xQueueCRSend( ( pxQueue) , ( pvItemToQueue) , ( xTicksToWait ) );   \\\n    if( *( pxResult ) == errQUEUE_BLOCKED )                                             \\\n    {                                                                                   \\\n        crSET_STATE0( ( xHandle ) );                                                    \\\n        *pxResult = xQueueCRSend( ( pxQueue ), ( pvItemToQueue ), 0 );                  \\\n    }                                                                                   \\\n    if( *pxResult == errQUEUE_YIELD )                                                   \\\n    {                                                                                   \\\n        crSET_STATE1( ( xHandle ) );                                                    \\\n        *pxResult = pdPASS;                                                             \\\n    }                                                                                   \\\n}\n</code></pre>"},{"location":"apiStm/croutine_8h/#define-crqueue_send_from_isr","title":"define crQUEUE_SEND_FROM_ISR","text":"<pre><code>#define crQUEUE_SEND_FROM_ISR (\npxQueue,\npvItemToQueue,\nxCoRoutinePreviouslyWoken\n) xQueueCRSendFromISR( ( pxQueue ), ( pvItemToQueue ), ( xCoRoutinePreviouslyWoken ) )\n</code></pre>"},{"location":"apiStm/croutine_8h/#define-crset_state0","title":"define crSET_STATE0","text":"<pre><code>#define crSET_STATE0 (\nxHandle\n) ( ( CRCB_t * )( xHandle ) )-&gt;uxState = (__LINE__ * 2); return; case (__LINE__ * 2):\n</code></pre>"},{"location":"apiStm/croutine_8h/#define-crset_state1","title":"define crSET_STATE1","text":"<pre><code>#define crSET_STATE1 (\nxHandle\n) ( ( CRCB_t * )( xHandle ) )-&gt;uxState = ((__LINE__ * 2)+1); return; case ((__LINE__ * 2)+1):\n</code></pre>"},{"location":"apiStm/croutine_8h/#define-crstart","title":"define crSTART","text":"<pre><code>#define crSTART (\npxCRCB\n) switch( ( ( CRCB_t * )( pxCRCB ) )-&gt;uxState ) { case 0:\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/croutine.h</code></p>"},{"location":"apiStm/croutine_8h_source/","title":"File croutine.h","text":"<p>File List &gt; FreeRTOS &gt; include &gt; croutine.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n#ifndef CO_ROUTINE_H\n#define CO_ROUTINE_H\n\n#ifndef INC_FREERTOS_H\n#error \"include FreeRTOS.h must appear in source files before include croutine.h\"\n#endif\n\n#include \"list.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Used to hide the implementation of the co-routine control block.  The\ncontrol block structure however has to be included in the header due to\nthe macro implementation of the co-routine functionality. */\ntypedef void * CoRoutineHandle_t;\n\n/* Defines the prototype to which co-routine functions must conform. */\ntypedef void (*crCOROUTINE_CODE)( CoRoutineHandle_t, UBaseType_t );\n\ntypedef struct corCoRoutineControlBlock\n{\ncrCOROUTINE_CODE    pxCoRoutineFunction;\nListItem_t          xGenericListItem;   /*&lt; List item used to place the CRCB in ready and blocked queues. */\nListItem_t          xEventListItem;     /*&lt; List item used to place the CRCB in event lists. */\nUBaseType_t         uxPriority;         /*&lt; The priority of the co-routine in relation to other co-routines. */\nUBaseType_t         uxIndex;            /*&lt; Used to distinguish between co-routines when multiple co-routines use the same co-routine function. */\nuint16_t            uxState;            /*&lt; Used internally by the co-routine implementation. */\n} CRCB_t; /* Co-routine control block.  Note must be identical in size down to uxPriority with TCB_t. */\n\nBaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex );\n\n\nvoid vCoRoutineSchedule( void );\n\n#define crSTART( pxCRCB ) switch( ( ( CRCB_t * )( pxCRCB ) )-&gt;uxState ) { case 0:\n\n#define crEND() }\n\n/*\n * These macros are intended for internal use by the co-routine implementation\n * only.  The macros should not be used directly by application writers.\n */\n#define crSET_STATE0( xHandle ) ( ( CRCB_t * )( xHandle ) )-&gt;uxState = (__LINE__ * 2); return; case (__LINE__ * 2):\n#define crSET_STATE1( xHandle ) ( ( CRCB_t * )( xHandle ) )-&gt;uxState = ((__LINE__ * 2)+1); return; case ((__LINE__ * 2)+1):\n\n#define crDELAY( xHandle, xTicksToDelay )                                               \\\n    if( ( xTicksToDelay ) &gt; 0 )                                                         \\\n    {                                                                                   \\\n        vCoRoutineAddToDelayedList( ( xTicksToDelay ), NULL );                          \\\n    }                                                                                   \\\n    crSET_STATE0( ( xHandle ) );\n\n#define crQUEUE_SEND( xHandle, pxQueue, pvItemToQueue, xTicksToWait, pxResult )         \\\n{                                                                                       \\\n    *( pxResult ) = xQueueCRSend( ( pxQueue) , ( pvItemToQueue) , ( xTicksToWait ) );   \\\n    if( *( pxResult ) == errQUEUE_BLOCKED )                                             \\\n    {                                                                                   \\\n        crSET_STATE0( ( xHandle ) );                                                    \\\n        *pxResult = xQueueCRSend( ( pxQueue ), ( pvItemToQueue ), 0 );                  \\\n    }                                                                                   \\\n    if( *pxResult == errQUEUE_YIELD )                                                   \\\n    {                                                                                   \\\n        crSET_STATE1( ( xHandle ) );                                                    \\\n        *pxResult = pdPASS;                                                             \\\n    }                                                                                   \\\n}\n\n#define crQUEUE_RECEIVE( xHandle, pxQueue, pvBuffer, xTicksToWait, pxResult )           \\\n{                                                                                       \\\n    *( pxResult ) = xQueueCRReceive( ( pxQueue) , ( pvBuffer ), ( xTicksToWait ) );     \\\n    if( *( pxResult ) == errQUEUE_BLOCKED )                                             \\\n    {                                                                                   \\\n        crSET_STATE0( ( xHandle ) );                                                    \\\n        *( pxResult ) = xQueueCRReceive( ( pxQueue) , ( pvBuffer ), 0 );                \\\n    }                                                                                   \\\n    if( *( pxResult ) == errQUEUE_YIELD )                                               \\\n    {                                                                                   \\\n        crSET_STATE1( ( xHandle ) );                                                    \\\n        *( pxResult ) = pdPASS;                                                         \\\n    }                                                                                   \\\n}\n\n#define crQUEUE_SEND_FROM_ISR( pxQueue, pvItemToQueue, xCoRoutinePreviouslyWoken ) xQueueCRSendFromISR( ( pxQueue ), ( pvItemToQueue ), ( xCoRoutinePreviouslyWoken ) )\n\n\n#define crQUEUE_RECEIVE_FROM_ISR( pxQueue, pvBuffer, pxCoRoutineWoken ) xQueueCRReceiveFromISR( ( pxQueue ), ( pvBuffer ), ( pxCoRoutineWoken ) )\n\n/*\n * This function is intended for internal use by the co-routine macros only.\n * The macro nature of the co-routine implementation requires that the\n * prototype appears here.  The function should not be used by application\n * writers.\n *\n * Removes the current co-routine from its ready list and places it in the\n * appropriate delayed list.\n */\nvoid vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList );\n\n/*\n * This function is intended for internal use by the queue implementation only.\n * The function should not be used by application writers.\n *\n * Removes the highest priority co-routine from the event list and places it in\n * the pending ready list.\n */\nBaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList );\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* CO_ROUTINE_H */\n</code></pre>"},{"location":"apiStm/deprecated__definitions_8h/","title":"File deprecated_definitions.h","text":"<p>FileList &gt; FreeRTOS &gt; include &gt; deprecated_definitions.h</p> <p>Go to the source code of this file.</p> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/deprecated_definitions.h</code></p>"},{"location":"apiStm/deprecated__definitions_8h_source/","title":"File deprecated_definitions.h","text":"<p>File List &gt; FreeRTOS &gt; include &gt; deprecated_definitions.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n#ifndef DEPRECATED_DEFINITIONS_H\n#define DEPRECATED_DEFINITIONS_H\n\n\n/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a\npre-processor definition was used to ensure the pre-processor found the correct\nportmacro.h file for the port being used.  That scheme was deprecated in favour\nof setting the compiler's include path such that it found the correct\nportmacro.h file - removing the need for the constant and allowing the\nportmacro.h file to be located anywhere in relation to the port being used.  The\ndefinitions below remain in the code for backward compatibility only.  New\nprojects should not use them. */\n\n#ifdef OPEN_WATCOM_INDUSTRIAL_PC_PORT\n#include \"..\\..\\Source\\portable\\owatcom\\16bitdos\\pc\\portmacro.h\"\ntypedef void ( __interrupt __far *pxISR )();\n#endif\n\n#ifdef OPEN_WATCOM_FLASH_LITE_186_PORT\n#include \"..\\..\\Source\\portable\\owatcom\\16bitdos\\flsh186\\portmacro.h\"\ntypedef void ( __interrupt __far *pxISR )();\n#endif\n\n#ifdef GCC_MEGA_AVR\n#include \"../portable/GCC/ATMega323/portmacro.h\"\n#endif\n\n#ifdef IAR_MEGA_AVR\n#include \"../portable/IAR/ATMega323/portmacro.h\"\n#endif\n\n#ifdef MPLAB_PIC24_PORT\n#include \"../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h\"\n#endif\n\n#ifdef MPLAB_DSPIC_PORT\n#include \"../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h\"\n#endif\n\n#ifdef MPLAB_PIC18F_PORT\n#include \"../../Source/portable/MPLAB/PIC18F/portmacro.h\"\n#endif\n\n#ifdef MPLAB_PIC32MX_PORT\n#include \"../../Source/portable/MPLAB/PIC32MX/portmacro.h\"\n#endif\n\n#ifdef _FEDPICC\n#include \"libFreeRTOS/Include/portmacro.h\"\n#endif\n\n#ifdef SDCC_CYGNAL\n#include \"../../Source/portable/SDCC/Cygnal/portmacro.h\"\n#endif\n\n#ifdef GCC_ARM7\n#include \"../../Source/portable/GCC/ARM7_LPC2000/portmacro.h\"\n#endif\n\n#ifdef GCC_ARM7_ECLIPSE\n#include \"portmacro.h\"\n#endif\n\n#ifdef ROWLEY_LPC23xx\n#include \"../../Source/portable/GCC/ARM7_LPC23xx/portmacro.h\"\n#endif\n\n#ifdef IAR_MSP430\n#include \"..\\..\\Source\\portable\\IAR\\MSP430\\portmacro.h\"\n#endif\n\n#ifdef GCC_MSP430\n#include \"../../Source/portable/GCC/MSP430F449/portmacro.h\"\n#endif\n\n#ifdef ROWLEY_MSP430\n#include \"../../Source/portable/Rowley/MSP430F449/portmacro.h\"\n#endif\n\n#ifdef ARM7_LPC21xx_KEIL_RVDS\n#include \"..\\..\\Source\\portable\\RVDS\\ARM7_LPC21xx\\portmacro.h\"\n#endif\n\n#ifdef SAM7_GCC\n#include \"../../Source/portable/GCC/ARM7_AT91SAM7S/portmacro.h\"\n#endif\n\n#ifdef SAM7_IAR\n#include \"..\\..\\Source\\portable\\IAR\\AtmelSAM7S64\\portmacro.h\"\n#endif\n\n#ifdef SAM9XE_IAR\n#include \"..\\..\\Source\\portable\\IAR\\AtmelSAM9XE\\portmacro.h\"\n#endif\n\n#ifdef LPC2000_IAR\n#include \"..\\..\\Source\\portable\\IAR\\LPC2000\\portmacro.h\"\n#endif\n\n#ifdef STR71X_IAR\n#include \"..\\..\\Source\\portable\\IAR\\STR71x\\portmacro.h\"\n#endif\n\n#ifdef STR75X_IAR\n#include \"..\\..\\Source\\portable\\IAR\\STR75x\\portmacro.h\"\n#endif\n\n#ifdef STR75X_GCC\n#include \"..\\..\\Source\\portable\\GCC\\STR75x\\portmacro.h\"\n#endif\n\n#ifdef STR91X_IAR\n#include \"..\\..\\Source\\portable\\IAR\\STR91x\\portmacro.h\"\n#endif\n\n#ifdef GCC_H8S\n#include \"../../Source/portable/GCC/H8S2329/portmacro.h\"\n#endif\n\n#ifdef GCC_AT91FR40008\n#include \"../../Source/portable/GCC/ARM7_AT91FR40008/portmacro.h\"\n#endif\n\n#ifdef RVDS_ARMCM3_LM3S102\n#include \"../../Source/portable/RVDS/ARM_CM3/portmacro.h\"\n#endif\n\n#ifdef GCC_ARMCM3_LM3S102\n#include \"../../Source/portable/GCC/ARM_CM3/portmacro.h\"\n#endif\n\n#ifdef GCC_ARMCM3\n#include \"../../Source/portable/GCC/ARM_CM3/portmacro.h\"\n#endif\n\n#ifdef IAR_ARM_CM3\n#include \"../../Source/portable/IAR/ARM_CM3/portmacro.h\"\n#endif\n\n#ifdef IAR_ARMCM3_LM\n#include \"../../Source/portable/IAR/ARM_CM3/portmacro.h\"\n#endif\n\n#ifdef HCS12_CODE_WARRIOR\n#include \"../../Source/portable/CodeWarrior/HCS12/portmacro.h\"\n#endif\n\n#ifdef MICROBLAZE_GCC\n#include \"../../Source/portable/GCC/MicroBlaze/portmacro.h\"\n#endif\n\n#ifdef TERN_EE\n#include \"..\\..\\Source\\portable\\Paradigm\\Tern_EE\\small\\portmacro.h\"\n#endif\n\n#ifdef GCC_HCS12\n#include \"../../Source/portable/GCC/HCS12/portmacro.h\"\n#endif\n\n#ifdef GCC_MCF5235\n#include \"../../Source/portable/GCC/MCF5235/portmacro.h\"\n#endif\n\n#ifdef COLDFIRE_V2_GCC\n#include \"../../../Source/portable/GCC/ColdFire_V2/portmacro.h\"\n#endif\n\n#ifdef COLDFIRE_V2_CODEWARRIOR\n#include \"../../Source/portable/CodeWarrior/ColdFire_V2/portmacro.h\"\n#endif\n\n#ifdef GCC_PPC405\n#include \"../../Source/portable/GCC/PPC405_Xilinx/portmacro.h\"\n#endif\n\n#ifdef GCC_PPC440\n#include \"../../Source/portable/GCC/PPC440_Xilinx/portmacro.h\"\n#endif\n\n#ifdef _16FX_SOFTUNE\n#include \"..\\..\\Source\\portable\\Softune\\MB96340\\portmacro.h\"\n#endif\n\n#ifdef BCC_INDUSTRIAL_PC_PORT\n/* A short file name has to be used in place of the normal\n    FreeRTOSConfig.h when using the Borland compiler. */\n#include \"frconfig.h\"\n#include \"..\\portable\\BCC\\16BitDOS\\PC\\prtmacro.h\"\ntypedef void ( __interrupt __far *pxISR )();\n#endif\n\n#ifdef BCC_FLASH_LITE_186_PORT\n/* A short file name has to be used in place of the normal\n    FreeRTOSConfig.h when using the Borland compiler. */\n#include \"frconfig.h\"\n#include \"..\\portable\\BCC\\16BitDOS\\flsh186\\prtmacro.h\"\ntypedef void ( __interrupt __far *pxISR )();\n#endif\n\n#ifdef __GNUC__\n#ifdef __AVR32_AVR32A__\n#include \"portmacro.h\"\n#endif\n#endif\n\n#ifdef __ICCAVR32__\n#ifdef __CORE__\n#if __CORE__ == __AVR32A__\n#include \"portmacro.h\"\n#endif\n#endif\n#endif\n\n#ifdef __91467D\n#include \"portmacro.h\"\n#endif\n\n#ifdef __96340\n#include \"portmacro.h\"\n#endif\n\n\n#ifdef __IAR_V850ES_Fx3__\n#include \"../../Source/portable/IAR/V850ES/portmacro.h\"\n#endif\n\n#ifdef __IAR_V850ES_Jx3__\n#include \"../../Source/portable/IAR/V850ES/portmacro.h\"\n#endif\n\n#ifdef __IAR_V850ES_Jx3_L__\n#include \"../../Source/portable/IAR/V850ES/portmacro.h\"\n#endif\n\n#ifdef __IAR_V850ES_Jx2__\n#include \"../../Source/portable/IAR/V850ES/portmacro.h\"\n#endif\n\n#ifdef __IAR_V850ES_Hx2__\n#include \"../../Source/portable/IAR/V850ES/portmacro.h\"\n#endif\n\n#ifdef __IAR_78K0R_Kx3__\n#include \"../../Source/portable/IAR/78K0R/portmacro.h\"\n#endif\n\n#ifdef __IAR_78K0R_Kx3L__\n#include \"../../Source/portable/IAR/78K0R/portmacro.h\"\n#endif\n\n#endif /* DEPRECATED_DEFINITIONS_H */\n</code></pre>"},{"location":"apiStm/event__groups_8h/","title":"File event_groups.h","text":"<p>FileList &gt; FreeRTOS &gt; include &gt; event_groups.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"timers.h\"</code></li> </ul>"},{"location":"apiStm/event__groups_8h/#public-types","title":"Public Types","text":"Type Name typedef TickType_t EventBits_t typedef struct EventGroupDef_t * EventGroupHandle_t"},{"location":"apiStm/event__groups_8h/#public-functions","title":"Public Functions","text":"Type Name void vEventGroupClearBitsCallback (void * pvEventGroup, const uint32_t ulBitsToClear)  void vEventGroupDelete (EventGroupHandle_t xEventGroup)  void vEventGroupSetBitsCallback (void * pvEventGroup, const uint32_t ulBitsToSet)  EventBits_t xEventGroupClearBits (EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear)  EventBits_t xEventGroupGetBitsFromISR (EventGroupHandle_t xEventGroup)  EventBits_t xEventGroupSetBits (EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet)  EventBits_t xEventGroupSync (EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait)  EventBits_t xEventGroupWaitBits (EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait)"},{"location":"apiStm/event__groups_8h/#macros","title":"Macros","text":"Type Name define xEventGroupClearBitsFromISR (xEventGroup, uxBitsToClear) xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL ) define xEventGroupGetBits (xEventGroup) xEventGroupClearBits( xEventGroup, 0 ) define xEventGroupSetBitsFromISR (xEventGroup, uxBitsToSet, pxHigherPriorityTaskWoken) xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken )"},{"location":"apiStm/event__groups_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/event__groups_8h/#typedef-eventbits_t","title":"typedef EventBits_t","text":"<pre><code>typedef TickType_t EventBits_t;\n</code></pre>"},{"location":"apiStm/event__groups_8h/#typedef-eventgrouphandle_t","title":"typedef EventGroupHandle_t","text":"<pre><code>typedef struct EventGroupDef_t* EventGroupHandle_t;\n</code></pre>"},{"location":"apiStm/event__groups_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/event__groups_8h/#function-veventgroupclearbitscallback","title":"function vEventGroupClearBitsCallback","text":"<pre><code>void vEventGroupClearBitsCallback (\nvoid * pvEventGroup,\nconst uint32_t ulBitsToClear\n) </code></pre>"},{"location":"apiStm/event__groups_8h/#function-veventgroupdelete","title":"function vEventGroupDelete","text":"<pre><code>void vEventGroupDelete (\nEventGroupHandle_t xEventGroup\n) </code></pre> <p>event_groups.h </p> <p>Delete an event group that was previously created by a call to xEventGroupCreate(). Tasks that are blocked on the event group will be unblocked and obtain 0 as the event group's value.</p> <p>Parameters:</p> <ul> <li><code>xEventGroup</code> The event group being deleted. </li> </ul>"},{"location":"apiStm/event__groups_8h/#function-veventgroupsetbitscallback","title":"function vEventGroupSetBitsCallback","text":"<pre><code>void vEventGroupSetBitsCallback (\nvoid * pvEventGroup,\nconst uint32_t ulBitsToSet\n) </code></pre>"},{"location":"apiStm/event__groups_8h/#function-xeventgroupclearbits","title":"function xEventGroupClearBits","text":"<pre><code>EventBits_t xEventGroupClearBits (\nEventGroupHandle_t xEventGroup,\nconst EventBits_t uxBitsToClear\n) </code></pre>"},{"location":"apiStm/event__groups_8h/#function-xeventgroupgetbitsfromisr","title":"function xEventGroupGetBitsFromISR","text":"<pre><code>EventBits_t xEventGroupGetBitsFromISR (\nEventGroupHandle_t xEventGroup\n) </code></pre>"},{"location":"apiStm/event__groups_8h/#function-xeventgroupsetbits","title":"function xEventGroupSetBits","text":"<pre><code>EventBits_t xEventGroupSetBits (\nEventGroupHandle_t xEventGroup,\nconst EventBits_t uxBitsToSet\n) </code></pre>"},{"location":"apiStm/event__groups_8h/#function-xeventgroupsync","title":"function xEventGroupSync","text":"<pre><code>EventBits_t xEventGroupSync (\nEventGroupHandle_t xEventGroup,\nconst EventBits_t uxBitsToSet,\nconst EventBits_t uxBitsToWaitFor,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/event__groups_8h/#function-xeventgroupwaitbits","title":"function xEventGroupWaitBits","text":"<pre><code>EventBits_t xEventGroupWaitBits (\nEventGroupHandle_t xEventGroup,\nconst EventBits_t uxBitsToWaitFor,\nconst BaseType_t xClearOnExit,\nconst BaseType_t xWaitForAllBits,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/event__groups_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/event__groups_8h/#define-xeventgroupclearbitsfromisr","title":"define xEventGroupClearBitsFromISR","text":"<pre><code>#define xEventGroupClearBitsFromISR (\nxEventGroup,\nuxBitsToClear\n) xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL )\n</code></pre>"},{"location":"apiStm/event__groups_8h/#define-xeventgroupgetbits","title":"define xEventGroupGetBits","text":"<pre><code>#define xEventGroupGetBits (\nxEventGroup\n) xEventGroupClearBits( xEventGroup, 0 )\n</code></pre>"},{"location":"apiStm/event__groups_8h/#define-xeventgroupsetbitsfromisr","title":"define xEventGroupSetBitsFromISR","text":"<pre><code>#define xEventGroupSetBitsFromISR (\nxEventGroup,\nuxBitsToSet,\npxHigherPriorityTaskWoken\n) xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken )\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/event_groups.h</code></p>"},{"location":"apiStm/event__groups_8h_source/","title":"File event_groups.h","text":"<p>File List &gt; FreeRTOS &gt; include &gt; event_groups.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n#ifndef EVENT_GROUPS_H\n#define EVENT_GROUPS_H\n\n#ifndef INC_FREERTOS_H\n#error \"include FreeRTOS.h\" must appear in source files before \"include event_groups.h\"\n#endif\n\n/* FreeRTOS includes. */\n#include \"timers.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstruct EventGroupDef_t;\ntypedef struct EventGroupDef_t * EventGroupHandle_t;\n\n/*\n * The type that holds event bits always matches TickType_t - therefore the\n * number of bits it holds is set by configUSE_16_BIT_TICKS (16 bits if set to 1,\n * 32 bits if set to 0.\n *\n * \\defgroup EventBits_t EventBits_t\n * \\ingroup EventGroup\n */\ntypedef TickType_t EventBits_t;\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\nEventGroupHandle_t xEventGroupCreate( void ) PRIVILEGED_FUNCTION;\n#endif\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\nEventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t *pxEventGroupBuffer ) PRIVILEGED_FUNCTION;\n#endif\n\nEventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\n\nEventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear ) PRIVILEGED_FUNCTION;\n\n#if( configUSE_TRACE_FACILITY == 1 )\nBaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear ) PRIVILEGED_FUNCTION;\n#else\n#define xEventGroupClearBitsFromISR( xEventGroup, uxBitsToClear ) xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL )\n#endif\n\nEventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet ) PRIVILEGED_FUNCTION;\n\n#if( configUSE_TRACE_FACILITY == 1 )\nBaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;\n#else\n#define xEventGroupSetBitsFromISR( xEventGroup, uxBitsToSet, pxHigherPriorityTaskWoken ) xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken )\n#endif\n\nEventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\n\n\n#define xEventGroupGetBits( xEventGroup ) xEventGroupClearBits( xEventGroup, 0 )\n\nEventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup ) PRIVILEGED_FUNCTION;\n\nvoid vEventGroupDelete( EventGroupHandle_t xEventGroup ) PRIVILEGED_FUNCTION;\n\n/* For internal use only. */\nvoid vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet ) PRIVILEGED_FUNCTION;\nvoid vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear ) PRIVILEGED_FUNCTION;\n\n\n#if (configUSE_TRACE_FACILITY == 1)\nUBaseType_t uxEventGroupGetNumber( void* xEventGroup ) PRIVILEGED_FUNCTION;\nvoid vEventGroupSetNumber( void* xEventGroup, UBaseType_t uxEventGroupNumber ) PRIVILEGED_FUNCTION;\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* EVENT_GROUPS_H */\n</code></pre>"},{"location":"apiStm/list_8h/","title":"File list.h","text":"<p>FileList &gt; FreeRTOS &gt; include &gt; list.h</p> <p>Go to the source code of this file.</p>"},{"location":"apiStm/list_8h/#classes","title":"Classes","text":"Type Name struct xLIST struct xLIST_ITEM struct xMINI_LIST_ITEM"},{"location":"apiStm/list_8h/#public-types","title":"Public Types","text":"Type Name typedef struct xLIST_ITEM ListItem_t typedef struct xLIST List_t typedef struct xMINI_LIST_ITEM MiniListItem_t"},{"location":"apiStm/list_8h/#public-functions","title":"Public Functions","text":"Type Name UBaseType_t uxListRemove (ListItem_t *const pxItemToRemove)  void vListInitialise (List_t *const pxList)  void vListInitialiseItem (ListItem_t *const pxItem)  void vListInsert (List_t *const pxList, ListItem_t *const pxNewListItem)  void vListInsertEnd (List_t *const pxList, ListItem_t *const pxNewListItem)"},{"location":"apiStm/list_8h/#macros","title":"Macros","text":"Type Name define configLIST_VOLATILE define listCURRENT_LIST_LENGTH (pxList) ( ( pxList )-&gt;uxNumberOfItems ) define listFIRST_LIST_INTEGRITY_CHECK_VALUE define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE define listGET_END_MARKER (pxList) ( ( ListItem_t const * ) ( &amp;( ( pxList )-&gt;xListEnd ) ) ) define listGET_HEAD_ENTRY (pxList) ( ( ( pxList )-&gt;xListEnd ).pxNext ) define listGET_ITEM_VALUE_OF_HEAD_ENTRY (pxList) ( ( ( pxList )-&gt;xListEnd ).pxNext-&gt;xItemValue ) define listGET_LIST_ITEM_OWNER (pxListItem) ( ( pxListItem )-&gt;pvOwner ) define listGET_LIST_ITEM_VALUE (pxListItem) ( ( pxListItem )-&gt;xItemValue ) define listGET_NEXT (pxListItem) ( ( pxListItem )-&gt;pxNext ) define listGET_OWNER_OF_HEAD_ENTRY (pxList) ( (&amp;( ( pxList )-&gt;xListEnd ))-&gt;pxNext-&gt;pvOwner ) define listGET_OWNER_OF_NEXT_ENTRY (pxTCB, pxList)  define listIS_CONTAINED_WITHIN (pxList, pxListItem) ( ( ( pxListItem )-&gt;pxContainer == ( pxList ) ) ? ( pdTRUE ) : ( pdFALSE ) ) define listLIST_IS_EMPTY (pxList) ( ( ( pxList )-&gt;uxNumberOfItems == ( UBaseType_t ) 0 ) ? pdTRUE : pdFALSE ) define listLIST_IS_INITIALISED (pxList) ( ( pxList )-&gt;xListEnd.xItemValue == portMAX_DELAY ) define listLIST_ITEM_CONTAINER (pxListItem) ( ( pxListItem )-&gt;pxContainer ) define listSECOND_LIST_INTEGRITY_CHECK_VALUE define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE (pxItem)  define listSET_LIST_INTEGRITY_CHECK_1_VALUE (pxList)  define listSET_LIST_INTEGRITY_CHECK_2_VALUE (pxList)  define listSET_LIST_ITEM_OWNER (pxListItem, pxOwner) ( ( pxListItem )-&gt;pvOwner = ( void * ) ( pxOwner ) ) define listSET_LIST_ITEM_VALUE (pxListItem, xValue) ( ( pxListItem )-&gt;xItemValue = ( xValue ) ) define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE (pxItem)  define listTEST_LIST_INTEGRITY (pxList)  define listTEST_LIST_ITEM_INTEGRITY (pxItem)"},{"location":"apiStm/list_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/list_8h/#typedef-listitem_t","title":"typedef ListItem_t","text":"<pre><code>typedef struct xLIST_ITEM ListItem_t;\n</code></pre>"},{"location":"apiStm/list_8h/#typedef-list_t","title":"typedef List_t","text":"<pre><code>typedef struct xLIST List_t;\n</code></pre>"},{"location":"apiStm/list_8h/#typedef-minilistitem_t","title":"typedef MiniListItem_t","text":"<pre><code>typedef struct xMINI_LIST_ITEM MiniListItem_t;\n</code></pre>"},{"location":"apiStm/list_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/list_8h/#function-uxlistremove","title":"function uxListRemove","text":"<pre><code>UBaseType_t uxListRemove (\nListItem_t *const pxItemToRemove\n) </code></pre>"},{"location":"apiStm/list_8h/#function-vlistinitialise","title":"function vListInitialise","text":"<pre><code>void vListInitialise (\nList_t *const pxList\n) </code></pre>"},{"location":"apiStm/list_8h/#function-vlistinitialiseitem","title":"function vListInitialiseItem","text":"<pre><code>void vListInitialiseItem (\nListItem_t *const pxItem\n) </code></pre>"},{"location":"apiStm/list_8h/#function-vlistinsert","title":"function vListInsert","text":"<pre><code>void vListInsert (\nList_t *const pxList,\nListItem_t *const pxNewListItem\n) </code></pre>"},{"location":"apiStm/list_8h/#function-vlistinsertend","title":"function vListInsertEnd","text":"<pre><code>void vListInsertEnd (\nList_t *const pxList,\nListItem_t *const pxNewListItem\n) </code></pre>"},{"location":"apiStm/list_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/list_8h/#define-configlist_volatile","title":"define configLIST_VOLATILE","text":"<pre><code>#define configLIST_VOLATILE \n</code></pre>"},{"location":"apiStm/list_8h/#define-listcurrent_list_length","title":"define listCURRENT_LIST_LENGTH","text":"<pre><code>#define listCURRENT_LIST_LENGTH (\npxList\n) ( ( pxList )-&gt;uxNumberOfItems )\n</code></pre>"},{"location":"apiStm/list_8h/#define-listfirst_list_integrity_check_value","title":"define listFIRST_LIST_INTEGRITY_CHECK_VALUE","text":"<pre><code>#define listFIRST_LIST_INTEGRITY_CHECK_VALUE \n</code></pre>"},{"location":"apiStm/list_8h/#define-listfirst_list_item_integrity_check_value","title":"define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE","text":"<pre><code>#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE \n</code></pre>"},{"location":"apiStm/list_8h/#define-listget_end_marker","title":"define listGET_END_MARKER","text":"<pre><code>#define listGET_END_MARKER (\npxList\n) ( ( ListItem_t const * ) ( &amp;( ( pxList )-&gt;xListEnd ) ) )\n</code></pre>"},{"location":"apiStm/list_8h/#define-listget_head_entry","title":"define listGET_HEAD_ENTRY","text":"<pre><code>#define listGET_HEAD_ENTRY (\npxList\n) ( ( ( pxList )-&gt;xListEnd ).pxNext )\n</code></pre>"},{"location":"apiStm/list_8h/#define-listget_item_value_of_head_entry","title":"define listGET_ITEM_VALUE_OF_HEAD_ENTRY","text":"<pre><code>#define listGET_ITEM_VALUE_OF_HEAD_ENTRY (\npxList\n) ( ( ( pxList )-&gt;xListEnd ).pxNext-&gt;xItemValue )\n</code></pre>"},{"location":"apiStm/list_8h/#define-listget_list_item_owner","title":"define listGET_LIST_ITEM_OWNER","text":"<pre><code>#define listGET_LIST_ITEM_OWNER (\npxListItem\n) ( ( pxListItem )-&gt;pvOwner )\n</code></pre>"},{"location":"apiStm/list_8h/#define-listget_list_item_value","title":"define listGET_LIST_ITEM_VALUE","text":"<pre><code>#define listGET_LIST_ITEM_VALUE (\npxListItem\n) ( ( pxListItem )-&gt;xItemValue )\n</code></pre>"},{"location":"apiStm/list_8h/#define-listget_next","title":"define listGET_NEXT","text":"<pre><code>#define listGET_NEXT (\npxListItem\n) ( ( pxListItem )-&gt;pxNext )\n</code></pre>"},{"location":"apiStm/list_8h/#define-listget_owner_of_head_entry","title":"define listGET_OWNER_OF_HEAD_ENTRY","text":"<pre><code>#define listGET_OWNER_OF_HEAD_ENTRY (\npxList\n) ( (&amp;( ( pxList )-&gt;xListEnd ))-&gt;pxNext-&gt;pvOwner )\n</code></pre>"},{"location":"apiStm/list_8h/#define-listget_owner_of_next_entry","title":"define listGET_OWNER_OF_NEXT_ENTRY","text":"<pre><code>#define listGET_OWNER_OF_NEXT_ENTRY (\npxTCB,\npxList\n) {                                                                                         \\ List_t * const pxConstList = ( pxList );                                                  \\\n    /* Increment the index to the next item and return the item, ensuring */                \\\n    /* we don't return the marker used at the end of the list.  */                          \\\n    ( pxConstList )-&gt;pxIndex = ( pxConstList )-&gt;pxIndex-&gt;pxNext;                            \\\n    if( ( void * ) ( pxConstList )-&gt;pxIndex == ( void * ) &amp;( ( pxConstList )-&gt;xListEnd ) )  \\\n    {                                                                                       \\\n        ( pxConstList )-&gt;pxIndex = ( pxConstList )-&gt;pxIndex-&gt;pxNext;                        \\\n    }                                                                                       \\\n    ( pxTCB ) = ( pxConstList )-&gt;pxIndex-&gt;pvOwner;                                          \\\n}\n</code></pre>"},{"location":"apiStm/list_8h/#define-listis_contained_within","title":"define listIS_CONTAINED_WITHIN","text":"<pre><code>#define listIS_CONTAINED_WITHIN (\npxList,\npxListItem\n) ( ( ( pxListItem )-&gt;pxContainer == ( pxList ) ) ? ( pdTRUE ) : ( pdFALSE ) )\n</code></pre>"},{"location":"apiStm/list_8h/#define-listlist_is_empty","title":"define listLIST_IS_EMPTY","text":"<pre><code>#define listLIST_IS_EMPTY (\npxList\n) ( ( ( pxList )-&gt;uxNumberOfItems == ( UBaseType_t ) 0 ) ? pdTRUE : pdFALSE )\n</code></pre>"},{"location":"apiStm/list_8h/#define-listlist_is_initialised","title":"define listLIST_IS_INITIALISED","text":"<pre><code>#define listLIST_IS_INITIALISED (\npxList\n) ( ( pxList )-&gt;xListEnd.xItemValue == portMAX_DELAY )\n</code></pre>"},{"location":"apiStm/list_8h/#define-listlist_item_container","title":"define listLIST_ITEM_CONTAINER","text":"<pre><code>#define listLIST_ITEM_CONTAINER (\npxListItem\n) ( ( pxListItem )-&gt;pxContainer )\n</code></pre>"},{"location":"apiStm/list_8h/#define-listsecond_list_integrity_check_value","title":"define listSECOND_LIST_INTEGRITY_CHECK_VALUE","text":"<pre><code>#define listSECOND_LIST_INTEGRITY_CHECK_VALUE \n</code></pre>"},{"location":"apiStm/list_8h/#define-listsecond_list_item_integrity_check_value","title":"define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE","text":"<pre><code>#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE \n</code></pre>"},{"location":"apiStm/list_8h/#define-listset_first_list_item_integrity_check_value","title":"define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE","text":"<pre><code>#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE (\npxItem\n) </code></pre>"},{"location":"apiStm/list_8h/#define-listset_list_integrity_check_1_value","title":"define listSET_LIST_INTEGRITY_CHECK_1_VALUE","text":"<pre><code>#define listSET_LIST_INTEGRITY_CHECK_1_VALUE (\npxList\n) </code></pre>"},{"location":"apiStm/list_8h/#define-listset_list_integrity_check_2_value","title":"define listSET_LIST_INTEGRITY_CHECK_2_VALUE","text":"<pre><code>#define listSET_LIST_INTEGRITY_CHECK_2_VALUE (\npxList\n) </code></pre>"},{"location":"apiStm/list_8h/#define-listset_list_item_owner","title":"define listSET_LIST_ITEM_OWNER","text":"<pre><code>#define listSET_LIST_ITEM_OWNER (\npxListItem,\npxOwner\n) ( ( pxListItem )-&gt;pvOwner = ( void * ) ( pxOwner ) )\n</code></pre>"},{"location":"apiStm/list_8h/#define-listset_list_item_value","title":"define listSET_LIST_ITEM_VALUE","text":"<pre><code>#define listSET_LIST_ITEM_VALUE (\npxListItem,\nxValue\n) ( ( pxListItem )-&gt;xItemValue = ( xValue ) )\n</code></pre>"},{"location":"apiStm/list_8h/#define-listset_second_list_item_integrity_check_value","title":"define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE","text":"<pre><code>#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE (\npxItem\n) </code></pre>"},{"location":"apiStm/list_8h/#define-listtest_list_integrity","title":"define listTEST_LIST_INTEGRITY","text":"<pre><code>#define listTEST_LIST_INTEGRITY (\npxList\n) </code></pre>"},{"location":"apiStm/list_8h/#define-listtest_list_item_integrity","title":"define listTEST_LIST_ITEM_INTEGRITY","text":"<pre><code>#define listTEST_LIST_ITEM_INTEGRITY (\npxItem\n) </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/list.h</code></p>"},{"location":"apiStm/list_8h_source/","title":"File list.h","text":"<p>File List &gt; FreeRTOS &gt; include &gt; list.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n/*\n * This is the list implementation used by the scheduler.  While it is tailored\n * heavily for the schedulers needs, it is also available for use by\n * application code.\n *\n * list_ts can only store pointers to list_item_ts.  Each ListItem_t contains a\n * numeric value (xItemValue).  Most of the time the lists are sorted in\n * descending item value order.\n *\n * Lists are created already containing one list item.  The value of this\n * item is the maximum possible that can be stored, it is therefore always at\n * the end of the list and acts as a marker.  The list member pxHead always\n * points to this marker - even though it is at the tail of the list.  This\n * is because the tail contains a wrap back pointer to the true head of\n * the list.\n *\n * In addition to it's value, each list item contains a pointer to the next\n * item in the list (pxNext), a pointer to the list it is in (pxContainer)\n * and a pointer to back to the object that contains it.  These later two\n * pointers are included for efficiency of list manipulation.  There is\n * effectively a two way link between the object containing the list item and\n * the list item itself.\n *\n *\n * \\page ListIntroduction List Implementation\n * \\ingroup FreeRTOSIntro\n */\n\n#ifndef INC_FREERTOS_H\n#error FreeRTOS.h must be included before list.h\n#endif\n\n#ifndef LIST_H\n#define LIST_H\n\n/*\n * The list structure members are modified from within interrupts, and therefore\n * by rights should be declared volatile.  However, they are only modified in a\n * functionally atomic way (within critical sections of with the scheduler\n * suspended) and are either passed by reference into a function or indexed via\n * a volatile variable.  Therefore, in all use cases tested so far, the volatile\n * qualifier can be omitted in order to provide a moderate performance\n * improvement without adversely affecting functional behaviour.  The assembly\n * instructions generated by the IAR, ARM and GCC compilers when the respective\n * compiler's options were set for maximum optimisation has been inspected and\n * deemed to be as intended.  That said, as compiler technology advances, and\n * especially if aggressive cross module optimisation is used (a use case that\n * has not been exercised to any great extend) then it is feasible that the\n * volatile qualifier will be needed for correct optimisation.  It is expected\n * that a compiler removing essential code because, without the volatile\n * qualifier on the list structure members and with aggressive cross module\n * optimisation, the compiler deemed the code unnecessary will result in\n * complete and obvious failure of the scheduler.  If this is ever experienced\n * then the volatile qualifier can be inserted in the relevant places within the\n * list structures by simply defining configLIST_VOLATILE to volatile in\n * FreeRTOSConfig.h (as per the example at the bottom of this comment block).\n * If configLIST_VOLATILE is not defined then the preprocessor directives below\n * will simply #define configLIST_VOLATILE away completely.\n *\n * To use volatile list structure members then add the following line to\n * FreeRTOSConfig.h (without the quotes):\n * \"#define configLIST_VOLATILE volatile\"\n */\n#ifndef configLIST_VOLATILE\n#define configLIST_VOLATILE\n#endif /* configSUPPORT_CROSS_MODULE_OPTIMISATION */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Macros that can be used to place known values within the list structures,\nthen check that the known values do not get corrupted during the execution of\nthe application.   These may catch the list data structures being overwritten in\nmemory.  They will not catch data errors caused by incorrect configuration or\nuse of FreeRTOS.*/\n#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 0 )\n/* Define the macros to do nothing. */\n#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE\n#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE\n#define listFIRST_LIST_INTEGRITY_CHECK_VALUE\n#define listSECOND_LIST_INTEGRITY_CHECK_VALUE\n#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )\n#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )\n#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )\n#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )\n#define listTEST_LIST_ITEM_INTEGRITY( pxItem )\n#define listTEST_LIST_INTEGRITY( pxList )\n#else\n/* Define macros that add new members into the list structures. */\n#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE               TickType_t xListItemIntegrityValue1;\n#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE              TickType_t xListItemIntegrityValue2;\n#define listFIRST_LIST_INTEGRITY_CHECK_VALUE                    TickType_t xListIntegrityValue1;\n#define listSECOND_LIST_INTEGRITY_CHECK_VALUE                   TickType_t xListIntegrityValue2;\n\n/* Define macros that set the new structure members to known values. */\n#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )     ( pxItem )-&gt;xListItemIntegrityValue1 = pdINTEGRITY_CHECK_VALUE\n#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )    ( pxItem )-&gt;xListItemIntegrityValue2 = pdINTEGRITY_CHECK_VALUE\n#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )      ( pxList )-&gt;xListIntegrityValue1 = pdINTEGRITY_CHECK_VALUE\n#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )      ( pxList )-&gt;xListIntegrityValue2 = pdINTEGRITY_CHECK_VALUE\n\n/* Define macros that will assert if one of the structure members does not\n    contain its expected value. */\n#define listTEST_LIST_ITEM_INTEGRITY( pxItem )      configASSERT( ( ( pxItem )-&gt;xListItemIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) &amp;&amp; ( ( pxItem )-&gt;xListItemIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )\n#define listTEST_LIST_INTEGRITY( pxList )           configASSERT( ( ( pxList )-&gt;xListIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) &amp;&amp; ( ( pxList )-&gt;xListIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )\n#endif /* configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES */\n\n\n/*\n * Definition of the only type of object that a list can contain.\n */\nstruct xLIST;\nstruct xLIST_ITEM\n{\nlistFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE           /*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */\nconfigLIST_VOLATILE TickType_t xItemValue;          /*&lt; The value being listed.  In most cases this is used to sort the list in descending order. */\nstruct xLIST_ITEM * configLIST_VOLATILE pxNext;     /*&lt; Pointer to the next ListItem_t in the list. */\nstruct xLIST_ITEM * configLIST_VOLATILE pxPrevious; /*&lt; Pointer to the previous ListItem_t in the list. */\nvoid * pvOwner;                                     /*&lt; Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */\nstruct xLIST * configLIST_VOLATILE pxContainer;     /*&lt; Pointer to the list in which this list item is placed (if any). */\nlistSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE          /*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */\n};\ntypedef struct xLIST_ITEM ListItem_t;                   /* For some reason lint wants this as two separate definitions. */\n\nstruct xMINI_LIST_ITEM\n{\nlistFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE           /*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */\nconfigLIST_VOLATILE TickType_t xItemValue;\nstruct xLIST_ITEM * configLIST_VOLATILE pxNext;\nstruct xLIST_ITEM * configLIST_VOLATILE pxPrevious;\n};\ntypedef struct xMINI_LIST_ITEM MiniListItem_t;\n\n/*\n * Definition of the type of queue used by the scheduler.\n */\ntypedef struct xLIST\n{\nlistFIRST_LIST_INTEGRITY_CHECK_VALUE                /*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */\nvolatile UBaseType_t uxNumberOfItems;\nListItem_t * configLIST_VOLATILE pxIndex;           /*&lt; Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). */\nMiniListItem_t xListEnd;                            /*&lt; List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */\nlistSECOND_LIST_INTEGRITY_CHECK_VALUE               /*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */\n} List_t;\n\n/*\n * Access macro to set the owner of a list item.  The owner of a list item\n * is the object (usually a TCB) that contains the list item.\n *\n * \\page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER\n * \\ingroup LinkedList\n */\n#define listSET_LIST_ITEM_OWNER( pxListItem, pxOwner )      ( ( pxListItem )-&gt;pvOwner = ( void * ) ( pxOwner ) )\n\n/*\n * Access macro to get the owner of a list item.  The owner of a list item\n * is the object (usually a TCB) that contains the list item.\n *\n * \\page listGET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER\n * \\ingroup LinkedList\n */\n#define listGET_LIST_ITEM_OWNER( pxListItem )   ( ( pxListItem )-&gt;pvOwner )\n\n/*\n * Access macro to set the value of the list item.  In most cases the value is\n * used to sort the list in descending order.\n *\n * \\page listSET_LIST_ITEM_VALUE listSET_LIST_ITEM_VALUE\n * \\ingroup LinkedList\n */\n#define listSET_LIST_ITEM_VALUE( pxListItem, xValue )   ( ( pxListItem )-&gt;xItemValue = ( xValue ) )\n\n/*\n * Access macro to retrieve the value of the list item.  The value can\n * represent anything - for example the priority of a task, or the time at\n * which a task should be unblocked.\n *\n * \\page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE\n * \\ingroup LinkedList\n */\n#define listGET_LIST_ITEM_VALUE( pxListItem )   ( ( pxListItem )-&gt;xItemValue )\n\n/*\n * Access macro to retrieve the value of the list item at the head of a given\n * list.\n *\n * \\page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE\n * \\ingroup LinkedList\n */\n#define listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )  ( ( ( pxList )-&gt;xListEnd ).pxNext-&gt;xItemValue )\n\n/*\n * Return the list item at the head of the list.\n *\n * \\page listGET_HEAD_ENTRY listGET_HEAD_ENTRY\n * \\ingroup LinkedList\n */\n#define listGET_HEAD_ENTRY( pxList )    ( ( ( pxList )-&gt;xListEnd ).pxNext )\n\n/*\n * Return the next list item.\n *\n * \\page listGET_NEXT listGET_NEXT\n * \\ingroup LinkedList\n */\n#define listGET_NEXT( pxListItem )  ( ( pxListItem )-&gt;pxNext )\n\n/*\n * Return the list item that marks the end of the list\n *\n * \\page listGET_END_MARKER listGET_END_MARKER\n * \\ingroup LinkedList\n */\n#define listGET_END_MARKER( pxList )    ( ( ListItem_t const * ) ( &amp;( ( pxList )-&gt;xListEnd ) ) )\n\n/*\n * Access macro to determine if a list contains any items.  The macro will\n * only have the value true if the list is empty.\n *\n * \\page listLIST_IS_EMPTY listLIST_IS_EMPTY\n * \\ingroup LinkedList\n */\n#define listLIST_IS_EMPTY( pxList ) ( ( ( pxList )-&gt;uxNumberOfItems == ( UBaseType_t ) 0 ) ? pdTRUE : pdFALSE )\n\n/*\n * Access macro to return the number of items in the list.\n */\n#define listCURRENT_LIST_LENGTH( pxList )   ( ( pxList )-&gt;uxNumberOfItems )\n\n/*\n * Access function to obtain the owner of the next entry in a list.\n *\n * The list member pxIndex is used to walk through a list.  Calling\n * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list\n * and returns that entry's pxOwner parameter.  Using multiple calls to this\n * function it is therefore possible to move through every item contained in\n * a list.\n *\n * The pxOwner parameter of a list item is a pointer to the object that owns\n * the list item.  In the scheduler this is normally a task control block.\n * The pxOwner parameter effectively creates a two way link between the list\n * item and its owner.\n *\n * @param pxTCB pxTCB is set to the address of the owner of the next list item.\n * @param pxList The list from which the next item owner is to be returned.\n *\n * \\page listGET_OWNER_OF_NEXT_ENTRY listGET_OWNER_OF_NEXT_ENTRY\n * \\ingroup LinkedList\n */\n#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )                                        \\\n{                                                                                           \\\nList_t * const pxConstList = ( pxList );                                                    \\\n/* Increment the index to the next item and return the item, ensuring */                \\\n/* we don't return the marker used at the end of the list.  */                          \\\n    ( pxConstList )-&gt;pxIndex = ( pxConstList )-&gt;pxIndex-&gt;pxNext;                            \\\n    if( ( void * ) ( pxConstList )-&gt;pxIndex == ( void * ) &amp;( ( pxConstList )-&gt;xListEnd ) )  \\\n    {                                                                                       \\\n        ( pxConstList )-&gt;pxIndex = ( pxConstList )-&gt;pxIndex-&gt;pxNext;                        \\\n    }                                                                                       \\\n    ( pxTCB ) = ( pxConstList )-&gt;pxIndex-&gt;pvOwner;                                          \\\n}\n\n\n/*\n * Access function to obtain the owner of the first entry in a list.  Lists\n * are normally sorted in ascending item value order.\n *\n * This function returns the pxOwner member of the first item in the list.\n * The pxOwner parameter of a list item is a pointer to the object that owns\n * the list item.  In the scheduler this is normally a task control block.\n * The pxOwner parameter effectively creates a two way link between the list\n * item and its owner.\n *\n * @param pxList The list from which the owner of the head item is to be\n * returned.\n *\n * \\page listGET_OWNER_OF_HEAD_ENTRY listGET_OWNER_OF_HEAD_ENTRY\n * \\ingroup LinkedList\n */\n#define listGET_OWNER_OF_HEAD_ENTRY( pxList )  ( (&amp;( ( pxList )-&gt;xListEnd ))-&gt;pxNext-&gt;pvOwner )\n\n/*\n * Check to see if a list item is within a list.  The list item maintains a\n * \"container\" pointer that points to the list it is in.  All this macro does\n * is check to see if the container and the list match.\n *\n * @param pxList The list we want to know if the list item is within.\n * @param pxListItem The list item we want to know if is in the list.\n * @return pdTRUE if the list item is in the list, otherwise pdFALSE.\n */\n#define listIS_CONTAINED_WITHIN( pxList, pxListItem ) ( ( ( pxListItem )-&gt;pxContainer == ( pxList ) ) ? ( pdTRUE ) : ( pdFALSE ) )\n\n/*\n * Return the list a list item is contained within (referenced from).\n *\n * @param pxListItem The list item being queried.\n * @return A pointer to the List_t object that references the pxListItem\n */\n#define listLIST_ITEM_CONTAINER( pxListItem ) ( ( pxListItem )-&gt;pxContainer )\n\n/*\n * This provides a crude means of knowing if a list has been initialised, as\n * pxList-&gt;xListEnd.xItemValue is set to portMAX_DELAY by the vListInitialise()\n * function.\n */\n#define listLIST_IS_INITIALISED( pxList ) ( ( pxList )-&gt;xListEnd.xItemValue == portMAX_DELAY )\n\n/*\n * Must be called before a list is used!  This initialises all the members\n * of the list structure and inserts the xListEnd item into the list as a\n * marker to the back of the list.\n *\n * @param pxList Pointer to the list being initialised.\n *\n * \\page vListInitialise vListInitialise\n * \\ingroup LinkedList\n */\nvoid vListInitialise( List_t * const pxList ) PRIVILEGED_FUNCTION;\n\n/*\n * Must be called before a list item is used.  This sets the list container to\n * null so the item does not think that it is already contained in a list.\n *\n * @param pxItem Pointer to the list item being initialised.\n *\n * \\page vListInitialiseItem vListInitialiseItem\n * \\ingroup LinkedList\n */\nvoid vListInitialiseItem( ListItem_t * const pxItem ) PRIVILEGED_FUNCTION;\n\n/*\n * Insert a list item into a list.  The item will be inserted into the list in\n * a position determined by its item value (descending item value order).\n *\n * @param pxList The list into which the item is to be inserted.\n *\n * @param pxNewListItem The item that is to be placed in the list.\n *\n * \\page vListInsert vListInsert\n * \\ingroup LinkedList\n */\nvoid vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;\n\n/*\n * Insert a list item into a list.  The item will be inserted in a position\n * such that it will be the last item within the list returned by multiple\n * calls to listGET_OWNER_OF_NEXT_ENTRY.\n *\n * The list member pxIndex is used to walk through a list.  Calling\n * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list.\n * Placing an item in a list using vListInsertEnd effectively places the item\n * in the list position pointed to by pxIndex.  This means that every other\n * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY before\n * the pxIndex parameter again points to the item being inserted.\n *\n * @param pxList The list into which the item is to be inserted.\n *\n * @param pxNewListItem The list item to be inserted into the list.\n *\n * \\page vListInsertEnd vListInsertEnd\n * \\ingroup LinkedList\n */\nvoid vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;\n\n/*\n * Remove an item from a list.  The list item has a pointer to the list that\n * it is in, so only the list item need be passed into the function.\n *\n * @param uxListRemove The item to be removed.  The item will remove itself from\n * the list pointed to by it's pxContainer parameter.\n *\n * @return The number of items that remain in the list after the list item has\n * been removed.\n *\n * \\page uxListRemove uxListRemove\n * \\ingroup LinkedList\n */\nUBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) PRIVILEGED_FUNCTION;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n</code></pre>"},{"location":"apiStm/message__buffer_8h/","title":"File message_buffer.h","text":"<p>FileList &gt; FreeRTOS &gt; include &gt; message_buffer.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"stream_buffer.h\"</code></li> </ul>"},{"location":"apiStm/message__buffer_8h/#public-types","title":"Public Types","text":"Type Name typedef void * MessageBufferHandle_t"},{"location":"apiStm/message__buffer_8h/#macros","title":"Macros","text":"Type Name define vMessageBufferDelete (xMessageBuffer) vStreamBufferDelete( ( StreamBufferHandle_t ) xMessageBuffer ) define xMessageBufferCreate (xBufferSizeBytes) ( MessageBufferHandle_t ) xStreamBufferGenericCreate( xBufferSizeBytes, ( size_t ) 0, pdTRUE ) define xMessageBufferCreateStatic (xBufferSizeBytes, pucMessageBufferStorageArea, pxStaticMessageBuffer) ( MessageBufferHandle_t ) xStreamBufferGenericCreateStatic( xBufferSizeBytes, 0, pdTRUE, pucMessageBufferStorageArea, pxStaticMessageBuffer ) define xMessageBufferIsEmpty (xMessageBuffer) xStreamBufferIsEmpty( ( StreamBufferHandle_t ) xMessageBuffer ) define xMessageBufferIsFull (xMessageBuffer) xStreamBufferIsFull( ( StreamBufferHandle_t ) xMessageBuffer ) define xMessageBufferNextLengthBytes (xMessageBuffer) xStreamBufferNextMessageLengthBytes( ( StreamBufferHandle_t ) xMessageBuffer ) PRIVILEGED_FUNCTION; define xMessageBufferReceive (xMessageBuffer, pvRxData, xBufferLengthBytes, xTicksToWait) xStreamBufferReceive( ( StreamBufferHandle_t ) xMessageBuffer, pvRxData, xBufferLengthBytes, xTicksToWait ) define xMessageBufferReceiveCompletedFromISR (xMessageBuffer, pxHigherPriorityTaskWoken) xStreamBufferReceiveCompletedFromISR( ( StreamBufferHandle_t ) xMessageBuffer, pxHigherPriorityTaskWoken ) define xMessageBufferReceiveFromISR (xMessageBuffer, pvRxData, xBufferLengthBytes, pxHigherPriorityTaskWoken) xStreamBufferReceiveFromISR( ( StreamBufferHandle_t ) xMessageBuffer, pvRxData, xBufferLengthBytes, pxHigherPriorityTaskWoken ) define xMessageBufferReset (xMessageBuffer) xStreamBufferReset( ( StreamBufferHandle_t ) xMessageBuffer ) define xMessageBufferSend (xMessageBuffer, pvTxData, xDataLengthBytes, xTicksToWait) xStreamBufferSend( ( StreamBufferHandle_t ) xMessageBuffer, pvTxData, xDataLengthBytes, xTicksToWait ) define xMessageBufferSendCompletedFromISR (xMessageBuffer, pxHigherPriorityTaskWoken) xStreamBufferSendCompletedFromISR( ( StreamBufferHandle_t ) xMessageBuffer, pxHigherPriorityTaskWoken ) define xMessageBufferSendFromISR (xMessageBuffer, pvTxData, xDataLengthBytes, pxHigherPriorityTaskWoken) xStreamBufferSendFromISR( ( StreamBufferHandle_t ) xMessageBuffer, pvTxData, xDataLengthBytes, pxHigherPriorityTaskWoken ) define xMessageBufferSpaceAvailable (xMessageBuffer) xStreamBufferSpacesAvailable( ( StreamBufferHandle_t ) xMessageBuffer ) define xMessageBufferSpacesAvailable (xMessageBuffer) xStreamBufferSpacesAvailable( ( StreamBufferHandle_t ) xMessageBuffer ) /* Corrects typo in original macro name. */"},{"location":"apiStm/message__buffer_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/message__buffer_8h/#typedef-messagebufferhandle_t","title":"typedef MessageBufferHandle_t","text":"<pre><code>typedef void* MessageBufferHandle_t;\n</code></pre> <p>Type by which message buffers are referenced. For example, a call to xMessageBufferCreate() returns an MessageBufferHandle_t variable that can then be used as a parameter to xMessageBufferSend(), xMessageBufferReceive(), etc. </p>"},{"location":"apiStm/message__buffer_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/message__buffer_8h/#define-vmessagebufferdelete","title":"define vMessageBufferDelete","text":"<pre><code>#define vMessageBufferDelete (\nxMessageBuffer\n) vStreamBufferDelete( ( StreamBufferHandle_t ) xMessageBuffer )\n</code></pre> <p>message_buffer.h</p> <p>Deletes a message buffer that was previously created using a call to xMessageBufferCreate() or xMessageBufferCreateStatic(). If the message buffer was created using dynamic memory (that is, by xMessageBufferCreate()), then the allocated memory is freed.</p> <p>A message buffer handle must not be used after the message buffer has been deleted.</p> <p>Parameters:</p> <ul> <li><code>xMessageBuffer</code> The handle of the message buffer to be deleted. </li> </ul>"},{"location":"apiStm/message__buffer_8h/#define-xmessagebuffercreate","title":"define xMessageBufferCreate","text":"<pre><code>#define xMessageBufferCreate (\nxBufferSizeBytes\n) ( MessageBufferHandle_t ) xStreamBufferGenericCreate( xBufferSizeBytes, ( size_t ) 0, pdTRUE )\n</code></pre>"},{"location":"apiStm/message__buffer_8h/#define-xmessagebuffercreatestatic","title":"define xMessageBufferCreateStatic","text":"<pre><code>#define xMessageBufferCreateStatic (\nxBufferSizeBytes,\npucMessageBufferStorageArea,\npxStaticMessageBuffer\n) ( MessageBufferHandle_t ) xStreamBufferGenericCreateStatic( xBufferSizeBytes, 0, pdTRUE, pucMessageBufferStorageArea, pxStaticMessageBuffer )\n</code></pre>"},{"location":"apiStm/message__buffer_8h/#define-xmessagebufferisempty","title":"define xMessageBufferIsEmpty","text":"<pre><code>#define xMessageBufferIsEmpty (\nxMessageBuffer\n) xStreamBufferIsEmpty( ( StreamBufferHandle_t ) xMessageBuffer )\n</code></pre> <p>message_buffer.h </p> <p>Tests to see if a message buffer is empty (does not contain any messages).</p> <p>Parameters:</p> <ul> <li><code>xMessageBuffer</code> The handle of the message buffer being queried.</li> </ul> <p>Returns:</p> <p>If the message buffer referenced by xMessageBuffer is empty then pdTRUE is returned. Otherwise pdFALSE is returned. </p>"},{"location":"apiStm/message__buffer_8h/#define-xmessagebufferisfull","title":"define xMessageBufferIsFull","text":"<pre><code>#define xMessageBufferIsFull (\nxMessageBuffer\n) xStreamBufferIsFull( ( StreamBufferHandle_t ) xMessageBuffer )\n</code></pre> <p>message_buffer.h </p> <p>Tests to see if a message buffer is full. A message buffer is full if it cannot accept any more messages, of any size, until space is made available by a message being removed from the message buffer.</p> <p>Parameters:</p> <ul> <li><code>xMessageBuffer</code> The handle of the message buffer being queried.</li> </ul> <p>Returns:</p> <p>If the message buffer referenced by xMessageBuffer is full then pdTRUE is returned. Otherwise pdFALSE is returned. </p>"},{"location":"apiStm/message__buffer_8h/#define-xmessagebuffernextlengthbytes","title":"define xMessageBufferNextLengthBytes","text":"<pre><code>#define xMessageBufferNextLengthBytes (\nxMessageBuffer\n) xStreamBufferNextMessageLengthBytes( ( StreamBufferHandle_t ) xMessageBuffer ) PRIVILEGED_FUNCTION;\n</code></pre>"},{"location":"apiStm/message__buffer_8h/#define-xmessagebufferreceive","title":"define xMessageBufferReceive","text":"<pre><code>#define xMessageBufferReceive (\nxMessageBuffer,\npvRxData,\nxBufferLengthBytes,\nxTicksToWait\n) xStreamBufferReceive( ( StreamBufferHandle_t ) xMessageBuffer, pvRxData, xBufferLengthBytes, xTicksToWait )\n</code></pre>"},{"location":"apiStm/message__buffer_8h/#define-xmessagebufferreceivecompletedfromisr","title":"define xMessageBufferReceiveCompletedFromISR","text":"<pre><code>#define xMessageBufferReceiveCompletedFromISR (\nxMessageBuffer,\npxHigherPriorityTaskWoken\n) xStreamBufferReceiveCompletedFromISR( ( StreamBufferHandle_t ) xMessageBuffer, pxHigherPriorityTaskWoken )\n</code></pre>"},{"location":"apiStm/message__buffer_8h/#define-xmessagebufferreceivefromisr","title":"define xMessageBufferReceiveFromISR","text":"<pre><code>#define xMessageBufferReceiveFromISR (\nxMessageBuffer,\npvRxData,\nxBufferLengthBytes,\npxHigherPriorityTaskWoken\n) xStreamBufferReceiveFromISR( ( StreamBufferHandle_t ) xMessageBuffer, pvRxData, xBufferLengthBytes, pxHigherPriorityTaskWoken )\n</code></pre>"},{"location":"apiStm/message__buffer_8h/#define-xmessagebufferreset","title":"define xMessageBufferReset","text":"<pre><code>#define xMessageBufferReset (\nxMessageBuffer\n) xStreamBufferReset( ( StreamBufferHandle_t ) xMessageBuffer )\n</code></pre>"},{"location":"apiStm/message__buffer_8h/#define-xmessagebuffersend","title":"define xMessageBufferSend","text":"<pre><code>#define xMessageBufferSend (\nxMessageBuffer,\npvTxData,\nxDataLengthBytes,\nxTicksToWait\n) xStreamBufferSend( ( StreamBufferHandle_t ) xMessageBuffer, pvTxData, xDataLengthBytes, xTicksToWait )\n</code></pre>"},{"location":"apiStm/message__buffer_8h/#define-xmessagebuffersendcompletedfromisr","title":"define xMessageBufferSendCompletedFromISR","text":"<pre><code>#define xMessageBufferSendCompletedFromISR (\nxMessageBuffer,\npxHigherPriorityTaskWoken\n) xStreamBufferSendCompletedFromISR( ( StreamBufferHandle_t ) xMessageBuffer, pxHigherPriorityTaskWoken )\n</code></pre>"},{"location":"apiStm/message__buffer_8h/#define-xmessagebuffersendfromisr","title":"define xMessageBufferSendFromISR","text":"<pre><code>#define xMessageBufferSendFromISR (\nxMessageBuffer,\npvTxData,\nxDataLengthBytes,\npxHigherPriorityTaskWoken\n) xStreamBufferSendFromISR( ( StreamBufferHandle_t ) xMessageBuffer, pvTxData, xDataLengthBytes, pxHigherPriorityTaskWoken )\n</code></pre>"},{"location":"apiStm/message__buffer_8h/#define-xmessagebufferspaceavailable","title":"define xMessageBufferSpaceAvailable","text":"<pre><code>#define xMessageBufferSpaceAvailable (\nxMessageBuffer\n) xStreamBufferSpacesAvailable( ( StreamBufferHandle_t ) xMessageBuffer )\n</code></pre>"},{"location":"apiStm/message__buffer_8h/#define-xmessagebufferspacesavailable","title":"define xMessageBufferSpacesAvailable","text":"<pre><code>#define xMessageBufferSpacesAvailable (\nxMessageBuffer\n) xStreamBufferSpacesAvailable( ( StreamBufferHandle_t ) xMessageBuffer ) /* Corrects typo in original macro name. */\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/message_buffer.h</code></p>"},{"location":"apiStm/message__buffer_8h_source/","title":"File message_buffer.h","text":"<p>File List &gt; FreeRTOS &gt; include &gt; message_buffer.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n\n/*\n * Message buffers build functionality on top of FreeRTOS stream buffers.\n * Whereas stream buffers are used to send a continuous stream of data from one\n * task or interrupt to another, message buffers are used to send variable\n * length discrete messages from one task or interrupt to another.  Their\n * implementation is light weight, making them particularly suited for interrupt\n * to task and core to core communication scenarios.\n *\n * ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer\n * implementation (so also the message buffer implementation, as message buffers\n * are built on top of stream buffers) assumes there is only one task or\n * interrupt that will write to the buffer (the writer), and only one task or\n * interrupt that will read from the buffer (the reader).  It is safe for the\n * writer and reader to be different tasks or interrupts, but, unlike other\n * FreeRTOS objects, it is not safe to have multiple different writers or\n * multiple different readers.  If there are to be multiple different writers\n * then the application writer must place each call to a writing API function\n * (such as xMessageBufferSend()) inside a critical section and set the send\n * block time to 0.  Likewise, if there are to be multiple different readers\n * then the application writer must place each call to a reading API function\n * (such as xMessageBufferRead()) inside a critical section and set the receive\n * timeout to 0.\n *\n * Message buffers hold variable length messages.  To enable that, when a\n * message is written to the message buffer an additional sizeof( size_t ) bytes\n * are also written to store the message's length (that happens internally, with\n * the API function).  sizeof( size_t ) is typically 4 bytes on a 32-bit\n * architecture, so writing a 10 byte message to a message buffer on a 32-bit\n * architecture will actually reduce the available space in the message buffer\n * by 14 bytes (10 byte are used by the message, and 4 bytes to hold the length\n * of the message).\n */\n\n#ifndef FREERTOS_MESSAGE_BUFFER_H\n#define FREERTOS_MESSAGE_BUFFER_H\n\n#ifndef INC_FREERTOS_H\n#error \"include FreeRTOS.h must appear in source files before include message_buffer.h\"\n#endif\n\n/* Message buffers are built onto of stream buffers. */\n#include \"stream_buffer.h\"\n\n#if defined( __cplusplus )\nextern \"C\" {\n#endif\n\ntypedef void * MessageBufferHandle_t;\n\n/*-----------------------------------------------------------*/\n\n#define xMessageBufferCreate( xBufferSizeBytes ) ( MessageBufferHandle_t ) xStreamBufferGenericCreate( xBufferSizeBytes, ( size_t ) 0, pdTRUE )\n\n#define xMessageBufferCreateStatic( xBufferSizeBytes, pucMessageBufferStorageArea, pxStaticMessageBuffer ) ( MessageBufferHandle_t ) xStreamBufferGenericCreateStatic( xBufferSizeBytes, 0, pdTRUE, pucMessageBufferStorageArea, pxStaticMessageBuffer )\n\n#define xMessageBufferSend( xMessageBuffer, pvTxData, xDataLengthBytes, xTicksToWait ) xStreamBufferSend( ( StreamBufferHandle_t ) xMessageBuffer, pvTxData, xDataLengthBytes, xTicksToWait )\n\n#define xMessageBufferSendFromISR( xMessageBuffer, pvTxData, xDataLengthBytes, pxHigherPriorityTaskWoken ) xStreamBufferSendFromISR( ( StreamBufferHandle_t ) xMessageBuffer, pvTxData, xDataLengthBytes, pxHigherPriorityTaskWoken )\n\n#define xMessageBufferReceive( xMessageBuffer, pvRxData, xBufferLengthBytes, xTicksToWait ) xStreamBufferReceive( ( StreamBufferHandle_t ) xMessageBuffer, pvRxData, xBufferLengthBytes, xTicksToWait )\n\n\n#define xMessageBufferReceiveFromISR( xMessageBuffer, pvRxData, xBufferLengthBytes, pxHigherPriorityTaskWoken ) xStreamBufferReceiveFromISR( ( StreamBufferHandle_t ) xMessageBuffer, pvRxData, xBufferLengthBytes, pxHigherPriorityTaskWoken )\n\n#define vMessageBufferDelete( xMessageBuffer ) vStreamBufferDelete( ( StreamBufferHandle_t ) xMessageBuffer )\n\n#define xMessageBufferIsFull( xMessageBuffer ) xStreamBufferIsFull( ( StreamBufferHandle_t ) xMessageBuffer )\n\n#define xMessageBufferIsEmpty( xMessageBuffer ) xStreamBufferIsEmpty( ( StreamBufferHandle_t ) xMessageBuffer )\n\n#define xMessageBufferReset( xMessageBuffer ) xStreamBufferReset( ( StreamBufferHandle_t ) xMessageBuffer )\n\n\n#define xMessageBufferSpaceAvailable( xMessageBuffer ) xStreamBufferSpacesAvailable( ( StreamBufferHandle_t ) xMessageBuffer )\n#define xMessageBufferSpacesAvailable( xMessageBuffer ) xStreamBufferSpacesAvailable( ( StreamBufferHandle_t ) xMessageBuffer ) /* Corrects typo in original macro name. */\n\n#define xMessageBufferNextLengthBytes( xMessageBuffer ) xStreamBufferNextMessageLengthBytes( ( StreamBufferHandle_t ) xMessageBuffer ) PRIVILEGED_FUNCTION;\n\n#define xMessageBufferSendCompletedFromISR( xMessageBuffer, pxHigherPriorityTaskWoken ) xStreamBufferSendCompletedFromISR( ( StreamBufferHandle_t ) xMessageBuffer, pxHigherPriorityTaskWoken )\n\n#define xMessageBufferReceiveCompletedFromISR( xMessageBuffer, pxHigherPriorityTaskWoken ) xStreamBufferReceiveCompletedFromISR( ( StreamBufferHandle_t ) xMessageBuffer, pxHigherPriorityTaskWoken )\n\n#if defined( __cplusplus )\n} /* extern \"C\" */\n#endif\n\n#endif  /* !defined( FREERTOS_MESSAGE_BUFFER_H ) */\n</code></pre>"},{"location":"apiStm/mpu__prototypes_8h/","title":"File mpu_prototypes.h","text":"<p>FileList &gt; FreeRTOS &gt; include &gt; mpu_prototypes.h</p> <p>Go to the source code of this file.</p>"},{"location":"apiStm/mpu__prototypes_8h/#public-functions","title":"Public Functions","text":"Type Name eTaskState MPU_eTaskGetState (TaskHandle_t xTask)  const char * MPU_pcQueueGetName (QueueHandle_t xQueue)  char * MPU_pcTaskGetName (TaskHandle_t xTaskToQuery)  const char * MPU_pcTimerGetName (TimerHandle_t xTimer)  void * MPU_pvTaskGetThreadLocalStoragePointer (TaskHandle_t xTaskToQuery, BaseType_t xIndex)  void * MPU_pvTimerGetTimerID (const TimerHandle_t xTimer)  uint8_t MPU_ucQueueGetQueueType (QueueHandle_t xQueue)  uint32_t MPU_ulTaskGetIdleRunTimeCounter (void)  uint32_t MPU_ulTaskNotifyTake (BaseType_t xClearCountOnExit, TickType_t xTicksToWait)  uint32_t MPU_ulTaskNotifyValueClear (TaskHandle_t xTask, uint32_t ulBitsToClear)  UBaseType_t MPU_uxEventGroupGetNumber (void * xEventGroup)  UBaseType_t MPU_uxQueueGetQueueNumber (QueueHandle_t xQueue)  UBaseType_t MPU_uxQueueMessagesWaiting (const QueueHandle_t xQueue)  UBaseType_t MPU_uxQueueSpacesAvailable (const QueueHandle_t xQueue)  UBaseType_t MPU_uxTaskGetNumberOfTasks (void)  UBaseType_t MPU_uxTaskGetStackHighWaterMark (TaskHandle_t xTask)  configSTACK_DEPTH_TYPE MPU_uxTaskGetStackHighWaterMark2 (TaskHandle_t xTask)  UBaseType_t MPU_uxTaskGetSystemState (TaskStatus_t *const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t *const pulTotalRunTime)  UBaseType_t MPU_uxTaskPriorityGet (const TaskHandle_t xTask)  UBaseType_t MPU_uxTimerGetReloadMode (TimerHandle_t xTimer)  void MPU_vEventGroupDelete (EventGroupHandle_t xEventGroup)  void MPU_vQueueAddToRegistry (QueueHandle_t xQueue, const char * pcName)  void MPU_vQueueDelete (QueueHandle_t xQueue)  void MPU_vQueueSetQueueNumber (QueueHandle_t xQueue, UBaseType_t uxQueueNumber)  void MPU_vQueueUnregisterQueue (QueueHandle_t xQueue)  void MPU_vStreamBufferDelete (StreamBufferHandle_t xStreamBuffer)  void MPU_vTaskAllocateMPURegions (TaskHandle_t xTask, const MemoryRegion_t *const pxRegions)  void MPU_vTaskDelay (const TickType_t xTicksToDelay)  void MPU_vTaskDelayUntil (TickType_t *const pxPreviousWakeTime, const TickType_t xTimeIncrement)  void MPU_vTaskDelete (TaskHandle_t xTaskToDelete)  void MPU_vTaskGetInfo (TaskHandle_t xTask, TaskStatus_t * pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState)  void MPU_vTaskGetRunTimeStats (char * pcWriteBuffer)  void MPU_vTaskList (char * pcWriteBuffer)  void MPU_vTaskMissedYield (void)  void MPU_vTaskPrioritySet (TaskHandle_t xTask, UBaseType_t uxNewPriority)  void MPU_vTaskResume (TaskHandle_t xTaskToResume)  void MPU_vTaskSetApplicationTaskTag (TaskHandle_t xTask, TaskHookFunction_t pxHookFunction)  void MPU_vTaskSetThreadLocalStoragePointer (TaskHandle_t xTaskToSet, BaseType_t xIndex, void * pvValue)  void MPU_vTaskSetTimeOutState (TimeOut_t *const pxTimeOut)  void MPU_vTaskStartScheduler (void)  void MPU_vTaskSuspend (TaskHandle_t xTaskToSuspend)  void MPU_vTaskSuspendAll (void)  void MPU_vTimerSetReloadMode (TimerHandle_t xTimer, const UBaseType_t uxAutoReload)  void MPU_vTimerSetTimerID (TimerHandle_t xTimer, void * pvNewID)  EventBits_t MPU_xEventGroupClearBits (EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear)  EventGroupHandle_t MPU_xEventGroupCreate (void)  EventGroupHandle_t MPU_xEventGroupCreateStatic (StaticEventGroup_t * pxEventGroupBuffer)  EventBits_t MPU_xEventGroupSetBits (EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet)  EventBits_t MPU_xEventGroupSync (EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait)  EventBits_t MPU_xEventGroupWaitBits (EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait)  BaseType_t MPU_xQueueAddToSet (QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet)  QueueHandle_t MPU_xQueueCreateCountingSemaphore (const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount)  QueueHandle_t MPU_xQueueCreateCountingSemaphoreStatic (const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t * pxStaticQueue)  QueueHandle_t MPU_xQueueCreateMutex (const uint8_t ucQueueType)  QueueHandle_t MPU_xQueueCreateMutexStatic (const uint8_t ucQueueType, StaticQueue_t * pxStaticQueue)  QueueSetHandle_t MPU_xQueueCreateSet (const UBaseType_t uxEventQueueLength)  QueueHandle_t MPU_xQueueGenericCreate (const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType)  QueueHandle_t MPU_xQueueGenericCreateStatic (const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t * pucQueueStorage, StaticQueue_t * pxStaticQueue, const uint8_t ucQueueType)  BaseType_t MPU_xQueueGenericReset (QueueHandle_t xQueue, BaseType_t xNewQueue)  BaseType_t MPU_xQueueGenericSend (QueueHandle_t xQueue, const void *const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition)  TaskHandle_t MPU_xQueueGetMutexHolder (QueueHandle_t xSemaphore)  BaseType_t MPU_xQueueGiveMutexRecursive (QueueHandle_t pxMutex)  BaseType_t MPU_xQueuePeek (QueueHandle_t xQueue, void *const pvBuffer, TickType_t xTicksToWait)  BaseType_t MPU_xQueueReceive (QueueHandle_t xQueue, void *const pvBuffer, TickType_t xTicksToWait)  BaseType_t MPU_xQueueRemoveFromSet (QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet)  QueueSetMemberHandle_t MPU_xQueueSelectFromSet (QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait)  BaseType_t MPU_xQueueSemaphoreTake (QueueHandle_t xQueue, TickType_t xTicksToWait)  BaseType_t MPU_xQueueTakeMutexRecursive (QueueHandle_t xMutex, TickType_t xTicksToWait)  size_t MPU_xStreamBufferBytesAvailable (StreamBufferHandle_t xStreamBuffer)  StreamBufferHandle_t MPU_xStreamBufferGenericCreate (size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer)  StreamBufferHandle_t MPU_xStreamBufferGenericCreateStatic (size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer, uint8_t *const pucStreamBufferStorageArea, StaticStreamBuffer_t *const pxStaticStreamBuffer)  BaseType_t MPU_xStreamBufferIsEmpty (StreamBufferHandle_t xStreamBuffer)  BaseType_t MPU_xStreamBufferIsFull (StreamBufferHandle_t xStreamBuffer)  size_t MPU_xStreamBufferNextMessageLengthBytes (StreamBufferHandle_t xStreamBuffer)  size_t MPU_xStreamBufferReceive (StreamBufferHandle_t xStreamBuffer, void * pvRxData, size_t xBufferLengthBytes, TickType_t xTicksToWait)  BaseType_t MPU_xStreamBufferReset (StreamBufferHandle_t xStreamBuffer)  size_t MPU_xStreamBufferSend (StreamBufferHandle_t xStreamBuffer, const void * pvTxData, size_t xDataLengthBytes, TickType_t xTicksToWait)  BaseType_t MPU_xStreamBufferSetTriggerLevel (StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel)  size_t MPU_xStreamBufferSpacesAvailable (StreamBufferHandle_t xStreamBuffer)  BaseType_t MPU_xTaskAbortDelay (TaskHandle_t xTask)  BaseType_t MPU_xTaskCallApplicationTaskHook (TaskHandle_t xTask, void * pvParameter)  BaseType_t MPU_xTaskCatchUpTicks (TickType_t xTicksToCatchUp)  BaseType_t MPU_xTaskCheckForTimeOut (TimeOut_t *const pxTimeOut, TickType_t *const pxTicksToWait)  BaseType_t MPU_xTaskCreate (TaskFunction_t pxTaskCode, const char *const pcName, const uint16_t usStackDepth, void *const pvParameters, UBaseType_t uxPriority, TaskHandle_t *const pxCreatedTask)  BaseType_t MPU_xTaskCreateRestricted (const TaskParameters_t *const pxTaskDefinition, TaskHandle_t * pxCreatedTask)  BaseType_t MPU_xTaskCreateRestrictedStatic (const TaskParameters_t *const pxTaskDefinition, TaskHandle_t * pxCreatedTask)  TaskHandle_t MPU_xTaskCreateStatic (TaskFunction_t pxTaskCode, const char *const pcName, const uint32_t ulStackDepth, void *const pvParameters, UBaseType_t uxPriority, StackType_t *const puxStackBuffer, StaticTask_t *const pxTaskBuffer)  BaseType_t MPU_xTaskGenericNotify (TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t * pulPreviousNotificationValue)  TaskHookFunction_t MPU_xTaskGetApplicationTaskTag (TaskHandle_t xTask)  TaskHandle_t MPU_xTaskGetCurrentTaskHandle (void)  TaskHandle_t MPU_xTaskGetHandle (const char * pcNameToQuery)  TaskHandle_t MPU_xTaskGetIdleTaskHandle (void)  BaseType_t MPU_xTaskGetSchedulerState (void)  TickType_t MPU_xTaskGetTickCount (void)  BaseType_t MPU_xTaskIncrementTick (void)  BaseType_t MPU_xTaskNotifyStateClear (TaskHandle_t xTask)  BaseType_t MPU_xTaskNotifyWait (uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t * pulNotificationValue, TickType_t xTicksToWait)  BaseType_t MPU_xTaskResumeAll (void)  TimerHandle_t MPU_xTimerCreate (const char *const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void *const pvTimerID, TimerCallbackFunction_t pxCallbackFunction)  TimerHandle_t MPU_xTimerCreateStatic (const char *const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void *const pvTimerID, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t * pxTimerBuffer)  BaseType_t MPU_xTimerCreateTimerTask (void)  BaseType_t MPU_xTimerGenericCommand (TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t *const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait)  TickType_t MPU_xTimerGetExpiryTime (TimerHandle_t xTimer)  TickType_t MPU_xTimerGetPeriod (TimerHandle_t xTimer)  TaskHandle_t MPU_xTimerGetTimerDaemonTaskHandle (void)  BaseType_t MPU_xTimerIsTimerActive (TimerHandle_t xTimer)  BaseType_t MPU_xTimerPendFunctionCall (PendedFunction_t xFunctionToPend, void * pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait)"},{"location":"apiStm/mpu__prototypes_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_etaskgetstate","title":"function MPU_eTaskGetState","text":"<pre><code>eTaskState MPU_eTaskGetState (\nTaskHandle_t xTask\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_pcqueuegetname","title":"function MPU_pcQueueGetName","text":"<pre><code>const char * MPU_pcQueueGetName (\nQueueHandle_t xQueue\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_pctaskgetname","title":"function MPU_pcTaskGetName","text":"<pre><code>char * MPU_pcTaskGetName (\nTaskHandle_t xTaskToQuery\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_pctimergetname","title":"function MPU_pcTimerGetName","text":"<pre><code>const char * MPU_pcTimerGetName (\nTimerHandle_t xTimer\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_pvtaskgetthreadlocalstoragepointer","title":"function MPU_pvTaskGetThreadLocalStoragePointer","text":"<pre><code>void * MPU_pvTaskGetThreadLocalStoragePointer (\nTaskHandle_t xTaskToQuery,\nBaseType_t xIndex\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_pvtimergettimerid","title":"function MPU_pvTimerGetTimerID","text":"<pre><code>void * MPU_pvTimerGetTimerID (\nconst TimerHandle_t xTimer\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_ucqueuegetqueuetype","title":"function MPU_ucQueueGetQueueType","text":"<pre><code>uint8_t MPU_ucQueueGetQueueType (\nQueueHandle_t xQueue\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_ultaskgetidleruntimecounter","title":"function MPU_ulTaskGetIdleRunTimeCounter","text":"<pre><code>uint32_t MPU_ulTaskGetIdleRunTimeCounter (\nvoid\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_ultasknotifytake","title":"function MPU_ulTaskNotifyTake","text":"<pre><code>uint32_t MPU_ulTaskNotifyTake (\nBaseType_t xClearCountOnExit,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_ultasknotifyvalueclear","title":"function MPU_ulTaskNotifyValueClear","text":"<pre><code>uint32_t MPU_ulTaskNotifyValueClear (\nTaskHandle_t xTask,\nuint32_t ulBitsToClear\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_uxeventgroupgetnumber","title":"function MPU_uxEventGroupGetNumber","text":"<pre><code>UBaseType_t MPU_uxEventGroupGetNumber (\nvoid * xEventGroup\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_uxqueuegetqueuenumber","title":"function MPU_uxQueueGetQueueNumber","text":"<pre><code>UBaseType_t MPU_uxQueueGetQueueNumber (\nQueueHandle_t xQueue\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_uxqueuemessageswaiting","title":"function MPU_uxQueueMessagesWaiting","text":"<pre><code>UBaseType_t MPU_uxQueueMessagesWaiting (\nconst QueueHandle_t xQueue\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_uxqueuespacesavailable","title":"function MPU_uxQueueSpacesAvailable","text":"<pre><code>UBaseType_t MPU_uxQueueSpacesAvailable (\nconst QueueHandle_t xQueue\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_uxtaskgetnumberoftasks","title":"function MPU_uxTaskGetNumberOfTasks","text":"<pre><code>UBaseType_t MPU_uxTaskGetNumberOfTasks (\nvoid\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_uxtaskgetstackhighwatermark","title":"function MPU_uxTaskGetStackHighWaterMark","text":"<pre><code>UBaseType_t MPU_uxTaskGetStackHighWaterMark (\nTaskHandle_t xTask\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_uxtaskgetstackhighwatermark2","title":"function MPU_uxTaskGetStackHighWaterMark2","text":"<pre><code>configSTACK_DEPTH_TYPE MPU_uxTaskGetStackHighWaterMark2 (\nTaskHandle_t xTask\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_uxtaskgetsystemstate","title":"function MPU_uxTaskGetSystemState","text":"<pre><code>UBaseType_t MPU_uxTaskGetSystemState (\nTaskStatus_t *const pxTaskStatusArray,\nconst UBaseType_t uxArraySize,\nuint32_t *const pulTotalRunTime\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_uxtaskpriorityget","title":"function MPU_uxTaskPriorityGet","text":"<pre><code>UBaseType_t MPU_uxTaskPriorityGet (\nconst TaskHandle_t xTask\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_uxtimergetreloadmode","title":"function MPU_uxTimerGetReloadMode","text":"<pre><code>UBaseType_t MPU_uxTimerGetReloadMode (\nTimerHandle_t xTimer\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_veventgroupdelete","title":"function MPU_vEventGroupDelete","text":"<pre><code>void MPU_vEventGroupDelete (\nEventGroupHandle_t xEventGroup\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_vqueueaddtoregistry","title":"function MPU_vQueueAddToRegistry","text":"<pre><code>void MPU_vQueueAddToRegistry (\nQueueHandle_t xQueue,\nconst char * pcName\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_vqueuedelete","title":"function MPU_vQueueDelete","text":"<pre><code>void MPU_vQueueDelete (\nQueueHandle_t xQueue\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_vqueuesetqueuenumber","title":"function MPU_vQueueSetQueueNumber","text":"<pre><code>void MPU_vQueueSetQueueNumber (\nQueueHandle_t xQueue,\nUBaseType_t uxQueueNumber\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_vqueueunregisterqueue","title":"function MPU_vQueueUnregisterQueue","text":"<pre><code>void MPU_vQueueUnregisterQueue (\nQueueHandle_t xQueue\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_vstreambufferdelete","title":"function MPU_vStreamBufferDelete","text":"<pre><code>void MPU_vStreamBufferDelete (\nStreamBufferHandle_t xStreamBuffer\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_vtaskallocatempuregions","title":"function MPU_vTaskAllocateMPURegions","text":"<pre><code>void MPU_vTaskAllocateMPURegions (\nTaskHandle_t xTask,\nconst MemoryRegion_t *const pxRegions\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_vtaskdelay","title":"function MPU_vTaskDelay","text":"<pre><code>void MPU_vTaskDelay (\nconst TickType_t xTicksToDelay\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_vtaskdelayuntil","title":"function MPU_vTaskDelayUntil","text":"<pre><code>void MPU_vTaskDelayUntil (\nTickType_t *const pxPreviousWakeTime,\nconst TickType_t xTimeIncrement\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_vtaskdelete","title":"function MPU_vTaskDelete","text":"<pre><code>void MPU_vTaskDelete (\nTaskHandle_t xTaskToDelete\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_vtaskgetinfo","title":"function MPU_vTaskGetInfo","text":"<pre><code>void MPU_vTaskGetInfo (\nTaskHandle_t xTask,\nTaskStatus_t * pxTaskStatus,\nBaseType_t xGetFreeStackSpace,\neTaskState eState\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_vtaskgetruntimestats","title":"function MPU_vTaskGetRunTimeStats","text":"<pre><code>void MPU_vTaskGetRunTimeStats (\nchar * pcWriteBuffer\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_vtasklist","title":"function MPU_vTaskList","text":"<pre><code>void MPU_vTaskList (\nchar * pcWriteBuffer\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_vtaskmissedyield","title":"function MPU_vTaskMissedYield","text":"<pre><code>void MPU_vTaskMissedYield (\nvoid\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_vtaskpriorityset","title":"function MPU_vTaskPrioritySet","text":"<pre><code>void MPU_vTaskPrioritySet (\nTaskHandle_t xTask,\nUBaseType_t uxNewPriority\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_vtaskresume","title":"function MPU_vTaskResume","text":"<pre><code>void MPU_vTaskResume (\nTaskHandle_t xTaskToResume\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_vtasksetapplicationtasktag","title":"function MPU_vTaskSetApplicationTaskTag","text":"<pre><code>void MPU_vTaskSetApplicationTaskTag (\nTaskHandle_t xTask,\nTaskHookFunction_t pxHookFunction\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_vtasksetthreadlocalstoragepointer","title":"function MPU_vTaskSetThreadLocalStoragePointer","text":"<pre><code>void MPU_vTaskSetThreadLocalStoragePointer (\nTaskHandle_t xTaskToSet,\nBaseType_t xIndex,\nvoid * pvValue\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_vtasksettimeoutstate","title":"function MPU_vTaskSetTimeOutState","text":"<pre><code>void MPU_vTaskSetTimeOutState (\nTimeOut_t *const pxTimeOut\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_vtaskstartscheduler","title":"function MPU_vTaskStartScheduler","text":"<pre><code>void MPU_vTaskStartScheduler (\nvoid\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_vtasksuspend","title":"function MPU_vTaskSuspend","text":"<pre><code>void MPU_vTaskSuspend (\nTaskHandle_t xTaskToSuspend\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_vtasksuspendall","title":"function MPU_vTaskSuspendAll","text":"<pre><code>void MPU_vTaskSuspendAll (\nvoid\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_vtimersetreloadmode","title":"function MPU_vTimerSetReloadMode","text":"<pre><code>void MPU_vTimerSetReloadMode (\nTimerHandle_t xTimer,\nconst UBaseType_t uxAutoReload\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_vtimersettimerid","title":"function MPU_vTimerSetTimerID","text":"<pre><code>void MPU_vTimerSetTimerID (\nTimerHandle_t xTimer,\nvoid * pvNewID\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xeventgroupclearbits","title":"function MPU_xEventGroupClearBits","text":"<pre><code>EventBits_t MPU_xEventGroupClearBits (\nEventGroupHandle_t xEventGroup,\nconst EventBits_t uxBitsToClear\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xeventgroupcreate","title":"function MPU_xEventGroupCreate","text":"<pre><code>EventGroupHandle_t MPU_xEventGroupCreate (\nvoid\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xeventgroupcreatestatic","title":"function MPU_xEventGroupCreateStatic","text":"<pre><code>EventGroupHandle_t MPU_xEventGroupCreateStatic (\nStaticEventGroup_t * pxEventGroupBuffer\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xeventgroupsetbits","title":"function MPU_xEventGroupSetBits","text":"<pre><code>EventBits_t MPU_xEventGroupSetBits (\nEventGroupHandle_t xEventGroup,\nconst EventBits_t uxBitsToSet\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xeventgroupsync","title":"function MPU_xEventGroupSync","text":"<pre><code>EventBits_t MPU_xEventGroupSync (\nEventGroupHandle_t xEventGroup,\nconst EventBits_t uxBitsToSet,\nconst EventBits_t uxBitsToWaitFor,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xeventgroupwaitbits","title":"function MPU_xEventGroupWaitBits","text":"<pre><code>EventBits_t MPU_xEventGroupWaitBits (\nEventGroupHandle_t xEventGroup,\nconst EventBits_t uxBitsToWaitFor,\nconst BaseType_t xClearOnExit,\nconst BaseType_t xWaitForAllBits,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xqueueaddtoset","title":"function MPU_xQueueAddToSet","text":"<pre><code>BaseType_t MPU_xQueueAddToSet (\nQueueSetMemberHandle_t xQueueOrSemaphore,\nQueueSetHandle_t xQueueSet\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xqueuecreatecountingsemaphore","title":"function MPU_xQueueCreateCountingSemaphore","text":"<pre><code>QueueHandle_t MPU_xQueueCreateCountingSemaphore (\nconst UBaseType_t uxMaxCount,\nconst UBaseType_t uxInitialCount\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xqueuecreatecountingsemaphorestatic","title":"function MPU_xQueueCreateCountingSemaphoreStatic","text":"<pre><code>QueueHandle_t MPU_xQueueCreateCountingSemaphoreStatic (\nconst UBaseType_t uxMaxCount,\nconst UBaseType_t uxInitialCount,\nStaticQueue_t * pxStaticQueue\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xqueuecreatemutex","title":"function MPU_xQueueCreateMutex","text":"<pre><code>QueueHandle_t MPU_xQueueCreateMutex (\nconst uint8_t ucQueueType\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xqueuecreatemutexstatic","title":"function MPU_xQueueCreateMutexStatic","text":"<pre><code>QueueHandle_t MPU_xQueueCreateMutexStatic (\nconst uint8_t ucQueueType,\nStaticQueue_t * pxStaticQueue\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xqueuecreateset","title":"function MPU_xQueueCreateSet","text":"<pre><code>QueueSetHandle_t MPU_xQueueCreateSet (\nconst UBaseType_t uxEventQueueLength\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xqueuegenericcreate","title":"function MPU_xQueueGenericCreate","text":"<pre><code>QueueHandle_t MPU_xQueueGenericCreate (\nconst UBaseType_t uxQueueLength,\nconst UBaseType_t uxItemSize,\nconst uint8_t ucQueueType\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xqueuegenericcreatestatic","title":"function MPU_xQueueGenericCreateStatic","text":"<pre><code>QueueHandle_t MPU_xQueueGenericCreateStatic (\nconst UBaseType_t uxQueueLength,\nconst UBaseType_t uxItemSize,\nuint8_t * pucQueueStorage,\nStaticQueue_t * pxStaticQueue,\nconst uint8_t ucQueueType\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xqueuegenericreset","title":"function MPU_xQueueGenericReset","text":"<pre><code>BaseType_t MPU_xQueueGenericReset (\nQueueHandle_t xQueue,\nBaseType_t xNewQueue\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xqueuegenericsend","title":"function MPU_xQueueGenericSend","text":"<pre><code>BaseType_t MPU_xQueueGenericSend (\nQueueHandle_t xQueue,\nconst void *const pvItemToQueue,\nTickType_t xTicksToWait,\nconst BaseType_t xCopyPosition\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xqueuegetmutexholder","title":"function MPU_xQueueGetMutexHolder","text":"<pre><code>TaskHandle_t MPU_xQueueGetMutexHolder (\nQueueHandle_t xSemaphore\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xqueuegivemutexrecursive","title":"function MPU_xQueueGiveMutexRecursive","text":"<pre><code>BaseType_t MPU_xQueueGiveMutexRecursive (\nQueueHandle_t pxMutex\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xqueuepeek","title":"function MPU_xQueuePeek","text":"<pre><code>BaseType_t MPU_xQueuePeek (\nQueueHandle_t xQueue,\nvoid *const pvBuffer,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xqueuereceive","title":"function MPU_xQueueReceive","text":"<pre><code>BaseType_t MPU_xQueueReceive (\nQueueHandle_t xQueue,\nvoid *const pvBuffer,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xqueueremovefromset","title":"function MPU_xQueueRemoveFromSet","text":"<pre><code>BaseType_t MPU_xQueueRemoveFromSet (\nQueueSetMemberHandle_t xQueueOrSemaphore,\nQueueSetHandle_t xQueueSet\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xqueueselectfromset","title":"function MPU_xQueueSelectFromSet","text":"<pre><code>QueueSetMemberHandle_t MPU_xQueueSelectFromSet (\nQueueSetHandle_t xQueueSet,\nconst TickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xqueuesemaphoretake","title":"function MPU_xQueueSemaphoreTake","text":"<pre><code>BaseType_t MPU_xQueueSemaphoreTake (\nQueueHandle_t xQueue,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xqueuetakemutexrecursive","title":"function MPU_xQueueTakeMutexRecursive","text":"<pre><code>BaseType_t MPU_xQueueTakeMutexRecursive (\nQueueHandle_t xMutex,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xstreambufferbytesavailable","title":"function MPU_xStreamBufferBytesAvailable","text":"<pre><code>size_t MPU_xStreamBufferBytesAvailable (\nStreamBufferHandle_t xStreamBuffer\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xstreambuffergenericcreate","title":"function MPU_xStreamBufferGenericCreate","text":"<pre><code>StreamBufferHandle_t MPU_xStreamBufferGenericCreate (\nsize_t xBufferSizeBytes,\nsize_t xTriggerLevelBytes,\nBaseType_t xIsMessageBuffer\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xstreambuffergenericcreatestatic","title":"function MPU_xStreamBufferGenericCreateStatic","text":"<pre><code>StreamBufferHandle_t MPU_xStreamBufferGenericCreateStatic (\nsize_t xBufferSizeBytes,\nsize_t xTriggerLevelBytes,\nBaseType_t xIsMessageBuffer,\nuint8_t *const pucStreamBufferStorageArea,\nStaticStreamBuffer_t *const pxStaticStreamBuffer\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xstreambufferisempty","title":"function MPU_xStreamBufferIsEmpty","text":"<pre><code>BaseType_t MPU_xStreamBufferIsEmpty (\nStreamBufferHandle_t xStreamBuffer\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xstreambufferisfull","title":"function MPU_xStreamBufferIsFull","text":"<pre><code>BaseType_t MPU_xStreamBufferIsFull (\nStreamBufferHandle_t xStreamBuffer\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xstreambuffernextmessagelengthbytes","title":"function MPU_xStreamBufferNextMessageLengthBytes","text":"<pre><code>size_t MPU_xStreamBufferNextMessageLengthBytes (\nStreamBufferHandle_t xStreamBuffer\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xstreambufferreceive","title":"function MPU_xStreamBufferReceive","text":"<pre><code>size_t MPU_xStreamBufferReceive (\nStreamBufferHandle_t xStreamBuffer,\nvoid * pvRxData,\nsize_t xBufferLengthBytes,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xstreambufferreset","title":"function MPU_xStreamBufferReset","text":"<pre><code>BaseType_t MPU_xStreamBufferReset (\nStreamBufferHandle_t xStreamBuffer\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xstreambuffersend","title":"function MPU_xStreamBufferSend","text":"<pre><code>size_t MPU_xStreamBufferSend (\nStreamBufferHandle_t xStreamBuffer,\nconst void * pvTxData,\nsize_t xDataLengthBytes,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xstreambuffersettriggerlevel","title":"function MPU_xStreamBufferSetTriggerLevel","text":"<pre><code>BaseType_t MPU_xStreamBufferSetTriggerLevel (\nStreamBufferHandle_t xStreamBuffer,\nsize_t xTriggerLevel\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xstreambufferspacesavailable","title":"function MPU_xStreamBufferSpacesAvailable","text":"<pre><code>size_t MPU_xStreamBufferSpacesAvailable (\nStreamBufferHandle_t xStreamBuffer\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtaskabortdelay","title":"function MPU_xTaskAbortDelay","text":"<pre><code>BaseType_t MPU_xTaskAbortDelay (\nTaskHandle_t xTask\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtaskcallapplicationtaskhook","title":"function MPU_xTaskCallApplicationTaskHook","text":"<pre><code>BaseType_t MPU_xTaskCallApplicationTaskHook (\nTaskHandle_t xTask,\nvoid * pvParameter\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtaskcatchupticks","title":"function MPU_xTaskCatchUpTicks","text":"<pre><code>BaseType_t MPU_xTaskCatchUpTicks (\nTickType_t xTicksToCatchUp\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtaskcheckfortimeout","title":"function MPU_xTaskCheckForTimeOut","text":"<pre><code>BaseType_t MPU_xTaskCheckForTimeOut (\nTimeOut_t *const pxTimeOut,\nTickType_t *const pxTicksToWait\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtaskcreate","title":"function MPU_xTaskCreate","text":"<pre><code>BaseType_t MPU_xTaskCreate (\nTaskFunction_t pxTaskCode,\nconst char *const pcName,\nconst uint16_t usStackDepth,\nvoid *const pvParameters,\nUBaseType_t uxPriority,\nTaskHandle_t *const pxCreatedTask\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtaskcreaterestricted","title":"function MPU_xTaskCreateRestricted","text":"<pre><code>BaseType_t MPU_xTaskCreateRestricted (\nconst TaskParameters_t *const pxTaskDefinition,\nTaskHandle_t * pxCreatedTask\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtaskcreaterestrictedstatic","title":"function MPU_xTaskCreateRestrictedStatic","text":"<pre><code>BaseType_t MPU_xTaskCreateRestrictedStatic (\nconst TaskParameters_t *const pxTaskDefinition,\nTaskHandle_t * pxCreatedTask\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtaskcreatestatic","title":"function MPU_xTaskCreateStatic","text":"<pre><code>TaskHandle_t MPU_xTaskCreateStatic (\nTaskFunction_t pxTaskCode,\nconst char *const pcName,\nconst uint32_t ulStackDepth,\nvoid *const pvParameters,\nUBaseType_t uxPriority,\nStackType_t *const puxStackBuffer,\nStaticTask_t *const pxTaskBuffer\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtaskgenericnotify","title":"function MPU_xTaskGenericNotify","text":"<pre><code>BaseType_t MPU_xTaskGenericNotify (\nTaskHandle_t xTaskToNotify,\nuint32_t ulValue,\neNotifyAction eAction,\nuint32_t * pulPreviousNotificationValue\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtaskgetapplicationtasktag","title":"function MPU_xTaskGetApplicationTaskTag","text":"<pre><code>TaskHookFunction_t MPU_xTaskGetApplicationTaskTag (\nTaskHandle_t xTask\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtaskgetcurrenttaskhandle","title":"function MPU_xTaskGetCurrentTaskHandle","text":"<pre><code>TaskHandle_t MPU_xTaskGetCurrentTaskHandle (\nvoid\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtaskgethandle","title":"function MPU_xTaskGetHandle","text":"<pre><code>TaskHandle_t MPU_xTaskGetHandle (\nconst char * pcNameToQuery\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtaskgetidletaskhandle","title":"function MPU_xTaskGetIdleTaskHandle","text":"<pre><code>TaskHandle_t MPU_xTaskGetIdleTaskHandle (\nvoid\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtaskgetschedulerstate","title":"function MPU_xTaskGetSchedulerState","text":"<pre><code>BaseType_t MPU_xTaskGetSchedulerState (\nvoid\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtaskgettickcount","title":"function MPU_xTaskGetTickCount","text":"<pre><code>TickType_t MPU_xTaskGetTickCount (\nvoid\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtaskincrementtick","title":"function MPU_xTaskIncrementTick","text":"<pre><code>BaseType_t MPU_xTaskIncrementTick (\nvoid\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtasknotifystateclear","title":"function MPU_xTaskNotifyStateClear","text":"<pre><code>BaseType_t MPU_xTaskNotifyStateClear (\nTaskHandle_t xTask\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtasknotifywait","title":"function MPU_xTaskNotifyWait","text":"<pre><code>BaseType_t MPU_xTaskNotifyWait (\nuint32_t ulBitsToClearOnEntry,\nuint32_t ulBitsToClearOnExit,\nuint32_t * pulNotificationValue,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtaskresumeall","title":"function MPU_xTaskResumeAll","text":"<pre><code>BaseType_t MPU_xTaskResumeAll (\nvoid\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtimercreate","title":"function MPU_xTimerCreate","text":"<pre><code>TimerHandle_t MPU_xTimerCreate (\nconst char *const pcTimerName,\nconst TickType_t xTimerPeriodInTicks,\nconst UBaseType_t uxAutoReload,\nvoid *const pvTimerID,\nTimerCallbackFunction_t pxCallbackFunction\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtimercreatestatic","title":"function MPU_xTimerCreateStatic","text":"<pre><code>TimerHandle_t MPU_xTimerCreateStatic (\nconst char *const pcTimerName,\nconst TickType_t xTimerPeriodInTicks,\nconst UBaseType_t uxAutoReload,\nvoid *const pvTimerID,\nTimerCallbackFunction_t pxCallbackFunction,\nStaticTimer_t * pxTimerBuffer\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtimercreatetimertask","title":"function MPU_xTimerCreateTimerTask","text":"<pre><code>BaseType_t MPU_xTimerCreateTimerTask (\nvoid\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtimergenericcommand","title":"function MPU_xTimerGenericCommand","text":"<pre><code>BaseType_t MPU_xTimerGenericCommand (\nTimerHandle_t xTimer,\nconst BaseType_t xCommandID,\nconst TickType_t xOptionalValue,\nBaseType_t *const pxHigherPriorityTaskWoken,\nconst TickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtimergetexpirytime","title":"function MPU_xTimerGetExpiryTime","text":"<pre><code>TickType_t MPU_xTimerGetExpiryTime (\nTimerHandle_t xTimer\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtimergetperiod","title":"function MPU_xTimerGetPeriod","text":"<pre><code>TickType_t MPU_xTimerGetPeriod (\nTimerHandle_t xTimer\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtimergettimerdaemontaskhandle","title":"function MPU_xTimerGetTimerDaemonTaskHandle","text":"<pre><code>TaskHandle_t MPU_xTimerGetTimerDaemonTaskHandle (\nvoid\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtimeristimeractive","title":"function MPU_xTimerIsTimerActive","text":"<pre><code>BaseType_t MPU_xTimerIsTimerActive (\nTimerHandle_t xTimer\n) </code></pre>"},{"location":"apiStm/mpu__prototypes_8h/#function-mpu_xtimerpendfunctioncall","title":"function MPU_xTimerPendFunctionCall","text":"<pre><code>BaseType_t MPU_xTimerPendFunctionCall (\nPendedFunction_t xFunctionToPend,\nvoid * pvParameter1,\nuint32_t ulParameter2,\nTickType_t xTicksToWait\n) </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/mpu_prototypes.h</code></p>"},{"location":"apiStm/mpu__prototypes_8h_source/","title":"File mpu_prototypes.h","text":"<p>File List &gt; FreeRTOS &gt; include &gt; mpu_prototypes.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n/*\n * When the MPU is used the standard (non MPU) API functions are mapped to\n * equivalents that start \"MPU_\", the prototypes for which are defined in this\n * header files.  This will cause the application code to call the MPU_ version\n * which wraps the non-MPU version with privilege promoting then demoting code,\n * so the kernel code always runs will full privileges.\n */\n\n\n#ifndef MPU_PROTOTYPES_H\n#define MPU_PROTOTYPES_H\n\n/* MPU versions of tasks.h API functions. */\nBaseType_t MPU_xTaskCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask ) FREERTOS_SYSTEM_CALL;\nTaskHandle_t MPU_xTaskCreateStatic( TaskFunction_t pxTaskCode, const char * const pcName, const uint32_t ulStackDepth, void * const pvParameters, UBaseType_t uxPriority, StackType_t * const puxStackBuffer, StaticTask_t * const pxTaskBuffer ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) FREERTOS_SYSTEM_CALL;\nvoid MPU_vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) FREERTOS_SYSTEM_CALL;\nvoid MPU_vTaskDelete( TaskHandle_t xTaskToDelete ) FREERTOS_SYSTEM_CALL;\nvoid MPU_vTaskDelay( const TickType_t xTicksToDelay ) FREERTOS_SYSTEM_CALL;\nvoid MPU_vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xTaskAbortDelay( TaskHandle_t xTask ) FREERTOS_SYSTEM_CALL;\nUBaseType_t MPU_uxTaskPriorityGet( const TaskHandle_t xTask ) FREERTOS_SYSTEM_CALL;\neTaskState MPU_eTaskGetState( TaskHandle_t xTask ) FREERTOS_SYSTEM_CALL;\nvoid MPU_vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) FREERTOS_SYSTEM_CALL;\nvoid MPU_vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) FREERTOS_SYSTEM_CALL;\nvoid MPU_vTaskSuspend( TaskHandle_t xTaskToSuspend ) FREERTOS_SYSTEM_CALL;\nvoid MPU_vTaskResume( TaskHandle_t xTaskToResume ) FREERTOS_SYSTEM_CALL;\nvoid MPU_vTaskStartScheduler( void ) FREERTOS_SYSTEM_CALL;\nvoid MPU_vTaskSuspendAll( void ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xTaskResumeAll( void ) FREERTOS_SYSTEM_CALL;\nTickType_t MPU_xTaskGetTickCount( void ) FREERTOS_SYSTEM_CALL;\nUBaseType_t MPU_uxTaskGetNumberOfTasks( void ) FREERTOS_SYSTEM_CALL;\nchar * MPU_pcTaskGetName( TaskHandle_t xTaskToQuery ) FREERTOS_SYSTEM_CALL;\nTaskHandle_t MPU_xTaskGetHandle( const char *pcNameToQuery ) FREERTOS_SYSTEM_CALL;\nUBaseType_t MPU_uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) FREERTOS_SYSTEM_CALL;\nconfigSTACK_DEPTH_TYPE MPU_uxTaskGetStackHighWaterMark2( TaskHandle_t xTask ) FREERTOS_SYSTEM_CALL;\nvoid MPU_vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction ) FREERTOS_SYSTEM_CALL;\nTaskHookFunction_t MPU_xTaskGetApplicationTaskTag( TaskHandle_t xTask ) FREERTOS_SYSTEM_CALL;\nvoid MPU_vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) FREERTOS_SYSTEM_CALL;\nvoid * MPU_pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) FREERTOS_SYSTEM_CALL;\nTaskHandle_t MPU_xTaskGetIdleTaskHandle( void ) FREERTOS_SYSTEM_CALL;\nUBaseType_t MPU_uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) FREERTOS_SYSTEM_CALL;\nuint32_t MPU_ulTaskGetIdleRunTimeCounter( void ) FREERTOS_SYSTEM_CALL;\nvoid MPU_vTaskList( char * pcWriteBuffer ) FREERTOS_SYSTEM_CALL;\nvoid MPU_vTaskGetRunTimeStats( char *pcWriteBuffer ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;\nuint32_t MPU_ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xTaskNotifyStateClear( TaskHandle_t xTask ) FREERTOS_SYSTEM_CALL;\nuint32_t MPU_ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xTaskIncrementTick( void ) FREERTOS_SYSTEM_CALL;\nTaskHandle_t MPU_xTaskGetCurrentTaskHandle( void ) FREERTOS_SYSTEM_CALL;\nvoid MPU_vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) FREERTOS_SYSTEM_CALL;\nvoid MPU_vTaskMissedYield( void ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xTaskGetSchedulerState( void ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xTaskCatchUpTicks( TickType_t xTicksToCatchUp ) FREERTOS_SYSTEM_CALL;\n\n/* MPU versions of queue.h API functions. */\nBaseType_t MPU_xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;\nUBaseType_t MPU_uxQueueMessagesWaiting( const QueueHandle_t xQueue ) FREERTOS_SYSTEM_CALL;\nUBaseType_t MPU_uxQueueSpacesAvailable( const QueueHandle_t xQueue ) FREERTOS_SYSTEM_CALL;\nvoid MPU_vQueueDelete( QueueHandle_t xQueue ) FREERTOS_SYSTEM_CALL;\nQueueHandle_t MPU_xQueueCreateMutex( const uint8_t ucQueueType ) FREERTOS_SYSTEM_CALL;\nQueueHandle_t MPU_xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue ) FREERTOS_SYSTEM_CALL;\nQueueHandle_t MPU_xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) FREERTOS_SYSTEM_CALL;\nQueueHandle_t MPU_xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue ) FREERTOS_SYSTEM_CALL;\nTaskHandle_t MPU_xQueueGetMutexHolder( QueueHandle_t xSemaphore ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xQueueGiveMutexRecursive( QueueHandle_t pxMutex ) FREERTOS_SYSTEM_CALL;\nvoid MPU_vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcName ) FREERTOS_SYSTEM_CALL;\nvoid MPU_vQueueUnregisterQueue( QueueHandle_t xQueue ) FREERTOS_SYSTEM_CALL;\nconst char * MPU_pcQueueGetName( QueueHandle_t xQueue ) FREERTOS_SYSTEM_CALL;\nQueueHandle_t MPU_xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) FREERTOS_SYSTEM_CALL;\nQueueHandle_t MPU_xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType ) FREERTOS_SYSTEM_CALL;\nQueueSetHandle_t MPU_xQueueCreateSet( const UBaseType_t uxEventQueueLength ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) FREERTOS_SYSTEM_CALL;\nQueueSetMemberHandle_t MPU_xQueueSelectFromSet( QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) FREERTOS_SYSTEM_CALL;\nvoid MPU_vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber ) FREERTOS_SYSTEM_CALL;\nUBaseType_t MPU_uxQueueGetQueueNumber( QueueHandle_t xQueue ) FREERTOS_SYSTEM_CALL;\nuint8_t MPU_ucQueueGetQueueType( QueueHandle_t xQueue ) FREERTOS_SYSTEM_CALL;\n\n/* MPU versions of timers.h API functions. */\nTimerHandle_t MPU_xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) FREERTOS_SYSTEM_CALL;\nTimerHandle_t MPU_xTimerCreateStatic( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t *pxTimerBuffer ) FREERTOS_SYSTEM_CALL;\nvoid * MPU_pvTimerGetTimerID( const TimerHandle_t xTimer ) FREERTOS_SYSTEM_CALL;\nvoid MPU_vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xTimerIsTimerActive( TimerHandle_t xTimer ) FREERTOS_SYSTEM_CALL;\nTaskHandle_t MPU_xTimerGetTimerDaemonTaskHandle( void ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;\nconst char * MPU_pcTimerGetName( TimerHandle_t xTimer ) FREERTOS_SYSTEM_CALL;\nvoid MPU_vTimerSetReloadMode( TimerHandle_t xTimer, const UBaseType_t uxAutoReload ) FREERTOS_SYSTEM_CALL;\nUBaseType_t MPU_uxTimerGetReloadMode( TimerHandle_t xTimer ) FREERTOS_SYSTEM_CALL;\nTickType_t MPU_xTimerGetPeriod( TimerHandle_t xTimer ) FREERTOS_SYSTEM_CALL;\nTickType_t MPU_xTimerGetExpiryTime( TimerHandle_t xTimer ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xTimerCreateTimerTask( void ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;\n\n/* MPU versions of event_group.h API functions. */\nEventGroupHandle_t MPU_xEventGroupCreate( void ) FREERTOS_SYSTEM_CALL;\nEventGroupHandle_t MPU_xEventGroupCreateStatic( StaticEventGroup_t *pxEventGroupBuffer ) FREERTOS_SYSTEM_CALL;\nEventBits_t MPU_xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;\nEventBits_t MPU_xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear ) FREERTOS_SYSTEM_CALL;\nEventBits_t MPU_xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet ) FREERTOS_SYSTEM_CALL;\nEventBits_t MPU_xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;\nvoid MPU_vEventGroupDelete( EventGroupHandle_t xEventGroup ) FREERTOS_SYSTEM_CALL;\nUBaseType_t MPU_uxEventGroupGetNumber( void* xEventGroup ) FREERTOS_SYSTEM_CALL;\n\n/* MPU versions of message/stream_buffer.h API functions. */\nsize_t MPU_xStreamBufferSend( StreamBufferHandle_t xStreamBuffer, const void *pvTxData, size_t xDataLengthBytes, TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;\nsize_t MPU_xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer, void *pvRxData, size_t xBufferLengthBytes, TickType_t xTicksToWait ) FREERTOS_SYSTEM_CALL;\nsize_t MPU_xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer ) FREERTOS_SYSTEM_CALL;\nvoid MPU_vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xStreamBufferReset( StreamBufferHandle_t xStreamBuffer ) FREERTOS_SYSTEM_CALL;\nsize_t MPU_xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer ) FREERTOS_SYSTEM_CALL;\nsize_t MPU_xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer ) FREERTOS_SYSTEM_CALL;\nBaseType_t MPU_xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel ) FREERTOS_SYSTEM_CALL;\nStreamBufferHandle_t MPU_xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer ) FREERTOS_SYSTEM_CALL;\nStreamBufferHandle_t MPU_xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer, uint8_t * const pucStreamBufferStorageArea, StaticStreamBuffer_t * const pxStaticStreamBuffer ) FREERTOS_SYSTEM_CALL;\n\n\n\n#endif /* MPU_PROTOTYPES_H */\n</code></pre>"},{"location":"apiStm/mpu__wrappers_8h/","title":"File mpu_wrappers.h","text":"<p>FileList &gt; FreeRTOS &gt; include &gt; mpu_wrappers.h</p> <p>Go to the source code of this file.</p>"},{"location":"apiStm/mpu__wrappers_8h/#macros","title":"Macros","text":"Type Name define FREERTOS_SYSTEM_CALL define PRIVILEGED_DATA define PRIVILEGED_FUNCTION define portUSING_MPU_WRAPPERS  0"},{"location":"apiStm/mpu__wrappers_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/mpu__wrappers_8h/#define-freertos_system_call","title":"define FREERTOS_SYSTEM_CALL","text":"<pre><code>#define FREERTOS_SYSTEM_CALL \n</code></pre>"},{"location":"apiStm/mpu__wrappers_8h/#define-privileged_data","title":"define PRIVILEGED_DATA","text":"<pre><code>#define PRIVILEGED_DATA \n</code></pre>"},{"location":"apiStm/mpu__wrappers_8h/#define-privileged_function","title":"define PRIVILEGED_FUNCTION","text":"<pre><code>#define PRIVILEGED_FUNCTION \n</code></pre>"},{"location":"apiStm/mpu__wrappers_8h/#define-portusing_mpu_wrappers","title":"define portUSING_MPU_WRAPPERS","text":"<pre><code>#define portUSING_MPU_WRAPPERS 0\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/mpu_wrappers.h</code></p>"},{"location":"apiStm/mpu__wrappers_8h_source/","title":"File mpu_wrappers.h","text":"<p>File List &gt; FreeRTOS &gt; include &gt; mpu_wrappers.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n#ifndef MPU_WRAPPERS_H\n#define MPU_WRAPPERS_H\n\n/* This file redefines API functions to be called through a wrapper macro, but\nonly for ports that are using the MPU. */\n#ifdef portUSING_MPU_WRAPPERS\n\n/* MPU_WRAPPERS_INCLUDED_FROM_API_FILE will be defined when this file is\n    included from queue.c or task.c to prevent it from having an effect within\n    those files. */\n#ifndef MPU_WRAPPERS_INCLUDED_FROM_API_FILE\n\n/*\n         * Map standard (non MPU) API functions to equivalents that start\n         * \"MPU_\".  This will cause the application code to call the MPU_\n         * version, which wraps the non-MPU version with privilege promoting\n         * then demoting code, so the kernel code always runs will full\n         * privileges.\n         */\n\n/* Map standard tasks.h API functions to the MPU equivalents. */\n#define xTaskCreate                             MPU_xTaskCreate\n#define xTaskCreateStatic                       MPU_xTaskCreateStatic\n#define xTaskCreateRestricted                   MPU_xTaskCreateRestricted\n#define vTaskAllocateMPURegions                 MPU_vTaskAllocateMPURegions\n#define vTaskDelete                             MPU_vTaskDelete\n#define vTaskDelay                              MPU_vTaskDelay\n#define vTaskDelayUntil                         MPU_vTaskDelayUntil\n#define xTaskAbortDelay                         MPU_xTaskAbortDelay\n#define uxTaskPriorityGet                       MPU_uxTaskPriorityGet\n#define eTaskGetState                           MPU_eTaskGetState\n#define vTaskGetInfo                            MPU_vTaskGetInfo\n#define vTaskPrioritySet                        MPU_vTaskPrioritySet\n#define vTaskSuspend                            MPU_vTaskSuspend\n#define vTaskResume                             MPU_vTaskResume\n#define vTaskSuspendAll                         MPU_vTaskSuspendAll\n#define xTaskResumeAll                          MPU_xTaskResumeAll\n#define xTaskGetTickCount                       MPU_xTaskGetTickCount\n#define uxTaskGetNumberOfTasks                  MPU_uxTaskGetNumberOfTasks\n#define pcTaskGetName                           MPU_pcTaskGetName\n#define xTaskGetHandle                          MPU_xTaskGetHandle\n#define uxTaskGetStackHighWaterMark             MPU_uxTaskGetStackHighWaterMark\n#define uxTaskGetStackHighWaterMark2            MPU_uxTaskGetStackHighWaterMark2\n#define vTaskSetApplicationTaskTag              MPU_vTaskSetApplicationTaskTag\n#define xTaskGetApplicationTaskTag              MPU_xTaskGetApplicationTaskTag\n#define vTaskSetThreadLocalStoragePointer       MPU_vTaskSetThreadLocalStoragePointer\n#define pvTaskGetThreadLocalStoragePointer      MPU_pvTaskGetThreadLocalStoragePointer\n#define xTaskCallApplicationTaskHook            MPU_xTaskCallApplicationTaskHook\n#define xTaskGetIdleTaskHandle                  MPU_xTaskGetIdleTaskHandle\n#define uxTaskGetSystemState                    MPU_uxTaskGetSystemState\n#define vTaskList                               MPU_vTaskList\n#define vTaskGetRunTimeStats                    MPU_vTaskGetRunTimeStats\n#define ulTaskGetIdleRunTimeCounter             MPU_ulTaskGetIdleRunTimeCounter\n#define xTaskGenericNotify                      MPU_xTaskGenericNotify\n#define xTaskNotifyWait                         MPU_xTaskNotifyWait\n#define ulTaskNotifyTake                        MPU_ulTaskNotifyTake\n#define xTaskNotifyStateClear                   MPU_xTaskNotifyStateClear\n#define ulTaskNotifyValueClear                  MPU_ulTaskNotifyValueClear\n#define xTaskCatchUpTicks                       MPU_xTaskCatchUpTicks\n\n#define xTaskGetCurrentTaskHandle               MPU_xTaskGetCurrentTaskHandle\n#define vTaskSetTimeOutState                    MPU_vTaskSetTimeOutState\n#define xTaskCheckForTimeOut                    MPU_xTaskCheckForTimeOut\n#define xTaskGetSchedulerState                  MPU_xTaskGetSchedulerState\n\n/* Map standard queue.h API functions to the MPU equivalents. */\n#define xQueueGenericSend                       MPU_xQueueGenericSend\n#define xQueueReceive                           MPU_xQueueReceive\n#define xQueuePeek                              MPU_xQueuePeek\n#define xQueueSemaphoreTake                     MPU_xQueueSemaphoreTake\n#define uxQueueMessagesWaiting                  MPU_uxQueueMessagesWaiting\n#define uxQueueSpacesAvailable                  MPU_uxQueueSpacesAvailable\n#define vQueueDelete                            MPU_vQueueDelete\n#define xQueueCreateMutex                       MPU_xQueueCreateMutex\n#define xQueueCreateMutexStatic                 MPU_xQueueCreateMutexStatic\n#define xQueueCreateCountingSemaphore           MPU_xQueueCreateCountingSemaphore\n#define xQueueCreateCountingSemaphoreStatic     MPU_xQueueCreateCountingSemaphoreStatic\n#define xQueueGetMutexHolder                    MPU_xQueueGetMutexHolder\n#define xQueueTakeMutexRecursive                MPU_xQueueTakeMutexRecursive\n#define xQueueGiveMutexRecursive                MPU_xQueueGiveMutexRecursive\n#define xQueueGenericCreate                     MPU_xQueueGenericCreate\n#define xQueueGenericCreateStatic               MPU_xQueueGenericCreateStatic\n#define xQueueCreateSet                         MPU_xQueueCreateSet\n#define xQueueAddToSet                          MPU_xQueueAddToSet\n#define xQueueRemoveFromSet                     MPU_xQueueRemoveFromSet\n#define xQueueSelectFromSet                     MPU_xQueueSelectFromSet\n#define xQueueGenericReset                      MPU_xQueueGenericReset\n\n#if( configQUEUE_REGISTRY_SIZE &gt; 0 )\n#define vQueueAddToRegistry                     MPU_vQueueAddToRegistry\n#define vQueueUnregisterQueue                   MPU_vQueueUnregisterQueue\n#define pcQueueGetName                          MPU_pcQueueGetName\n#endif\n\n/* Map standard timer.h API functions to the MPU equivalents. */\n#define xTimerCreate                            MPU_xTimerCreate\n#define xTimerCreateStatic                      MPU_xTimerCreateStatic\n#define pvTimerGetTimerID                       MPU_pvTimerGetTimerID\n#define vTimerSetTimerID                        MPU_vTimerSetTimerID\n#define xTimerIsTimerActive                     MPU_xTimerIsTimerActive\n#define xTimerGetTimerDaemonTaskHandle          MPU_xTimerGetTimerDaemonTaskHandle\n#define xTimerPendFunctionCall                  MPU_xTimerPendFunctionCall\n#define pcTimerGetName                          MPU_pcTimerGetName\n#define vTimerSetReloadMode                     MPU_vTimerSetReloadMode\n#define uxTimerGetReloadMode                    MPU_uxTimerGetReloadMode\n#define xTimerGetPeriod                         MPU_xTimerGetPeriod\n#define xTimerGetExpiryTime                     MPU_xTimerGetExpiryTime\n#define xTimerGenericCommand                    MPU_xTimerGenericCommand\n\n/* Map standard event_group.h API functions to the MPU equivalents. */\n#define xEventGroupCreate                       MPU_xEventGroupCreate\n#define xEventGroupCreateStatic                 MPU_xEventGroupCreateStatic\n#define xEventGroupWaitBits                     MPU_xEventGroupWaitBits\n#define xEventGroupClearBits                    MPU_xEventGroupClearBits\n#define xEventGroupSetBits                      MPU_xEventGroupSetBits\n#define xEventGroupSync                         MPU_xEventGroupSync\n#define vEventGroupDelete                       MPU_vEventGroupDelete\n\n/* Map standard message/stream_buffer.h API functions to the MPU\n        equivalents. */\n#define xStreamBufferSend                       MPU_xStreamBufferSend\n#define xStreamBufferReceive                    MPU_xStreamBufferReceive\n#define xStreamBufferNextMessageLengthBytes     MPU_xStreamBufferNextMessageLengthBytes\n#define vStreamBufferDelete                     MPU_vStreamBufferDelete\n#define xStreamBufferIsFull                     MPU_xStreamBufferIsFull\n#define xStreamBufferIsEmpty                    MPU_xStreamBufferIsEmpty\n#define xStreamBufferReset                      MPU_xStreamBufferReset\n#define xStreamBufferSpacesAvailable            MPU_xStreamBufferSpacesAvailable\n#define xStreamBufferBytesAvailable             MPU_xStreamBufferBytesAvailable\n#define xStreamBufferSetTriggerLevel            MPU_xStreamBufferSetTriggerLevel\n#define xStreamBufferGenericCreate              MPU_xStreamBufferGenericCreate\n#define xStreamBufferGenericCreateStatic        MPU_xStreamBufferGenericCreateStatic\n\n\n/* Remove the privileged function macro, but keep the PRIVILEGED_DATA\n        macro so applications can place data in privileged access sections\n        (useful when using statically allocated objects). */\n#define PRIVILEGED_FUNCTION\n#define PRIVILEGED_DATA __attribute__((section(\"privileged_data\")))\n#define FREERTOS_SYSTEM_CALL\n\n#else /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */\n\n/* Ensure API functions go in the privileged execution section. */\n#define PRIVILEGED_FUNCTION __attribute__((section(\"privileged_functions\")))\n#define PRIVILEGED_DATA __attribute__((section(\"privileged_data\")))\n#define FREERTOS_SYSTEM_CALL __attribute__((section( \"freertos_system_calls\")))\n\n#endif /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */\n\n#else /* portUSING_MPU_WRAPPERS */\n\n#define PRIVILEGED_FUNCTION\n#define PRIVILEGED_DATA\n#define FREERTOS_SYSTEM_CALL\n#define portUSING_MPU_WRAPPERS 0\n\n#endif /* portUSING_MPU_WRAPPERS */\n\n\n#endif /* MPU_WRAPPERS_H */\n</code></pre>"},{"location":"apiStm/portable_8h/","title":"File portable.h","text":"<p>FileList &gt; FreeRTOS &gt; include &gt; portable.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"deprecated_definitions.h\"</code></li> <li><code>#include \"portmacro.h\"</code></li> <li><code>#include \"mpu_wrappers.h\"</code></li> </ul>"},{"location":"apiStm/portable_8h/#classes","title":"Classes","text":"Type Name struct HeapRegion struct xHeapStats"},{"location":"apiStm/portable_8h/#public-types","title":"Public Types","text":"Type Name typedef struct HeapRegion HeapRegion_t typedef struct xHeapStats HeapStats_t"},{"location":"apiStm/portable_8h/#public-functions","title":"Public Functions","text":"Type Name void * pvPortMalloc (size_t xSize)  StackType_t * pxPortInitialiseStack (StackType_t * pxTopOfStack, TaskFunction_t pxCode, void * pvParameters)  void vPortDefineHeapRegions (const HeapRegion_t *const pxHeapRegions)  void vPortEndScheduler (void)  void vPortFree (void * pv)  void vPortGetHeapStats (HeapStats_t * pxHeapStats)  void vPortInitialiseBlocks (void)  size_t xPortGetFreeHeapSize (void)  size_t xPortGetMinimumEverFreeHeapSize (void)  BaseType_t xPortStartScheduler (void)"},{"location":"apiStm/portable_8h/#macros","title":"Macros","text":"Type Name define portARCH_NAME  NULL define portHAS_STACK_OVERFLOW_CHECKING  0 define portNUM_CONFIGURABLE_REGIONS  1"},{"location":"apiStm/portable_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/portable_8h/#typedef-heapregion_t","title":"typedef HeapRegion_t","text":"<pre><code>typedef struct HeapRegion HeapRegion_t;\n</code></pre>"},{"location":"apiStm/portable_8h/#typedef-heapstats_t","title":"typedef HeapStats_t","text":"<pre><code>typedef struct xHeapStats HeapStats_t;\n</code></pre>"},{"location":"apiStm/portable_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/portable_8h/#function-pvportmalloc","title":"function pvPortMalloc","text":"<pre><code>void * pvPortMalloc (\nsize_t xSize\n) </code></pre>"},{"location":"apiStm/portable_8h/#function-pxportinitialisestack","title":"function pxPortInitialiseStack","text":"<pre><code>StackType_t * pxPortInitialiseStack (\nStackType_t * pxTopOfStack,\nTaskFunction_t pxCode,\nvoid * pvParameters\n) </code></pre>"},{"location":"apiStm/portable_8h/#function-vportdefineheapregions","title":"function vPortDefineHeapRegions","text":"<pre><code>void vPortDefineHeapRegions (\nconst HeapRegion_t *const pxHeapRegions\n) </code></pre>"},{"location":"apiStm/portable_8h/#function-vportendscheduler","title":"function vPortEndScheduler","text":"<pre><code>void vPortEndScheduler (\nvoid\n) </code></pre>"},{"location":"apiStm/portable_8h/#function-vportfree","title":"function vPortFree","text":"<pre><code>void vPortFree (\nvoid * pv\n) </code></pre>"},{"location":"apiStm/portable_8h/#function-vportgetheapstats","title":"function vPortGetHeapStats","text":"<pre><code>void vPortGetHeapStats (\nHeapStats_t * pxHeapStats\n) </code></pre>"},{"location":"apiStm/portable_8h/#function-vportinitialiseblocks","title":"function vPortInitialiseBlocks","text":"<pre><code>void vPortInitialiseBlocks (\nvoid\n) </code></pre>"},{"location":"apiStm/portable_8h/#function-xportgetfreeheapsize","title":"function xPortGetFreeHeapSize","text":"<pre><code>size_t xPortGetFreeHeapSize (\nvoid\n) </code></pre>"},{"location":"apiStm/portable_8h/#function-xportgetminimumeverfreeheapsize","title":"function xPortGetMinimumEverFreeHeapSize","text":"<pre><code>size_t xPortGetMinimumEverFreeHeapSize (\nvoid\n) </code></pre>"},{"location":"apiStm/portable_8h/#function-xportstartscheduler","title":"function xPortStartScheduler","text":"<pre><code>BaseType_t xPortStartScheduler (\nvoid\n) </code></pre>"},{"location":"apiStm/portable_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/portable_8h/#define-portarch_name","title":"define portARCH_NAME","text":"<pre><code>#define portARCH_NAME NULL\n</code></pre>"},{"location":"apiStm/portable_8h/#define-porthas_stack_overflow_checking","title":"define portHAS_STACK_OVERFLOW_CHECKING","text":"<pre><code>#define portHAS_STACK_OVERFLOW_CHECKING 0\n</code></pre>"},{"location":"apiStm/portable_8h/#define-portnum_configurable_regions","title":"define portNUM_CONFIGURABLE_REGIONS","text":"<pre><code>#define portNUM_CONFIGURABLE_REGIONS 1\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/portable.h</code></p>"},{"location":"apiStm/portable_8h_source/","title":"File portable.h","text":"<p>File List &gt; FreeRTOS &gt; include &gt; portable.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n/*-----------------------------------------------------------\n * Portable layer API.  Each function must be defined for each port.\n *----------------------------------------------------------*/\n\n#ifndef PORTABLE_H\n#define PORTABLE_H\n\n/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a\npre-processor definition was used to ensure the pre-processor found the correct\nportmacro.h file for the port being used.  That scheme was deprecated in favour\nof setting the compiler's include path such that it found the correct\nportmacro.h file - removing the need for the constant and allowing the\nportmacro.h file to be located anywhere in relation to the port being used.\nPurely for reasons of backward compatibility the old method is still valid, but\nto make it clear that new projects should not use it, support for the port\nspecific constants has been moved into the deprecated_definitions.h header\nfile. */\n#include \"deprecated_definitions.h\"\n\n/* If portENTER_CRITICAL is not defined then including deprecated_definitions.h\ndid not result in a portmacro.h header file being included - and it should be\nincluded here.  In this case the path to the correct portmacro.h header file\nmust be set in the compiler's include path. */\n#ifndef portENTER_CRITICAL\n#include \"portmacro.h\"\n#endif\n\n#if portBYTE_ALIGNMENT == 32\n#define portBYTE_ALIGNMENT_MASK ( 0x001f )\n#endif\n\n#if portBYTE_ALIGNMENT == 16\n#define portBYTE_ALIGNMENT_MASK ( 0x000f )\n#endif\n\n#if portBYTE_ALIGNMENT == 8\n#define portBYTE_ALIGNMENT_MASK ( 0x0007 )\n#endif\n\n#if portBYTE_ALIGNMENT == 4\n#define portBYTE_ALIGNMENT_MASK ( 0x0003 )\n#endif\n\n#if portBYTE_ALIGNMENT == 2\n#define portBYTE_ALIGNMENT_MASK ( 0x0001 )\n#endif\n\n#if portBYTE_ALIGNMENT == 1\n#define portBYTE_ALIGNMENT_MASK ( 0x0000 )\n#endif\n\n#ifndef portBYTE_ALIGNMENT_MASK\n#error \"Invalid portBYTE_ALIGNMENT definition\"\n#endif\n\n#ifndef portNUM_CONFIGURABLE_REGIONS\n#define portNUM_CONFIGURABLE_REGIONS 1\n#endif\n\n#ifndef portHAS_STACK_OVERFLOW_CHECKING\n#define portHAS_STACK_OVERFLOW_CHECKING 0\n#endif\n\n#ifndef portARCH_NAME\n#define portARCH_NAME NULL\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"mpu_wrappers.h\"\n\n/*\n * Setup the stack of a new task so it is ready to be placed under the\n * scheduler control.  The registers have to be placed on the stack in\n * the order that the port expects to find them.\n *\n */\n#if( portUSING_MPU_WRAPPERS == 1 )\n#if( portHAS_STACK_OVERFLOW_CHECKING == 1 )\nStackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, StackType_t *pxEndOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) PRIVILEGED_FUNCTION;\n#else\nStackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) PRIVILEGED_FUNCTION;\n#endif\n#else\n#if( portHAS_STACK_OVERFLOW_CHECKING == 1 )\nStackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, StackType_t *pxEndOfStack, TaskFunction_t pxCode, void *pvParameters ) PRIVILEGED_FUNCTION;\n#else\nStackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) PRIVILEGED_FUNCTION;\n#endif\n#endif\n\n/* Used by heap_5.c to define the start address and size of each memory region\nthat together comprise the total FreeRTOS heap space. */\ntypedef struct HeapRegion\n{\nuint8_t *pucStartAddress;\nsize_t xSizeInBytes;\n} HeapRegion_t;\n\n/* Used to pass information about the heap out of vPortGetHeapStats(). */\ntypedef struct xHeapStats\n{\nsize_t xAvailableHeapSpaceInBytes;      /* The total heap size currently available - this is the sum of all the free blocks, not the largest block that can be allocated. */\nsize_t xSizeOfLargestFreeBlockInBytes;  /* The maximum size, in bytes, of all the free blocks within the heap at the time vPortGetHeapStats() is called. */\nsize_t xSizeOfSmallestFreeBlockInBytes; /* The minimum size, in bytes, of all the free blocks within the heap at the time vPortGetHeapStats() is called. */\nsize_t xNumberOfFreeBlocks;             /* The number of free memory blocks within the heap at the time vPortGetHeapStats() is called. */\nsize_t xMinimumEverFreeBytesRemaining;  /* The minimum amount of total free memory (sum of all free blocks) there has been in the heap since the system booted. */\nsize_t xNumberOfSuccessfulAllocations;  /* The number of calls to pvPortMalloc() that have returned a valid memory block. */\nsize_t xNumberOfSuccessfulFrees;        /* The number of calls to vPortFree() that has successfully freed a block of memory. */\n} HeapStats_t;\n\n/*\n * Used to define multiple heap regions for use by heap_5.c.  This function\n * must be called before any calls to pvPortMalloc() - not creating a task,\n * queue, semaphore, mutex, software timer, event group, etc. will result in\n * pvPortMalloc being called.\n *\n * pxHeapRegions passes in an array of HeapRegion_t structures - each of which\n * defines a region of memory that can be used as the heap.  The array is\n * terminated by a HeapRegions_t structure that has a size of 0.  The region\n * with the lowest start address must appear first in the array.\n */\nvoid vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) PRIVILEGED_FUNCTION;\n\n/*\n * Returns a HeapStats_t structure filled with information about the current\n * heap state.\n */\nvoid vPortGetHeapStats( HeapStats_t *pxHeapStats );\n\n/*\n * Map to the memory management routines required for the port.\n */\nvoid *pvPortMalloc( size_t xSize ) PRIVILEGED_FUNCTION;\nvoid vPortFree( void *pv ) PRIVILEGED_FUNCTION;\nvoid vPortInitialiseBlocks( void ) PRIVILEGED_FUNCTION;\nsize_t xPortGetFreeHeapSize( void ) PRIVILEGED_FUNCTION;\nsize_t xPortGetMinimumEverFreeHeapSize( void ) PRIVILEGED_FUNCTION;\n\n/*\n * Setup the hardware ready for the scheduler to take control.  This generally\n * sets up a tick interrupt and sets timers for the correct tick frequency.\n */\nBaseType_t xPortStartScheduler( void ) PRIVILEGED_FUNCTION;\n\n/*\n * Undo any hardware/ISR setup that was performed by xPortStartScheduler() so\n * the hardware is left in its original condition after the scheduler stops\n * executing.\n */\nvoid vPortEndScheduler( void ) PRIVILEGED_FUNCTION;\n\n/*\n * The structures and methods of manipulating the MPU are contained within the\n * port layer.\n *\n * Fills the xMPUSettings structure with the memory region information\n * contained in xRegions.\n */\n#if( portUSING_MPU_WRAPPERS == 1 )\nstruct xMEMORY_REGION;\nvoid vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth ) PRIVILEGED_FUNCTION;\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* PORTABLE_H */\n</code></pre>"},{"location":"apiStm/projdefs_8h/","title":"File projdefs.h","text":"<p>FileList &gt; FreeRTOS &gt; include &gt; projdefs.h</p> <p>Go to the source code of this file.</p>"},{"location":"apiStm/projdefs_8h/#public-types","title":"Public Types","text":"Type Name typedef void(* TaskFunction_t"},{"location":"apiStm/projdefs_8h/#macros","title":"Macros","text":"Type Name define configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES  0 define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY  ( -1 ) define errQUEUE_BLOCKED  ( -4 ) define errQUEUE_EMPTY  ( ( BaseType_t ) 0 ) define errQUEUE_FULL  ( ( BaseType_t ) 0 ) define errQUEUE_YIELD  ( -5 ) define pdBIG_ENDIAN  pdFREERTOS_BIG_ENDIAN define pdFAIL  ( pdFALSE ) define pdFALSE  ( ( BaseType_t ) 0 ) define pdFREERTOS_BIG_ENDIAN  1 define pdFREERTOS_ERRNO_EACCES  13  /* Permission denied */ define pdFREERTOS_ERRNO_EADDRINUSE  112 /* Address already in use */ define pdFREERTOS_ERRNO_EADDRNOTAVAIL  125   /* Address not available */ define pdFREERTOS_ERRNO_EAGAIN  11  /* No more processes */ define pdFREERTOS_ERRNO_EALREADY  120 /* Socket already connected */ define pdFREERTOS_ERRNO_EBADE  50    /* Invalid exchange */ define pdFREERTOS_ERRNO_EBADF  9 /* Bad file number */ define pdFREERTOS_ERRNO_EBUSY  16    /* Mount device busy */ define pdFREERTOS_ERRNO_ECANCELED  140   /* Operation canceled. */ define pdFREERTOS_ERRNO_EEXIST  17  /* File exists */ define pdFREERTOS_ERRNO_EFAULT  14  /* Bad address */ define pdFREERTOS_ERRNO_EFTYPE  79  /* Inappropriate file type or format */ define pdFREERTOS_ERRNO_EILSEQ  138 /* An invalid UTF-16 sequence was encountered. */ define pdFREERTOS_ERRNO_EINPROGRESS  119   /* Connection already in progress */ define pdFREERTOS_ERRNO_EINTR  4 /* Interrupted system call */ define pdFREERTOS_ERRNO_EINVAL  22  /* Invalid argument */ define pdFREERTOS_ERRNO_EIO  5 /* I/O error */ define pdFREERTOS_ERRNO_EISCONN  127   /* Socket is already connected */ define pdFREERTOS_ERRNO_EISDIR  21  /* Is a directory */ define pdFREERTOS_ERRNO_ENAMETOOLONG  91  /* File or path name too long */ define pdFREERTOS_ERRNO_ENMFILE  89    /* No more files */ define pdFREERTOS_ERRNO_ENOBUFS  105   /* No buffer space available */ define pdFREERTOS_ERRNO_ENODEV  19  /* No such device */ define pdFREERTOS_ERRNO_ENOENT  2   /* No such file or directory */ define pdFREERTOS_ERRNO_ENOMEDIUM  135   /* No medium inserted */ define pdFREERTOS_ERRNO_ENOMEM  12  /* Not enough memory */ define pdFREERTOS_ERRNO_ENOPROTOOPT  109   /* Protocol not available */ define pdFREERTOS_ERRNO_ENOSPC  28  /* No space left on device */ define pdFREERTOS_ERRNO_ENOTCONN  128 /* Socket is not connected */ define pdFREERTOS_ERRNO_ENOTDIR  20    /* Not a directory */ define pdFREERTOS_ERRNO_ENOTEMPTY  90    /* Directory not empty */ define pdFREERTOS_ERRNO_ENXIO  6 /* No such device or address */ define pdFREERTOS_ERRNO_EOPNOTSUPP  95  /* Operation not supported on transport endpoint */ define pdFREERTOS_ERRNO_EROFS  30    /* Read only file system */ define pdFREERTOS_ERRNO_ESPIPE  29  /* Illegal seek */ define pdFREERTOS_ERRNO_ETIMEDOUT  116   /* Connection timed out */ define pdFREERTOS_ERRNO_EUNATCH  42    /* Protocol driver not attached */ define pdFREERTOS_ERRNO_EWOULDBLOCK  11    /* Operation would block */ define pdFREERTOS_ERRNO_EXDEV  18    /* Cross-device link */ define pdFREERTOS_ERRNO_NONE  0   /* No errors */ define pdFREERTOS_LITTLE_ENDIAN  0 define pdINTEGRITY_CHECK_VALUE  0x5a5a5a5aUL define pdLITTLE_ENDIAN  pdFREERTOS_LITTLE_ENDIAN define pdMS_TO_TICKS (xTimeInMs) ( ( TickType_t ) ( ( ( TickType_t ) ( xTimeInMs ) * ( TickType_t ) configTICK_RATE_HZ ) / ( TickType_t ) 1000 ) ) define pdPASS  ( pdTRUE ) define pdTRUE  ( ( BaseType_t ) 1 )"},{"location":"apiStm/projdefs_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/projdefs_8h/#typedef-taskfunction_t","title":"typedef TaskFunction_t","text":"<pre><code>typedef void(* TaskFunction_t) (void *);\n</code></pre>"},{"location":"apiStm/projdefs_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/projdefs_8h/#define-configuse_list_data_integrity_check_bytes","title":"define configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES","text":"<pre><code>#define configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES 0\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-errcould_not_allocate_required_memory","title":"define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY","text":"<pre><code>#define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY ( -1 )\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-errqueue_blocked","title":"define errQUEUE_BLOCKED","text":"<pre><code>#define errQUEUE_BLOCKED ( -4 )\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-errqueue_empty","title":"define errQUEUE_EMPTY","text":"<pre><code>#define errQUEUE_EMPTY ( ( BaseType_t ) 0 )\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-errqueue_full","title":"define errQUEUE_FULL","text":"<pre><code>#define errQUEUE_FULL ( ( BaseType_t ) 0 )\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-errqueue_yield","title":"define errQUEUE_YIELD","text":"<pre><code>#define errQUEUE_YIELD ( -5 )\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdbig_endian","title":"define pdBIG_ENDIAN","text":"<pre><code>#define pdBIG_ENDIAN pdFREERTOS_BIG_ENDIAN\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfail","title":"define pdFAIL","text":"<pre><code>#define pdFAIL ( pdFALSE )\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfalse","title":"define pdFALSE","text":"<pre><code>#define pdFALSE ( ( BaseType_t ) 0 )\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_big_endian","title":"define pdFREERTOS_BIG_ENDIAN","text":"<pre><code>#define pdFREERTOS_BIG_ENDIAN 1\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_eacces","title":"define pdFREERTOS_ERRNO_EACCES","text":"<pre><code>#define pdFREERTOS_ERRNO_EACCES 13  /* Permission denied */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_eaddrinuse","title":"define pdFREERTOS_ERRNO_EADDRINUSE","text":"<pre><code>#define pdFREERTOS_ERRNO_EADDRINUSE 112 /* Address already in use */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_eaddrnotavail","title":"define pdFREERTOS_ERRNO_EADDRNOTAVAIL","text":"<pre><code>#define pdFREERTOS_ERRNO_EADDRNOTAVAIL 125  /* Address not available */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_eagain","title":"define pdFREERTOS_ERRNO_EAGAIN","text":"<pre><code>#define pdFREERTOS_ERRNO_EAGAIN 11  /* No more processes */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_ealready","title":"define pdFREERTOS_ERRNO_EALREADY","text":"<pre><code>#define pdFREERTOS_ERRNO_EALREADY 120   /* Socket already connected */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_ebade","title":"define pdFREERTOS_ERRNO_EBADE","text":"<pre><code>#define pdFREERTOS_ERRNO_EBADE 50   /* Invalid exchange */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_ebadf","title":"define pdFREERTOS_ERRNO_EBADF","text":"<pre><code>#define pdFREERTOS_ERRNO_EBADF 9    /* Bad file number */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_ebusy","title":"define pdFREERTOS_ERRNO_EBUSY","text":"<pre><code>#define pdFREERTOS_ERRNO_EBUSY 16   /* Mount device busy */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_ecanceled","title":"define pdFREERTOS_ERRNO_ECANCELED","text":"<pre><code>#define pdFREERTOS_ERRNO_ECANCELED 140  /* Operation canceled. */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_eexist","title":"define pdFREERTOS_ERRNO_EEXIST","text":"<pre><code>#define pdFREERTOS_ERRNO_EEXIST 17  /* File exists */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_efault","title":"define pdFREERTOS_ERRNO_EFAULT","text":"<pre><code>#define pdFREERTOS_ERRNO_EFAULT 14  /* Bad address */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_eftype","title":"define pdFREERTOS_ERRNO_EFTYPE","text":"<pre><code>#define pdFREERTOS_ERRNO_EFTYPE 79  /* Inappropriate file type or format */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_eilseq","title":"define pdFREERTOS_ERRNO_EILSEQ","text":"<pre><code>#define pdFREERTOS_ERRNO_EILSEQ 138 /* An invalid UTF-16 sequence was encountered. */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_einprogress","title":"define pdFREERTOS_ERRNO_EINPROGRESS","text":"<pre><code>#define pdFREERTOS_ERRNO_EINPROGRESS 119    /* Connection already in progress */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_eintr","title":"define pdFREERTOS_ERRNO_EINTR","text":"<pre><code>#define pdFREERTOS_ERRNO_EINTR 4    /* Interrupted system call */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_einval","title":"define pdFREERTOS_ERRNO_EINVAL","text":"<pre><code>#define pdFREERTOS_ERRNO_EINVAL 22  /* Invalid argument */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_eio","title":"define pdFREERTOS_ERRNO_EIO","text":"<pre><code>#define pdFREERTOS_ERRNO_EIO 5  /* I/O error */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_eisconn","title":"define pdFREERTOS_ERRNO_EISCONN","text":"<pre><code>#define pdFREERTOS_ERRNO_EISCONN 127    /* Socket is already connected */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_eisdir","title":"define pdFREERTOS_ERRNO_EISDIR","text":"<pre><code>#define pdFREERTOS_ERRNO_EISDIR 21  /* Is a directory */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_enametoolong","title":"define pdFREERTOS_ERRNO_ENAMETOOLONG","text":"<pre><code>#define pdFREERTOS_ERRNO_ENAMETOOLONG 91    /* File or path name too long */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_enmfile","title":"define pdFREERTOS_ERRNO_ENMFILE","text":"<pre><code>#define pdFREERTOS_ERRNO_ENMFILE 89 /* No more files */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_enobufs","title":"define pdFREERTOS_ERRNO_ENOBUFS","text":"<pre><code>#define pdFREERTOS_ERRNO_ENOBUFS 105    /* No buffer space available */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_enodev","title":"define pdFREERTOS_ERRNO_ENODEV","text":"<pre><code>#define pdFREERTOS_ERRNO_ENODEV 19  /* No such device */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_enoent","title":"define pdFREERTOS_ERRNO_ENOENT","text":"<pre><code>#define pdFREERTOS_ERRNO_ENOENT 2   /* No such file or directory */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_enomedium","title":"define pdFREERTOS_ERRNO_ENOMEDIUM","text":"<pre><code>#define pdFREERTOS_ERRNO_ENOMEDIUM 135  /* No medium inserted */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_enomem","title":"define pdFREERTOS_ERRNO_ENOMEM","text":"<pre><code>#define pdFREERTOS_ERRNO_ENOMEM 12  /* Not enough memory */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_enoprotoopt","title":"define pdFREERTOS_ERRNO_ENOPROTOOPT","text":"<pre><code>#define pdFREERTOS_ERRNO_ENOPROTOOPT 109    /* Protocol not available */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_enospc","title":"define pdFREERTOS_ERRNO_ENOSPC","text":"<pre><code>#define pdFREERTOS_ERRNO_ENOSPC 28  /* No space left on device */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_enotconn","title":"define pdFREERTOS_ERRNO_ENOTCONN","text":"<pre><code>#define pdFREERTOS_ERRNO_ENOTCONN 128   /* Socket is not connected */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_enotdir","title":"define pdFREERTOS_ERRNO_ENOTDIR","text":"<pre><code>#define pdFREERTOS_ERRNO_ENOTDIR 20 /* Not a directory */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_enotempty","title":"define pdFREERTOS_ERRNO_ENOTEMPTY","text":"<pre><code>#define pdFREERTOS_ERRNO_ENOTEMPTY 90   /* Directory not empty */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_enxio","title":"define pdFREERTOS_ERRNO_ENXIO","text":"<pre><code>#define pdFREERTOS_ERRNO_ENXIO 6    /* No such device or address */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_eopnotsupp","title":"define pdFREERTOS_ERRNO_EOPNOTSUPP","text":"<pre><code>#define pdFREERTOS_ERRNO_EOPNOTSUPP 95  /* Operation not supported on transport endpoint */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_erofs","title":"define pdFREERTOS_ERRNO_EROFS","text":"<pre><code>#define pdFREERTOS_ERRNO_EROFS 30   /* Read only file system */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_espipe","title":"define pdFREERTOS_ERRNO_ESPIPE","text":"<pre><code>#define pdFREERTOS_ERRNO_ESPIPE 29  /* Illegal seek */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_etimedout","title":"define pdFREERTOS_ERRNO_ETIMEDOUT","text":"<pre><code>#define pdFREERTOS_ERRNO_ETIMEDOUT 116  /* Connection timed out */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_eunatch","title":"define pdFREERTOS_ERRNO_EUNATCH","text":"<pre><code>#define pdFREERTOS_ERRNO_EUNATCH 42 /* Protocol driver not attached */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_ewouldblock","title":"define pdFREERTOS_ERRNO_EWOULDBLOCK","text":"<pre><code>#define pdFREERTOS_ERRNO_EWOULDBLOCK 11 /* Operation would block */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_exdev","title":"define pdFREERTOS_ERRNO_EXDEV","text":"<pre><code>#define pdFREERTOS_ERRNO_EXDEV 18   /* Cross-device link */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_errno_none","title":"define pdFREERTOS_ERRNO_NONE","text":"<pre><code>#define pdFREERTOS_ERRNO_NONE 0 /* No errors */\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdfreertos_little_endian","title":"define pdFREERTOS_LITTLE_ENDIAN","text":"<pre><code>#define pdFREERTOS_LITTLE_ENDIAN 0\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdintegrity_check_value","title":"define pdINTEGRITY_CHECK_VALUE","text":"<pre><code>#define pdINTEGRITY_CHECK_VALUE 0x5a5a5a5aUL\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdlittle_endian","title":"define pdLITTLE_ENDIAN","text":"<pre><code>#define pdLITTLE_ENDIAN pdFREERTOS_LITTLE_ENDIAN\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdms_to_ticks","title":"define pdMS_TO_TICKS","text":"<pre><code>#define pdMS_TO_TICKS (\nxTimeInMs\n) ( ( TickType_t ) ( ( ( TickType_t ) ( xTimeInMs ) * ( TickType_t ) configTICK_RATE_HZ ) / ( TickType_t ) 1000 ) )\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdpass","title":"define pdPASS","text":"<pre><code>#define pdPASS ( pdTRUE )\n</code></pre>"},{"location":"apiStm/projdefs_8h/#define-pdtrue","title":"define pdTRUE","text":"<pre><code>#define pdTRUE ( ( BaseType_t ) 1 )\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/projdefs.h</code></p>"},{"location":"apiStm/projdefs_8h_source/","title":"File projdefs.h","text":"<p>File List &gt; FreeRTOS &gt; include &gt; projdefs.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n#ifndef PROJDEFS_H\n#define PROJDEFS_H\n\n/*\n * Defines the prototype to which task functions must conform.  Defined in this\n * file to ensure the type is known before portable.h is included.\n */\ntypedef void (*TaskFunction_t)( void * );\n\n/* Converts a time in milliseconds to a time in ticks.  This macro can be\noverridden by a macro of the same name defined in FreeRTOSConfig.h in case the\ndefinition here is not suitable for your application. */\n#ifndef pdMS_TO_TICKS\n#define pdMS_TO_TICKS( xTimeInMs ) ( ( TickType_t ) ( ( ( TickType_t ) ( xTimeInMs ) * ( TickType_t ) configTICK_RATE_HZ ) / ( TickType_t ) 1000 ) )\n#endif\n\n#define pdFALSE         ( ( BaseType_t ) 0 )\n#define pdTRUE          ( ( BaseType_t ) 1 )\n\n#define pdPASS          ( pdTRUE )\n#define pdFAIL          ( pdFALSE )\n#define errQUEUE_EMPTY  ( ( BaseType_t ) 0 )\n#define errQUEUE_FULL   ( ( BaseType_t ) 0 )\n\n/* FreeRTOS error definitions. */\n#define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY   ( -1 )\n#define errQUEUE_BLOCKED                        ( -4 )\n#define errQUEUE_YIELD                          ( -5 )\n\n/* Macros used for basic data corruption checks. */\n#ifndef configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES\n#define configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES 0\n#endif\n\n#if( configUSE_16_BIT_TICKS == 1 )\n#define pdINTEGRITY_CHECK_VALUE 0x5a5a\n#else\n#define pdINTEGRITY_CHECK_VALUE 0x5a5a5a5aUL\n#endif\n\n/* The following errno values are used by FreeRTOS+ components, not FreeRTOS\nitself. */\n#define pdFREERTOS_ERRNO_NONE           0   /* No errors */\n#define pdFREERTOS_ERRNO_ENOENT         2   /* No such file or directory */\n#define pdFREERTOS_ERRNO_EINTR          4   /* Interrupted system call */\n#define pdFREERTOS_ERRNO_EIO            5   /* I/O error */\n#define pdFREERTOS_ERRNO_ENXIO          6   /* No such device or address */\n#define pdFREERTOS_ERRNO_EBADF          9   /* Bad file number */\n#define pdFREERTOS_ERRNO_EAGAIN         11  /* No more processes */\n#define pdFREERTOS_ERRNO_EWOULDBLOCK    11  /* Operation would block */\n#define pdFREERTOS_ERRNO_ENOMEM         12  /* Not enough memory */\n#define pdFREERTOS_ERRNO_EACCES         13  /* Permission denied */\n#define pdFREERTOS_ERRNO_EFAULT         14  /* Bad address */\n#define pdFREERTOS_ERRNO_EBUSY          16  /* Mount device busy */\n#define pdFREERTOS_ERRNO_EEXIST         17  /* File exists */\n#define pdFREERTOS_ERRNO_EXDEV          18  /* Cross-device link */\n#define pdFREERTOS_ERRNO_ENODEV         19  /* No such device */\n#define pdFREERTOS_ERRNO_ENOTDIR        20  /* Not a directory */\n#define pdFREERTOS_ERRNO_EISDIR         21  /* Is a directory */\n#define pdFREERTOS_ERRNO_EINVAL         22  /* Invalid argument */\n#define pdFREERTOS_ERRNO_ENOSPC         28  /* No space left on device */\n#define pdFREERTOS_ERRNO_ESPIPE         29  /* Illegal seek */\n#define pdFREERTOS_ERRNO_EROFS          30  /* Read only file system */\n#define pdFREERTOS_ERRNO_EUNATCH        42  /* Protocol driver not attached */\n#define pdFREERTOS_ERRNO_EBADE          50  /* Invalid exchange */\n#define pdFREERTOS_ERRNO_EFTYPE         79  /* Inappropriate file type or format */\n#define pdFREERTOS_ERRNO_ENMFILE        89  /* No more files */\n#define pdFREERTOS_ERRNO_ENOTEMPTY      90  /* Directory not empty */\n#define pdFREERTOS_ERRNO_ENAMETOOLONG   91  /* File or path name too long */\n#define pdFREERTOS_ERRNO_EOPNOTSUPP     95  /* Operation not supported on transport endpoint */\n#define pdFREERTOS_ERRNO_ENOBUFS        105 /* No buffer space available */\n#define pdFREERTOS_ERRNO_ENOPROTOOPT    109 /* Protocol not available */\n#define pdFREERTOS_ERRNO_EADDRINUSE     112 /* Address already in use */\n#define pdFREERTOS_ERRNO_ETIMEDOUT      116 /* Connection timed out */\n#define pdFREERTOS_ERRNO_EINPROGRESS    119 /* Connection already in progress */\n#define pdFREERTOS_ERRNO_EALREADY       120 /* Socket already connected */\n#define pdFREERTOS_ERRNO_EADDRNOTAVAIL  125 /* Address not available */\n#define pdFREERTOS_ERRNO_EISCONN        127 /* Socket is already connected */\n#define pdFREERTOS_ERRNO_ENOTCONN       128 /* Socket is not connected */\n#define pdFREERTOS_ERRNO_ENOMEDIUM      135 /* No medium inserted */\n#define pdFREERTOS_ERRNO_EILSEQ         138 /* An invalid UTF-16 sequence was encountered. */\n#define pdFREERTOS_ERRNO_ECANCELED      140 /* Operation canceled. */\n\n/* The following endian values are used by FreeRTOS+ components, not FreeRTOS\nitself. */\n#define pdFREERTOS_LITTLE_ENDIAN        0\n#define pdFREERTOS_BIG_ENDIAN           1\n\n/* Re-defining endian values for generic naming. */\n#define pdLITTLE_ENDIAN                 pdFREERTOS_LITTLE_ENDIAN\n#define pdBIG_ENDIAN                    pdFREERTOS_BIG_ENDIAN\n\n\n#endif /* PROJDEFS_H */\n</code></pre>"},{"location":"apiStm/queue_8h/","title":"File queue.h","text":"<p>FileList &gt; FreeRTOS &gt; include &gt; queue.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"task.h\"</code></li> </ul>"},{"location":"apiStm/queue_8h/#public-types","title":"Public Types","text":"Type Name typedef struct QueueDefinition * QueueHandle_t typedef struct QueueDefinition * QueueSetHandle_t typedef struct QueueDefinition * QueueSetMemberHandle_t"},{"location":"apiStm/queue_8h/#public-functions","title":"Public Functions","text":"Type Name uint8_t ucQueueGetQueueType (QueueHandle_t xQueue)  UBaseType_t uxQueueGetQueueNumber (QueueHandle_t xQueue)  UBaseType_t uxQueueMessagesWaiting (const QueueHandle_t xQueue)  UBaseType_t uxQueueMessagesWaitingFromISR (const QueueHandle_t xQueue)  UBaseType_t uxQueueSpacesAvailable (const QueueHandle_t xQueue)  void vQueueDelete (QueueHandle_t xQueue)  void vQueueSetQueueNumber (QueueHandle_t xQueue, UBaseType_t uxQueueNumber)  void vQueueWaitForMessageRestricted (QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely)  BaseType_t xQueueAddToSet (QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet)  BaseType_t xQueueCRReceive (QueueHandle_t xQueue, void * pvBuffer, TickType_t xTicksToWait)  BaseType_t xQueueCRReceiveFromISR (QueueHandle_t xQueue, void * pvBuffer, BaseType_t * pxTaskWoken)  BaseType_t xQueueCRSend (QueueHandle_t xQueue, const void * pvItemToQueue, TickType_t xTicksToWait)  BaseType_t xQueueCRSendFromISR (QueueHandle_t xQueue, const void * pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken)  QueueHandle_t xQueueCreateCountingSemaphore (const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount)  QueueHandle_t xQueueCreateCountingSemaphoreStatic (const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t * pxStaticQueue)  QueueHandle_t xQueueCreateMutex (const uint8_t ucQueueType)  QueueHandle_t xQueueCreateMutexStatic (const uint8_t ucQueueType, StaticQueue_t * pxStaticQueue)  QueueSetHandle_t xQueueCreateSet (const UBaseType_t uxEventQueueLength)  BaseType_t xQueueGenericReset (QueueHandle_t xQueue, BaseType_t xNewQueue)  BaseType_t xQueueGenericSend (QueueHandle_t xQueue, const void *const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition)  BaseType_t xQueueGenericSendFromISR (QueueHandle_t xQueue, const void *const pvItemToQueue, BaseType_t *const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition)  TaskHandle_t xQueueGetMutexHolder (QueueHandle_t xSemaphore)  TaskHandle_t xQueueGetMutexHolderFromISR (QueueHandle_t xSemaphore)  BaseType_t xQueueGiveFromISR (QueueHandle_t xQueue, BaseType_t *const pxHigherPriorityTaskWoken)  BaseType_t xQueueGiveMutexRecursive (QueueHandle_t xMutex)  BaseType_t xQueueIsQueueEmptyFromISR (const QueueHandle_t xQueue)  BaseType_t xQueueIsQueueFullFromISR (const QueueHandle_t xQueue)  BaseType_t xQueuePeek (QueueHandle_t xQueue, void *const pvBuffer, TickType_t xTicksToWait)  BaseType_t xQueuePeekFromISR (QueueHandle_t xQueue, void *const pvBuffer)  BaseType_t xQueueReceive (QueueHandle_t xQueue, void *const pvBuffer, TickType_t xTicksToWait)  BaseType_t xQueueReceiveFromISR (QueueHandle_t xQueue, void *const pvBuffer, BaseType_t *const pxHigherPriorityTaskWoken)  BaseType_t xQueueRemoveFromSet (QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet)  QueueSetMemberHandle_t xQueueSelectFromSet (QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait)  QueueSetMemberHandle_t xQueueSelectFromSetFromISR (QueueSetHandle_t xQueueSet)  BaseType_t xQueueSemaphoreTake (QueueHandle_t xQueue, TickType_t xTicksToWait)  BaseType_t xQueueTakeMutexRecursive (QueueHandle_t xMutex, TickType_t xTicksToWait)"},{"location":"apiStm/queue_8h/#macros","title":"Macros","text":"Type Name define queueOVERWRITE  ( ( BaseType_t ) 2 ) define queueQUEUE_TYPE_BASE  ( ( uint8_t ) 0U ) define queueQUEUE_TYPE_BINARY_SEMAPHORE  ( ( uint8_t ) 3U ) define queueQUEUE_TYPE_COUNTING_SEMAPHORE  ( ( uint8_t ) 2U ) define queueQUEUE_TYPE_MUTEX  ( ( uint8_t ) 1U ) define queueQUEUE_TYPE_RECURSIVE_MUTEX  ( ( uint8_t ) 4U ) define queueQUEUE_TYPE_SET  ( ( uint8_t ) 0U ) define queueSEND_TO_BACK  ( ( BaseType_t ) 0 ) define queueSEND_TO_FRONT  ( ( BaseType_t ) 1 ) define xQueueOverwrite (xQueue, pvItemToQueue) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), 0, queueOVERWRITE ) define xQueueOverwriteFromISR (xQueue, pvItemToQueue, pxHigherPriorityTaskWoken) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueOVERWRITE ) define xQueueReset (xQueue) xQueueGenericReset( xQueue, pdFALSE ) define xQueueSend (xQueue, pvItemToQueue, xTicksToWait) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK ) define xQueueSendFromISR (xQueue, pvItemToQueue, pxHigherPriorityTaskWoken) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK ) define xQueueSendToBack (xQueue, pvItemToQueue, xTicksToWait) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK ) define xQueueSendToBackFromISR (xQueue, pvItemToQueue, pxHigherPriorityTaskWoken) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK ) define xQueueSendToFront (xQueue, pvItemToQueue, xTicksToWait) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_FRONT ) define xQueueSendToFrontFromISR (xQueue, pvItemToQueue, pxHigherPriorityTaskWoken) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_FRONT )"},{"location":"apiStm/queue_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/queue_8h/#typedef-queuehandle_t","title":"typedef QueueHandle_t","text":"<pre><code>typedef struct QueueDefinition* QueueHandle_t;\n</code></pre>"},{"location":"apiStm/queue_8h/#typedef-queuesethandle_t","title":"typedef QueueSetHandle_t","text":"<pre><code>typedef struct QueueDefinition* QueueSetHandle_t;\n</code></pre> <p>Type by which queue sets are referenced. For example, a call to xQueueCreateSet() returns an xQueueSet variable that can then be used as a parameter to xQueueSelectFromSet(), xQueueAddToSet(), etc. </p>"},{"location":"apiStm/queue_8h/#typedef-queuesetmemberhandle_t","title":"typedef QueueSetMemberHandle_t","text":"<pre><code>typedef struct QueueDefinition* QueueSetMemberHandle_t;\n</code></pre> <p>Queue sets can contain both queues and semaphores, so the QueueSetMemberHandle_t is defined as a type to be used where a parameter or return value can be either an QueueHandle_t or an SemaphoreHandle_t. </p>"},{"location":"apiStm/queue_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/queue_8h/#function-ucqueuegetqueuetype","title":"function ucQueueGetQueueType","text":"<pre><code>uint8_t ucQueueGetQueueType (\nQueueHandle_t xQueue\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-uxqueuegetqueuenumber","title":"function uxQueueGetQueueNumber","text":"<pre><code>UBaseType_t uxQueueGetQueueNumber (\nQueueHandle_t xQueue\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-uxqueuemessageswaiting","title":"function uxQueueMessagesWaiting","text":"<pre><code>UBaseType_t uxQueueMessagesWaiting (\nconst QueueHandle_t xQueue\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-uxqueuemessageswaitingfromisr","title":"function uxQueueMessagesWaitingFromISR","text":"<pre><code>UBaseType_t uxQueueMessagesWaitingFromISR (\nconst QueueHandle_t xQueue\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-uxqueuespacesavailable","title":"function uxQueueSpacesAvailable","text":"<pre><code>UBaseType_t uxQueueSpacesAvailable (\nconst QueueHandle_t xQueue\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-vqueuedelete","title":"function vQueueDelete","text":"<pre><code>void vQueueDelete (\nQueueHandle_t xQueue\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-vqueuesetqueuenumber","title":"function vQueueSetQueueNumber","text":"<pre><code>void vQueueSetQueueNumber (\nQueueHandle_t xQueue,\nUBaseType_t uxQueueNumber\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-vqueuewaitformessagerestricted","title":"function vQueueWaitForMessageRestricted","text":"<pre><code>void vQueueWaitForMessageRestricted (\nQueueHandle_t xQueue,\nTickType_t xTicksToWait,\nconst BaseType_t xWaitIndefinitely\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueueaddtoset","title":"function xQueueAddToSet","text":"<pre><code>BaseType_t xQueueAddToSet (\nQueueSetMemberHandle_t xQueueOrSemaphore,\nQueueSetHandle_t xQueueSet\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueuecrreceive","title":"function xQueueCRReceive","text":"<pre><code>BaseType_t xQueueCRReceive (\nQueueHandle_t xQueue,\nvoid * pvBuffer,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueuecrreceivefromisr","title":"function xQueueCRReceiveFromISR","text":"<pre><code>BaseType_t xQueueCRReceiveFromISR (\nQueueHandle_t xQueue,\nvoid * pvBuffer,\nBaseType_t * pxTaskWoken\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueuecrsend","title":"function xQueueCRSend","text":"<pre><code>BaseType_t xQueueCRSend (\nQueueHandle_t xQueue,\nconst void * pvItemToQueue,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueuecrsendfromisr","title":"function xQueueCRSendFromISR","text":"<pre><code>BaseType_t xQueueCRSendFromISR (\nQueueHandle_t xQueue,\nconst void * pvItemToQueue,\nBaseType_t xCoRoutinePreviouslyWoken\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueuecreatecountingsemaphore","title":"function xQueueCreateCountingSemaphore","text":"<pre><code>QueueHandle_t xQueueCreateCountingSemaphore (\nconst UBaseType_t uxMaxCount,\nconst UBaseType_t uxInitialCount\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueuecreatecountingsemaphorestatic","title":"function xQueueCreateCountingSemaphoreStatic","text":"<pre><code>QueueHandle_t xQueueCreateCountingSemaphoreStatic (\nconst UBaseType_t uxMaxCount,\nconst UBaseType_t uxInitialCount,\nStaticQueue_t * pxStaticQueue\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueuecreatemutex","title":"function xQueueCreateMutex","text":"<pre><code>QueueHandle_t xQueueCreateMutex (\nconst uint8_t ucQueueType\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueuecreatemutexstatic","title":"function xQueueCreateMutexStatic","text":"<pre><code>QueueHandle_t xQueueCreateMutexStatic (\nconst uint8_t ucQueueType,\nStaticQueue_t * pxStaticQueue\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueuecreateset","title":"function xQueueCreateSet","text":"<pre><code>QueueSetHandle_t xQueueCreateSet (\nconst UBaseType_t uxEventQueueLength\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueuegenericreset","title":"function xQueueGenericReset","text":"<pre><code>BaseType_t xQueueGenericReset (\nQueueHandle_t xQueue,\nBaseType_t xNewQueue\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueuegenericsend","title":"function xQueueGenericSend","text":"<pre><code>BaseType_t xQueueGenericSend (\nQueueHandle_t xQueue,\nconst void *const pvItemToQueue,\nTickType_t xTicksToWait,\nconst BaseType_t xCopyPosition\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueuegenericsendfromisr","title":"function xQueueGenericSendFromISR","text":"<pre><code>BaseType_t xQueueGenericSendFromISR (\nQueueHandle_t xQueue,\nconst void *const pvItemToQueue,\nBaseType_t *const pxHigherPriorityTaskWoken,\nconst BaseType_t xCopyPosition\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueuegetmutexholder","title":"function xQueueGetMutexHolder","text":"<pre><code>TaskHandle_t xQueueGetMutexHolder (\nQueueHandle_t xSemaphore\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueuegetmutexholderfromisr","title":"function xQueueGetMutexHolderFromISR","text":"<pre><code>TaskHandle_t xQueueGetMutexHolderFromISR (\nQueueHandle_t xSemaphore\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueuegivefromisr","title":"function xQueueGiveFromISR","text":"<pre><code>BaseType_t xQueueGiveFromISR (\nQueueHandle_t xQueue,\nBaseType_t *const pxHigherPriorityTaskWoken\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueuegivemutexrecursive","title":"function xQueueGiveMutexRecursive","text":"<pre><code>BaseType_t xQueueGiveMutexRecursive (\nQueueHandle_t xMutex\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueueisqueueemptyfromisr","title":"function xQueueIsQueueEmptyFromISR","text":"<pre><code>BaseType_t xQueueIsQueueEmptyFromISR (\nconst QueueHandle_t xQueue\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueueisqueuefullfromisr","title":"function xQueueIsQueueFullFromISR","text":"<pre><code>BaseType_t xQueueIsQueueFullFromISR (\nconst QueueHandle_t xQueue\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueuepeek","title":"function xQueuePeek","text":"<pre><code>BaseType_t xQueuePeek (\nQueueHandle_t xQueue,\nvoid *const pvBuffer,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueuepeekfromisr","title":"function xQueuePeekFromISR","text":"<pre><code>BaseType_t xQueuePeekFromISR (\nQueueHandle_t xQueue,\nvoid *const pvBuffer\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueuereceive","title":"function xQueueReceive","text":"<pre><code>BaseType_t xQueueReceive (\nQueueHandle_t xQueue,\nvoid *const pvBuffer,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueuereceivefromisr","title":"function xQueueReceiveFromISR","text":"<pre><code>BaseType_t xQueueReceiveFromISR (\nQueueHandle_t xQueue,\nvoid *const pvBuffer,\nBaseType_t *const pxHigherPriorityTaskWoken\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueueremovefromset","title":"function xQueueRemoveFromSet","text":"<pre><code>BaseType_t xQueueRemoveFromSet (\nQueueSetMemberHandle_t xQueueOrSemaphore,\nQueueSetHandle_t xQueueSet\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueueselectfromset","title":"function xQueueSelectFromSet","text":"<pre><code>QueueSetMemberHandle_t xQueueSelectFromSet (\nQueueSetHandle_t xQueueSet,\nconst TickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueueselectfromsetfromisr","title":"function xQueueSelectFromSetFromISR","text":"<pre><code>QueueSetMemberHandle_t xQueueSelectFromSetFromISR (\nQueueSetHandle_t xQueueSet\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueuesemaphoretake","title":"function xQueueSemaphoreTake","text":"<pre><code>BaseType_t xQueueSemaphoreTake (\nQueueHandle_t xQueue,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/queue_8h/#function-xqueuetakemutexrecursive","title":"function xQueueTakeMutexRecursive","text":"<pre><code>BaseType_t xQueueTakeMutexRecursive (\nQueueHandle_t xMutex,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/queue_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/queue_8h/#define-queueoverwrite","title":"define queueOVERWRITE","text":"<pre><code>#define queueOVERWRITE ( ( BaseType_t ) 2 )\n</code></pre>"},{"location":"apiStm/queue_8h/#define-queuequeue_type_base","title":"define queueQUEUE_TYPE_BASE","text":"<pre><code>#define queueQUEUE_TYPE_BASE ( ( uint8_t ) 0U )\n</code></pre>"},{"location":"apiStm/queue_8h/#define-queuequeue_type_binary_semaphore","title":"define queueQUEUE_TYPE_BINARY_SEMAPHORE","text":"<pre><code>#define queueQUEUE_TYPE_BINARY_SEMAPHORE ( ( uint8_t ) 3U )\n</code></pre>"},{"location":"apiStm/queue_8h/#define-queuequeue_type_counting_semaphore","title":"define queueQUEUE_TYPE_COUNTING_SEMAPHORE","text":"<pre><code>#define queueQUEUE_TYPE_COUNTING_SEMAPHORE ( ( uint8_t ) 2U )\n</code></pre>"},{"location":"apiStm/queue_8h/#define-queuequeue_type_mutex","title":"define queueQUEUE_TYPE_MUTEX","text":"<pre><code>#define queueQUEUE_TYPE_MUTEX ( ( uint8_t ) 1U )\n</code></pre>"},{"location":"apiStm/queue_8h/#define-queuequeue_type_recursive_mutex","title":"define queueQUEUE_TYPE_RECURSIVE_MUTEX","text":"<pre><code>#define queueQUEUE_TYPE_RECURSIVE_MUTEX ( ( uint8_t ) 4U )\n</code></pre>"},{"location":"apiStm/queue_8h/#define-queuequeue_type_set","title":"define queueQUEUE_TYPE_SET","text":"<pre><code>#define queueQUEUE_TYPE_SET ( ( uint8_t ) 0U )\n</code></pre>"},{"location":"apiStm/queue_8h/#define-queuesend_to_back","title":"define queueSEND_TO_BACK","text":"<pre><code>#define queueSEND_TO_BACK ( ( BaseType_t ) 0 )\n</code></pre>"},{"location":"apiStm/queue_8h/#define-queuesend_to_front","title":"define queueSEND_TO_FRONT","text":"<pre><code>#define queueSEND_TO_FRONT ( ( BaseType_t ) 1 )\n</code></pre>"},{"location":"apiStm/queue_8h/#define-xqueueoverwrite","title":"define xQueueOverwrite","text":"<pre><code>#define xQueueOverwrite (\nxQueue,\npvItemToQueue\n) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), 0, queueOVERWRITE )\n</code></pre>"},{"location":"apiStm/queue_8h/#define-xqueueoverwritefromisr","title":"define xQueueOverwriteFromISR","text":"<pre><code>#define xQueueOverwriteFromISR (\nxQueue,\npvItemToQueue,\npxHigherPriorityTaskWoken\n) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueOVERWRITE )\n</code></pre>"},{"location":"apiStm/queue_8h/#define-xqueuereset","title":"define xQueueReset","text":"<pre><code>#define xQueueReset (\nxQueue\n) xQueueGenericReset( xQueue, pdFALSE )\n</code></pre>"},{"location":"apiStm/queue_8h/#define-xqueuesend","title":"define xQueueSend","text":"<pre><code>#define xQueueSend (\nxQueue,\npvItemToQueue,\nxTicksToWait\n) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )\n</code></pre>"},{"location":"apiStm/queue_8h/#define-xqueuesendfromisr","title":"define xQueueSendFromISR","text":"<pre><code>#define xQueueSendFromISR (\nxQueue,\npvItemToQueue,\npxHigherPriorityTaskWoken\n) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )\n</code></pre>"},{"location":"apiStm/queue_8h/#define-xqueuesendtoback","title":"define xQueueSendToBack","text":"<pre><code>#define xQueueSendToBack (\nxQueue,\npvItemToQueue,\nxTicksToWait\n) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )\n</code></pre>"},{"location":"apiStm/queue_8h/#define-xqueuesendtobackfromisr","title":"define xQueueSendToBackFromISR","text":"<pre><code>#define xQueueSendToBackFromISR (\nxQueue,\npvItemToQueue,\npxHigherPriorityTaskWoken\n) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )\n</code></pre>"},{"location":"apiStm/queue_8h/#define-xqueuesendtofront","title":"define xQueueSendToFront","text":"<pre><code>#define xQueueSendToFront (\nxQueue,\npvItemToQueue,\nxTicksToWait\n) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_FRONT )\n</code></pre>"},{"location":"apiStm/queue_8h/#define-xqueuesendtofrontfromisr","title":"define xQueueSendToFrontFromISR","text":"<pre><code>#define xQueueSendToFrontFromISR (\nxQueue,\npvItemToQueue,\npxHigherPriorityTaskWoken\n) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_FRONT )\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/queue.h</code></p>"},{"location":"apiStm/queue_8h_source/","title":"File queue.h","text":"<p>File List &gt; FreeRTOS &gt; include &gt; queue.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n\n#ifndef QUEUE_H\n#define QUEUE_H\n\n#ifndef INC_FREERTOS_H\n#error \"include FreeRTOS.h\" must appear in source files before \"include queue.h\"\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"task.h\"\n\nstruct QueueDefinition; /* Using old naming convention so as not to break kernel aware debuggers. */\ntypedef struct QueueDefinition * QueueHandle_t;\n\ntypedef struct QueueDefinition * QueueSetHandle_t;\n\ntypedef struct QueueDefinition * QueueSetMemberHandle_t;\n\n/* For internal use only. */\n#define queueSEND_TO_BACK       ( ( BaseType_t ) 0 )\n#define queueSEND_TO_FRONT      ( ( BaseType_t ) 1 )\n#define queueOVERWRITE          ( ( BaseType_t ) 2 )\n\n/* For internal use only.  These definitions *must* match those in queue.c. */\n#define queueQUEUE_TYPE_BASE                ( ( uint8_t ) 0U )\n#define queueQUEUE_TYPE_SET                 ( ( uint8_t ) 0U )\n#define queueQUEUE_TYPE_MUTEX               ( ( uint8_t ) 1U )\n#define queueQUEUE_TYPE_COUNTING_SEMAPHORE  ( ( uint8_t ) 2U )\n#define queueQUEUE_TYPE_BINARY_SEMAPHORE    ( ( uint8_t ) 3U )\n#define queueQUEUE_TYPE_RECURSIVE_MUTEX     ( ( uint8_t ) 4U )\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n#define xQueueCreate( uxQueueLength, uxItemSize ) xQueueGenericCreate( ( uxQueueLength ), ( uxItemSize ), ( queueQUEUE_TYPE_BASE ) )\n#endif\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n#define xQueueCreateStatic( uxQueueLength, uxItemSize, pucQueueStorage, pxQueueBuffer ) xQueueGenericCreateStatic( ( uxQueueLength ), ( uxItemSize ), ( pucQueueStorage ), ( pxQueueBuffer ), ( queueQUEUE_TYPE_BASE ) )\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n\n#define xQueueSendToFront( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_FRONT )\n\n#define xQueueSendToBack( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )\n\n#define xQueueSend( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )\n\n#define xQueueOverwrite( xQueue, pvItemToQueue ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), 0, queueOVERWRITE )\n\n\nBaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;\n\nBaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\n\nBaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;\n\nBaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\n\nUBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;\n\nUBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;\n\nvoid vQueueDelete( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;\n\n#define xQueueSendToFrontFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_FRONT )\n\n\n#define xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )\n\n#define xQueueOverwriteFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueOVERWRITE )\n\n#define xQueueSendFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )\n\nBaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;\nBaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;\n\nBaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;\n\n/*\n * Utilities to query queues that are safe to use from an ISR.  These utilities\n * should be used only from witin an ISR, or within a critical section.\n */\nBaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;\nBaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;\nUBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;\n\n/*\n * The functions defined above are for passing data to and from tasks.  The\n * functions below are the equivalents for passing data to and from\n * co-routines.\n *\n * These functions are called from the co-routine macro implementation and\n * should not be called directly from application code.  Instead use the macro\n * wrappers defined within croutine.h.\n */\nBaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken );\nBaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxTaskWoken );\nBaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait );\nBaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait );\n\n/*\n * For internal use only.  Use xSemaphoreCreateMutex(),\n * xSemaphoreCreateCounting() or xSemaphoreGetMutexHolder() instead of calling\n * these functions directly.\n */\nQueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;\nQueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue ) PRIVILEGED_FUNCTION;\nQueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) PRIVILEGED_FUNCTION;\nQueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue ) PRIVILEGED_FUNCTION;\nBaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\nTaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore ) PRIVILEGED_FUNCTION;\nTaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore ) PRIVILEGED_FUNCTION;\n\n/*\n * For internal use only.  Use xSemaphoreTakeMutexRecursive() or\n * xSemaphoreGiveMutexRecursive() instead of calling these functions directly.\n */\nBaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\nBaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex ) PRIVILEGED_FUNCTION;\n\n/*\n * Reset a queue back to its original empty state.  The return value is now\n * obsolete and is always set to pdPASS.\n */\n#define xQueueReset( xQueue ) xQueueGenericReset( xQueue, pdFALSE )\n\n/*\n * The registry is provided as a means for kernel aware debuggers to\n * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add\n * a queue, semaphore or mutex handle to the registry if you want the handle\n * to be available to a kernel aware debugger.  If you are not using a kernel\n * aware debugger then this function can be ignored.\n *\n * configQUEUE_REGISTRY_SIZE defines the maximum number of handles the\n * registry can hold.  configQUEUE_REGISTRY_SIZE must be greater than 0\n * within FreeRTOSConfig.h for the registry to be available.  Its value\n * does not effect the number of queues, semaphores and mutexes that can be\n * created - just the number that the registry can hold.\n *\n * @param xQueue The handle of the queue being added to the registry.  This\n * is the handle returned by a call to xQueueCreate().  Semaphore and mutex\n * handles can also be passed in here.\n *\n * @param pcName The name to be associated with the handle.  This is the\n * name that the kernel aware debugger will display.  The queue registry only\n * stores a pointer to the string - so the string must be persistent (global or\n * preferably in ROM/Flash), not on the stack.\n */\n#if( configQUEUE_REGISTRY_SIZE &gt; 0 )\nvoid vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n#endif\n\n/*\n * The registry is provided as a means for kernel aware debuggers to\n * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add\n * a queue, semaphore or mutex handle to the registry if you want the handle\n * to be available to a kernel aware debugger, and vQueueUnregisterQueue() to\n * remove the queue, semaphore or mutex from the register.  If you are not using\n * a kernel aware debugger then this function can be ignored.\n *\n * @param xQueue The handle of the queue being removed from the registry.\n */\n#if( configQUEUE_REGISTRY_SIZE &gt; 0 )\nvoid vQueueUnregisterQueue( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;\n#endif\n\n/*\n * The queue registry is provided as a means for kernel aware debuggers to\n * locate queues, semaphores and mutexes.  Call pcQueueGetName() to look\n * up and return the name of a queue in the queue registry from the queue's\n * handle.\n *\n * @param xQueue The handle of the queue the name of which will be returned.\n * @return If the queue is in the registry then a pointer to the name of the\n * queue is returned.  If the queue is not in the registry then NULL is\n * returned.\n */\n#if( configQUEUE_REGISTRY_SIZE &gt; 0 )\nconst char *pcQueueGetName( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n#endif\n\n/*\n * Generic version of the function used to creaet a queue using dynamic memory\n * allocation.  This is called by other functions and macros that create other\n * RTOS objects that use the queue structure as their base.\n */\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\nQueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;\n#endif\n\n/*\n * Generic version of the function used to creaet a queue using dynamic memory\n * allocation.  This is called by other functions and macros that create other\n * RTOS objects that use the queue structure as their base.\n */\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\nQueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;\n#endif\n\n/*\n * Queue sets provide a mechanism to allow a task to block (pend) on a read\n * operation from multiple queues or semaphores simultaneously.\n *\n * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this\n * function.\n *\n * A queue set must be explicitly created using a call to xQueueCreateSet()\n * before it can be used.  Once created, standard FreeRTOS queues and semaphores\n * can be added to the set using calls to xQueueAddToSet().\n * xQueueSelectFromSet() is then used to determine which, if any, of the queues\n * or semaphores contained in the set is in a state where a queue read or\n * semaphore take operation would be successful.\n *\n * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html\n * for reasons why queue sets are very rarely needed in practice as there are\n * simpler methods of blocking on multiple objects.\n *\n * Note 2:  Blocking on a queue set that contains a mutex will not cause the\n * mutex holder to inherit the priority of the blocked task.\n *\n * Note 3:  An additional 4 bytes of RAM is required for each space in a every\n * queue added to a queue set.  Therefore counting semaphores that have a high\n * maximum count value should not be added to a queue set.\n *\n * Note 4:  A receive (in the case of a queue) or take (in the case of a\n * semaphore) operation must not be performed on a member of a queue set unless\n * a call to xQueueSelectFromSet() has first returned a handle to that set member.\n *\n * @param uxEventQueueLength Queue sets store events that occur on\n * the queues and semaphores contained in the set.  uxEventQueueLength specifies\n * the maximum number of events that can be queued at once.  To be absolutely\n * certain that events are not lost uxEventQueueLength should be set to the\n * total sum of the length of the queues added to the set, where binary\n * semaphores and mutexes have a length of 1, and counting semaphores have a\n * length set by their maximum count value.  Examples:\n *  + If a queue set is to hold a queue of length 5, another queue of length 12,\n *    and a binary semaphore, then uxEventQueueLength should be set to\n *    (5 + 12 + 1), or 18.\n *  + If a queue set is to hold three binary semaphores then uxEventQueueLength\n *    should be set to (1 + 1 + 1 ), or 3.\n *  + If a queue set is to hold a counting semaphore that has a maximum count of\n *    5, and a counting semaphore that has a maximum count of 3, then\n *    uxEventQueueLength should be set to (5 + 3), or 8.\n *\n * @return If the queue set is created successfully then a handle to the created\n * queue set is returned.  Otherwise NULL is returned.\n */\nQueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) PRIVILEGED_FUNCTION;\n\n/*\n * Adds a queue or semaphore to a queue set that was previously created by a\n * call to xQueueCreateSet().\n *\n * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this\n * function.\n *\n * Note 1:  A receive (in the case of a queue) or take (in the case of a\n * semaphore) operation must not be performed on a member of a queue set unless\n * a call to xQueueSelectFromSet() has first returned a handle to that set member.\n *\n * @param xQueueOrSemaphore The handle of the queue or semaphore being added to\n * the queue set (cast to an QueueSetMemberHandle_t type).\n *\n * @param xQueueSet The handle of the queue set to which the queue or semaphore\n * is being added.\n *\n * @return If the queue or semaphore was successfully added to the queue set\n * then pdPASS is returned.  If the queue could not be successfully added to the\n * queue set because it is already a member of a different queue set then pdFAIL\n * is returned.\n */\nBaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;\n\n/*\n * Removes a queue or semaphore from a queue set.  A queue or semaphore can only\n * be removed from a set if the queue or semaphore is empty.\n *\n * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this\n * function.\n *\n * @param xQueueOrSemaphore The handle of the queue or semaphore being removed\n * from the queue set (cast to an QueueSetMemberHandle_t type).\n *\n * @param xQueueSet The handle of the queue set in which the queue or semaphore\n * is included.\n *\n * @return If the queue or semaphore was successfully removed from the queue set\n * then pdPASS is returned.  If the queue was not in the queue set, or the\n * queue (or semaphore) was not empty, then pdFAIL is returned.\n */\nBaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;\n\n/*\n * xQueueSelectFromSet() selects from the members of a queue set a queue or\n * semaphore that either contains data (in the case of a queue) or is available\n * to take (in the case of a semaphore).  xQueueSelectFromSet() effectively\n * allows a task to block (pend) on a read operation on all the queues and\n * semaphores in a queue set simultaneously.\n *\n * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this\n * function.\n *\n * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html\n * for reasons why queue sets are very rarely needed in practice as there are\n * simpler methods of blocking on multiple objects.\n *\n * Note 2:  Blocking on a queue set that contains a mutex will not cause the\n * mutex holder to inherit the priority of the blocked task.\n *\n * Note 3:  A receive (in the case of a queue) or take (in the case of a\n * semaphore) operation must not be performed on a member of a queue set unless\n * a call to xQueueSelectFromSet() has first returned a handle to that set member.\n *\n * @param xQueueSet The queue set on which the task will (potentially) block.\n *\n * @param xTicksToWait The maximum time, in ticks, that the calling task will\n * remain in the Blocked state (with other tasks executing) to wait for a member\n * of the queue set to be ready for a successful queue read or semaphore take\n * operation.\n *\n * @return xQueueSelectFromSet() will return the handle of a queue (cast to\n * a QueueSetMemberHandle_t type) contained in the queue set that contains data,\n * or the handle of a semaphore (cast to a QueueSetMemberHandle_t type) contained\n * in the queue set that is available, or NULL if no such queue or semaphore\n * exists before before the specified block time expires.\n */\nQueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\n\n/*\n * A version of xQueueSelectFromSet() that can be used from an ISR.\n */\nQueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;\n\n/* Not public API functions. */\nvoid vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;\nBaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) PRIVILEGED_FUNCTION;\nvoid vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber ) PRIVILEGED_FUNCTION;\nUBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;\nuint8_t ucQueueGetQueueType( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* QUEUE_H */\n</code></pre>"},{"location":"apiStm/semphr_8h/","title":"File semphr.h","text":"<p>FileList &gt; FreeRTOS &gt; include &gt; semphr.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"queue.h\"</code></li> </ul>"},{"location":"apiStm/semphr_8h/#public-types","title":"Public Types","text":"Type Name typedef QueueHandle_t SemaphoreHandle_t"},{"location":"apiStm/semphr_8h/#macros","title":"Macros","text":"Type Name define semBINARY_SEMAPHORE_QUEUE_LENGTH  ( ( uint8_t ) 1U ) define semGIVE_BLOCK_TIME  ( ( TickType_t ) 0U ) define semSEMAPHORE_QUEUE_ITEM_LENGTH  ( ( uint8_t ) 0U ) define uxSemaphoreGetCount (xSemaphore) uxQueueMessagesWaiting( ( QueueHandle_t ) ( xSemaphore ) ) define vSemaphoreDelete (xSemaphore) vQueueDelete( ( QueueHandle_t ) ( xSemaphore ) ) define xSemaphoreGetMutexHolder (xSemaphore) xQueueGetMutexHolder( ( xSemaphore ) ) define xSemaphoreGetMutexHolderFromISR (xSemaphore) xQueueGetMutexHolderFromISR( ( xSemaphore ) ) define xSemaphoreGive (xSemaphore) xQueueGenericSend( ( QueueHandle_t ) ( xSemaphore ), NULL, semGIVE_BLOCK_TIME, queueSEND_TO_BACK ) define xSemaphoreGiveFromISR (xSemaphore, pxHigherPriorityTaskWoken) xQueueGiveFromISR( ( QueueHandle_t ) ( xSemaphore ), ( pxHigherPriorityTaskWoken ) ) define xSemaphoreTake (xSemaphore, xBlockTime) xQueueSemaphoreTake( ( xSemaphore ), ( xBlockTime ) ) define xSemaphoreTakeFromISR (xSemaphore, pxHigherPriorityTaskWoken) xQueueReceiveFromISR( ( QueueHandle_t ) ( xSemaphore ), NULL, ( pxHigherPriorityTaskWoken ) )"},{"location":"apiStm/semphr_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/semphr_8h/#typedef-semaphorehandle_t","title":"typedef SemaphoreHandle_t","text":"<pre><code>typedef QueueHandle_t SemaphoreHandle_t;\n</code></pre>"},{"location":"apiStm/semphr_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/semphr_8h/#define-sembinary_semaphore_queue_length","title":"define semBINARY_SEMAPHORE_QUEUE_LENGTH","text":"<pre><code>#define semBINARY_SEMAPHORE_QUEUE_LENGTH ( ( uint8_t ) 1U )\n</code></pre>"},{"location":"apiStm/semphr_8h/#define-semgive_block_time","title":"define semGIVE_BLOCK_TIME","text":"<pre><code>#define semGIVE_BLOCK_TIME ( ( TickType_t ) 0U )\n</code></pre>"},{"location":"apiStm/semphr_8h/#define-semsemaphore_queue_item_length","title":"define semSEMAPHORE_QUEUE_ITEM_LENGTH","text":"<pre><code>#define semSEMAPHORE_QUEUE_ITEM_LENGTH ( ( uint8_t ) 0U )\n</code></pre>"},{"location":"apiStm/semphr_8h/#define-uxsemaphoregetcount","title":"define uxSemaphoreGetCount","text":"<pre><code>#define uxSemaphoreGetCount (\nxSemaphore\n) uxQueueMessagesWaiting( ( QueueHandle_t ) ( xSemaphore ) )\n</code></pre> <p>semphr.h </p> <p>If the semaphore is a counting semaphore then uxSemaphoreGetCount() returns its current count value. If the semaphore is a binary semaphore then uxSemaphoreGetCount() returns 1 if the semaphore is available, and 0 if the semaphore is not available. </p>"},{"location":"apiStm/semphr_8h/#define-vsemaphoredelete","title":"define vSemaphoreDelete","text":"<pre><code>#define vSemaphoreDelete (\nxSemaphore\n) vQueueDelete( ( QueueHandle_t ) ( xSemaphore ) )\n</code></pre>"},{"location":"apiStm/semphr_8h/#define-xsemaphoregetmutexholder","title":"define xSemaphoreGetMutexHolder","text":"<pre><code>#define xSemaphoreGetMutexHolder (\nxSemaphore\n) xQueueGetMutexHolder( ( xSemaphore ) )\n</code></pre> <p>semphr.h </p> <p>If xMutex is indeed a mutex type semaphore, return the current mutex holder. If xMutex is not a mutex type semaphore, or the mutex is available (not held by a task), return NULL.</p> <p>Note: This is a good way of determining if the calling task is the mutex holder, but not a good way of determining the identity of the mutex holder as the holder may change between the function exiting and the returned value being tested. </p>"},{"location":"apiStm/semphr_8h/#define-xsemaphoregetmutexholderfromisr","title":"define xSemaphoreGetMutexHolderFromISR","text":"<pre><code>#define xSemaphoreGetMutexHolderFromISR (\nxSemaphore\n) xQueueGetMutexHolderFromISR( ( xSemaphore ) )\n</code></pre> <p>semphr.h </p> <p>If xMutex is indeed a mutex type semaphore, return the current mutex holder. If xMutex is not a mutex type semaphore, or the mutex is available (not held by a task), return NULL. </p>"},{"location":"apiStm/semphr_8h/#define-xsemaphoregive","title":"define xSemaphoreGive","text":"<pre><code>#define xSemaphoreGive (\nxSemaphore\n) xQueueGenericSend( ( QueueHandle_t ) ( xSemaphore ), NULL, semGIVE_BLOCK_TIME, queueSEND_TO_BACK )\n</code></pre>"},{"location":"apiStm/semphr_8h/#define-xsemaphoregivefromisr","title":"define xSemaphoreGiveFromISR","text":"<pre><code>#define xSemaphoreGiveFromISR (\nxSemaphore,\npxHigherPriorityTaskWoken\n) xQueueGiveFromISR( ( QueueHandle_t ) ( xSemaphore ), ( pxHigherPriorityTaskWoken ) )\n</code></pre>"},{"location":"apiStm/semphr_8h/#define-xsemaphoretake","title":"define xSemaphoreTake","text":"<pre><code>#define xSemaphoreTake (\nxSemaphore,\nxBlockTime\n) xQueueSemaphoreTake( ( xSemaphore ), ( xBlockTime ) )\n</code></pre>"},{"location":"apiStm/semphr_8h/#define-xsemaphoretakefromisr","title":"define xSemaphoreTakeFromISR","text":"<pre><code>#define xSemaphoreTakeFromISR (\nxSemaphore,\npxHigherPriorityTaskWoken\n) xQueueReceiveFromISR( ( QueueHandle_t ) ( xSemaphore ), NULL, ( pxHigherPriorityTaskWoken ) )\n</code></pre> <p>semphr. h </p> <p>Macro to take a semaphore from an ISR. The semaphore must have previously been created with a call to xSemaphoreCreateBinary() or xSemaphoreCreateCounting().</p> <p>Mutex type semaphores (those created using a call to xSemaphoreCreateMutex()) must not be used with this macro.</p> <p>This macro can be used from an ISR, however taking a semaphore from an ISR is not a common operation. It is likely to only be useful when taking a counting semaphore when an interrupt is obtaining an object from a resource pool (when the semaphore count indicates the number of resources available).</p> <p>Parameters:</p> <ul> <li><code>xSemaphore</code> A handle to the semaphore being taken. This is the handle returned when the semaphore was created.</li> <li><code>pxHigherPriorityTaskWoken</code> xSemaphoreTakeFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if taking the semaphore caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xSemaphoreTakeFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</li> </ul> <p>Returns:</p> <p>pdTRUE if the semaphore was successfully taken, otherwise pdFALSE </p> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/semphr.h</code></p>"},{"location":"apiStm/semphr_8h_source/","title":"File semphr.h","text":"<p>File List &gt; FreeRTOS &gt; include &gt; semphr.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n#ifndef SEMAPHORE_H\n#define SEMAPHORE_H\n\n#ifndef INC_FREERTOS_H\n#error \"include FreeRTOS.h\" must appear in source files before \"include semphr.h\"\n#endif\n\n#include \"queue.h\"\n\ntypedef QueueHandle_t SemaphoreHandle_t;\n\n#define semBINARY_SEMAPHORE_QUEUE_LENGTH    ( ( uint8_t ) 1U )\n#define semSEMAPHORE_QUEUE_ITEM_LENGTH      ( ( uint8_t ) 0U )\n#define semGIVE_BLOCK_TIME                  ( ( TickType_t ) 0U )\n\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n#define vSemaphoreCreateBinary( xSemaphore )                                                                                            \\\n        {                                                                                                                                   \\\n            ( xSemaphore ) = xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE );    \\\n            if( ( xSemaphore ) != NULL )                                                                                                    \\\n            {                                                                                                                               \\\n                ( void ) xSemaphoreGive( ( xSemaphore ) );                                                                                  \\\n            }                                                                                                                               \\\n        }\n#endif\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n#define xSemaphoreCreateBinary() xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE )\n#endif\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n#define xSemaphoreCreateBinaryStatic( pxStaticSemaphore ) xQueueGenericCreateStatic( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticSemaphore, queueQUEUE_TYPE_BINARY_SEMAPHORE )\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n\n#define xSemaphoreTake( xSemaphore, xBlockTime )        xQueueSemaphoreTake( ( xSemaphore ), ( xBlockTime ) )\n\n#if( configUSE_RECURSIVE_MUTEXES == 1 )\n#define xSemaphoreTakeRecursive( xMutex, xBlockTime )   xQueueTakeMutexRecursive( ( xMutex ), ( xBlockTime ) )\n#endif\n\n#define xSemaphoreGive( xSemaphore )        xQueueGenericSend( ( QueueHandle_t ) ( xSemaphore ), NULL, semGIVE_BLOCK_TIME, queueSEND_TO_BACK )\n\n#if( configUSE_RECURSIVE_MUTEXES == 1 )\n#define xSemaphoreGiveRecursive( xMutex )   xQueueGiveMutexRecursive( ( xMutex ) )\n#endif\n\n#define xSemaphoreGiveFromISR( xSemaphore, pxHigherPriorityTaskWoken )  xQueueGiveFromISR( ( QueueHandle_t ) ( xSemaphore ), ( pxHigherPriorityTaskWoken ) )\n\n#define xSemaphoreTakeFromISR( xSemaphore, pxHigherPriorityTaskWoken )  xQueueReceiveFromISR( ( QueueHandle_t ) ( xSemaphore ), NULL, ( pxHigherPriorityTaskWoken ) )\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n#define xSemaphoreCreateMutex() xQueueCreateMutex( queueQUEUE_TYPE_MUTEX )\n#endif\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n#define xSemaphoreCreateMutexStatic( pxMutexBuffer ) xQueueCreateMutexStatic( queueQUEUE_TYPE_MUTEX, ( pxMutexBuffer ) )\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n\n\n#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) &amp;&amp; ( configUSE_RECURSIVE_MUTEXES == 1 ) )\n#define xSemaphoreCreateRecursiveMutex() xQueueCreateMutex( queueQUEUE_TYPE_RECURSIVE_MUTEX )\n#endif\n\n#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp; ( configUSE_RECURSIVE_MUTEXES == 1 ) )\n#define xSemaphoreCreateRecursiveMutexStatic( pxStaticSemaphore ) xQueueCreateMutexStatic( queueQUEUE_TYPE_RECURSIVE_MUTEX, pxStaticSemaphore )\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n#define xSemaphoreCreateCounting( uxMaxCount, uxInitialCount ) xQueueCreateCountingSemaphore( ( uxMaxCount ), ( uxInitialCount ) )\n#endif\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n#define xSemaphoreCreateCountingStatic( uxMaxCount, uxInitialCount, pxSemaphoreBuffer ) xQueueCreateCountingSemaphoreStatic( ( uxMaxCount ), ( uxInitialCount ), ( pxSemaphoreBuffer ) )\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n\n#define vSemaphoreDelete( xSemaphore ) vQueueDelete( ( QueueHandle_t ) ( xSemaphore ) )\n\n#define xSemaphoreGetMutexHolder( xSemaphore ) xQueueGetMutexHolder( ( xSemaphore ) )\n\n#define xSemaphoreGetMutexHolderFromISR( xSemaphore ) xQueueGetMutexHolderFromISR( ( xSemaphore ) )\n\n#define uxSemaphoreGetCount( xSemaphore ) uxQueueMessagesWaiting( ( QueueHandle_t ) ( xSemaphore ) )\n\n#endif /* SEMAPHORE_H */\n</code></pre>"},{"location":"apiStm/stack__macros_8h/","title":"File stack_macros.h","text":"<p>FileList &gt; FreeRTOS &gt; include &gt; stack_macros.h</p> <p>Go to the source code of this file.</p>"},{"location":"apiStm/stack__macros_8h/#macros","title":"Macros","text":"Type Name define taskCHECK_FOR_STACK_OVERFLOW ()"},{"location":"apiStm/stack__macros_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/stack__macros_8h/#define-taskcheck_for_stack_overflow","title":"define taskCHECK_FOR_STACK_OVERFLOW","text":"<pre><code>#define taskCHECK_FOR_STACK_OVERFLOW (\n\n) </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/stack_macros.h</code></p>"},{"location":"apiStm/stack__macros_8h_source/","title":"File stack_macros.h","text":"<p>File List &gt; FreeRTOS &gt; include &gt; stack_macros.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n#ifndef STACK_MACROS_H\n#define STACK_MACROS_H\n\n/*\n * Call the stack overflow hook function if the stack of the task being swapped\n * out is currently overflowed, or looks like it might have overflowed in the\n * past.\n *\n * Setting configCHECK_FOR_STACK_OVERFLOW to 1 will cause the macro to check\n * the current stack state only - comparing the current top of stack value to\n * the stack limit.  Setting configCHECK_FOR_STACK_OVERFLOW to greater than 1\n * will also cause the last few stack bytes to be checked to ensure the value\n * to which the bytes were set when the task was created have not been\n * overwritten.  Note this second test does not guarantee that an overflowed\n * stack will always be recognised.\n */\n\n/*-----------------------------------------------------------*/\n\n#if( ( configCHECK_FOR_STACK_OVERFLOW == 1 ) &amp;&amp; ( portSTACK_GROWTH &lt; 0 ) )\n\n/* Only the current stack state is to be checked. */\n#define taskCHECK_FOR_STACK_OVERFLOW()                                                              \\\n    {                                                                                                   \\\n/* Is the currently saved stack pointer within the stack limit? */                              \\\n        if( pxCurrentTCB-&gt;pxTopOfStack &lt;= pxCurrentTCB-&gt;pxStack )                                       \\\n        {                                                                                               \\\n            vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB-&gt;pcTaskName );   \\\n        }                                                                                               \\\n    }\n\n#endif /* configCHECK_FOR_STACK_OVERFLOW == 1 */\n/*-----------------------------------------------------------*/\n\n#if( ( configCHECK_FOR_STACK_OVERFLOW == 1 ) &amp;&amp; ( portSTACK_GROWTH &gt; 0 ) )\n\n/* Only the current stack state is to be checked. */\n#define taskCHECK_FOR_STACK_OVERFLOW()                                                              \\\n    {                                                                                                   \\\n                                                                                                        \\\n/* Is the currently saved stack pointer within the stack limit? */                              \\\n        if( pxCurrentTCB-&gt;pxTopOfStack &gt;= pxCurrentTCB-&gt;pxEndOfStack )                                  \\\n        {                                                                                               \\\n            vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB-&gt;pcTaskName );   \\\n        }                                                                                               \\\n    }\n\n#endif /* configCHECK_FOR_STACK_OVERFLOW == 1 */\n/*-----------------------------------------------------------*/\n\n#if( ( configCHECK_FOR_STACK_OVERFLOW &gt; 1 ) &amp;&amp; ( portSTACK_GROWTH &lt; 0 ) )\n\n#define taskCHECK_FOR_STACK_OVERFLOW()                                                              \\\n    {                                                                                                   \\\n        const uint32_t * const pulStack = ( uint32_t * ) pxCurrentTCB-&gt;pxStack;                         \\\n        const uint32_t ulCheckValue = ( uint32_t ) 0xa5a5a5a5;                                          \\\n                                                                                                        \\\n        if( ( pulStack[ 0 ] != ulCheckValue ) ||                                                        \\\n            ( pulStack[ 1 ] != ulCheckValue ) ||                                                        \\\n            ( pulStack[ 2 ] != ulCheckValue ) ||                                                        \\\n            ( pulStack[ 3 ] != ulCheckValue ) )                                                         \\\n        {                                                                                               \\\n            vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB-&gt;pcTaskName );   \\\n        }                                                                                               \\\n    }\n\n#endif /* #if( configCHECK_FOR_STACK_OVERFLOW &gt; 1 ) */\n/*-----------------------------------------------------------*/\n\n#if( ( configCHECK_FOR_STACK_OVERFLOW &gt; 1 ) &amp;&amp; ( portSTACK_GROWTH &gt; 0 ) )\n\n#define taskCHECK_FOR_STACK_OVERFLOW()                                                                                              \\\n    {                                                                                                                                   \\\n    int8_t *pcEndOfStack = ( int8_t * ) pxCurrentTCB-&gt;pxEndOfStack;                                                                     \\\n    static const uint8_t ucExpectedStackBytes[] = { tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,     \\\n                                                    tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,     \\\n                                                    tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,     \\\n                                                    tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,     \\\n                                                    tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE };   \\\n                                                                                                                                        \\\n                                                                                                                                        \\\n        pcEndOfStack -= sizeof( ucExpectedStackBytes );                                                                                 \\\n                                                                                                                                        \\\n/* Has the extremity of the task stack ever been written over? */                                                               \\\n        if( memcmp( ( void * ) pcEndOfStack, ( void * ) ucExpectedStackBytes, sizeof( ucExpectedStackBytes ) ) != 0 )                   \\\n        {                                                                                                                               \\\n            vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB-&gt;pcTaskName );                                   \\\n        }                                                                                                                               \\\n    }\n\n#endif /* #if( configCHECK_FOR_STACK_OVERFLOW &gt; 1 ) */\n/*-----------------------------------------------------------*/\n\n/* Remove stack overflow macro if not being used. */\n#ifndef taskCHECK_FOR_STACK_OVERFLOW\n#define taskCHECK_FOR_STACK_OVERFLOW()\n#endif\n\n\n\n#endif /* STACK_MACROS_H */\n</code></pre>"},{"location":"apiStm/stream__buffer_8h/","title":"File stream_buffer.h","text":"<p>FileList &gt; FreeRTOS &gt; include &gt; stream_buffer.h</p> <p>Go to the source code of this file.</p>"},{"location":"apiStm/stream__buffer_8h/#public-types","title":"Public Types","text":"Type Name typedef struct StreamBufferDef_t * StreamBufferHandle_t"},{"location":"apiStm/stream__buffer_8h/#public-functions","title":"Public Functions","text":"Type Name void vStreamBufferDelete (StreamBufferHandle_t xStreamBuffer)  size_t xStreamBufferBytesAvailable (StreamBufferHandle_t xStreamBuffer)  StreamBufferHandle_t xStreamBufferGenericCreate (size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer)  StreamBufferHandle_t xStreamBufferGenericCreateStatic (size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer, uint8_t *const pucStreamBufferStorageArea, StaticStreamBuffer_t *const pxStaticStreamBuffer)  BaseType_t xStreamBufferIsEmpty (StreamBufferHandle_t xStreamBuffer)  BaseType_t xStreamBufferIsFull (StreamBufferHandle_t xStreamBuffer)  size_t xStreamBufferNextMessageLengthBytes (StreamBufferHandle_t xStreamBuffer)  size_t xStreamBufferReceive (StreamBufferHandle_t xStreamBuffer, void * pvRxData, size_t xBufferLengthBytes, TickType_t xTicksToWait)  BaseType_t xStreamBufferReceiveCompletedFromISR (StreamBufferHandle_t xStreamBuffer, BaseType_t * pxHigherPriorityTaskWoken)  size_t xStreamBufferReceiveFromISR (StreamBufferHandle_t xStreamBuffer, void * pvRxData, size_t xBufferLengthBytes, BaseType_t *const pxHigherPriorityTaskWoken)  BaseType_t xStreamBufferReset (StreamBufferHandle_t xStreamBuffer)  size_t xStreamBufferSend (StreamBufferHandle_t xStreamBuffer, const void * pvTxData, size_t xDataLengthBytes, TickType_t xTicksToWait)  BaseType_t xStreamBufferSendCompletedFromISR (StreamBufferHandle_t xStreamBuffer, BaseType_t * pxHigherPriorityTaskWoken)  size_t xStreamBufferSendFromISR (StreamBufferHandle_t xStreamBuffer, const void * pvTxData, size_t xDataLengthBytes, BaseType_t *const pxHigherPriorityTaskWoken)  BaseType_t xStreamBufferSetTriggerLevel (StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel)  size_t xStreamBufferSpacesAvailable (StreamBufferHandle_t xStreamBuffer)"},{"location":"apiStm/stream__buffer_8h/#macros","title":"Macros","text":"Type Name define xStreamBufferCreate (xBufferSizeBytes, xTriggerLevelBytes) xStreamBufferGenericCreate( xBufferSizeBytes, xTriggerLevelBytes, pdFALSE ) define xStreamBufferCreateStatic (xBufferSizeBytes, xTriggerLevelBytes, pucStreamBufferStorageArea, pxStaticStreamBuffer) xStreamBufferGenericCreateStatic( xBufferSizeBytes, xTriggerLevelBytes, pdFALSE, pucStreamBufferStorageArea, pxStaticStreamBuffer )"},{"location":"apiStm/stream__buffer_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/stream__buffer_8h/#typedef-streambufferhandle_t","title":"typedef StreamBufferHandle_t","text":"<pre><code>typedef struct StreamBufferDef_t* StreamBufferHandle_t;\n</code></pre>"},{"location":"apiStm/stream__buffer_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/stream__buffer_8h/#function-vstreambufferdelete","title":"function vStreamBufferDelete","text":"<pre><code>void vStreamBufferDelete (\nStreamBufferHandle_t xStreamBuffer\n) </code></pre>"},{"location":"apiStm/stream__buffer_8h/#function-xstreambufferbytesavailable","title":"function xStreamBufferBytesAvailable","text":"<pre><code>size_t xStreamBufferBytesAvailable (\nStreamBufferHandle_t xStreamBuffer\n) </code></pre>"},{"location":"apiStm/stream__buffer_8h/#function-xstreambuffergenericcreate","title":"function xStreamBufferGenericCreate","text":"<pre><code>StreamBufferHandle_t xStreamBufferGenericCreate (\nsize_t xBufferSizeBytes,\nsize_t xTriggerLevelBytes,\nBaseType_t xIsMessageBuffer\n) </code></pre>"},{"location":"apiStm/stream__buffer_8h/#function-xstreambuffergenericcreatestatic","title":"function xStreamBufferGenericCreateStatic","text":"<pre><code>StreamBufferHandle_t xStreamBufferGenericCreateStatic (\nsize_t xBufferSizeBytes,\nsize_t xTriggerLevelBytes,\nBaseType_t xIsMessageBuffer,\nuint8_t *const pucStreamBufferStorageArea,\nStaticStreamBuffer_t *const pxStaticStreamBuffer\n) </code></pre>"},{"location":"apiStm/stream__buffer_8h/#function-xstreambufferisempty","title":"function xStreamBufferIsEmpty","text":"<pre><code>BaseType_t xStreamBufferIsEmpty (\nStreamBufferHandle_t xStreamBuffer\n) </code></pre>"},{"location":"apiStm/stream__buffer_8h/#function-xstreambufferisfull","title":"function xStreamBufferIsFull","text":"<pre><code>BaseType_t xStreamBufferIsFull (\nStreamBufferHandle_t xStreamBuffer\n) </code></pre>"},{"location":"apiStm/stream__buffer_8h/#function-xstreambuffernextmessagelengthbytes","title":"function xStreamBufferNextMessageLengthBytes","text":"<pre><code>size_t xStreamBufferNextMessageLengthBytes (\nStreamBufferHandle_t xStreamBuffer\n) </code></pre>"},{"location":"apiStm/stream__buffer_8h/#function-xstreambufferreceive","title":"function xStreamBufferReceive","text":"<pre><code>size_t xStreamBufferReceive (\nStreamBufferHandle_t xStreamBuffer,\nvoid * pvRxData,\nsize_t xBufferLengthBytes,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/stream__buffer_8h/#function-xstreambufferreceivecompletedfromisr","title":"function xStreamBufferReceiveCompletedFromISR","text":"<pre><code>BaseType_t xStreamBufferReceiveCompletedFromISR (\nStreamBufferHandle_t xStreamBuffer,\nBaseType_t * pxHigherPriorityTaskWoken\n) </code></pre>"},{"location":"apiStm/stream__buffer_8h/#function-xstreambufferreceivefromisr","title":"function xStreamBufferReceiveFromISR","text":"<pre><code>size_t xStreamBufferReceiveFromISR (\nStreamBufferHandle_t xStreamBuffer,\nvoid * pvRxData,\nsize_t xBufferLengthBytes,\nBaseType_t *const pxHigherPriorityTaskWoken\n) </code></pre>"},{"location":"apiStm/stream__buffer_8h/#function-xstreambufferreset","title":"function xStreamBufferReset","text":"<pre><code>BaseType_t xStreamBufferReset (\nStreamBufferHandle_t xStreamBuffer\n) </code></pre>"},{"location":"apiStm/stream__buffer_8h/#function-xstreambuffersend","title":"function xStreamBufferSend","text":"<pre><code>size_t xStreamBufferSend (\nStreamBufferHandle_t xStreamBuffer,\nconst void * pvTxData,\nsize_t xDataLengthBytes,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/stream__buffer_8h/#function-xstreambuffersendcompletedfromisr","title":"function xStreamBufferSendCompletedFromISR","text":"<pre><code>BaseType_t xStreamBufferSendCompletedFromISR (\nStreamBufferHandle_t xStreamBuffer,\nBaseType_t * pxHigherPriorityTaskWoken\n) </code></pre>"},{"location":"apiStm/stream__buffer_8h/#function-xstreambuffersendfromisr","title":"function xStreamBufferSendFromISR","text":"<pre><code>size_t xStreamBufferSendFromISR (\nStreamBufferHandle_t xStreamBuffer,\nconst void * pvTxData,\nsize_t xDataLengthBytes,\nBaseType_t *const pxHigherPriorityTaskWoken\n) </code></pre>"},{"location":"apiStm/stream__buffer_8h/#function-xstreambuffersettriggerlevel","title":"function xStreamBufferSetTriggerLevel","text":"<pre><code>BaseType_t xStreamBufferSetTriggerLevel (\nStreamBufferHandle_t xStreamBuffer,\nsize_t xTriggerLevel\n) </code></pre>"},{"location":"apiStm/stream__buffer_8h/#function-xstreambufferspacesavailable","title":"function xStreamBufferSpacesAvailable","text":"<pre><code>size_t xStreamBufferSpacesAvailable (\nStreamBufferHandle_t xStreamBuffer\n) </code></pre>"},{"location":"apiStm/stream__buffer_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/stream__buffer_8h/#define-xstreambuffercreate","title":"define xStreamBufferCreate","text":"<pre><code>#define xStreamBufferCreate (\nxBufferSizeBytes,\nxTriggerLevelBytes\n) xStreamBufferGenericCreate( xBufferSizeBytes, xTriggerLevelBytes, pdFALSE )\n</code></pre>"},{"location":"apiStm/stream__buffer_8h/#define-xstreambuffercreatestatic","title":"define xStreamBufferCreateStatic","text":"<pre><code>#define xStreamBufferCreateStatic (\nxBufferSizeBytes,\nxTriggerLevelBytes,\npucStreamBufferStorageArea,\npxStaticStreamBuffer\n) xStreamBufferGenericCreateStatic( xBufferSizeBytes, xTriggerLevelBytes, pdFALSE, pucStreamBufferStorageArea, pxStaticStreamBuffer )\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/stream_buffer.h</code></p>"},{"location":"apiStm/stream__buffer_8h_source/","title":"File stream_buffer.h","text":"<p>File List &gt; FreeRTOS &gt; include &gt; stream_buffer.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n/*\n * Stream buffers are used to send a continuous stream of data from one task or\n * interrupt to another.  Their implementation is light weight, making them\n * particularly suited for interrupt to task and core to core communication\n * scenarios.\n *\n * ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer\n * implementation (so also the message buffer implementation, as message buffers\n * are built on top of stream buffers) assumes there is only one task or\n * interrupt that will write to the buffer (the writer), and only one task or\n * interrupt that will read from the buffer (the reader).  It is safe for the\n * writer and reader to be different tasks or interrupts, but, unlike other\n * FreeRTOS objects, it is not safe to have multiple different writers or\n * multiple different readers.  If there are to be multiple different writers\n * then the application writer must place each call to a writing API function\n * (such as xStreamBufferSend()) inside a critical section and set the send\n * block time to 0.  Likewise, if there are to be multiple different readers\n * then the application writer must place each call to a reading API function\n * (such as xStreamBufferReceive()) inside a critical section section and set the\n * receive block time to 0.\n *\n */\n\n#ifndef STREAM_BUFFER_H\n#define STREAM_BUFFER_H\n\n#ifndef INC_FREERTOS_H\n#error \"include FreeRTOS.h must appear in source files before include stream_buffer.h\"\n#endif\n\n#if defined( __cplusplus )\nextern \"C\" {\n#endif\n\nstruct StreamBufferDef_t;\ntypedef struct StreamBufferDef_t * StreamBufferHandle_t;\n\n\n#define xStreamBufferCreate( xBufferSizeBytes, xTriggerLevelBytes ) xStreamBufferGenericCreate( xBufferSizeBytes, xTriggerLevelBytes, pdFALSE )\n\n#define xStreamBufferCreateStatic( xBufferSizeBytes, xTriggerLevelBytes, pucStreamBufferStorageArea, pxStaticStreamBuffer ) xStreamBufferGenericCreateStatic( xBufferSizeBytes, xTriggerLevelBytes, pdFALSE, pucStreamBufferStorageArea, pxStaticStreamBuffer )\n\nsize_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,\nconst void *pvTxData,\nsize_t xDataLengthBytes,\nTickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\n\nsize_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,\nconst void *pvTxData,\nsize_t xDataLengthBytes,\nBaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;\n\nsize_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,\nvoid *pvRxData,\nsize_t xBufferLengthBytes,\nTickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\n\nsize_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,\nvoid *pvRxData,\nsize_t xBufferLengthBytes,\nBaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;\n\nvoid vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;\n\nBaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;\n\nBaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;\n\nBaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;\n\nsize_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;\n\nsize_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;\n\nBaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel ) PRIVILEGED_FUNCTION;\n\nBaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;\n\nBaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;\n\n/* Functions below here are not part of the public API. */\nStreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,\nsize_t xTriggerLevelBytes,\nBaseType_t xIsMessageBuffer ) PRIVILEGED_FUNCTION;\n\nStreamBufferHandle_t xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes,\nsize_t xTriggerLevelBytes,\nBaseType_t xIsMessageBuffer,\nuint8_t * const pucStreamBufferStorageArea,\nStaticStreamBuffer_t * const pxStaticStreamBuffer ) PRIVILEGED_FUNCTION;\n\nsize_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;\n\n#if( configUSE_TRACE_FACILITY == 1 )\nvoid vStreamBufferSetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer, UBaseType_t uxStreamBufferNumber ) PRIVILEGED_FUNCTION;\nUBaseType_t uxStreamBufferGetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;\nuint8_t ucStreamBufferGetStreamBufferType( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;\n#endif\n\n#if defined( __cplusplus )\n}\n#endif\n\n#endif  /* !defined( STREAM_BUFFER_H ) */\n</code></pre>"},{"location":"apiStm/task_8h/","title":"File task.h","text":"<p>FileList &gt; FreeRTOS &gt; include &gt; task.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"list.h\"</code></li> </ul>"},{"location":"apiStm/task_8h/#classes","title":"Classes","text":"Type Name struct xMEMORY_REGION struct xTASK_PARAMETERS struct xTASK_STATUS struct xTIME_OUT"},{"location":"apiStm/task_8h/#public-types","title":"Public Types","text":"Type Name typedef struct xMEMORY_REGION MemoryRegion_t typedef struct tskTaskControlBlock * TaskHandle_t typedef BaseType_t(* TaskHookFunction_t typedef struct xTASK_PARAMETERS TaskParameters_t typedef struct xTASK_STATUS TaskStatus_t typedef struct xTIME_OUT TimeOut_t enum eNotifyAction enum eSleepModeStatus enum eTaskState"},{"location":"apiStm/task_8h/#public-functions","title":"Public Functions","text":"Type Name eSleepModeStatus eTaskConfirmSleepModeStatus (void)  eTaskState eTaskGetState (TaskHandle_t xTask)  char * pcTaskGetName (TaskHandle_t xTaskToQuery)  TaskHandle_t pvTaskIncrementMutexHeldCount (void)  uint32_t ulTaskGetIdleRunTimeCounter (void)  uint32_t ulTaskNotifyTake (BaseType_t xClearCountOnExit, TickType_t xTicksToWait)  uint32_t ulTaskNotifyValueClear (TaskHandle_t xTask, uint32_t ulBitsToClear)  UBaseType_t uxTaskGetNumberOfTasks (void)  UBaseType_t uxTaskGetStackHighWaterMark (TaskHandle_t xTask)  configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2 (TaskHandle_t xTask)  UBaseType_t uxTaskGetSystemState (TaskStatus_t *const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t *const pulTotalRunTime)  UBaseType_t uxTaskGetTaskNumber (TaskHandle_t xTask)  UBaseType_t uxTaskPriorityGet (const TaskHandle_t xTask)  UBaseType_t uxTaskPriorityGetFromISR (const TaskHandle_t xTask)  TickType_t uxTaskResetEventItemValue (void)  void vTaskAllocateMPURegions (TaskHandle_t xTask, const MemoryRegion_t *const pxRegions)  void vTaskDelay (const TickType_t xTicksToDelay)  void vTaskDelayUntil (TickType_t *const pxPreviousWakeTime, const TickType_t xTimeIncrement)  void vTaskDelete (TaskHandle_t xTaskToDelete)  void vTaskEndScheduler (void)  void vTaskGetInfo (TaskHandle_t xTask, TaskStatus_t * pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState)  void vTaskGetRunTimeStats (char * pcWriteBuffer)  void vTaskInternalSetTimeOutState (TimeOut_t *const pxTimeOut)  void vTaskList (char * pcWriteBuffer)  void vTaskMissedYield (void)  void vTaskNotifyGiveFromISR (TaskHandle_t xTaskToNotify, BaseType_t * pxHigherPriorityTaskWoken)  void vTaskPlaceOnEventList (List_t *const pxEventList, const TickType_t xTicksToWait)  void vTaskPlaceOnEventListRestricted (List_t *const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely)  void vTaskPlaceOnUnorderedEventList (List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait)  void vTaskPriorityDisinheritAfterTimeout (TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask)  void vTaskPrioritySet (TaskHandle_t xTask, UBaseType_t uxNewPriority)  void vTaskRemoveFromUnorderedEventList (ListItem_t * pxEventListItem, const TickType_t xItemValue)  void vTaskResume (TaskHandle_t xTaskToResume)  void vTaskSetTaskNumber (TaskHandle_t xTask, const UBaseType_t uxHandle)  void vTaskSetTimeOutState (TimeOut_t *const pxTimeOut)  void vTaskStartScheduler (void)  void vTaskStepTick (const TickType_t xTicksToJump)  void vTaskSuspend (TaskHandle_t xTaskToSuspend)  void vTaskSuspendAll (void)  portDONT_DISCARD void vTaskSwitchContext (void)  BaseType_t xTaskAbortDelay (TaskHandle_t xTask)  BaseType_t xTaskCallApplicationTaskHook (TaskHandle_t xTask, void * pvParameter)  BaseType_t xTaskCatchUpTicks (TickType_t xTicksToCatchUp)  BaseType_t xTaskCheckForTimeOut (TimeOut_t *const pxTimeOut, TickType_t *const pxTicksToWait)  BaseType_t xTaskGenericNotify (TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t * pulPreviousNotificationValue)  BaseType_t xTaskGenericNotifyFromISR (TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t * pulPreviousNotificationValue, BaseType_t * pxHigherPriorityTaskWoken)  TaskHandle_t xTaskGetCurrentTaskHandle (void)  TaskHandle_t xTaskGetHandle (const char * pcNameToQuery)  TaskHandle_t xTaskGetIdleTaskHandle (void)  BaseType_t xTaskGetSchedulerState (void)  TickType_t xTaskGetTickCount (void)  TickType_t xTaskGetTickCountFromISR (void)  BaseType_t xTaskIncrementTick (void)  BaseType_t xTaskNotifyStateClear (TaskHandle_t xTask)  BaseType_t xTaskNotifyWait (uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t * pulNotificationValue, TickType_t xTicksToWait)  BaseType_t xTaskPriorityDisinherit (TaskHandle_t const pxMutexHolder)  BaseType_t xTaskPriorityInherit (TaskHandle_t const pxMutexHolder)  BaseType_t xTaskRemoveFromEventList (const List_t *const pxEventList)  BaseType_t xTaskResumeAll (void)  BaseType_t xTaskResumeFromISR (TaskHandle_t xTaskToResume)"},{"location":"apiStm/task_8h/#macros","title":"Macros","text":"Type Name define taskDISABLE_INTERRUPTS () portDISABLE_INTERRUPTS() define taskENABLE_INTERRUPTS () portENABLE_INTERRUPTS() define taskENTER_CRITICAL () portENTER_CRITICAL() define taskENTER_CRITICAL_FROM_ISR () portSET_INTERRUPT_MASK_FROM_ISR() define taskEXIT_CRITICAL () portEXIT_CRITICAL() define taskEXIT_CRITICAL_FROM_ISR (x) portCLEAR_INTERRUPT_MASK_FROM_ISR( x ) define taskSCHEDULER_NOT_STARTED  ( ( BaseType_t ) 1 ) define taskSCHEDULER_RUNNING  ( ( BaseType_t ) 2 ) define taskSCHEDULER_SUSPENDED  ( ( BaseType_t ) 0 ) define taskYIELD () portYIELD() define tskIDLE_PRIORITY  ( ( UBaseType_t ) 0U ) define tskKERNEL_VERSION_BUILD  1 define tskKERNEL_VERSION_MAJOR  10 define tskKERNEL_VERSION_MINOR  3 define tskKERNEL_VERSION_NUMBER  \"V10.3.1\" define tskMPU_REGION_DEVICE_MEMORY  ( 1UL &lt;&lt; 4UL ) define tskMPU_REGION_EXECUTE_NEVER  ( 1UL &lt;&lt; 2UL ) define tskMPU_REGION_NORMAL_MEMORY  ( 1UL &lt;&lt; 3UL ) define tskMPU_REGION_READ_ONLY  ( 1UL &lt;&lt; 0UL ) define tskMPU_REGION_READ_WRITE  ( 1UL &lt;&lt; 1UL ) define xTaskNotify (xTaskToNotify, ulValue, eAction) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL ) define xTaskNotifyAndQuery (xTaskToNotify, ulValue, eAction, pulPreviousNotifyValue) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotifyValue ) ) define xTaskNotifyAndQueryFromISR (xTaskToNotify, ulValue, eAction, pulPreviousNotificationValue, pxHigherPriorityTaskWoken) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotificationValue ), ( pxHigherPriorityTaskWoken ) ) define xTaskNotifyFromISR (xTaskToNotify, ulValue, eAction, pxHigherPriorityTaskWoken) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL, ( pxHigherPriorityTaskWoken ) ) define xTaskNotifyGive (xTaskToNotify) xTaskGenericNotify( ( xTaskToNotify ), ( 0 ), eIncrement, NULL )"},{"location":"apiStm/task_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/task_8h/#typedef-memoryregion_t","title":"typedef MemoryRegion_t","text":"<pre><code>typedef struct xMEMORY_REGION MemoryRegion_t;\n</code></pre>"},{"location":"apiStm/task_8h/#typedef-taskhandle_t","title":"typedef TaskHandle_t","text":"<pre><code>typedef struct tskTaskControlBlock* TaskHandle_t;\n</code></pre>"},{"location":"apiStm/task_8h/#typedef-taskhookfunction_t","title":"typedef TaskHookFunction_t","text":"<pre><code>typedef BaseType_t(* TaskHookFunction_t) (void *);\n</code></pre>"},{"location":"apiStm/task_8h/#typedef-taskparameters_t","title":"typedef TaskParameters_t","text":"<pre><code>typedef struct xTASK_PARAMETERS TaskParameters_t;\n</code></pre>"},{"location":"apiStm/task_8h/#typedef-taskstatus_t","title":"typedef TaskStatus_t","text":"<pre><code>typedef struct xTASK_STATUS TaskStatus_t;\n</code></pre>"},{"location":"apiStm/task_8h/#typedef-timeout_t","title":"typedef TimeOut_t","text":"<pre><code>typedef struct xTIME_OUT TimeOut_t;\n</code></pre>"},{"location":"apiStm/task_8h/#enum-enotifyaction","title":"enum eNotifyAction","text":"<pre><code>enum eNotifyAction {\neNoAction = 0,\neSetBits,\neIncrement,\neSetValueWithOverwrite,\neSetValueWithoutOverwrite\n};\n</code></pre>"},{"location":"apiStm/task_8h/#enum-esleepmodestatus","title":"enum eSleepModeStatus","text":"<pre><code>enum eSleepModeStatus {\neAbortSleep = 0,\neStandardSleep,\neNoTasksWaitingTimeout\n};\n</code></pre>"},{"location":"apiStm/task_8h/#enum-etaskstate","title":"enum eTaskState","text":"<pre><code>enum eTaskState {\neRunning = 0,\neReady,\neBlocked,\neSuspended,\neDeleted,\neInvalid\n};\n</code></pre>"},{"location":"apiStm/task_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/task_8h/#function-etaskconfirmsleepmodestatus","title":"function eTaskConfirmSleepModeStatus","text":"<pre><code>eSleepModeStatus eTaskConfirmSleepModeStatus (\nvoid\n) </code></pre>"},{"location":"apiStm/task_8h/#function-etaskgetstate","title":"function eTaskGetState","text":"<pre><code>eTaskState eTaskGetState (\nTaskHandle_t xTask\n) </code></pre> <p>task. h </p> <p>INCLUDE_eTaskGetState must be defined as 1 for this function to be available. See the configuration section for more information.</p> <p>Obtain the state of any task. States are encoded by the eTaskState enumerated type.</p> <p>Parameters:</p> <ul> <li><code>xTask</code> Handle of the task to be queried.</li> </ul> <p>Returns:</p> <p>The state of xTask at the time the function was called. Note the state of the task might change between the function being called, and the functions return value being tested by the calling task. </p>"},{"location":"apiStm/task_8h/#function-pctaskgetname","title":"function pcTaskGetName","text":"<pre><code>char * pcTaskGetName (\nTaskHandle_t xTaskToQuery\n) </code></pre>"},{"location":"apiStm/task_8h/#function-pvtaskincrementmutexheldcount","title":"function pvTaskIncrementMutexHeldCount","text":"<pre><code>TaskHandle_t pvTaskIncrementMutexHeldCount (\nvoid\n) </code></pre>"},{"location":"apiStm/task_8h/#function-ultaskgetidleruntimecounter","title":"function ulTaskGetIdleRunTimeCounter","text":"<pre><code>uint32_t ulTaskGetIdleRunTimeCounter (\nvoid\n) </code></pre>"},{"location":"apiStm/task_8h/#function-ultasknotifytake","title":"function ulTaskNotifyTake","text":"<pre><code>uint32_t ulTaskNotifyTake (\nBaseType_t xClearCountOnExit,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/task_8h/#function-ultasknotifyvalueclear","title":"function ulTaskNotifyValueClear","text":"<pre><code>uint32_t ulTaskNotifyValueClear (\nTaskHandle_t xTask,\nuint32_t ulBitsToClear\n) </code></pre>"},{"location":"apiStm/task_8h/#function-uxtaskgetnumberoftasks","title":"function uxTaskGetNumberOfTasks","text":"<pre><code>UBaseType_t uxTaskGetNumberOfTasks (\nvoid\n) </code></pre>"},{"location":"apiStm/task_8h/#function-uxtaskgetstackhighwatermark","title":"function uxTaskGetStackHighWaterMark","text":"<pre><code>UBaseType_t uxTaskGetStackHighWaterMark (\nTaskHandle_t xTask\n) </code></pre> <p>task.h </p> <p>INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for this function to be available.</p> <p>Returns the high water mark of the stack associated with xTask. That is, the minimum free stack space there has been (in words, so on a 32 bit machine a value of 1 means 4 bytes) since the task started. The smaller the returned number the closer the task has come to overflowing its stack.</p> <p>uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the same except for their return type. Using configSTACK_DEPTH_TYPE allows the user to determine the return type. It gets around the problem of the value overflowing on 8-bit types without breaking backward compatibility for applications that expect an 8-bit return type.</p> <p>Parameters:</p> <ul> <li><code>xTask</code> Handle of the task associated with the stack to be checked. Set xTask to NULL to check the stack of the calling task.</li> </ul> <p>Returns:</p> <p>The smallest amount of free stack space there has been (in words, so actual spaces on the stack rather than bytes) since the task referenced by xTask was created. </p>"},{"location":"apiStm/task_8h/#function-uxtaskgetstackhighwatermark2","title":"function uxTaskGetStackHighWaterMark2","text":"<pre><code>configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2 (\nTaskHandle_t xTask\n) </code></pre> <p>task.h </p> <p>INCLUDE_uxTaskGetStackHighWaterMark2 must be set to 1 in FreeRTOSConfig.h for this function to be available.</p> <p>Returns the high water mark of the stack associated with xTask. That is, the minimum free stack space there has been (in words, so on a 32 bit machine a value of 1 means 4 bytes) since the task started. The smaller the returned number the closer the task has come to overflowing its stack.</p> <p>uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the same except for their return type. Using configSTACK_DEPTH_TYPE allows the user to determine the return type. It gets around the problem of the value overflowing on 8-bit types without breaking backward compatibility for applications that expect an 8-bit return type.</p> <p>Parameters:</p> <ul> <li><code>xTask</code> Handle of the task associated with the stack to be checked. Set xTask to NULL to check the stack of the calling task.</li> </ul> <p>Returns:</p> <p>The smallest amount of free stack space there has been (in words, so actual spaces on the stack rather than bytes) since the task referenced by xTask was created. </p>"},{"location":"apiStm/task_8h/#function-uxtaskgetsystemstate","title":"function uxTaskGetSystemState","text":"<pre><code>UBaseType_t uxTaskGetSystemState (\nTaskStatus_t *const pxTaskStatusArray,\nconst UBaseType_t uxArraySize,\nuint32_t *const pulTotalRunTime\n) </code></pre> <p>configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for uxTaskGetSystemState() to be available.</p> <p>uxTaskGetSystemState() populates an TaskStatus_t structure for each task in the system. TaskStatus_t structures contain, among other things, members for the task handle, task name, task priority, task state, and total amount of run time consumed by the task. See the TaskStatus_t structure definition in this file for the full member list.</p> <p>NOTE: This function is intended for debugging use only as its use results in the scheduler remaining suspended for an extended period.</p> <p>Parameters:</p> <ul> <li><code>pxTaskStatusArray</code> A pointer to an array of TaskStatus_t structures. The array must contain at least one TaskStatus_t structure for each task that is under the control of the RTOS. The number of tasks under the control of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.</li> <li><code>uxArraySize</code> The size of the array pointed to by the pxTaskStatusArray parameter. The size is specified as the number of indexes in the array, or the number of TaskStatus_t structures contained in the array, not by the number of bytes in the array.</li> <li><code>pulTotalRunTime</code> If configGENERATE_RUN_TIME_STATS is set to 1 in FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the total run time (as defined by the run time stats clock, see http://www.freertos.org/rtos-run-time-stats.html) since the target booted. pulTotalRunTime can be set to NULL to omit the total run time information.</li> </ul> <p>Returns:</p> <p>The number of TaskStatus_t structures that were populated by uxTaskGetSystemState(). This should equal the number returned by the uxTaskGetNumberOfTasks() API function, but will be zero if the value passed in the uxArraySize parameter was too small.</p> <p>Example usage:  </p>"},{"location":"apiStm/task_8h/#function-uxtaskgettasknumber","title":"function uxTaskGetTaskNumber","text":"<pre><code>UBaseType_t uxTaskGetTaskNumber (\nTaskHandle_t xTask\n) </code></pre>"},{"location":"apiStm/task_8h/#function-uxtaskpriorityget","title":"function uxTaskPriorityGet","text":"<pre><code>UBaseType_t uxTaskPriorityGet (\nconst TaskHandle_t xTask\n) </code></pre>"},{"location":"apiStm/task_8h/#function-uxtaskprioritygetfromisr","title":"function uxTaskPriorityGetFromISR","text":"<pre><code>UBaseType_t uxTaskPriorityGetFromISR (\nconst TaskHandle_t xTask\n) </code></pre> <p>task. h </p> <p>A version of uxTaskPriorityGet() that can be used from an ISR. </p>"},{"location":"apiStm/task_8h/#function-uxtaskreseteventitemvalue","title":"function uxTaskResetEventItemValue","text":"<pre><code>TickType_t uxTaskResetEventItemValue (\nvoid\n) </code></pre>"},{"location":"apiStm/task_8h/#function-vtaskallocatempuregions","title":"function vTaskAllocateMPURegions","text":"<pre><code>void vTaskAllocateMPURegions (\nTaskHandle_t xTask,\nconst MemoryRegion_t *const pxRegions\n) </code></pre>"},{"location":"apiStm/task_8h/#function-vtaskdelay","title":"function vTaskDelay","text":"<pre><code>void vTaskDelay (\nconst TickType_t xTicksToDelay\n) </code></pre>"},{"location":"apiStm/task_8h/#function-vtaskdelayuntil","title":"function vTaskDelayUntil","text":"<pre><code>void vTaskDelayUntil (\nTickType_t *const pxPreviousWakeTime,\nconst TickType_t xTimeIncrement\n) </code></pre>"},{"location":"apiStm/task_8h/#function-vtaskdelete","title":"function vTaskDelete","text":"<pre><code>void vTaskDelete (\nTaskHandle_t xTaskToDelete\n) </code></pre>"},{"location":"apiStm/task_8h/#function-vtaskendscheduler","title":"function vTaskEndScheduler","text":"<pre><code>void vTaskEndScheduler (\nvoid\n) </code></pre>"},{"location":"apiStm/task_8h/#function-vtaskgetinfo","title":"function vTaskGetInfo","text":"<pre><code>void vTaskGetInfo (\nTaskHandle_t xTask,\nTaskStatus_t * pxTaskStatus,\nBaseType_t xGetFreeStackSpace,\neTaskState eState\n) </code></pre>"},{"location":"apiStm/task_8h/#function-vtaskgetruntimestats","title":"function vTaskGetRunTimeStats","text":"<pre><code>void vTaskGetRunTimeStats (\nchar * pcWriteBuffer\n) </code></pre>"},{"location":"apiStm/task_8h/#function-vtaskinternalsettimeoutstate","title":"function vTaskInternalSetTimeOutState","text":"<pre><code>void vTaskInternalSetTimeOutState (\nTimeOut_t *const pxTimeOut\n) </code></pre>"},{"location":"apiStm/task_8h/#function-vtasklist","title":"function vTaskList","text":"<pre><code>void vTaskList (\nchar * pcWriteBuffer\n) </code></pre>"},{"location":"apiStm/task_8h/#function-vtaskmissedyield","title":"function vTaskMissedYield","text":"<pre><code>void vTaskMissedYield (\nvoid\n) </code></pre>"},{"location":"apiStm/task_8h/#function-vtasknotifygivefromisr","title":"function vTaskNotifyGiveFromISR","text":"<pre><code>void vTaskNotifyGiveFromISR (\nTaskHandle_t xTaskToNotify,\nBaseType_t * pxHigherPriorityTaskWoken\n) </code></pre>"},{"location":"apiStm/task_8h/#function-vtaskplaceoneventlist","title":"function vTaskPlaceOnEventList","text":"<pre><code>void vTaskPlaceOnEventList (\nList_t *const pxEventList,\nconst TickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/task_8h/#function-vtaskplaceoneventlistrestricted","title":"function vTaskPlaceOnEventListRestricted","text":"<pre><code>void vTaskPlaceOnEventListRestricted (\nList_t *const pxEventList,\nTickType_t xTicksToWait,\nconst BaseType_t xWaitIndefinitely\n) </code></pre>"},{"location":"apiStm/task_8h/#function-vtaskplaceonunorderedeventlist","title":"function vTaskPlaceOnUnorderedEventList","text":"<pre><code>void vTaskPlaceOnUnorderedEventList (\nList_t * pxEventList,\nconst TickType_t xItemValue,\nconst TickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/task_8h/#function-vtaskprioritydisinheritaftertimeout","title":"function vTaskPriorityDisinheritAfterTimeout","text":"<pre><code>void vTaskPriorityDisinheritAfterTimeout (\nTaskHandle_t const pxMutexHolder,\nUBaseType_t uxHighestPriorityWaitingTask\n) </code></pre>"},{"location":"apiStm/task_8h/#function-vtaskpriorityset","title":"function vTaskPrioritySet","text":"<pre><code>void vTaskPrioritySet (\nTaskHandle_t xTask,\nUBaseType_t uxNewPriority\n) </code></pre>"},{"location":"apiStm/task_8h/#function-vtaskremovefromunorderedeventlist","title":"function vTaskRemoveFromUnorderedEventList","text":"<pre><code>void vTaskRemoveFromUnorderedEventList (\nListItem_t * pxEventListItem,\nconst TickType_t xItemValue\n) </code></pre>"},{"location":"apiStm/task_8h/#function-vtaskresume","title":"function vTaskResume","text":"<pre><code>void vTaskResume (\nTaskHandle_t xTaskToResume\n) </code></pre>"},{"location":"apiStm/task_8h/#function-vtasksettasknumber","title":"function vTaskSetTaskNumber","text":"<pre><code>void vTaskSetTaskNumber (\nTaskHandle_t xTask,\nconst UBaseType_t uxHandle\n) </code></pre>"},{"location":"apiStm/task_8h/#function-vtasksettimeoutstate","title":"function vTaskSetTimeOutState","text":"<pre><code>void vTaskSetTimeOutState (\nTimeOut_t *const pxTimeOut\n) </code></pre>"},{"location":"apiStm/task_8h/#function-vtaskstartscheduler","title":"function vTaskStartScheduler","text":"<pre><code>void vTaskStartScheduler (\nvoid\n) </code></pre>"},{"location":"apiStm/task_8h/#function-vtasksteptick","title":"function vTaskStepTick","text":"<pre><code>void vTaskStepTick (\nconst TickType_t xTicksToJump\n) </code></pre>"},{"location":"apiStm/task_8h/#function-vtasksuspend","title":"function vTaskSuspend","text":"<pre><code>void vTaskSuspend (\nTaskHandle_t xTaskToSuspend\n) </code></pre>"},{"location":"apiStm/task_8h/#function-vtasksuspendall","title":"function vTaskSuspendAll","text":"<pre><code>void vTaskSuspendAll (\nvoid\n) </code></pre>"},{"location":"apiStm/task_8h/#function-vtaskswitchcontext","title":"function vTaskSwitchContext","text":"<pre><code>portDONT_DISCARD void vTaskSwitchContext (\nvoid\n) </code></pre>"},{"location":"apiStm/task_8h/#function-xtaskabortdelay","title":"function xTaskAbortDelay","text":"<pre><code>BaseType_t xTaskAbortDelay (\nTaskHandle_t xTask\n) </code></pre>"},{"location":"apiStm/task_8h/#function-xtaskcallapplicationtaskhook","title":"function xTaskCallApplicationTaskHook","text":"<pre><code>BaseType_t xTaskCallApplicationTaskHook (\nTaskHandle_t xTask,\nvoid * pvParameter\n) </code></pre> <p>task.h </p> <p>Calls the hook function associated with xTask. Passing xTask as NULL has the effect of calling the Running tasks (the calling task) hook function.</p> <p>pvParameter is passed to the hook function for the task to interpret as it wants. The return value is the value returned by the task hook function registered by the user. </p>"},{"location":"apiStm/task_8h/#function-xtaskcatchupticks","title":"function xTaskCatchUpTicks","text":"<pre><code>BaseType_t xTaskCatchUpTicks (\nTickType_t xTicksToCatchUp\n) </code></pre>"},{"location":"apiStm/task_8h/#function-xtaskcheckfortimeout","title":"function xTaskCheckForTimeOut","text":"<pre><code>BaseType_t xTaskCheckForTimeOut (\nTimeOut_t *const pxTimeOut,\nTickType_t *const pxTicksToWait\n) </code></pre>"},{"location":"apiStm/task_8h/#function-xtaskgenericnotify","title":"function xTaskGenericNotify","text":"<pre><code>BaseType_t xTaskGenericNotify (\nTaskHandle_t xTaskToNotify,\nuint32_t ulValue,\neNotifyAction eAction,\nuint32_t * pulPreviousNotificationValue\n) </code></pre>"},{"location":"apiStm/task_8h/#function-xtaskgenericnotifyfromisr","title":"function xTaskGenericNotifyFromISR","text":"<pre><code>BaseType_t xTaskGenericNotifyFromISR (\nTaskHandle_t xTaskToNotify,\nuint32_t ulValue,\neNotifyAction eAction,\nuint32_t * pulPreviousNotificationValue,\nBaseType_t * pxHigherPriorityTaskWoken\n) </code></pre>"},{"location":"apiStm/task_8h/#function-xtaskgetcurrenttaskhandle","title":"function xTaskGetCurrentTaskHandle","text":"<pre><code>TaskHandle_t xTaskGetCurrentTaskHandle (\nvoid\n) </code></pre>"},{"location":"apiStm/task_8h/#function-xtaskgethandle","title":"function xTaskGetHandle","text":"<pre><code>TaskHandle_t xTaskGetHandle (\nconst char * pcNameToQuery\n) </code></pre>"},{"location":"apiStm/task_8h/#function-xtaskgetidletaskhandle","title":"function xTaskGetIdleTaskHandle","text":"<pre><code>TaskHandle_t xTaskGetIdleTaskHandle (\nvoid\n) </code></pre> <p>xTaskGetIdleTaskHandle() is only available if INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.</p> <p>Simply returns the handle of the idle task. It is not valid to call xTaskGetIdleTaskHandle() before the scheduler has been started. </p>"},{"location":"apiStm/task_8h/#function-xtaskgetschedulerstate","title":"function xTaskGetSchedulerState","text":"<pre><code>BaseType_t xTaskGetSchedulerState (\nvoid\n) </code></pre>"},{"location":"apiStm/task_8h/#function-xtaskgettickcount","title":"function xTaskGetTickCount","text":"<pre><code>TickType_t xTaskGetTickCount (\nvoid\n) </code></pre>"},{"location":"apiStm/task_8h/#function-xtaskgettickcountfromisr","title":"function xTaskGetTickCountFromISR","text":"<pre><code>TickType_t xTaskGetTickCountFromISR (\nvoid\n) </code></pre>"},{"location":"apiStm/task_8h/#function-xtaskincrementtick","title":"function xTaskIncrementTick","text":"<pre><code>BaseType_t xTaskIncrementTick (\nvoid\n) </code></pre>"},{"location":"apiStm/task_8h/#function-xtasknotifystateclear","title":"function xTaskNotifyStateClear","text":"<pre><code>BaseType_t xTaskNotifyStateClear (\nTaskHandle_t xTask\n) </code></pre>"},{"location":"apiStm/task_8h/#function-xtasknotifywait","title":"function xTaskNotifyWait","text":"<pre><code>BaseType_t xTaskNotifyWait (\nuint32_t ulBitsToClearOnEntry,\nuint32_t ulBitsToClearOnExit,\nuint32_t * pulNotificationValue,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/task_8h/#function-xtaskprioritydisinherit","title":"function xTaskPriorityDisinherit","text":"<pre><code>BaseType_t xTaskPriorityDisinherit (\nTaskHandle_t const pxMutexHolder\n) </code></pre>"},{"location":"apiStm/task_8h/#function-xtaskpriorityinherit","title":"function xTaskPriorityInherit","text":"<pre><code>BaseType_t xTaskPriorityInherit (\nTaskHandle_t const pxMutexHolder\n) </code></pre>"},{"location":"apiStm/task_8h/#function-xtaskremovefromeventlist","title":"function xTaskRemoveFromEventList","text":"<pre><code>BaseType_t xTaskRemoveFromEventList (\nconst List_t *const pxEventList\n) </code></pre>"},{"location":"apiStm/task_8h/#function-xtaskresumeall","title":"function xTaskResumeAll","text":"<pre><code>BaseType_t xTaskResumeAll (\nvoid\n) </code></pre>"},{"location":"apiStm/task_8h/#function-xtaskresumefromisr","title":"function xTaskResumeFromISR","text":"<pre><code>BaseType_t xTaskResumeFromISR (\nTaskHandle_t xTaskToResume\n) </code></pre>"},{"location":"apiStm/task_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/task_8h/#define-taskdisable_interrupts","title":"define taskDISABLE_INTERRUPTS","text":"<pre><code>#define taskDISABLE_INTERRUPTS (\n\n) portDISABLE_INTERRUPTS()\n</code></pre>"},{"location":"apiStm/task_8h/#define-taskenable_interrupts","title":"define taskENABLE_INTERRUPTS","text":"<pre><code>#define taskENABLE_INTERRUPTS (\n\n) portENABLE_INTERRUPTS()\n</code></pre>"},{"location":"apiStm/task_8h/#define-taskenter_critical","title":"define taskENTER_CRITICAL","text":"<pre><code>#define taskENTER_CRITICAL (\n\n) portENTER_CRITICAL()\n</code></pre>"},{"location":"apiStm/task_8h/#define-taskenter_critical_from_isr","title":"define taskENTER_CRITICAL_FROM_ISR","text":"<pre><code>#define taskENTER_CRITICAL_FROM_ISR (\n\n) portSET_INTERRUPT_MASK_FROM_ISR()\n</code></pre>"},{"location":"apiStm/task_8h/#define-taskexit_critical","title":"define taskEXIT_CRITICAL","text":"<pre><code>#define taskEXIT_CRITICAL (\n\n) portEXIT_CRITICAL()\n</code></pre>"},{"location":"apiStm/task_8h/#define-taskexit_critical_from_isr","title":"define taskEXIT_CRITICAL_FROM_ISR","text":"<pre><code>#define taskEXIT_CRITICAL_FROM_ISR (\nx\n) portCLEAR_INTERRUPT_MASK_FROM_ISR( x )\n</code></pre>"},{"location":"apiStm/task_8h/#define-taskscheduler_not_started","title":"define taskSCHEDULER_NOT_STARTED","text":"<pre><code>#define taskSCHEDULER_NOT_STARTED ( ( BaseType_t ) 1 )\n</code></pre>"},{"location":"apiStm/task_8h/#define-taskscheduler_running","title":"define taskSCHEDULER_RUNNING","text":"<pre><code>#define taskSCHEDULER_RUNNING ( ( BaseType_t ) 2 )\n</code></pre>"},{"location":"apiStm/task_8h/#define-taskscheduler_suspended","title":"define taskSCHEDULER_SUSPENDED","text":"<pre><code>#define taskSCHEDULER_SUSPENDED ( ( BaseType_t ) 0 )\n</code></pre>"},{"location":"apiStm/task_8h/#define-taskyield","title":"define taskYIELD","text":"<pre><code>#define taskYIELD (\n\n) portYIELD()\n</code></pre>"},{"location":"apiStm/task_8h/#define-tskidle_priority","title":"define tskIDLE_PRIORITY","text":"<pre><code>#define tskIDLE_PRIORITY ( ( UBaseType_t ) 0U )\n</code></pre> <p>Defines the priority used by the idle task. This must not be modified. </p>"},{"location":"apiStm/task_8h/#define-tskkernel_version_build","title":"define tskKERNEL_VERSION_BUILD","text":"<pre><code>#define tskKERNEL_VERSION_BUILD 1\n</code></pre>"},{"location":"apiStm/task_8h/#define-tskkernel_version_major","title":"define tskKERNEL_VERSION_MAJOR","text":"<pre><code>#define tskKERNEL_VERSION_MAJOR 10\n</code></pre>"},{"location":"apiStm/task_8h/#define-tskkernel_version_minor","title":"define tskKERNEL_VERSION_MINOR","text":"<pre><code>#define tskKERNEL_VERSION_MINOR 3\n</code></pre>"},{"location":"apiStm/task_8h/#define-tskkernel_version_number","title":"define tskKERNEL_VERSION_NUMBER","text":"<pre><code>#define tskKERNEL_VERSION_NUMBER \"V10.3.1\"\n</code></pre>"},{"location":"apiStm/task_8h/#define-tskmpu_region_device_memory","title":"define tskMPU_REGION_DEVICE_MEMORY","text":"<pre><code>#define tskMPU_REGION_DEVICE_MEMORY ( 1UL &lt;&lt; 4UL )\n</code></pre>"},{"location":"apiStm/task_8h/#define-tskmpu_region_execute_never","title":"define tskMPU_REGION_EXECUTE_NEVER","text":"<pre><code>#define tskMPU_REGION_EXECUTE_NEVER ( 1UL &lt;&lt; 2UL )\n</code></pre>"},{"location":"apiStm/task_8h/#define-tskmpu_region_normal_memory","title":"define tskMPU_REGION_NORMAL_MEMORY","text":"<pre><code>#define tskMPU_REGION_NORMAL_MEMORY ( 1UL &lt;&lt; 3UL )\n</code></pre>"},{"location":"apiStm/task_8h/#define-tskmpu_region_read_only","title":"define tskMPU_REGION_READ_ONLY","text":"<pre><code>#define tskMPU_REGION_READ_ONLY ( 1UL &lt;&lt; 0UL )\n</code></pre>"},{"location":"apiStm/task_8h/#define-tskmpu_region_read_write","title":"define tskMPU_REGION_READ_WRITE","text":"<pre><code>#define tskMPU_REGION_READ_WRITE ( 1UL &lt;&lt; 1UL )\n</code></pre>"},{"location":"apiStm/task_8h/#define-xtasknotify","title":"define xTaskNotify","text":"<pre><code>#define xTaskNotify (\nxTaskToNotify,\nulValue,\neAction\n) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL )\n</code></pre>"},{"location":"apiStm/task_8h/#define-xtasknotifyandquery","title":"define xTaskNotifyAndQuery","text":"<pre><code>#define xTaskNotifyAndQuery (\nxTaskToNotify,\nulValue,\neAction,\npulPreviousNotifyValue\n) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotifyValue ) )\n</code></pre>"},{"location":"apiStm/task_8h/#define-xtasknotifyandqueryfromisr","title":"define xTaskNotifyAndQueryFromISR","text":"<pre><code>#define xTaskNotifyAndQueryFromISR (\nxTaskToNotify,\nulValue,\neAction,\npulPreviousNotificationValue,\npxHigherPriorityTaskWoken\n) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotificationValue ), ( pxHigherPriorityTaskWoken ) )\n</code></pre>"},{"location":"apiStm/task_8h/#define-xtasknotifyfromisr","title":"define xTaskNotifyFromISR","text":"<pre><code>#define xTaskNotifyFromISR (\nxTaskToNotify,\nulValue,\neAction,\npxHigherPriorityTaskWoken\n) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL, ( pxHigherPriorityTaskWoken ) )\n</code></pre>"},{"location":"apiStm/task_8h/#define-xtasknotifygive","title":"define xTaskNotifyGive","text":"<pre><code>#define xTaskNotifyGive (\nxTaskToNotify\n) xTaskGenericNotify( ( xTaskToNotify ), ( 0 ), eIncrement, NULL )\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/task.h</code></p>"},{"location":"apiStm/task_8h_source/","title":"File task.h","text":"<p>File List &gt; FreeRTOS &gt; include &gt; task.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n\n#ifndef INC_TASK_H\n#define INC_TASK_H\n\n#ifndef INC_FREERTOS_H\n#error \"include FreeRTOS.h must appear in source files before include task.h\"\n#endif\n\n#include \"list.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*-----------------------------------------------------------\n * MACROS AND DEFINITIONS\n *----------------------------------------------------------*/\n\n#define tskKERNEL_VERSION_NUMBER \"V10.3.1\"\n#define tskKERNEL_VERSION_MAJOR 10\n#define tskKERNEL_VERSION_MINOR 3\n#define tskKERNEL_VERSION_BUILD 1\n\n/* MPU region parameters passed in ulParameters\n * of MemoryRegion_t struct. */\n#define tskMPU_REGION_READ_ONLY         ( 1UL &lt;&lt; 0UL )\n#define tskMPU_REGION_READ_WRITE        ( 1UL &lt;&lt; 1UL )\n#define tskMPU_REGION_EXECUTE_NEVER     ( 1UL &lt;&lt; 2UL )\n#define tskMPU_REGION_NORMAL_MEMORY     ( 1UL &lt;&lt; 3UL )\n#define tskMPU_REGION_DEVICE_MEMORY     ( 1UL &lt;&lt; 4UL )\n\nstruct tskTaskControlBlock; /* The old naming convention is used to prevent breaking kernel aware debuggers. */\ntypedef struct tskTaskControlBlock* TaskHandle_t;\n\n/*\n * Defines the prototype to which the application task hook function must\n * conform.\n */\ntypedef BaseType_t (*TaskHookFunction_t)( void * );\n\n/* Task states returned by eTaskGetState. */\ntypedef enum\n{\neRunning = 0,   /* A task is querying the state of itself, so must be running. */\neReady,         /* The task being queried is in a read or pending ready list. */\neBlocked,       /* The task being queried is in the Blocked state. */\neSuspended,     /* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */\neDeleted,       /* The task being queried has been deleted, but its TCB has not yet been freed. */\neInvalid        /* Used as an 'invalid state' value. */\n} eTaskState;\n\n/* Actions that can be performed when vTaskNotify() is called. */\ntypedef enum\n{\neNoAction = 0,              /* Notify the task without updating its notify value. */\neSetBits,                   /* Set bits in the task's notification value. */\neIncrement,                 /* Increment the task's notification value. */\neSetValueWithOverwrite,     /* Set the task's notification value to a specific value even if the previous value has not yet been read by the task. */\neSetValueWithoutOverwrite   /* Set the task's notification value if the previous value has been read by the task. */\n} eNotifyAction;\n\n/*\n * Used internally only.\n */\ntypedef struct xTIME_OUT\n{\nBaseType_t xOverflowCount;\nTickType_t xTimeOnEntering;\n} TimeOut_t;\n\n/*\n * Defines the memory ranges allocated to the task when an MPU is used.\n */\ntypedef struct xMEMORY_REGION\n{\nvoid *pvBaseAddress;\nuint32_t ulLengthInBytes;\nuint32_t ulParameters;\n} MemoryRegion_t;\n\n/*\n * Parameters required to create an MPU protected task.\n */\ntypedef struct xTASK_PARAMETERS\n{\nTaskFunction_t pvTaskCode;\nconst char * const pcName;  /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\nconfigSTACK_DEPTH_TYPE usStackDepth;\nvoid *pvParameters;\nUBaseType_t uxPriority;\nStackType_t *puxStackBuffer;\nMemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];\n#if ( ( portUSING_MPU_WRAPPERS == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) )\nStaticTask_t * const pxTaskBuffer;\n#endif\n} TaskParameters_t;\n\n/* Used with the uxTaskGetSystemState() function to return the state of each task\nin the system. */\ntypedef struct xTASK_STATUS\n{\nTaskHandle_t xHandle;           /* The handle of the task to which the rest of the information in the structure relates. */\nconst char *pcTaskName;         /* A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\nUBaseType_t xTaskNumber;        /* A number unique to the task. */\neTaskState eCurrentState;       /* The state in which the task existed when the structure was populated. */\nUBaseType_t uxCurrentPriority;  /* The priority at which the task was running (may be inherited) when the structure was populated. */\nUBaseType_t uxBasePriority;     /* The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. */\nuint32_t ulRunTimeCounter;      /* The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. */\nStackType_t *pxStackBase;       /* Points to the lowest address of the task's stack area. */\nconfigSTACK_DEPTH_TYPE usStackHighWaterMark;    /* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. */\n} TaskStatus_t;\n\n/* Possible return values for eTaskConfirmSleepModeStatus(). */\ntypedef enum\n{\neAbortSleep = 0,        /* A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. */\neStandardSleep,         /* Enter a sleep mode that will not last any longer than the expected idle time. */\neNoTasksWaitingTimeout  /* No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. */\n} eSleepModeStatus;\n\n#define tskIDLE_PRIORITY            ( ( UBaseType_t ) 0U )\n\n#define taskYIELD()                 portYIELD()\n\n#define taskENTER_CRITICAL()        portENTER_CRITICAL()\n#define taskENTER_CRITICAL_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()\n\n#define taskEXIT_CRITICAL()         portEXIT_CRITICAL()\n#define taskEXIT_CRITICAL_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( x )\n#define taskDISABLE_INTERRUPTS()    portDISABLE_INTERRUPTS()\n\n#define taskENABLE_INTERRUPTS()     portENABLE_INTERRUPTS()\n\n/* Definitions returned by xTaskGetSchedulerState().  taskSCHEDULER_SUSPENDED is\n0 to generate more optimal code when configASSERT() is defined as the constant\nis used in assert() statements. */\n#define taskSCHEDULER_SUSPENDED     ( ( BaseType_t ) 0 )\n#define taskSCHEDULER_NOT_STARTED   ( ( BaseType_t ) 1 )\n#define taskSCHEDULER_RUNNING       ( ( BaseType_t ) 2 )\n\n\n/*-----------------------------------------------------------\n * TASK CREATION API\n *----------------------------------------------------------*/\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\nBaseType_t xTaskCreate( TaskFunction_t pxTaskCode,\nconst char * const pcName,  /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\nconst configSTACK_DEPTH_TYPE usStackDepth,\nvoid * const pvParameters,\nUBaseType_t uxPriority,\nTaskHandle_t * const pxCreatedTask ) PRIVILEGED_FUNCTION;\n#endif\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\nTaskHandle_t xTaskCreateStatic( TaskFunction_t pxTaskCode,\nconst char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\nconst uint32_t ulStackDepth,\nvoid * const pvParameters,\nUBaseType_t uxPriority,\nStackType_t * const puxStackBuffer,\nStaticTask_t * const pxTaskBuffer ) PRIVILEGED_FUNCTION;\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n\n#if( portUSING_MPU_WRAPPERS == 1 )\nBaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) PRIVILEGED_FUNCTION;\n#endif\n\n#if( ( portUSING_MPU_WRAPPERS == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) )\nBaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) PRIVILEGED_FUNCTION;\n#endif\n\nvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) PRIVILEGED_FUNCTION;\n\nvoid vTaskDelete( TaskHandle_t xTaskToDelete ) PRIVILEGED_FUNCTION;\n\n/*-----------------------------------------------------------\n * TASK CONTROL API\n *----------------------------------------------------------*/\n\nvoid vTaskDelay( const TickType_t xTicksToDelay ) PRIVILEGED_FUNCTION;\n\nvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) PRIVILEGED_FUNCTION;\n\nBaseType_t xTaskAbortDelay( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\nUBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\nUBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\neTaskState eTaskGetState( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\nvoid vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) PRIVILEGED_FUNCTION;\n\nvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) PRIVILEGED_FUNCTION;\n\nvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) PRIVILEGED_FUNCTION;\n\nvoid vTaskResume( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;\n\nBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;\n\n/*-----------------------------------------------------------\n * SCHEDULER CONTROL\n *----------------------------------------------------------*/\n\nvoid vTaskStartScheduler( void ) PRIVILEGED_FUNCTION;\n\nvoid vTaskEndScheduler( void ) PRIVILEGED_FUNCTION;\n\nvoid vTaskSuspendAll( void ) PRIVILEGED_FUNCTION;\n\nBaseType_t xTaskResumeAll( void ) PRIVILEGED_FUNCTION;\n\n/*-----------------------------------------------------------\n * TASK UTILITIES\n *----------------------------------------------------------*/\n\nTickType_t xTaskGetTickCount( void ) PRIVILEGED_FUNCTION;\n\nTickType_t xTaskGetTickCountFromISR( void ) PRIVILEGED_FUNCTION;\n\nUBaseType_t uxTaskGetNumberOfTasks( void ) PRIVILEGED_FUNCTION;\n\nchar *pcTaskGetName( TaskHandle_t xTaskToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\nTaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\nUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\nconfigSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/* When using trace macros it is sometimes necessary to include task.h before\nFreeRTOS.h.  When this is done TaskHookFunction_t will not yet have been defined,\nso the following two prototypes will cause a compilation error.  This can be\nfixed by simply guarding against the inclusion of these two prototypes unless\nthey are explicitly required by the configUSE_APPLICATION_TASK_TAG configuration\nconstant. */\n#ifdef configUSE_APPLICATION_TASK_TAG\n#if configUSE_APPLICATION_TASK_TAG == 1\nvoid vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction ) PRIVILEGED_FUNCTION;\n\nTaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\nTaskHookFunction_t xTaskGetApplicationTaskTagFromISR( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n#endif /* configUSE_APPLICATION_TASK_TAG ==1 */\n#endif /* ifdef configUSE_APPLICATION_TASK_TAG */\n\n#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 )\n\n/* Each task contains an array of pointers that is dimensioned by the\n    configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.  The\n    kernel does not use the pointers itself, so the application writer can use\n    the pointers for any purpose they wish.  The following two functions are\n    used to set and query a pointer respectively. */\nvoid vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) PRIVILEGED_FUNCTION;\nvoid *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) PRIVILEGED_FUNCTION;\n\n#endif\n\nBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) PRIVILEGED_FUNCTION;\n\nTaskHandle_t xTaskGetIdleTaskHandle( void ) PRIVILEGED_FUNCTION;\n\nUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) PRIVILEGED_FUNCTION;\n\nvoid vTaskList( char * pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\nvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\nuint32_t ulTaskGetIdleRunTimeCounter( void ) PRIVILEGED_FUNCTION;\n\nBaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) PRIVILEGED_FUNCTION;\n#define xTaskNotify( xTaskToNotify, ulValue, eAction ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL )\n#define xTaskNotifyAndQuery( xTaskToNotify, ulValue, eAction, pulPreviousNotifyValue ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotifyValue ) )\n\nBaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;\n#define xTaskNotifyFromISR( xTaskToNotify, ulValue, eAction, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL, ( pxHigherPriorityTaskWoken ) )\n#define xTaskNotifyAndQueryFromISR( xTaskToNotify, ulValue, eAction, pulPreviousNotificationValue, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotificationValue ), ( pxHigherPriorityTaskWoken ) )\n\nBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\n\n#define xTaskNotifyGive( xTaskToNotify ) xTaskGenericNotify( ( xTaskToNotify ), ( 0 ), eIncrement, NULL )\n\nvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;\n\nuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\n\nBaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );\n\nuint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear ) PRIVILEGED_FUNCTION;\n\nvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;\n\nBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) PRIVILEGED_FUNCTION;\n\n/*-----------------------------------------------------------\n * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES\n *----------------------------------------------------------*/\n\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY\n * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS\n * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * Called from the real time kernel tick (either preemptive or cooperative),\n * this increments the tick count and checks if any tasks that are blocked\n * for a finite period required removing from a blocked list and placing on\n * a ready list.  If a non-zero value is returned then a context switch is\n * required because either:\n *   + A task was removed from a blocked list because its timeout had expired,\n *     or\n *   + Time slicing is in use and there is a task of equal priority to the\n *     currently running task.\n */\nBaseType_t xTaskIncrementTick( void ) PRIVILEGED_FUNCTION;\n\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN\n * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.\n *\n * Removes the calling task from the ready list and places it both\n * on the list of tasks waiting for a particular event, and the\n * list of delayed tasks.  The task will be removed from both lists\n * and replaced on the ready list should either the event occur (and\n * there be no higher priority tasks waiting on the same event) or\n * the delay period expires.\n *\n * The 'unordered' version replaces the event list item value with the\n * xItemValue value, and inserts the list item at the end of the list.\n *\n * The 'ordered' version uses the existing event list item value (which is the\n * owning tasks priority) to insert the list item into the event list is task\n * priority order.\n *\n * @param pxEventList The list containing tasks that are blocked waiting\n * for the event to occur.\n *\n * @param xItemValue The item value to use for the event list item when the\n * event list is not ordered by task priority.\n *\n * @param xTicksToWait The maximum amount of time that the task should wait\n * for the event to occur.  This is specified in kernel ticks,the constant\n * portTICK_PERIOD_MS can be used to convert kernel ticks into a real time\n * period.\n */\nvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\nvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\n\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN\n * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.\n *\n * This function performs nearly the same function as vTaskPlaceOnEventList().\n * The difference being that this function does not permit tasks to block\n * indefinitely, whereas vTaskPlaceOnEventList() does.\n *\n */\nvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;\n\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN\n * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.\n *\n * Removes a task from both the specified event list and the list of blocked\n * tasks, and places it on a ready queue.\n *\n * xTaskRemoveFromEventList()/vTaskRemoveFromUnorderedEventList() will be called\n * if either an event occurs to unblock a task, or the block timeout period\n * expires.\n *\n * xTaskRemoveFromEventList() is used when the event list is in task priority\n * order.  It removes the list item from the head of the event list as that will\n * have the highest priority owning task of all the tasks on the event list.\n * vTaskRemoveFromUnorderedEventList() is used when the event list is not\n * ordered and the event list items hold something other than the owning tasks\n * priority.  In this case the event list item value is updated to the value\n * passed in the xItemValue parameter.\n *\n * @return pdTRUE if the task being removed has a higher priority than the task\n * making the call, otherwise pdFALSE.\n */\nBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) PRIVILEGED_FUNCTION;\nvoid vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) PRIVILEGED_FUNCTION;\n\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY\n * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS\n * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * Sets the pointer to the current TCB to the TCB of the highest priority task\n * that is ready to run.\n */\nportDONT_DISCARD void vTaskSwitchContext( void ) PRIVILEGED_FUNCTION;\n\n/*\n * THESE FUNCTIONS MUST NOT BE USED FROM APPLICATION CODE.  THEY ARE USED BY\n * THE EVENT BITS MODULE.\n */\nTickType_t uxTaskResetEventItemValue( void ) PRIVILEGED_FUNCTION;\n\n/*\n * Return the handle of the calling task.\n */\nTaskHandle_t xTaskGetCurrentTaskHandle( void ) PRIVILEGED_FUNCTION;\n\n/*\n * Shortcut used by the queue implementation to prevent unnecessary call to\n * taskYIELD();\n */\nvoid vTaskMissedYield( void ) PRIVILEGED_FUNCTION;\n\n/*\n * Returns the scheduler state as taskSCHEDULER_RUNNING,\n * taskSCHEDULER_NOT_STARTED or taskSCHEDULER_SUSPENDED.\n */\nBaseType_t xTaskGetSchedulerState( void ) PRIVILEGED_FUNCTION;\n\n/*\n * Raises the priority of the mutex holder to that of the calling task should\n * the mutex holder have a priority less than the calling task.\n */\nBaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;\n\n/*\n * Set the priority of a task back to its proper priority in the case that it\n * inherited a higher priority while it was holding a semaphore.\n */\nBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;\n\n/*\n * If a higher priority task attempting to obtain a mutex caused a lower\n * priority task to inherit the higher priority task's priority - but the higher\n * priority task then timed out without obtaining the mutex, then the lower\n * priority task will disinherit the priority again - but only down as far as\n * the highest priority task that is still waiting for the mutex (if there were\n * more than one task waiting for the mutex).\n */\nvoid vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask ) PRIVILEGED_FUNCTION;\n\n/*\n * Get the uxTCBNumber assigned to the task referenced by the xTask parameter.\n */\nUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/*\n * Set the uxTaskNumber of the task referenced by the xTask parameter to\n * uxHandle.\n */\nvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) PRIVILEGED_FUNCTION;\n\n/*\n * Only available when configUSE_TICKLESS_IDLE is set to 1.\n * If tickless mode is being used, or a low power mode is implemented, then\n * the tick interrupt will not execute during idle periods.  When this is the\n * case, the tick count value maintained by the scheduler needs to be kept up\n * to date with the actual execution time by being skipped forward by a time\n * equal to the idle period.\n */\nvoid vTaskStepTick( const TickType_t xTicksToJump ) PRIVILEGED_FUNCTION;\n\n/* Correct the tick count value after the application code has held\ninterrupts disabled for an extended period.  xTicksToCatchUp is the number\nof tick interrupts that have been missed due to interrupts being disabled.\nIts value is not computed automatically, so must be computed by the\napplication writer.\n\nThis function is similar to vTaskStepTick(), however, unlike\nvTaskStepTick(), xTaskCatchUpTicks() may move the tick count forward past a\ntime at which a task should be removed from the blocked state.  That means\ntasks may have to be removed from the blocked state as the tick count is\nmoved. */\nBaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp ) PRIVILEGED_FUNCTION;\n\n/*\n * Only available when configUSE_TICKLESS_IDLE is set to 1.\n * Provided for use within portSUPPRESS_TICKS_AND_SLEEP() to allow the port\n * specific sleep function to determine if it is ok to proceed with the sleep,\n * and if it is ok to proceed, if it is ok to sleep indefinitely.\n *\n * This function is necessary because portSUPPRESS_TICKS_AND_SLEEP() is only\n * called with the scheduler suspended, not from within a critical section.  It\n * is therefore possible for an interrupt to request a context switch between\n * portSUPPRESS_TICKS_AND_SLEEP() and the low power mode actually being\n * entered.  eTaskConfirmSleepModeStatus() should be called from a short\n * critical section between the timer being stopped and the sleep mode being\n * entered to ensure it is ok to proceed into the sleep mode.\n */\neSleepModeStatus eTaskConfirmSleepModeStatus( void ) PRIVILEGED_FUNCTION;\n\n/*\n * For internal use only.  Increment the mutex held count when a mutex is\n * taken and return the handle of the task that has taken the mutex.\n */\nTaskHandle_t pvTaskIncrementMutexHeldCount( void ) PRIVILEGED_FUNCTION;\n\n/*\n * For internal use only.  Same as vTaskSetTimeOutState(), but without a critial\n * section.\n */\nvoid vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;\n\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* INC_TASK_H */\n</code></pre>"},{"location":"apiStm/timers_8h/","title":"File timers.h","text":"<p>FileList &gt; FreeRTOS &gt; include &gt; timers.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"task.h\"</code></li> </ul>"},{"location":"apiStm/timers_8h/#public-types","title":"Public Types","text":"Type Name typedef void(* PendedFunction_t typedef void(* TimerCallbackFunction_t typedef struct tmrTimerControl * TimerHandle_t"},{"location":"apiStm/timers_8h/#public-functions","title":"Public Functions","text":"Type Name const char * pcTimerGetName (TimerHandle_t xTimer)  void * pvTimerGetTimerID (const TimerHandle_t xTimer)  UBaseType_t uxTimerGetReloadMode (TimerHandle_t xTimer)  void vTimerSetReloadMode (TimerHandle_t xTimer, const UBaseType_t uxAutoReload)  void vTimerSetTimerID (TimerHandle_t xTimer, void * pvNewID)  BaseType_t xTimerCreateTimerTask (void)  BaseType_t xTimerGenericCommand (TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t *const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait)  TickType_t xTimerGetExpiryTime (TimerHandle_t xTimer)  TickType_t xTimerGetPeriod (TimerHandle_t xTimer)  TaskHandle_t xTimerGetTimerDaemonTaskHandle (void)  BaseType_t xTimerIsTimerActive (TimerHandle_t xTimer)  BaseType_t xTimerPendFunctionCall (PendedFunction_t xFunctionToPend, void * pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait)  BaseType_t xTimerPendFunctionCallFromISR (PendedFunction_t xFunctionToPend, void * pvParameter1, uint32_t ulParameter2, BaseType_t * pxHigherPriorityTaskWoken)"},{"location":"apiStm/timers_8h/#macros","title":"Macros","text":"Type Name define tmrCOMMAND_CHANGE_PERIOD  ( ( BaseType_t ) 4 ) define tmrCOMMAND_CHANGE_PERIOD_FROM_ISR  ( ( BaseType_t ) 9 ) define tmrCOMMAND_DELETE  ( ( BaseType_t ) 5 ) define tmrCOMMAND_EXECUTE_CALLBACK  ( ( BaseType_t ) -1 ) define tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR  ( ( BaseType_t ) -2 ) define tmrCOMMAND_RESET  ( ( BaseType_t ) 2 ) define tmrCOMMAND_RESET_FROM_ISR  ( ( BaseType_t ) 7 ) define tmrCOMMAND_START  ( ( BaseType_t ) 1 ) define tmrCOMMAND_START_DONT_TRACE  ( ( BaseType_t ) 0 ) define tmrCOMMAND_START_FROM_ISR  ( ( BaseType_t ) 6 ) define tmrCOMMAND_STOP  ( ( BaseType_t ) 3 ) define tmrCOMMAND_STOP_FROM_ISR  ( ( BaseType_t ) 8 ) define tmrFIRST_FROM_ISR_COMMAND  ( ( BaseType_t ) 6 ) define xTimerChangePeriod (xTimer, xNewPeriod, xTicksToWait) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_CHANGE_PERIOD, ( xNewPeriod ), NULL, ( xTicksToWait ) ) define xTimerChangePeriodFromISR (xTimer, xNewPeriod, pxHigherPriorityTaskWoken) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_CHANGE_PERIOD_FROM_ISR, ( xNewPeriod ), ( pxHigherPriorityTaskWoken ), 0U ) define xTimerDelete (xTimer, xTicksToWait) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_DELETE, 0U, NULL, ( xTicksToWait ) ) define xTimerReset (xTimer, xTicksToWait) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_RESET, ( xTaskGetTickCount() ), NULL, ( xTicksToWait ) ) define xTimerResetFromISR (xTimer, pxHigherPriorityTaskWoken) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_RESET_FROM_ISR, ( xTaskGetTickCountFromISR() ), ( pxHigherPriorityTaskWoken ), 0U ) define xTimerStart (xTimer, xTicksToWait) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_START, ( xTaskGetTickCount() ), NULL, ( xTicksToWait ) ) define xTimerStartFromISR (xTimer, pxHigherPriorityTaskWoken) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_START_FROM_ISR, ( xTaskGetTickCountFromISR() ), ( pxHigherPriorityTaskWoken ), 0U ) define xTimerStop (xTimer, xTicksToWait) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_STOP, 0U, NULL, ( xTicksToWait ) ) define xTimerStopFromISR (xTimer, pxHigherPriorityTaskWoken) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_STOP_FROM_ISR, 0, ( pxHigherPriorityTaskWoken ), 0U )"},{"location":"apiStm/timers_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/timers_8h/#typedef-pendedfunction_t","title":"typedef PendedFunction_t","text":"<pre><code>typedef void(* PendedFunction_t) (void *, uint32_t);\n</code></pre>"},{"location":"apiStm/timers_8h/#typedef-timercallbackfunction_t","title":"typedef TimerCallbackFunction_t","text":"<pre><code>typedef void(* TimerCallbackFunction_t) (TimerHandle_t xTimer);\n</code></pre>"},{"location":"apiStm/timers_8h/#typedef-timerhandle_t","title":"typedef TimerHandle_t","text":"<pre><code>typedef struct tmrTimerControl* TimerHandle_t;\n</code></pre>"},{"location":"apiStm/timers_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/timers_8h/#function-pctimergetname","title":"function pcTimerGetName","text":"<pre><code>const char * pcTimerGetName (\nTimerHandle_t xTimer\n) </code></pre> <p>const char * const pcTimerGetName( TimerHandle_t xTimer );</p> <p>Returns the name that was assigned to a timer when the timer was created.</p> <p>Parameters:</p> <ul> <li><code>xTimer</code> The handle of the timer being queried.</li> </ul> <p>Returns:</p> <p>The name assigned to the timer specified by the xTimer parameter. </p>"},{"location":"apiStm/timers_8h/#function-pvtimergettimerid","title":"function pvTimerGetTimerID","text":"<pre><code>void * pvTimerGetTimerID (\nconst TimerHandle_t xTimer\n) </code></pre> <p>TimerHandle_t xTimerCreate( const char * const pcTimerName, TickType_t xTimerPeriodInTicks, UBaseType_t uxAutoReload, void * pvTimerID, TimerCallbackFunction_t pxCallbackFunction );</p> <p>Creates a new software timer instance, and returns a handle by which the created software timer can be referenced.</p> <p>Internally, within the FreeRTOS implementation, software timers use a block of memory, in which the timer data structure is stored. If a software timer is created using xTimerCreate() then the required memory is automatically dynamically allocated inside the xTimerCreate() function. (see http://www.freertos.org/a00111.html). If a software timer is created using xTimerCreateStatic() then the application writer must provide the memory that will get used by the software timer. xTimerCreateStatic() therefore allows a software timer to be created without using any dynamic memory allocation.</p> <p>Timers are created in the dormant state. The xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the active state.</p> <p>Parameters:</p> <ul> <li><code>pcTimerName</code> A text name that is assigned to the timer. This is done purely to assist debugging. The kernel itself only ever references a timer by its handle, and never by its name.</li> <li><code>xTimerPeriodInTicks</code> The timer period. The time is defined in tick periods so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xTimerPeriodInTicks should be set to 100. Alternatively, if the timer must expire after 500ms, then xPeriod can be set to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000.</li> <li><code>uxAutoReload</code> If uxAutoReload is set to pdTRUE then the timer will expire repeatedly with a frequency set by the xTimerPeriodInTicks parameter. If uxAutoReload is set to pdFALSE then the timer will be a one-shot timer and enter the dormant state after it expires.</li> <li><code>pvTimerID</code> An identifier that is assigned to the timer being created. Typically this would be used in the timer callback function to identify which timer expired when the same callback function is assigned to more than one timer.</li> <li><code>pxCallbackFunction</code> The function to call when the timer expires. Callback functions must have the prototype defined by TimerCallbackFunction_t, which is \"void vCallbackFunction( TimerHandle_t xTimer );\".</li> </ul> <p>Returns:</p> <p>If the timer is successfully created then a handle to the newly created timer is returned. If the timer cannot be created (because either there is insufficient FreeRTOS heap remaining to allocate the timer structures, or the timer period was set to 0) then NULL is returned.</p> <p>Example usage:  TimerHandle_t xTimerCreateStatic(const char * const pcTimerName, TickType_t xTimerPeriodInTicks, UBaseType_t uxAutoReload, void * pvTimerID, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t *pxTimerBuffer );</p> <p>Creates a new software timer instance, and returns a handle by which the created software timer can be referenced.</p> <p>Internally, within the FreeRTOS implementation, software timers use a block of memory, in which the timer data structure is stored. If a software timer is created using xTimerCreate() then the required memory is automatically dynamically allocated inside the xTimerCreate() function. (see http://www.freertos.org/a00111.html). If a software timer is created using xTimerCreateStatic() then the application writer must provide the memory that will get used by the software timer. xTimerCreateStatic() therefore allows a software timer to be created without using any dynamic memory allocation.</p> <p>Timers are created in the dormant state. The xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the active state.</p> <p>Parameters:</p> <ul> <li><code>pcTimerName</code> A text name that is assigned to the timer. This is done purely to assist debugging. The kernel itself only ever references a timer by its handle, and never by its name.</li> <li><code>xTimerPeriodInTicks</code> The timer period. The time is defined in tick periods so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xTimerPeriodInTicks should be set to 100. Alternatively, if the timer must expire after 500ms, then xPeriod can be set to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000.</li> <li><code>uxAutoReload</code> If uxAutoReload is set to pdTRUE then the timer will expire repeatedly with a frequency set by the xTimerPeriodInTicks parameter. If uxAutoReload is set to pdFALSE then the timer will be a one-shot timer and enter the dormant state after it expires.</li> <li><code>pvTimerID</code> An identifier that is assigned to the timer being created. Typically this would be used in the timer callback function to identify which timer expired when the same callback function is assigned to more than one timer.</li> <li><code>pxCallbackFunction</code> The function to call when the timer expires. Callback functions must have the prototype defined by TimerCallbackFunction_t, which is \"void vCallbackFunction( TimerHandle_t xTimer );\".</li> <li><code>pxTimerBuffer</code> Must point to a variable of type StaticTimer_t, which will be then be used to hold the software timer's data structures, removing the need for the memory to be allocated dynamically.</li> </ul> <p>Returns:</p> <p>If the timer is created then a handle to the created timer is returned. If pxTimerBuffer was NULL then NULL is returned.</p> <p>Example usage:  void *pvTimerGetTimerID( TimerHandle_t xTimer );</p> <p>Returns the ID assigned to the timer.</p> <p>IDs are assigned to timers using the pvTimerID parameter of the call to xTimerCreated() that was used to create the timer, and by calling the vTimerSetTimerID() API function.</p> <p>If the same callback function is assigned to multiple timers then the timer ID can be used as time specific (timer local) storage.</p> <p>Parameters:</p> <ul> <li><code>xTimer</code> The timer being queried.</li> </ul> <p>Returns:</p> <p>The ID assigned to the timer being queried.</p> <p>Example usage:</p> <p>See the xTimerCreate() API function example usage scenario. </p>"},{"location":"apiStm/timers_8h/#function-uxtimergetreloadmode","title":"function uxTimerGetReloadMode","text":"<pre><code>UBaseType_t uxTimerGetReloadMode (\nTimerHandle_t xTimer\n) </code></pre> <p>UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer );</p> <p>Queries a timer to determine if it is an auto-reload timer, in which case the timer automatically resets itself each time it expires, or a one-shot timer, in which case the timer will only expire once unless it is manually restarted.</p> <p>Parameters:</p> <ul> <li><code>xTimer</code> The handle of the timer being queried.</li> </ul> <p>Returns:</p> <p>If the timer is an auto-reload timer then pdTRUE is returned, otherwise pdFALSE is returned. </p>"},{"location":"apiStm/timers_8h/#function-vtimersetreloadmode","title":"function vTimerSetReloadMode","text":"<pre><code>void vTimerSetReloadMode (\nTimerHandle_t xTimer,\nconst UBaseType_t uxAutoReload\n) </code></pre> <p>void vTimerSetReloadMode( TimerHandle_t xTimer, const UBaseType_t uxAutoReload );</p> <p>Updates a timer to be either an auto-reload timer, in which case the timer automatically resets itself each time it expires, or a one-shot timer, in which case the timer will only expire once unless it is manually restarted.</p> <p>Parameters:</p> <ul> <li><code>xTimer</code> The handle of the timer being updated.</li> <li><code>uxAutoReload</code> If uxAutoReload is set to pdTRUE then the timer will expire repeatedly with a frequency set by the timer's period (see the xTimerPeriodInTicks parameter of the xTimerCreate() API function). If uxAutoReload is set to pdFALSE then the timer will be a one-shot timer and enter the dormant state after it expires. </li> </ul>"},{"location":"apiStm/timers_8h/#function-vtimersettimerid","title":"function vTimerSetTimerID","text":"<pre><code>void vTimerSetTimerID (\nTimerHandle_t xTimer,\nvoid * pvNewID\n) </code></pre> <p>void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID );</p> <p>Sets the ID assigned to the timer.</p> <p>IDs are assigned to timers using the pvTimerID parameter of the call to xTimerCreated() that was used to create the timer.</p> <p>If the same callback function is assigned to multiple timers then the timer ID can be used as time specific (timer local) storage.</p> <p>Parameters:</p> <ul> <li><code>xTimer</code> The timer being updated.</li> <li><code>pvNewID</code> The ID to assign to the timer.</li> </ul> <p>Example usage:</p> <p>See the xTimerCreate() API function example usage scenario. </p>"},{"location":"apiStm/timers_8h/#function-xtimercreatetimertask","title":"function xTimerCreateTimerTask","text":"<pre><code>BaseType_t xTimerCreateTimerTask (\nvoid\n) </code></pre>"},{"location":"apiStm/timers_8h/#function-xtimergenericcommand","title":"function xTimerGenericCommand","text":"<pre><code>BaseType_t xTimerGenericCommand (\nTimerHandle_t xTimer,\nconst BaseType_t xCommandID,\nconst TickType_t xOptionalValue,\nBaseType_t *const pxHigherPriorityTaskWoken,\nconst TickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/timers_8h/#function-xtimergetexpirytime","title":"function xTimerGetExpiryTime","text":"<pre><code>TickType_t xTimerGetExpiryTime (\nTimerHandle_t xTimer\n) </code></pre> <p>TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer );</p> <p>Returns the time in ticks at which the timer will expire. If this is less than the current tick count then the expiry time has overflowed from the current time.</p> <p>Parameters:</p> <ul> <li><code>xTimer</code> The handle of the timer being queried.</li> </ul> <p>Returns:</p> <p>If the timer is running then the time in ticks at which the timer will next expire is returned. If the timer is not running then the return value is undefined. </p>"},{"location":"apiStm/timers_8h/#function-xtimergetperiod","title":"function xTimerGetPeriod","text":"<pre><code>TickType_t xTimerGetPeriod (\nTimerHandle_t xTimer\n) </code></pre> <p>TickType_t xTimerGetPeriod( TimerHandle_t xTimer );</p> <p>Returns the period of a timer.</p> <p>Parameters:</p> <ul> <li><code>xTimer</code> The handle of the timer being queried.</li> </ul> <p>Returns:</p> <p>The period of the timer in ticks. </p>"},{"location":"apiStm/timers_8h/#function-xtimergettimerdaemontaskhandle","title":"function xTimerGetTimerDaemonTaskHandle","text":"<pre><code>TaskHandle_t xTimerGetTimerDaemonTaskHandle (\nvoid\n) </code></pre> <p>TaskHandle_t xTimerGetTimerDaemonTaskHandle( void );</p> <p>Simply returns the handle of the timer service/daemon task. It it not valid to call xTimerGetTimerDaemonTaskHandle() before the scheduler has been started. </p>"},{"location":"apiStm/timers_8h/#function-xtimeristimeractive","title":"function xTimerIsTimerActive","text":"<pre><code>BaseType_t xTimerIsTimerActive (\nTimerHandle_t xTimer\n) </code></pre> <p>BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer );</p> <p>Queries a timer to see if it is active or dormant.</p> <p>A timer will be dormant if: 1) It has been created but not started, or 2) It is an expired one-shot timer that has not been restarted.</p> <p>Timers are created in the dormant state. The xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the active state.</p> <p>Parameters:</p> <ul> <li><code>xTimer</code> The timer being queried.</li> </ul> <p>Returns:</p> <p>pdFALSE will be returned if the timer is dormant. A value other than pdFALSE will be returned if the timer is active.</p> <p>Example usage:  </p>"},{"location":"apiStm/timers_8h/#function-xtimerpendfunctioncall","title":"function xTimerPendFunctionCall","text":"<pre><code>BaseType_t xTimerPendFunctionCall (\nPendedFunction_t xFunctionToPend,\nvoid * pvParameter1,\nuint32_t ulParameter2,\nTickType_t xTicksToWait\n) </code></pre> <p>BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait );</p> <p>Used to defer the execution of a function to the RTOS daemon task (the timer service task, hence this function is implemented in timers.c and is prefixed with 'Timer').</p> <p>Parameters:</p> <ul> <li><code>xFunctionToPend</code> The function to execute from the timer service/ daemon task. The function must conform to the PendedFunction_t prototype.</li> <li><code>pvParameter1</code> The value of the callback function's first parameter. The parameter has a void * type to allow it to be used to pass any type. For example, unsigned longs can be cast to a void *, or the void * can be used to point to a structure.</li> <li><code>ulParameter2</code> The value of the callback function's second parameter.</li> <li><code>xTicksToWait</code> Calling this function will result in a message being sent to the timer daemon task on a queue. xTicksToWait is the amount of time the calling task should remain in the Blocked state (so not using any processing time) for space to become available on the timer queue if the queue is found to be full.</li> </ul> <p>Returns:</p> <p>pdPASS is returned if the message was successfully sent to the timer daemon task, otherwise pdFALSE is returned. </p>"},{"location":"apiStm/timers_8h/#function-xtimerpendfunctioncallfromisr","title":"function xTimerPendFunctionCallFromISR","text":"<pre><code>BaseType_t xTimerPendFunctionCallFromISR (\nPendedFunction_t xFunctionToPend,\nvoid * pvParameter1,\nuint32_t ulParameter2,\nBaseType_t * pxHigherPriorityTaskWoken\n) </code></pre> <p>BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken );</p> <p>Used from application interrupt service routines to defer the execution of a function to the RTOS daemon task (the timer service task, hence this function is implemented in timers.c and is prefixed with 'Timer').</p> <p>Ideally an interrupt service routine (ISR) is kept as short as possible, but sometimes an ISR either has a lot of processing to do, or needs to perform processing that is not deterministic. In these cases xTimerPendFunctionCallFromISR() can be used to defer processing of a function to the RTOS daemon task.</p> <p>A mechanism is provided that allows the interrupt to return directly to the task that will subsequently execute the pended callback function. This allows the callback function to execute contiguously in time with the interrupt - just as if the callback had executed in the interrupt itself.</p> <p>Parameters:</p> <ul> <li><code>xFunctionToPend</code> The function to execute from the timer service/ daemon task. The function must conform to the PendedFunction_t prototype.</li> <li><code>pvParameter1</code> The value of the callback function's first parameter. The parameter has a void * type to allow it to be used to pass any type. For example, unsigned longs can be cast to a void *, or the void * can be used to point to a structure.</li> <li><code>ulParameter2</code> The value of the callback function's second parameter.</li> <li><code>pxHigherPriorityTaskWoken</code> As mentioned above, calling this function will result in a message being sent to the timer daemon task. If the priority of the timer daemon task (which is set using configTIMER_TASK_PRIORITY in FreeRTOSConfig.h) is higher than the priority of the currently running task (the task the interrupt interrupted) then *pxHigherPriorityTaskWoken will be set to pdTRUE within xTimerPendFunctionCallFromISR(), indicating that a context switch should be requested before the interrupt exits. For that reason *pxHigherPriorityTaskWoken must be initialised to pdFALSE. See the example code below.</li> </ul> <p>Returns:</p> <p>pdPASS is returned if the message was successfully sent to the timer daemon task, otherwise pdFALSE is returned.</p> <p>Example usage:  </p>"},{"location":"apiStm/timers_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/timers_8h/#define-tmrcommand_change_period","title":"define tmrCOMMAND_CHANGE_PERIOD","text":"<pre><code>#define tmrCOMMAND_CHANGE_PERIOD ( ( BaseType_t ) 4 )\n</code></pre>"},{"location":"apiStm/timers_8h/#define-tmrcommand_change_period_from_isr","title":"define tmrCOMMAND_CHANGE_PERIOD_FROM_ISR","text":"<pre><code>#define tmrCOMMAND_CHANGE_PERIOD_FROM_ISR ( ( BaseType_t ) 9 )\n</code></pre>"},{"location":"apiStm/timers_8h/#define-tmrcommand_delete","title":"define tmrCOMMAND_DELETE","text":"<pre><code>#define tmrCOMMAND_DELETE ( ( BaseType_t ) 5 )\n</code></pre>"},{"location":"apiStm/timers_8h/#define-tmrcommand_execute_callback","title":"define tmrCOMMAND_EXECUTE_CALLBACK","text":"<pre><code>#define tmrCOMMAND_EXECUTE_CALLBACK ( ( BaseType_t ) -1 )\n</code></pre>"},{"location":"apiStm/timers_8h/#define-tmrcommand_execute_callback_from_isr","title":"define tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR","text":"<pre><code>#define tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR ( ( BaseType_t ) -2 )\n</code></pre>"},{"location":"apiStm/timers_8h/#define-tmrcommand_reset","title":"define tmrCOMMAND_RESET","text":"<pre><code>#define tmrCOMMAND_RESET ( ( BaseType_t ) 2 )\n</code></pre>"},{"location":"apiStm/timers_8h/#define-tmrcommand_reset_from_isr","title":"define tmrCOMMAND_RESET_FROM_ISR","text":"<pre><code>#define tmrCOMMAND_RESET_FROM_ISR ( ( BaseType_t ) 7 )\n</code></pre>"},{"location":"apiStm/timers_8h/#define-tmrcommand_start","title":"define tmrCOMMAND_START","text":"<pre><code>#define tmrCOMMAND_START ( ( BaseType_t ) 1 )\n</code></pre>"},{"location":"apiStm/timers_8h/#define-tmrcommand_start_dont_trace","title":"define tmrCOMMAND_START_DONT_TRACE","text":"<pre><code>#define tmrCOMMAND_START_DONT_TRACE ( ( BaseType_t ) 0 )\n</code></pre>"},{"location":"apiStm/timers_8h/#define-tmrcommand_start_from_isr","title":"define tmrCOMMAND_START_FROM_ISR","text":"<pre><code>#define tmrCOMMAND_START_FROM_ISR ( ( BaseType_t ) 6 )\n</code></pre>"},{"location":"apiStm/timers_8h/#define-tmrcommand_stop","title":"define tmrCOMMAND_STOP","text":"<pre><code>#define tmrCOMMAND_STOP ( ( BaseType_t ) 3 )\n</code></pre>"},{"location":"apiStm/timers_8h/#define-tmrcommand_stop_from_isr","title":"define tmrCOMMAND_STOP_FROM_ISR","text":"<pre><code>#define tmrCOMMAND_STOP_FROM_ISR ( ( BaseType_t ) 8 )\n</code></pre>"},{"location":"apiStm/timers_8h/#define-tmrfirst_from_isr_command","title":"define tmrFIRST_FROM_ISR_COMMAND","text":"<pre><code>#define tmrFIRST_FROM_ISR_COMMAND ( ( BaseType_t ) 6 )\n</code></pre>"},{"location":"apiStm/timers_8h/#define-xtimerchangeperiod","title":"define xTimerChangePeriod","text":"<pre><code>#define xTimerChangePeriod (\nxTimer,\nxNewPeriod,\nxTicksToWait\n) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_CHANGE_PERIOD, ( xNewPeriod ), NULL, ( xTicksToWait ) )\n</code></pre> <p>BaseType_t xTimerChangePeriod( TimerHandle_t xTimer, TickType_t xNewPeriod, TickType_t xTicksToWait );</p> <p>Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.</p> <p>xTimerChangePeriod() changes the period of a timer that was previously created using the xTimerCreate() API function.</p> <p>xTimerChangePeriod() can be called to change the period of an active or dormant state timer.</p> <p>The configUSE_TIMERS configuration constant must be set to 1 for xTimerChangePeriod() to be available.</p> <p>Parameters:</p> <ul> <li><code>xTimer</code> The handle of the timer that is having its period changed.</li> <li><code>xNewPeriod</code> The new period for xTimer. Timer periods are specified in tick periods, so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xNewPeriod should be set to 100. Alternatively, if the timer must expire after 500ms, then xNewPeriod can be set to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000.</li> <li><code>xTicksToWait</code> Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the change period command to be successfully sent to the timer command queue, should the queue already be full when xTimerChangePeriod() was called. xTicksToWait is ignored if xTimerChangePeriod() is called before the scheduler is started.</li> </ul> <p>Returns:</p> <p>pdFAIL will be returned if the change period command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</p> <p>Example usage:  </p>"},{"location":"apiStm/timers_8h/#define-xtimerchangeperiodfromisr","title":"define xTimerChangePeriodFromISR","text":"<pre><code>#define xTimerChangePeriodFromISR (\nxTimer,\nxNewPeriod,\npxHigherPriorityTaskWoken\n) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_CHANGE_PERIOD_FROM_ISR, ( xNewPeriod ), ( pxHigherPriorityTaskWoken ), 0U )\n</code></pre> <p>BaseType_t xTimerChangePeriodFromISR( TimerHandle_t xTimer, TickType_t xNewPeriod, BaseType_t *pxHigherPriorityTaskWoken );</p> <p>A version of xTimerChangePeriod() that can be called from an interrupt service routine.</p> <p>Parameters:</p> <ul> <li><code>xTimer</code> The handle of the timer that is having its period changed.</li> <li><code>xNewPeriod</code> The new period for xTimer. Timer periods are specified in tick periods, so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xNewPeriod should be set to 100. Alternatively, if the timer must expire after 500ms, then xNewPeriod can be set to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000.</li> <li><code>pxHigherPriorityTaskWoken</code> The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling xTimerChangePeriodFromISR() writes a message to the timer command queue, so has the potential to transition the timer service/ daemon task out of the Blocked state. If calling xTimerChangePeriodFromISR() causes the timer service/daemon task to leave the Blocked state, and the timer service/daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the xTimerChangePeriodFromISR() function. If xTimerChangePeriodFromISR() sets this value to pdTRUE then a context switch should be performed before the interrupt exits.</li> </ul> <p>Returns:</p> <p>pdFAIL will be returned if the command to change the timers period could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</p> <p>Example usage:  </p>"},{"location":"apiStm/timers_8h/#define-xtimerdelete","title":"define xTimerDelete","text":"<pre><code>#define xTimerDelete (\nxTimer,\nxTicksToWait\n) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_DELETE, 0U, NULL, ( xTicksToWait ) )\n</code></pre> <p>BaseType_t xTimerDelete( TimerHandle_t xTimer, TickType_t xTicksToWait );</p> <p>Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.</p> <p>xTimerDelete() deletes a timer that was previously created using the xTimerCreate() API function.</p> <p>The configUSE_TIMERS configuration constant must be set to 1 for xTimerDelete() to be available.</p> <p>Parameters:</p> <ul> <li><code>xTimer</code> The handle of the timer being deleted.</li> <li><code>xTicksToWait</code> Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the delete command to be successfully sent to the timer command queue, should the queue already be full when xTimerDelete() was called. xTicksToWait is ignored if xTimerDelete() is called before the scheduler is started.</li> </ul> <p>Returns:</p> <p>pdFAIL will be returned if the delete command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</p> <p>Example usage:</p> <p>See the xTimerChangePeriod() API function example usage scenario. </p>"},{"location":"apiStm/timers_8h/#define-xtimerreset","title":"define xTimerReset","text":"<pre><code>#define xTimerReset (\nxTimer,\nxTicksToWait\n) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_RESET, ( xTaskGetTickCount() ), NULL, ( xTicksToWait ) )\n</code></pre> <p>BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xTicksToWait );</p> <p>Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.</p> <p>xTimerReset() re-starts a timer that was previously created using the xTimerCreate() API function. If the timer had already been started and was already in the active state, then xTimerReset() will cause the timer to re-evaluate its expiry time so that it is relative to when xTimerReset() was called. If the timer was in the dormant state then xTimerReset() has equivalent functionality to the xTimerStart() API function.</p> <p>Resetting a timer ensures the timer is in the active state. If the timer is not stopped, deleted, or reset in the mean time, the callback function associated with the timer will get called 'n' ticks after xTimerReset() was called, where 'n' is the timers defined period.</p> <p>It is valid to call xTimerReset() before the scheduler has been started, but when this is done the timer will not actually start until the scheduler is started, and the timers expiry time will be relative to when the scheduler is started, not relative to when xTimerReset() was called.</p> <p>The configUSE_TIMERS configuration constant must be set to 1 for xTimerReset() to be available.</p> <p>Parameters:</p> <ul> <li><code>xTimer</code> The handle of the timer being reset/started/restarted.</li> <li><code>xTicksToWait</code> Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the reset command to be successfully sent to the timer command queue, should the queue already be full when xTimerReset() was called. xTicksToWait is ignored if xTimerReset() is called before the scheduler is started.</li> </ul> <p>Returns:</p> <p>pdFAIL will be returned if the reset command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when xTimerStart() is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</p> <p>Example usage:  </p>"},{"location":"apiStm/timers_8h/#define-xtimerresetfromisr","title":"define xTimerResetFromISR","text":"<pre><code>#define xTimerResetFromISR (\nxTimer,\npxHigherPriorityTaskWoken\n) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_RESET_FROM_ISR, ( xTaskGetTickCountFromISR() ), ( pxHigherPriorityTaskWoken ), 0U )\n</code></pre> <p>BaseType_t xTimerResetFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriorityTaskWoken );</p> <p>A version of xTimerReset() that can be called from an interrupt service routine.</p> <p>Parameters:</p> <ul> <li><code>xTimer</code> The handle of the timer that is to be started, reset, or restarted.</li> <li><code>pxHigherPriorityTaskWoken</code> The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling xTimerResetFromISR() writes a message to the timer command queue, so has the potential to transition the timer service/daemon task out of the Blocked state. If calling xTimerResetFromISR() causes the timer service/daemon task to leave the Blocked state, and the timer service/ daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the xTimerResetFromISR() function. If xTimerResetFromISR() sets this value to pdTRUE then a context switch should be performed before the interrupt exits.</li> </ul> <p>Returns:</p> <p>pdFAIL will be returned if the reset command could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when xTimerResetFromISR() is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</p> <p>Example usage:  </p>"},{"location":"apiStm/timers_8h/#define-xtimerstart","title":"define xTimerStart","text":"<pre><code>#define xTimerStart (\nxTimer,\nxTicksToWait\n) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_START, ( xTaskGetTickCount() ), NULL, ( xTicksToWait ) )\n</code></pre> <p>BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xTicksToWait );</p> <p>Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.</p> <p>xTimerStart() starts a timer that was previously created using the xTimerCreate() API function. If the timer had already been started and was already in the active state, then xTimerStart() has equivalent functionality to the xTimerReset() API function.</p> <p>Starting a timer ensures the timer is in the active state. If the timer is not stopped, deleted, or reset in the mean time, the callback function associated with the timer will get called 'n' ticks after xTimerStart() was called, where 'n' is the timers defined period.</p> <p>It is valid to call xTimerStart() before the scheduler has been started, but when this is done the timer will not actually start until the scheduler is started, and the timers expiry time will be relative to when the scheduler is started, not relative to when xTimerStart() was called.</p> <p>The configUSE_TIMERS configuration constant must be set to 1 for xTimerStart() to be available.</p> <p>Parameters:</p> <ul> <li><code>xTimer</code> The handle of the timer being started/restarted.</li> <li><code>xTicksToWait</code> Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the start command to be successfully sent to the timer command queue, should the queue already be full when xTimerStart() was called. xTicksToWait is ignored if xTimerStart() is called before the scheduler is started.</li> </ul> <p>Returns:</p> <p>pdFAIL will be returned if the start command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when xTimerStart() is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</p> <p>Example usage:</p> <p>See the xTimerCreate() API function example usage scenario. </p>"},{"location":"apiStm/timers_8h/#define-xtimerstartfromisr","title":"define xTimerStartFromISR","text":"<pre><code>#define xTimerStartFromISR (\nxTimer,\npxHigherPriorityTaskWoken\n) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_START_FROM_ISR, ( xTaskGetTickCountFromISR() ), ( pxHigherPriorityTaskWoken ), 0U )\n</code></pre> <p>BaseType_t xTimerStartFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriorityTaskWoken );</p> <p>A version of xTimerStart() that can be called from an interrupt service routine.</p> <p>Parameters:</p> <ul> <li><code>xTimer</code> The handle of the timer being started/restarted.</li> <li><code>pxHigherPriorityTaskWoken</code> The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling xTimerStartFromISR() writes a message to the timer command queue, so has the potential to transition the timer service/daemon task out of the Blocked state. If calling xTimerStartFromISR() causes the timer service/daemon task to leave the Blocked state, and the timer service/ daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the xTimerStartFromISR() function. If xTimerStartFromISR() sets this value to pdTRUE then a context switch should be performed before the interrupt exits.</li> </ul> <p>Returns:</p> <p>pdFAIL will be returned if the start command could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when xTimerStartFromISR() is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</p> <p>Example usage:  </p>"},{"location":"apiStm/timers_8h/#define-xtimerstop","title":"define xTimerStop","text":"<pre><code>#define xTimerStop (\nxTimer,\nxTicksToWait\n) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_STOP, 0U, NULL, ( xTicksToWait ) )\n</code></pre> <p>BaseType_t xTimerStop( TimerHandle_t xTimer, TickType_t xTicksToWait );</p> <p>Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.</p> <p>xTimerStop() stops a timer that was previously started using either of the The xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() or xTimerChangePeriodFromISR() API functions.</p> <p>Stopping a timer ensures the timer is not in the active state.</p> <p>The configUSE_TIMERS configuration constant must be set to 1 for xTimerStop() to be available.</p> <p>Parameters:</p> <ul> <li><code>xTimer</code> The handle of the timer being stopped.</li> <li><code>xTicksToWait</code> Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the stop command to be successfully sent to the timer command queue, should the queue already be full when xTimerStop() was called. xTicksToWait is ignored if xTimerStop() is called before the scheduler is started.</li> </ul> <p>Returns:</p> <p>pdFAIL will be returned if the stop command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</p> <p>Example usage:</p> <p>See the xTimerCreate() API function example usage scenario. </p>"},{"location":"apiStm/timers_8h/#define-xtimerstopfromisr","title":"define xTimerStopFromISR","text":"<pre><code>#define xTimerStopFromISR (\nxTimer,\npxHigherPriorityTaskWoken\n) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_STOP_FROM_ISR, 0, ( pxHigherPriorityTaskWoken ), 0U )\n</code></pre> <p>BaseType_t xTimerStopFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriorityTaskWoken );</p> <p>A version of xTimerStop() that can be called from an interrupt service routine.</p> <p>Parameters:</p> <ul> <li><code>xTimer</code> The handle of the timer being stopped.</li> <li><code>pxHigherPriorityTaskWoken</code> The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling xTimerStopFromISR() writes a message to the timer command queue, so has the potential to transition the timer service/daemon task out of the Blocked state. If calling xTimerStopFromISR() causes the timer service/daemon task to leave the Blocked state, and the timer service/ daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the xTimerStopFromISR() function. If xTimerStopFromISR() sets this value to pdTRUE then a context switch should be performed before the interrupt exits.</li> </ul> <p>Returns:</p> <p>pdFAIL will be returned if the stop command could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</p> <p>Example usage:  </p> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/include/timers.h</code></p>"},{"location":"apiStm/timers_8h_source/","title":"File timers.h","text":"<p>File List &gt; FreeRTOS &gt; include &gt; timers.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n\n#ifndef TIMERS_H\n#define TIMERS_H\n\n#ifndef INC_FREERTOS_H\n#error \"include FreeRTOS.h must appear in source files before include timers.h\"\n#endif\n\n/*lint -save -e537 This headers are only multiply included if the application code\nhappens to also be including task.h. */\n#include \"task.h\"\n/*lint -restore */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*-----------------------------------------------------------\n * MACROS AND DEFINITIONS\n *----------------------------------------------------------*/\n\n/* IDs for commands that can be sent/received on the timer queue.  These are to\nbe used solely through the macros that make up the public software timer API,\nas defined below.  The commands that are sent from interrupts must use the\nhighest numbers as tmrFIRST_FROM_ISR_COMMAND is used to determine if the task\nor interrupt version of the queue send function should be used. */\n#define tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR    ( ( BaseType_t ) -2 )\n#define tmrCOMMAND_EXECUTE_CALLBACK             ( ( BaseType_t ) -1 )\n#define tmrCOMMAND_START_DONT_TRACE             ( ( BaseType_t ) 0 )\n#define tmrCOMMAND_START                        ( ( BaseType_t ) 1 )\n#define tmrCOMMAND_RESET                        ( ( BaseType_t ) 2 )\n#define tmrCOMMAND_STOP                         ( ( BaseType_t ) 3 )\n#define tmrCOMMAND_CHANGE_PERIOD                ( ( BaseType_t ) 4 )\n#define tmrCOMMAND_DELETE                       ( ( BaseType_t ) 5 )\n\n#define tmrFIRST_FROM_ISR_COMMAND               ( ( BaseType_t ) 6 )\n#define tmrCOMMAND_START_FROM_ISR               ( ( BaseType_t ) 6 )\n#define tmrCOMMAND_RESET_FROM_ISR               ( ( BaseType_t ) 7 )\n#define tmrCOMMAND_STOP_FROM_ISR                ( ( BaseType_t ) 8 )\n#define tmrCOMMAND_CHANGE_PERIOD_FROM_ISR       ( ( BaseType_t ) 9 )\n\n\nstruct tmrTimerControl; /* The old naming convention is used to prevent breaking kernel aware debuggers. */\ntypedef struct tmrTimerControl * TimerHandle_t;\n\n/*\n * Defines the prototype to which timer callback functions must conform.\n */\ntypedef void (*TimerCallbackFunction_t)( TimerHandle_t xTimer );\n\n/*\n * Defines the prototype to which functions used with the\n * xTimerPendFunctionCallFromISR() function must conform.\n */\ntypedef void (*PendedFunction_t)( void *, uint32_t );\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\nTimerHandle_t xTimerCreate( const char * const pcTimerName,         /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\nconst TickType_t xTimerPeriodInTicks,\nconst UBaseType_t uxAutoReload,\nvoid * const pvTimerID,\nTimerCallbackFunction_t pxCallbackFunction ) PRIVILEGED_FUNCTION;\n#endif\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\nTimerHandle_t xTimerCreateStatic(   const char * const pcTimerName,         /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\nconst TickType_t xTimerPeriodInTicks,\nconst UBaseType_t uxAutoReload,\nvoid * const pvTimerID,\nTimerCallbackFunction_t pxCallbackFunction,\nStaticTimer_t *pxTimerBuffer ) PRIVILEGED_FUNCTION;\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n\nvoid *pvTimerGetTimerID( const TimerHandle_t xTimer ) PRIVILEGED_FUNCTION;\n\nvoid vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID ) PRIVILEGED_FUNCTION;\n\nBaseType_t xTimerIsTimerActive( TimerHandle_t xTimer ) PRIVILEGED_FUNCTION;\n\nTaskHandle_t xTimerGetTimerDaemonTaskHandle( void ) PRIVILEGED_FUNCTION;\n\n#define xTimerStart( xTimer, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_START, ( xTaskGetTickCount() ), NULL, ( xTicksToWait ) )\n\n#define xTimerStop( xTimer, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_STOP, 0U, NULL, ( xTicksToWait ) )\n\n#define xTimerChangePeriod( xTimer, xNewPeriod, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_CHANGE_PERIOD, ( xNewPeriod ), NULL, ( xTicksToWait ) )\n\n#define xTimerDelete( xTimer, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_DELETE, 0U, NULL, ( xTicksToWait ) )\n\n#define xTimerReset( xTimer, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_RESET, ( xTaskGetTickCount() ), NULL, ( xTicksToWait ) )\n\n#define xTimerStartFromISR( xTimer, pxHigherPriorityTaskWoken ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_START_FROM_ISR, ( xTaskGetTickCountFromISR() ), ( pxHigherPriorityTaskWoken ), 0U )\n\n#define xTimerStopFromISR( xTimer, pxHigherPriorityTaskWoken ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_STOP_FROM_ISR, 0, ( pxHigherPriorityTaskWoken ), 0U )\n\n#define xTimerChangePeriodFromISR( xTimer, xNewPeriod, pxHigherPriorityTaskWoken ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_CHANGE_PERIOD_FROM_ISR, ( xNewPeriod ), ( pxHigherPriorityTaskWoken ), 0U )\n\n#define xTimerResetFromISR( xTimer, pxHigherPriorityTaskWoken ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_RESET_FROM_ISR, ( xTaskGetTickCountFromISR() ), ( pxHigherPriorityTaskWoken ), 0U )\n\n\nBaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;\n\nBaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\n\nconst char * pcTimerGetName( TimerHandle_t xTimer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\nvoid vTimerSetReloadMode( TimerHandle_t xTimer, const UBaseType_t uxAutoReload ) PRIVILEGED_FUNCTION;\n\nUBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer ) PRIVILEGED_FUNCTION;\n\nTickType_t xTimerGetPeriod( TimerHandle_t xTimer ) PRIVILEGED_FUNCTION;\n\nTickType_t xTimerGetExpiryTime( TimerHandle_t xTimer ) PRIVILEGED_FUNCTION;\n\n/*\n * Functions beyond this part are not part of the public API and are intended\n * for use by the kernel only.\n */\nBaseType_t xTimerCreateTimerTask( void ) PRIVILEGED_FUNCTION;\nBaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\n\n#if( configUSE_TRACE_FACILITY == 1 )\nvoid vTimerSetTimerNumber( TimerHandle_t xTimer, UBaseType_t uxTimerNumber ) PRIVILEGED_FUNCTION;\nUBaseType_t uxTimerGetTimerNumber( TimerHandle_t xTimer ) PRIVILEGED_FUNCTION;\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* TIMERS_H */\n</code></pre>"},{"location":"apiStm/dir_3e946fa640f7764a34038834221bbde8/","title":"Dir fw/rbcx-coprocessor/lib/FreeRTOS/src","text":"<p>FileList &gt; FreeRTOS &gt; src</p>"},{"location":"apiStm/dir_3e946fa640f7764a34038834221bbde8/#files","title":"Files","text":"Type Name file croutine.c file event_groups.c file heap_4.c file list.c file mpu_wrappers.c file port.c file portmacro.h file queue.c file stream_buffer.c file tasks.c file timers.c <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/src/</code></p>"},{"location":"apiStm/croutine_8c/","title":"File croutine.c","text":"<p>FileList &gt; FreeRTOS &gt; src &gt; croutine.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"task.h\"</code></li> <li><code>#include \"croutine.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/src/croutine.c</code></p>"},{"location":"apiStm/croutine_8c_source/","title":"File croutine.c","text":"<p>File List &gt; FreeRTOS &gt; src &gt; croutine.c</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n#include \"croutine.h\"\n\n/* Remove the whole file is co-routines are not being used. */\n#if( configUSE_CO_ROUTINES != 0 )\n\n/*\n * Some kernel aware debuggers require data to be viewed to be global, rather\n * than file scope.\n */\n#ifdef portREMOVE_STATIC_QUALIFIER\n#define static\n#endif\n\n\n/* Lists for ready and blocked co-routines. --------------------*/\nstatic List_t pxReadyCoRoutineLists[ configMAX_CO_ROUTINE_PRIORITIES ]; /*&lt; Prioritised ready co-routines. */\nstatic List_t xDelayedCoRoutineList1;                                   /*&lt; Delayed co-routines. */\nstatic List_t xDelayedCoRoutineList2;                                   /*&lt; Delayed co-routines (two lists are used - one for delays that have overflowed the current tick count. */\nstatic List_t * pxDelayedCoRoutineList;                                 /*&lt; Points to the delayed co-routine list currently being used. */\nstatic List_t * pxOverflowDelayedCoRoutineList;                         /*&lt; Points to the delayed co-routine list currently being used to hold co-routines that have overflowed the current tick count. */\nstatic List_t xPendingReadyCoRoutineList;                               /*&lt; Holds co-routines that have been readied by an external event.  They cannot be added directly to the ready lists as the ready lists cannot be accessed by interrupts. */\n\n/* Other file private variables. --------------------------------*/\nCRCB_t * pxCurrentCoRoutine = NULL;\nstatic UBaseType_t uxTopCoRoutineReadyPriority = 0;\nstatic TickType_t xCoRoutineTickCount = 0, xLastTickCount = 0, xPassedTicks = 0;\n\n/* The initial state of the co-routine when it is created. */\n#define corINITIAL_STATE    ( 0 )\n\n/*\n * Place the co-routine represented by pxCRCB into the appropriate ready queue\n * for the priority.  It is inserted at the end of the list.\n *\n * This macro accesses the co-routine ready lists and therefore must not be\n * used from within an ISR.\n */\n#define prvAddCoRoutineToReadyQueue( pxCRCB )                                                                       \\\n{                                                                                                                   \\\n    if( pxCRCB-&gt;uxPriority &gt; uxTopCoRoutineReadyPriority )                                                          \\\n    {                                                                                                               \\\n        uxTopCoRoutineReadyPriority = pxCRCB-&gt;uxPriority;                                                           \\\n    }                                                                                                               \\\n    vListInsertEnd( ( List_t * ) &amp;( pxReadyCoRoutineLists[ pxCRCB-&gt;uxPriority ] ), &amp;( pxCRCB-&gt;xGenericListItem ) ); \\\n}\n\n/*\n * Utility to ready all the lists used by the scheduler.  This is called\n * automatically upon the creation of the first co-routine.\n */\nstatic void prvInitialiseCoRoutineLists( void );\n\n/*\n * Co-routines that are readied by an interrupt cannot be placed directly into\n * the ready lists (there is no mutual exclusion).  Instead they are placed in\n * in the pending ready list in order that they can later be moved to the ready\n * list by the co-routine scheduler.\n */\nstatic void prvCheckPendingReadyList( void );\n\n/*\n * Macro that looks at the list of co-routines that are currently delayed to\n * see if any require waking.\n *\n * Co-routines are stored in the queue in the order of their wake time -\n * meaning once one co-routine has been found whose timer has not expired\n * we need not look any further down the list.\n */\nstatic void prvCheckDelayedList( void );\n\n/*-----------------------------------------------------------*/\n\nBaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )\n{\nBaseType_t xReturn;\nCRCB_t *pxCoRoutine;\n\n/* Allocate the memory that will store the co-routine control block. */\npxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );\nif( pxCoRoutine )\n{\n/* If pxCurrentCoRoutine is NULL then this is the first co-routine to\n        be created and the co-routine data structures need initialising. */\nif( pxCurrentCoRoutine == NULL )\n{\npxCurrentCoRoutine = pxCoRoutine;\nprvInitialiseCoRoutineLists();\n}\n\n/* Check the priority is within limits. */\nif( uxPriority &gt;= configMAX_CO_ROUTINE_PRIORITIES )\n{\nuxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;\n}\n\n/* Fill out the co-routine control block from the function parameters. */\npxCoRoutine-&gt;uxState = corINITIAL_STATE;\npxCoRoutine-&gt;uxPriority = uxPriority;\npxCoRoutine-&gt;uxIndex = uxIndex;\npxCoRoutine-&gt;pxCoRoutineFunction = pxCoRoutineCode;\n\n/* Initialise all the other co-routine control block parameters. */\nvListInitialiseItem( &amp;( pxCoRoutine-&gt;xGenericListItem ) );\nvListInitialiseItem( &amp;( pxCoRoutine-&gt;xEventListItem ) );\n\n/* Set the co-routine control block as a link back from the ListItem_t.\n        This is so we can get back to the containing CRCB from a generic item\n        in a list. */\nlistSET_LIST_ITEM_OWNER( &amp;( pxCoRoutine-&gt;xGenericListItem ), pxCoRoutine );\nlistSET_LIST_ITEM_OWNER( &amp;( pxCoRoutine-&gt;xEventListItem ), pxCoRoutine );\n\n/* Event lists are always in priority order. */\nlistSET_LIST_ITEM_VALUE( &amp;( pxCoRoutine-&gt;xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );\n\n/* Now the co-routine has been initialised it can be added to the ready\n        list at the correct priority. */\nprvAddCoRoutineToReadyQueue( pxCoRoutine );\n\nxReturn = pdPASS;\n}\nelse\n{\nxReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;\n}\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nvoid vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )\n{\nTickType_t xTimeToWake;\n\n/* Calculate the time to wake - this may overflow but this is\n    not a problem. */\nxTimeToWake = xCoRoutineTickCount + xTicksToDelay;\n\n/* We must remove ourselves from the ready list before adding\n    ourselves to the blocked list as the same list item is used for\n    both lists. */\n( void ) uxListRemove( ( ListItem_t * ) &amp;( pxCurrentCoRoutine-&gt;xGenericListItem ) );\n\n/* The list item will be inserted in wake time order. */\nlistSET_LIST_ITEM_VALUE( &amp;( pxCurrentCoRoutine-&gt;xGenericListItem ), xTimeToWake );\n\nif( xTimeToWake &lt; xCoRoutineTickCount )\n{\n/* Wake time has overflowed.  Place this item in the\n        overflow list. */\nvListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &amp;( pxCurrentCoRoutine-&gt;xGenericListItem ) );\n}\nelse\n{\n/* The wake time has not overflowed, so we can use the\n        current block list. */\nvListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &amp;( pxCurrentCoRoutine-&gt;xGenericListItem ) );\n}\n\nif( pxEventList )\n{\n/* Also add the co-routine to an event list.  If this is done then the\n        function must be called with interrupts disabled. */\nvListInsert( pxEventList, &amp;( pxCurrentCoRoutine-&gt;xEventListItem ) );\n}\n}\n/*-----------------------------------------------------------*/\n\nstatic void prvCheckPendingReadyList( void )\n{\n/* Are there any co-routines waiting to get moved to the ready list?  These\n    are co-routines that have been readied by an ISR.  The ISR cannot access\n    the ready lists itself. */\nwhile( listLIST_IS_EMPTY( &amp;xPendingReadyCoRoutineList ) == pdFALSE )\n{\nCRCB_t *pxUnblockedCRCB;\n\n/* The pending ready list can be accessed by an ISR. */\nportDISABLE_INTERRUPTS();\n{\npxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&amp;xPendingReadyCoRoutineList) );\n( void ) uxListRemove( &amp;( pxUnblockedCRCB-&gt;xEventListItem ) );\n}\nportENABLE_INTERRUPTS();\n\n( void ) uxListRemove( &amp;( pxUnblockedCRCB-&gt;xGenericListItem ) );\nprvAddCoRoutineToReadyQueue( pxUnblockedCRCB );\n}\n}\n/*-----------------------------------------------------------*/\n\nstatic void prvCheckDelayedList( void )\n{\nCRCB_t *pxCRCB;\n\nxPassedTicks = xTaskGetTickCount() - xLastTickCount;\nwhile( xPassedTicks )\n{\nxCoRoutineTickCount++;\nxPassedTicks--;\n\n/* If the tick count has overflowed we need to swap the ready lists. */\nif( xCoRoutineTickCount == 0 )\n{\nList_t * pxTemp;\n\n/* Tick count has overflowed so we need to swap the delay lists.  If there are\n            any items in pxDelayedCoRoutineList here then there is an error! */\npxTemp = pxDelayedCoRoutineList;\npxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;\npxOverflowDelayedCoRoutineList = pxTemp;\n}\n\n/* See if this tick has made a timeout expire. */\nwhile( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )\n{\npxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );\n\nif( xCoRoutineTickCount &lt; listGET_LIST_ITEM_VALUE( &amp;( pxCRCB-&gt;xGenericListItem ) ) )\n{\n/* Timeout not yet expired. */\nbreak;\n}\n\nportDISABLE_INTERRUPTS();\n{\n/* The event could have occurred just before this critical\n                section.  If this is the case then the generic list item will\n                have been moved to the pending ready list and the following\n                line is still valid.  Also the pvContainer parameter will have\n                been set to NULL so the following lines are also valid. */\n( void ) uxListRemove( &amp;( pxCRCB-&gt;xGenericListItem ) );\n\n/* Is the co-routine waiting on an event also? */\nif( pxCRCB-&gt;xEventListItem.pxContainer )\n{\n( void ) uxListRemove( &amp;( pxCRCB-&gt;xEventListItem ) );\n}\n}\nportENABLE_INTERRUPTS();\n\nprvAddCoRoutineToReadyQueue( pxCRCB );\n}\n}\n\nxLastTickCount = xCoRoutineTickCount;\n}\n/*-----------------------------------------------------------*/\n\nvoid vCoRoutineSchedule( void )\n{\n/* See if any co-routines readied by events need moving to the ready lists. */\nprvCheckPendingReadyList();\n\n/* See if any delayed co-routines have timed out. */\nprvCheckDelayedList();\n\n/* Find the highest priority queue that contains ready co-routines. */\nwhile( listLIST_IS_EMPTY( &amp;( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )\n{\nif( uxTopCoRoutineReadyPriority == 0 )\n{\n/* No more co-routines to check. */\nreturn;\n}\n--uxTopCoRoutineReadyPriority;\n}\n\n/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines\n     of the same priority get an equal share of the processor time. */\nlistGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &amp;( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );\n\n/* Call the co-routine. */\n( pxCurrentCoRoutine-&gt;pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine-&gt;uxIndex );\n\nreturn;\n}\n/*-----------------------------------------------------------*/\n\nstatic void prvInitialiseCoRoutineLists( void )\n{\nUBaseType_t uxPriority;\n\nfor( uxPriority = 0; uxPriority &lt; configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )\n{\nvListInitialise( ( List_t * ) &amp;( pxReadyCoRoutineLists[ uxPriority ] ) );\n}\n\nvListInitialise( ( List_t * ) &amp;xDelayedCoRoutineList1 );\nvListInitialise( ( List_t * ) &amp;xDelayedCoRoutineList2 );\nvListInitialise( ( List_t * ) &amp;xPendingReadyCoRoutineList );\n\n/* Start with pxDelayedCoRoutineList using list1 and the\n    pxOverflowDelayedCoRoutineList using list2. */\npxDelayedCoRoutineList = &amp;xDelayedCoRoutineList1;\npxOverflowDelayedCoRoutineList = &amp;xDelayedCoRoutineList2;\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )\n{\nCRCB_t *pxUnblockedCRCB;\nBaseType_t xReturn;\n\n/* This function is called from within an interrupt.  It can only access\n    event lists and the pending ready list.  This function assumes that a\n    check has already been made to ensure pxEventList is not empty. */\npxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );\n( void ) uxListRemove( &amp;( pxUnblockedCRCB-&gt;xEventListItem ) );\nvListInsertEnd( ( List_t * ) &amp;( xPendingReadyCoRoutineList ), &amp;( pxUnblockedCRCB-&gt;xEventListItem ) );\n\nif( pxUnblockedCRCB-&gt;uxPriority &gt;= pxCurrentCoRoutine-&gt;uxPriority )\n{\nxReturn = pdTRUE;\n}\nelse\n{\nxReturn = pdFALSE;\n}\n\nreturn xReturn;\n}\n\n#endif /* configUSE_CO_ROUTINES == 0 */\n</code></pre>"},{"location":"apiStm/event__groups_8c/","title":"File event_groups.c","text":"<p>FileList &gt; FreeRTOS &gt; src &gt; event_groups.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"task.h\"</code></li> <li><code>#include \"timers.h\"</code></li> <li><code>#include \"event_groups.h\"</code></li> </ul>"},{"location":"apiStm/event__groups_8c/#classes","title":"Classes","text":"Type Name struct EventGroupDef_t"},{"location":"apiStm/event__groups_8c/#public-types","title":"Public Types","text":"Type Name typedef struct EventGroupDef_t EventGroup_t"},{"location":"apiStm/event__groups_8c/#public-functions","title":"Public Functions","text":"Type Name void vEventGroupClearBitsCallback (void * pvEventGroup, const uint32_t ulBitsToClear)  void vEventGroupDelete (EventGroupHandle_t xEventGroup)  void vEventGroupSetBitsCallback (void * pvEventGroup, const uint32_t ulBitsToSet)  EventBits_t xEventGroupClearBits (EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear)  EventBits_t xEventGroupGetBitsFromISR (EventGroupHandle_t xEventGroup)  EventBits_t xEventGroupSetBits (EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet)  EventBits_t xEventGroupSync (EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait)  EventBits_t xEventGroupWaitBits (EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait)"},{"location":"apiStm/event__groups_8c/#public-static-functions","title":"Public Static Functions","text":"Type Name BaseType_t prvTestWaitCondition (const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits)"},{"location":"apiStm/event__groups_8c/#macros","title":"Macros","text":"Type Name define MPU_WRAPPERS_INCLUDED_FROM_API_FILE define eventCLEAR_EVENTS_ON_EXIT_BIT  0x01000000UL define eventEVENT_BITS_CONTROL_BYTES  0xff000000UL define eventUNBLOCKED_DUE_TO_BIT_SET  0x02000000UL define eventWAIT_FOR_ALL_BITS  0x04000000UL"},{"location":"apiStm/event__groups_8c/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/event__groups_8c/#typedef-eventgroup_t","title":"typedef EventGroup_t","text":"<pre><code>typedef struct EventGroupDef_t EventGroup_t;\n</code></pre>"},{"location":"apiStm/event__groups_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/event__groups_8c/#function-veventgroupclearbitscallback","title":"function vEventGroupClearBitsCallback","text":"<pre><code>void vEventGroupClearBitsCallback (\nvoid * pvEventGroup,\nconst uint32_t ulBitsToClear\n) </code></pre>"},{"location":"apiStm/event__groups_8c/#function-veventgroupdelete","title":"function vEventGroupDelete","text":"<pre><code>void vEventGroupDelete (\nEventGroupHandle_t xEventGroup\n) </code></pre> <p>event_groups.h </p> <p>Delete an event group that was previously created by a call to xEventGroupCreate(). Tasks that are blocked on the event group will be unblocked and obtain 0 as the event group's value.</p> <p>Parameters:</p> <ul> <li><code>xEventGroup</code> The event group being deleted. </li> </ul>"},{"location":"apiStm/event__groups_8c/#function-veventgroupsetbitscallback","title":"function vEventGroupSetBitsCallback","text":"<pre><code>void vEventGroupSetBitsCallback (\nvoid * pvEventGroup,\nconst uint32_t ulBitsToSet\n) </code></pre>"},{"location":"apiStm/event__groups_8c/#function-xeventgroupclearbits","title":"function xEventGroupClearBits","text":"<pre><code>EventBits_t xEventGroupClearBits (\nEventGroupHandle_t xEventGroup,\nconst EventBits_t uxBitsToClear\n) </code></pre>"},{"location":"apiStm/event__groups_8c/#function-xeventgroupgetbitsfromisr","title":"function xEventGroupGetBitsFromISR","text":"<pre><code>EventBits_t xEventGroupGetBitsFromISR (\nEventGroupHandle_t xEventGroup\n) </code></pre>"},{"location":"apiStm/event__groups_8c/#function-xeventgroupsetbits","title":"function xEventGroupSetBits","text":"<pre><code>EventBits_t xEventGroupSetBits (\nEventGroupHandle_t xEventGroup,\nconst EventBits_t uxBitsToSet\n) </code></pre>"},{"location":"apiStm/event__groups_8c/#function-xeventgroupsync","title":"function xEventGroupSync","text":"<pre><code>EventBits_t xEventGroupSync (\nEventGroupHandle_t xEventGroup,\nconst EventBits_t uxBitsToSet,\nconst EventBits_t uxBitsToWaitFor,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/event__groups_8c/#function-xeventgroupwaitbits","title":"function xEventGroupWaitBits","text":"<pre><code>EventBits_t xEventGroupWaitBits (\nEventGroupHandle_t xEventGroup,\nconst EventBits_t uxBitsToWaitFor,\nconst BaseType_t xClearOnExit,\nconst BaseType_t xWaitForAllBits,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/event__groups_8c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"apiStm/event__groups_8c/#function-prvtestwaitcondition","title":"function prvTestWaitCondition","text":"<pre><code>static BaseType_t prvTestWaitCondition (\nconst EventBits_t uxCurrentEventBits,\nconst EventBits_t uxBitsToWaitFor,\nconst BaseType_t xWaitForAllBits\n) </code></pre>"},{"location":"apiStm/event__groups_8c/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/event__groups_8c/#define-mpu_wrappers_included_from_api_file","title":"define MPU_WRAPPERS_INCLUDED_FROM_API_FILE","text":"<pre><code>#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE \n</code></pre>"},{"location":"apiStm/event__groups_8c/#define-eventclear_events_on_exit_bit","title":"define eventCLEAR_EVENTS_ON_EXIT_BIT","text":"<pre><code>#define eventCLEAR_EVENTS_ON_EXIT_BIT 0x01000000UL\n</code></pre>"},{"location":"apiStm/event__groups_8c/#define-eventevent_bits_control_bytes","title":"define eventEVENT_BITS_CONTROL_BYTES","text":"<pre><code>#define eventEVENT_BITS_CONTROL_BYTES 0xff000000UL\n</code></pre>"},{"location":"apiStm/event__groups_8c/#define-eventunblocked_due_to_bit_set","title":"define eventUNBLOCKED_DUE_TO_BIT_SET","text":"<pre><code>#define eventUNBLOCKED_DUE_TO_BIT_SET 0x02000000UL\n</code></pre>"},{"location":"apiStm/event__groups_8c/#define-eventwait_for_all_bits","title":"define eventWAIT_FOR_ALL_BITS","text":"<pre><code>#define eventWAIT_FOR_ALL_BITS 0x04000000UL\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/src/event_groups.c</code></p>"},{"location":"apiStm/event__groups_8c_source/","title":"File event_groups.c","text":"<p>File List &gt; FreeRTOS &gt; src &gt; event_groups.c</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n/* Standard includes. */\n#include &lt;stdlib.h&gt;\n\n/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining\nall the API functions to use the MPU wrappers.  That should only be done when\ntask.h is included from an application file. */\n#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE\n\n/* FreeRTOS includes. */\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n#include \"timers.h\"\n#include \"event_groups.h\"\n\n/* Lint e961, e750 and e9021 are suppressed as a MISRA exception justified\nbecause the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined\nfor the header files above, but not in this file, in order to generate the\ncorrect privileged Vs unprivileged linkage and placement. */\n#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021 See comment above. */\n\n/* The following bit fields convey control information in a task's event list\nitem value.  It is important they don't clash with the\ntaskEVENT_LIST_ITEM_VALUE_IN_USE definition. */\n#if configUSE_16_BIT_TICKS == 1\n#define eventCLEAR_EVENTS_ON_EXIT_BIT   0x0100U\n#define eventUNBLOCKED_DUE_TO_BIT_SET   0x0200U\n#define eventWAIT_FOR_ALL_BITS          0x0400U\n#define eventEVENT_BITS_CONTROL_BYTES   0xff00U\n#else\n#define eventCLEAR_EVENTS_ON_EXIT_BIT   0x01000000UL\n#define eventUNBLOCKED_DUE_TO_BIT_SET   0x02000000UL\n#define eventWAIT_FOR_ALL_BITS          0x04000000UL\n#define eventEVENT_BITS_CONTROL_BYTES   0xff000000UL\n#endif\n\ntypedef struct EventGroupDef_t\n{\nEventBits_t uxEventBits;\nList_t xTasksWaitingForBits;        /*&lt; List of tasks waiting for a bit to be set. */\n\n#if( configUSE_TRACE_FACILITY == 1 )\nUBaseType_t uxEventGroupNumber;\n#endif\n\n#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )\nuint8_t ucStaticallyAllocated; /*&lt; Set to pdTRUE if the event group is statically allocated to ensure no attempt is made to free the memory. */\n#endif\n} EventGroup_t;\n\n/*-----------------------------------------------------------*/\n\n/*\n * Test the bits set in uxCurrentEventBits to see if the wait condition is met.\n * The wait condition is defined by xWaitForAllBits.  If xWaitForAllBits is\n * pdTRUE then the wait condition is met if all the bits set in uxBitsToWaitFor\n * are also set in uxCurrentEventBits.  If xWaitForAllBits is pdFALSE then the\n * wait condition is met if any of the bits set in uxBitsToWait for are also set\n * in uxCurrentEventBits.\n */\nstatic BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits ) PRIVILEGED_FUNCTION;\n\n/*-----------------------------------------------------------*/\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n\nEventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t *pxEventGroupBuffer )\n{\nEventGroup_t *pxEventBits;\n\n/* A StaticEventGroup_t object must be provided. */\nconfigASSERT( pxEventGroupBuffer );\n\n#if( configASSERT_DEFINED == 1 )\n{\n/* Sanity check that the size of the structure used to declare a\n            variable of type StaticEventGroup_t equals the size of the real\n            event group structure. */\nvolatile size_t xSize = sizeof( StaticEventGroup_t );\nconfigASSERT( xSize == sizeof( EventGroup_t ) );\n} /*lint !e529 xSize is referenced if configASSERT() is defined. */\n#endif /* configASSERT_DEFINED */\n\n/* The user has provided a statically allocated event group - use it. */\npxEventBits = ( EventGroup_t * ) pxEventGroupBuffer; /*lint !e740 !e9087 EventGroup_t and StaticEventGroup_t are deliberately aliased for data hiding purposes and guaranteed to have the same size and alignment requirement - checked by configASSERT(). */\n\nif( pxEventBits != NULL )\n{\npxEventBits-&gt;uxEventBits = 0;\nvListInitialise( &amp;( pxEventBits-&gt;xTasksWaitingForBits ) );\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n{\n/* Both static and dynamic allocation can be used, so note that\n                this event group was created statically in case the event group\n                is later deleted. */\npxEventBits-&gt;ucStaticallyAllocated = pdTRUE;\n}\n#endif /* configSUPPORT_DYNAMIC_ALLOCATION */\n\ntraceEVENT_GROUP_CREATE( pxEventBits );\n}\nelse\n{\n/* xEventGroupCreateStatic should only ever be called with\n            pxEventGroupBuffer pointing to a pre-allocated (compile time\n            allocated) StaticEventGroup_t variable. */\ntraceEVENT_GROUP_CREATE_FAILED();\n}\n\nreturn pxEventBits;\n}\n\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n/*-----------------------------------------------------------*/\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n\nEventGroupHandle_t xEventGroupCreate( void )\n{\nEventGroup_t *pxEventBits;\n\n/* Allocate the event group.  Justification for MISRA deviation as\n        follows:  pvPortMalloc() always ensures returned memory blocks are\n        aligned per the requirements of the MCU stack.  In this case\n        pvPortMalloc() must return a pointer that is guaranteed to meet the\n        alignment requirements of the EventGroup_t structure - which (if you\n        follow it through) is the alignment requirements of the TickType_t type\n        (EventBits_t being of TickType_t itself).  Therefore, whenever the\n        stack alignment requirements are greater than or equal to the\n        TickType_t alignment requirements the cast is safe.  In other cases,\n        where the natural word size of the architecture is less than\n        sizeof( TickType_t ), the TickType_t variables will be accessed in two\n        or more reads operations, and the alignment requirements is only that\n        of each individual read. */\npxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */\n\nif( pxEventBits != NULL )\n{\npxEventBits-&gt;uxEventBits = 0;\nvListInitialise( &amp;( pxEventBits-&gt;xTasksWaitingForBits ) );\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n{\n/* Both static and dynamic allocation can be used, so note this\n                event group was allocated statically in case the event group is\n                later deleted. */\npxEventBits-&gt;ucStaticallyAllocated = pdFALSE;\n}\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n\ntraceEVENT_GROUP_CREATE( pxEventBits );\n}\nelse\n{\ntraceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */\n}\n\nreturn pxEventBits;\n}\n\n#endif /* configSUPPORT_DYNAMIC_ALLOCATION */\n/*-----------------------------------------------------------*/\n\nEventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )\n{\nEventBits_t uxOriginalBitValue, uxReturn;\nEventGroup_t *pxEventBits = xEventGroup;\nBaseType_t xAlreadyYielded;\nBaseType_t xTimeoutOccurred = pdFALSE;\n\nconfigASSERT( ( uxBitsToWaitFor &amp; eventEVENT_BITS_CONTROL_BYTES ) == 0 );\nconfigASSERT( uxBitsToWaitFor != 0 );\n#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )\n{\nconfigASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) &amp;&amp; ( xTicksToWait != 0 ) ) );\n}\n#endif\n\nvTaskSuspendAll();\n{\nuxOriginalBitValue = pxEventBits-&gt;uxEventBits;\n\n( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );\n\nif( ( ( uxOriginalBitValue | uxBitsToSet ) &amp; uxBitsToWaitFor ) == uxBitsToWaitFor )\n{\n/* All the rendezvous bits are now set - no need to block. */\nuxReturn = ( uxOriginalBitValue | uxBitsToSet );\n\n/* Rendezvous always clear the bits.  They will have been cleared\n            already unless this is the only task in the rendezvous. */\npxEventBits-&gt;uxEventBits &amp;= ~uxBitsToWaitFor;\n\nxTicksToWait = 0;\n}\nelse\n{\nif( xTicksToWait != ( TickType_t ) 0 )\n{\ntraceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );\n\n/* Store the bits that the calling task is waiting for in the\n                task's event list item so the kernel knows when a match is\n                found.  Then enter the blocked state. */\nvTaskPlaceOnUnorderedEventList( &amp;( pxEventBits-&gt;xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );\n\n/* This assignment is obsolete as uxReturn will get set after\n                the task unblocks, but some compilers mistakenly generate a\n                warning about uxReturn being returned without being set if the\n                assignment is omitted. */\nuxReturn = 0;\n}\nelse\n{\n/* The rendezvous bits were not set, but no block time was\n                specified - just return the current event bit value. */\nuxReturn = pxEventBits-&gt;uxEventBits;\nxTimeoutOccurred = pdTRUE;\n}\n}\n}\nxAlreadyYielded = xTaskResumeAll();\n\nif( xTicksToWait != ( TickType_t ) 0 )\n{\nif( xAlreadyYielded == pdFALSE )\n{\nportYIELD_WITHIN_API();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\n/* The task blocked to wait for its required bits to be set - at this\n        point either the required bits were set or the block time expired.  If\n        the required bits were set they will have been stored in the task's\n        event list item, and they should now be retrieved then cleared. */\nuxReturn = uxTaskResetEventItemValue();\n\nif( ( uxReturn &amp; eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )\n{\n/* The task timed out, just return the current event bit value. */\ntaskENTER_CRITICAL();\n{\nuxReturn = pxEventBits-&gt;uxEventBits;\n\n/* Although the task got here because it timed out before the\n                bits it was waiting for were set, it is possible that since it\n                unblocked another task has set the bits.  If this is the case\n                then it needs to clear the bits before exiting. */\nif( ( uxReturn &amp; uxBitsToWaitFor ) == uxBitsToWaitFor )\n{\npxEventBits-&gt;uxEventBits &amp;= ~uxBitsToWaitFor;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\ntaskEXIT_CRITICAL();\n\nxTimeoutOccurred = pdTRUE;\n}\nelse\n{\n/* The task unblocked because the bits were set. */\n}\n\n/* Control bits might be set as the task had blocked should not be\n        returned. */\nuxReturn &amp;= ~eventEVENT_BITS_CONTROL_BYTES;\n}\n\ntraceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );\n\n/* Prevent compiler warnings when trace macros are not used. */\n( void ) xTimeoutOccurred;\n\nreturn uxReturn;\n}\n/*-----------------------------------------------------------*/\n\nEventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )\n{\nEventGroup_t *pxEventBits = xEventGroup;\nEventBits_t uxReturn, uxControlBits = 0;\nBaseType_t xWaitConditionMet, xAlreadyYielded;\nBaseType_t xTimeoutOccurred = pdFALSE;\n\n/* Check the user is not attempting to wait on the bits used by the kernel\n    itself, and that at least one bit is being requested. */\nconfigASSERT( xEventGroup );\nconfigASSERT( ( uxBitsToWaitFor &amp; eventEVENT_BITS_CONTROL_BYTES ) == 0 );\nconfigASSERT( uxBitsToWaitFor != 0 );\n#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )\n{\nconfigASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) &amp;&amp; ( xTicksToWait != 0 ) ) );\n}\n#endif\n\nvTaskSuspendAll();\n{\nconst EventBits_t uxCurrentEventBits = pxEventBits-&gt;uxEventBits;\n\n/* Check to see if the wait condition is already met or not. */\nxWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );\n\nif( xWaitConditionMet != pdFALSE )\n{\n/* The wait condition has already been met so there is no need to\n            block. */\nuxReturn = uxCurrentEventBits;\nxTicksToWait = ( TickType_t ) 0;\n\n/* Clear the wait bits if requested to do so. */\nif( xClearOnExit != pdFALSE )\n{\npxEventBits-&gt;uxEventBits &amp;= ~uxBitsToWaitFor;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse if( xTicksToWait == ( TickType_t ) 0 )\n{\n/* The wait condition has not been met, but no block time was\n            specified, so just return the current value. */\nuxReturn = uxCurrentEventBits;\nxTimeoutOccurred = pdTRUE;\n}\nelse\n{\n/* The task is going to block to wait for its required bits to be\n            set.  uxControlBits are used to remember the specified behaviour of\n            this call to xEventGroupWaitBits() - for use when the event bits\n            unblock the task. */\nif( xClearOnExit != pdFALSE )\n{\nuxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nif( xWaitForAllBits != pdFALSE )\n{\nuxControlBits |= eventWAIT_FOR_ALL_BITS;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\n/* Store the bits that the calling task is waiting for in the\n            task's event list item so the kernel knows when a match is\n            found.  Then enter the blocked state. */\nvTaskPlaceOnUnorderedEventList( &amp;( pxEventBits-&gt;xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );\n\n/* This is obsolete as it will get set after the task unblocks, but\n            some compilers mistakenly generate a warning about the variable\n            being returned without being set if it is not done. */\nuxReturn = 0;\n\ntraceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );\n}\n}\nxAlreadyYielded = xTaskResumeAll();\n\nif( xTicksToWait != ( TickType_t ) 0 )\n{\nif( xAlreadyYielded == pdFALSE )\n{\nportYIELD_WITHIN_API();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\n/* The task blocked to wait for its required bits to be set - at this\n        point either the required bits were set or the block time expired.  If\n        the required bits were set they will have been stored in the task's\n        event list item, and they should now be retrieved then cleared. */\nuxReturn = uxTaskResetEventItemValue();\n\nif( ( uxReturn &amp; eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )\n{\ntaskENTER_CRITICAL();\n{\n/* The task timed out, just return the current event bit value. */\nuxReturn = pxEventBits-&gt;uxEventBits;\n\n/* It is possible that the event bits were updated between this\n                task leaving the Blocked state and running again. */\nif( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )\n{\nif( xClearOnExit != pdFALSE )\n{\npxEventBits-&gt;uxEventBits &amp;= ~uxBitsToWaitFor;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\nxTimeoutOccurred = pdTRUE;\n}\ntaskEXIT_CRITICAL();\n}\nelse\n{\n/* The task unblocked because the bits were set. */\n}\n\n/* The task blocked so control bits may have been set. */\nuxReturn &amp;= ~eventEVENT_BITS_CONTROL_BYTES;\n}\ntraceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );\n\n/* Prevent compiler warnings when trace macros are not used. */\n( void ) xTimeoutOccurred;\n\nreturn uxReturn;\n}\n/*-----------------------------------------------------------*/\n\nEventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )\n{\nEventGroup_t *pxEventBits = xEventGroup;\nEventBits_t uxReturn;\n\n/* Check the user is not attempting to clear the bits used by the kernel\n    itself. */\nconfigASSERT( xEventGroup );\nconfigASSERT( ( uxBitsToClear &amp; eventEVENT_BITS_CONTROL_BYTES ) == 0 );\n\ntaskENTER_CRITICAL();\n{\ntraceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );\n\n/* The value returned is the event group value prior to the bits being\n        cleared. */\nuxReturn = pxEventBits-&gt;uxEventBits;\n\n/* Clear the bits. */\npxEventBits-&gt;uxEventBits &amp;= ~uxBitsToClear;\n}\ntaskEXIT_CRITICAL();\n\nreturn uxReturn;\n}\n/*-----------------------------------------------------------*/\n\n#if ( ( configUSE_TRACE_FACILITY == 1 ) &amp;&amp; ( INCLUDE_xTimerPendFunctionCall == 1 ) &amp;&amp; ( configUSE_TIMERS == 1 ) )\n\nBaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )\n{\nBaseType_t xReturn;\n\ntraceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear );\nxReturn = xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL ); /*lint !e9087 Can't avoid cast to void* as a generic callback function not specific to this use case. Callback casts back to original type so safe. */\n\nreturn xReturn;\n}\n\n#endif\n/*-----------------------------------------------------------*/\n\nEventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )\n{\nUBaseType_t uxSavedInterruptStatus;\nEventGroup_t const * const pxEventBits = xEventGroup;\nEventBits_t uxReturn;\n\nuxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();\n{\nuxReturn = pxEventBits-&gt;uxEventBits;\n}\nportCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\n\nreturn uxReturn;\n} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */\n/*-----------------------------------------------------------*/\n\nEventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )\n{\nListItem_t *pxListItem, *pxNext;\nListItem_t const *pxListEnd;\nList_t const * pxList;\nEventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;\nEventGroup_t *pxEventBits = xEventGroup;\nBaseType_t xMatchFound = pdFALSE;\n\n/* Check the user is not attempting to set the bits used by the kernel\n    itself. */\nconfigASSERT( xEventGroup );\nconfigASSERT( ( uxBitsToSet &amp; eventEVENT_BITS_CONTROL_BYTES ) == 0 );\n\npxList = &amp;( pxEventBits-&gt;xTasksWaitingForBits );\npxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */\nvTaskSuspendAll();\n{\ntraceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );\n\npxListItem = listGET_HEAD_ENTRY( pxList );\n\n/* Set the bits. */\npxEventBits-&gt;uxEventBits |= uxBitsToSet;\n\n/* See if the new bit value should unblock any tasks. */\nwhile( pxListItem != pxListEnd )\n{\npxNext = listGET_NEXT( pxListItem );\nuxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );\nxMatchFound = pdFALSE;\n\n/* Split the bits waited for from the control bits. */\nuxControlBits = uxBitsWaitedFor &amp; eventEVENT_BITS_CONTROL_BYTES;\nuxBitsWaitedFor &amp;= ~eventEVENT_BITS_CONTROL_BYTES;\n\nif( ( uxControlBits &amp; eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )\n{\n/* Just looking for single bit being set. */\nif( ( uxBitsWaitedFor &amp; pxEventBits-&gt;uxEventBits ) != ( EventBits_t ) 0 )\n{\nxMatchFound = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse if( ( uxBitsWaitedFor &amp; pxEventBits-&gt;uxEventBits ) == uxBitsWaitedFor )\n{\n/* All bits are set. */\nxMatchFound = pdTRUE;\n}\nelse\n{\n/* Need all bits to be set, but not all the bits were set. */\n}\n\nif( xMatchFound != pdFALSE )\n{\n/* The bits match.  Should the bits be cleared on exit? */\nif( ( uxControlBits &amp; eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )\n{\nuxBitsToClear |= uxBitsWaitedFor;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\n/* Store the actual event flag value in the task's event list\n                item before removing the task from the event list.  The\n                eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows\n                that is was unblocked due to its required bits matching, rather\n                than because it timed out. */\nvTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits-&gt;uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );\n}\n\n/* Move onto the next list item.  Note pxListItem-&gt;pxNext is not\n            used here as the list item may have been removed from the event list\n            and inserted into the ready/pending reading list. */\npxListItem = pxNext;\n}\n\n/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT\n        bit was set in the control word. */\npxEventBits-&gt;uxEventBits &amp;= ~uxBitsToClear;\n}\n( void ) xTaskResumeAll();\n\nreturn pxEventBits-&gt;uxEventBits;\n}\n/*-----------------------------------------------------------*/\n\nvoid vEventGroupDelete( EventGroupHandle_t xEventGroup )\n{\nEventGroup_t *pxEventBits = xEventGroup;\nconst List_t *pxTasksWaitingForBits = &amp;( pxEventBits-&gt;xTasksWaitingForBits );\n\nvTaskSuspendAll();\n{\ntraceEVENT_GROUP_DELETE( xEventGroup );\n\nwhile( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) &gt; ( UBaseType_t ) 0 )\n{\n/* Unblock the task, returning 0 as the event list is being deleted\n            and cannot therefore have any bits set. */\nconfigASSERT( pxTasksWaitingForBits-&gt;xListEnd.pxNext != ( const ListItem_t * ) &amp;( pxTasksWaitingForBits-&gt;xListEnd ) );\nvTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits-&gt;xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );\n}\n\n#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 0 ) )\n{\n/* The event group can only have been allocated dynamically - free\n            it again. */\nvPortFree( pxEventBits );\n}\n#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) )\n{\n/* The event group could have been allocated statically or\n            dynamically, so check before attempting to free the memory. */\nif( pxEventBits-&gt;ucStaticallyAllocated == ( uint8_t ) pdFALSE )\n{\nvPortFree( pxEventBits );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n#endif /* configSUPPORT_DYNAMIC_ALLOCATION */\n}\n( void ) xTaskResumeAll();\n}\n/*-----------------------------------------------------------*/\n\n/* For internal use only - execute a 'set bits' command that was pended from\nan interrupt. */\nvoid vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )\n{\n( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */\n}\n/*-----------------------------------------------------------*/\n\n/* For internal use only - execute a 'clear bits' command that was pended from\nan interrupt. */\nvoid vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )\n{\n( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */\n}\n/*-----------------------------------------------------------*/\n\nstatic BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )\n{\nBaseType_t xWaitConditionMet = pdFALSE;\n\nif( xWaitForAllBits == pdFALSE )\n{\n/* Task only has to wait for one bit within uxBitsToWaitFor to be\n        set.  Is one already set? */\nif( ( uxCurrentEventBits &amp; uxBitsToWaitFor ) != ( EventBits_t ) 0 )\n{\nxWaitConditionMet = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\n/* Task has to wait for all the bits in uxBitsToWaitFor to be set.\n        Are they set already? */\nif( ( uxCurrentEventBits &amp; uxBitsToWaitFor ) == uxBitsToWaitFor )\n{\nxWaitConditionMet = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n\nreturn xWaitConditionMet;\n}\n/*-----------------------------------------------------------*/\n\n#if ( ( configUSE_TRACE_FACILITY == 1 ) &amp;&amp; ( INCLUDE_xTimerPendFunctionCall == 1 ) &amp;&amp; ( configUSE_TIMERS == 1 ) )\n\nBaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )\n{\nBaseType_t xReturn;\n\ntraceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );\nxReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken ); /*lint !e9087 Can't avoid cast to void* as a generic callback function not specific to this use case. Callback casts back to original type so safe. */\n\nreturn xReturn;\n}\n\n#endif\n/*-----------------------------------------------------------*/\n\n#if (configUSE_TRACE_FACILITY == 1)\n\nUBaseType_t uxEventGroupGetNumber( void* xEventGroup )\n{\nUBaseType_t xReturn;\nEventGroup_t const *pxEventBits = ( EventGroup_t * ) xEventGroup; /*lint !e9087 !e9079 EventGroupHandle_t is a pointer to an EventGroup_t, but EventGroupHandle_t is kept opaque outside of this file for data hiding purposes. */\n\nif( xEventGroup == NULL )\n{\nxReturn = 0;\n}\nelse\n{\nxReturn = pxEventBits-&gt;uxEventGroupNumber;\n}\n\nreturn xReturn;\n}\n\n#endif /* configUSE_TRACE_FACILITY */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_TRACE_FACILITY == 1 )\n\nvoid vEventGroupSetNumber( void * xEventGroup, UBaseType_t uxEventGroupNumber )\n{\n( ( EventGroup_t * ) xEventGroup )-&gt;uxEventGroupNumber = uxEventGroupNumber; /*lint !e9087 !e9079 EventGroupHandle_t is a pointer to an EventGroup_t, but EventGroupHandle_t is kept opaque outside of this file for data hiding purposes. */\n}\n\n#endif /* configUSE_TRACE_FACILITY */\n/*-----------------------------------------------------------*/\n</code></pre>"},{"location":"apiStm/heap__4_8c/","title":"File heap_4.c","text":"<p>FileList &gt; FreeRTOS &gt; src &gt; heap_4.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"task.h\"</code></li> </ul>"},{"location":"apiStm/heap__4_8c/#classes","title":"Classes","text":"Type Name struct A_BLOCK_LINK"},{"location":"apiStm/heap__4_8c/#public-types","title":"Public Types","text":"Type Name typedef struct A_BLOCK_LINK BlockLink_t"},{"location":"apiStm/heap__4_8c/#public-static-attributes","title":"Public Static Attributes","text":"Type Name BlockLink_t * pxEnd   = = NULL uint8_t ucHeap size_t xBlockAllocatedBit   = = 0 size_t xFreeBytesRemaining   = = 0U const size_t xHeapStructSize   = = (sizeof(BlockLink_t) + ((size_t)(portBYTE_ALIGNMENT - 1))) &amp; ~((size_t)portBYTE_ALIGNMENT_MASK) size_t xMinimumEverFreeBytesRemaining   = = 0U size_t xNumberOfSuccessfulAllocations   = = 0 size_t xNumberOfSuccessfulFrees   = = 0 BlockLink_t xStart"},{"location":"apiStm/heap__4_8c/#public-functions","title":"Public Functions","text":"Type Name void * pvPortMalloc (size_t xWantedSize)  void vPortFree (void * pv)  void vPortGetHeapStats (HeapStats_t * pxHeapStats)  void vPortInitialiseBlocks (void)  size_t xPortGetFreeHeapSize (void)  size_t xPortGetMinimumEverFreeHeapSize (void)"},{"location":"apiStm/heap__4_8c/#public-static-functions","title":"Public Static Functions","text":"Type Name void prvHeapInit (void)  void prvInsertBlockIntoFreeList (BlockLink_t * pxBlockToInsert)"},{"location":"apiStm/heap__4_8c/#macros","title":"Macros","text":"Type Name define MPU_WRAPPERS_INCLUDED_FROM_API_FILE define heapBITS_PER_BYTE  ((size_t)8) define heapMINIMUM_BLOCK_SIZE  ((size_t)(xHeapStructSize &lt;&lt; 1))"},{"location":"apiStm/heap__4_8c/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/heap__4_8c/#typedef-blocklink_t","title":"typedef BlockLink_t","text":"<pre><code>typedef struct A_BLOCK_LINK BlockLink_t;\n</code></pre>"},{"location":"apiStm/heap__4_8c/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"apiStm/heap__4_8c/#variable-pxend","title":"variable pxEnd","text":"<pre><code>BlockLink_t * pxEnd;\n</code></pre>"},{"location":"apiStm/heap__4_8c/#variable-ucheap","title":"variable ucHeap","text":"<pre><code>uint8_t ucHeap[configTOTAL_HEAP_SIZE];\n</code></pre>"},{"location":"apiStm/heap__4_8c/#variable-xblockallocatedbit","title":"variable xBlockAllocatedBit","text":"<pre><code>size_t xBlockAllocatedBit;\n</code></pre>"},{"location":"apiStm/heap__4_8c/#variable-xfreebytesremaining","title":"variable xFreeBytesRemaining","text":"<pre><code>size_t xFreeBytesRemaining;\n</code></pre>"},{"location":"apiStm/heap__4_8c/#variable-xheapstructsize","title":"variable xHeapStructSize","text":"<pre><code>const size_t xHeapStructSize;\n</code></pre>"},{"location":"apiStm/heap__4_8c/#variable-xminimumeverfreebytesremaining","title":"variable xMinimumEverFreeBytesRemaining","text":"<pre><code>size_t xMinimumEverFreeBytesRemaining;\n</code></pre>"},{"location":"apiStm/heap__4_8c/#variable-xnumberofsuccessfulallocations","title":"variable xNumberOfSuccessfulAllocations","text":"<pre><code>size_t xNumberOfSuccessfulAllocations;\n</code></pre>"},{"location":"apiStm/heap__4_8c/#variable-xnumberofsuccessfulfrees","title":"variable xNumberOfSuccessfulFrees","text":"<pre><code>size_t xNumberOfSuccessfulFrees;\n</code></pre>"},{"location":"apiStm/heap__4_8c/#variable-xstart","title":"variable xStart","text":"<pre><code>BlockLink_t xStart;\n</code></pre>"},{"location":"apiStm/heap__4_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/heap__4_8c/#function-pvportmalloc","title":"function pvPortMalloc","text":"<pre><code>void * pvPortMalloc (\nsize_t xWantedSize\n) </code></pre>"},{"location":"apiStm/heap__4_8c/#function-vportfree","title":"function vPortFree","text":"<pre><code>void vPortFree (\nvoid * pv\n) </code></pre>"},{"location":"apiStm/heap__4_8c/#function-vportgetheapstats","title":"function vPortGetHeapStats","text":"<pre><code>void vPortGetHeapStats (\nHeapStats_t * pxHeapStats\n) </code></pre>"},{"location":"apiStm/heap__4_8c/#function-vportinitialiseblocks","title":"function vPortInitialiseBlocks","text":"<pre><code>void vPortInitialiseBlocks (\nvoid\n) </code></pre>"},{"location":"apiStm/heap__4_8c/#function-xportgetfreeheapsize","title":"function xPortGetFreeHeapSize","text":"<pre><code>size_t xPortGetFreeHeapSize (\nvoid\n) </code></pre>"},{"location":"apiStm/heap__4_8c/#function-xportgetminimumeverfreeheapsize","title":"function xPortGetMinimumEverFreeHeapSize","text":"<pre><code>size_t xPortGetMinimumEverFreeHeapSize (\nvoid\n) </code></pre>"},{"location":"apiStm/heap__4_8c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"apiStm/heap__4_8c/#function-prvheapinit","title":"function prvHeapInit","text":"<pre><code>static void prvHeapInit (\nvoid\n) </code></pre>"},{"location":"apiStm/heap__4_8c/#function-prvinsertblockintofreelist","title":"function prvInsertBlockIntoFreeList","text":"<pre><code>static void prvInsertBlockIntoFreeList (\nBlockLink_t * pxBlockToInsert\n) </code></pre>"},{"location":"apiStm/heap__4_8c/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/heap__4_8c/#define-mpu_wrappers_included_from_api_file","title":"define MPU_WRAPPERS_INCLUDED_FROM_API_FILE","text":"<pre><code>#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE \n</code></pre>"},{"location":"apiStm/heap__4_8c/#define-heapbits_per_byte","title":"define heapBITS_PER_BYTE","text":"<pre><code>#define heapBITS_PER_BYTE ((size_t)8)\n</code></pre>"},{"location":"apiStm/heap__4_8c/#define-heapminimum_block_size","title":"define heapMINIMUM_BLOCK_SIZE","text":"<pre><code>#define heapMINIMUM_BLOCK_SIZE ((size_t)(xHeapStructSize &lt;&lt; 1))\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/src/heap_4.c</code></p>"},{"location":"apiStm/heap__4_8c_source/","title":"File heap_4.c","text":"<p>File List &gt; FreeRTOS &gt; src &gt; heap_4.c</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n/*\n * A sample implementation of pvPortMalloc() and vPortFree() that combines\n * (coalescences) adjacent memory blocks as they are freed, and in so doing\n * limits memory fragmentation.\n *\n * See heap_1.c, heap_2.c and heap_3.c for alternative implementations, and the\n * memory management pages of http://www.FreeRTOS.org for more information.\n */\n#include &lt;stdlib.h&gt;\n\n/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining\nall the API functions to use the MPU wrappers.  That should only be done when\ntask.h is included from an application file. */\n#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE\n\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n\n#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE\n\n#if (configSUPPORT_DYNAMIC_ALLOCATION == 0)\n#error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0\n#endif\n\n/* Block sizes must not get too small. */\n#define heapMINIMUM_BLOCK_SIZE ((size_t)(xHeapStructSize &lt;&lt; 1))\n\n/* Assumes 8bit bytes! */\n#define heapBITS_PER_BYTE ((size_t)8)\n\n/* Allocate the memory for the heap. */\n#if (configAPPLICATION_ALLOCATED_HEAP == 1)\n/* The application writer has already defined the array used for the RTOS\n    heap - probably so it can be placed in a special segment or address. */\nextern uint8_t ucHeap[configTOTAL_HEAP_SIZE];\n#else\nstatic uint8_t ucHeap[configTOTAL_HEAP_SIZE];\n#endif /* configAPPLICATION_ALLOCATED_HEAP */\n\n/* Define the linked list structure.  This is used to link free blocks in order\nof their memory address. */\ntypedef struct A_BLOCK_LINK {\nstruct A_BLOCK_LINK*\npxNextFreeBlock; /*&lt;&lt; The next free block in the list. */\nsize_t xBlockSize; /*&lt;&lt; The size of the free block. */\n} BlockLink_t;\n\n/*-----------------------------------------------------------*/\n\n/*\n * Inserts a block of memory that is being freed into the correct position in\n * the list of free memory blocks.  The block being freed will be merged with\n * the block in front it and/or the block behind it if the memory blocks are\n * adjacent to each other.\n */\nstatic void prvInsertBlockIntoFreeList(BlockLink_t* pxBlockToInsert);\n\n/*\n * Called automatically to setup the required heap structures the first time\n * pvPortMalloc() is called.\n */\nstatic void prvHeapInit(void);\n\n/*-----------------------------------------------------------*/\n\n/* The size of the structure placed at the beginning of each allocated memory\nblock must by correctly byte aligned. */\nstatic const size_t xHeapStructSize\n= (sizeof(BlockLink_t) + ((size_t)(portBYTE_ALIGNMENT - 1)))\n&amp; ~((size_t)portBYTE_ALIGNMENT_MASK);\n\n/* Create a couple of list links to mark the start and end of the list. */\nstatic BlockLink_t xStart, *pxEnd = NULL;\n\n/* Keeps track of the number of calls to allocate and free memory as well as the\nnumber of free bytes remaining, but says nothing about fragmentation. */\nstatic size_t xFreeBytesRemaining = 0U;\nstatic size_t xMinimumEverFreeBytesRemaining = 0U;\nstatic size_t xNumberOfSuccessfulAllocations = 0;\nstatic size_t xNumberOfSuccessfulFrees = 0;\n\n/* Gets set to the top bit of an size_t type.  When this bit in the xBlockSize\nmember of an BlockLink_t structure is set then the block belongs to the\napplication.  When the bit is free the block is still part of the free heap\nspace. */\nstatic size_t xBlockAllocatedBit = 0;\n\n/*-----------------------------------------------------------*/\n\nvoid* pvPortMalloc(size_t xWantedSize) {\nBlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;\nvoid* pvReturn = NULL;\n\nvTaskSuspendAll();\n{\n/* If this is the first call to malloc then the heap will require\n        initialisation to setup the list of free blocks. */\nif (pxEnd == NULL) {\nprvHeapInit();\n} else {\nmtCOVERAGE_TEST_MARKER();\n}\n\n/* Check the requested block size is not so large that the top bit is\n        set.  The top bit of the block size member of the BlockLink_t structure\n        is used to determine who owns the block - the application or the\n        kernel, so it must be free. */\nif ((xWantedSize &amp; xBlockAllocatedBit) == 0) {\n/* The wanted size is increased so it can contain a BlockLink_t\n            structure in addition to the requested amount of bytes. */\nif (xWantedSize &gt; 0) {\nxWantedSize += xHeapStructSize;\n\n/* Ensure that blocks are always aligned to the required number\n                of bytes. */\nif ((xWantedSize &amp; portBYTE_ALIGNMENT_MASK) != 0x00) {\n/* Byte alignment required. */\nxWantedSize += (portBYTE_ALIGNMENT\n- (xWantedSize &amp; portBYTE_ALIGNMENT_MASK));\nconfigASSERT((xWantedSize &amp; portBYTE_ALIGNMENT_MASK) == 0);\n} else {\nmtCOVERAGE_TEST_MARKER();\n}\n} else {\nmtCOVERAGE_TEST_MARKER();\n}\n\nif ((xWantedSize &gt; 0) &amp;&amp; (xWantedSize &lt;= xFreeBytesRemaining)) {\n/* Traverse the list from the start (lowest address) block until\n                one of adequate size is found. */\npxPreviousBlock = &amp;xStart;\npxBlock = xStart.pxNextFreeBlock;\nwhile ((pxBlock-&gt;xBlockSize &lt; xWantedSize)\n&amp;&amp; (pxBlock-&gt;pxNextFreeBlock != NULL)) {\npxPreviousBlock = pxBlock;\npxBlock = pxBlock-&gt;pxNextFreeBlock;\n}\n\n/* If the end marker was reached then a block of adequate size\n                was not found. */\nif (pxBlock != pxEnd) {\n/* Return the memory space pointed to - jumping over the\n                    BlockLink_t structure at its start. */\npvReturn\n= (void*)(((uint8_t*)pxPreviousBlock-&gt;pxNextFreeBlock)\n+ xHeapStructSize);\n\n/* This block is being returned for use so must be taken out\n                    of the list of free blocks. */\npxPreviousBlock-&gt;pxNextFreeBlock = pxBlock-&gt;pxNextFreeBlock;\n\n/* If the block is larger than required it can be split into\n                    two. */\nif ((pxBlock-&gt;xBlockSize - xWantedSize)\n&gt; heapMINIMUM_BLOCK_SIZE) {\n/* This block is to be split into two.  Create a new\n                        block following the number of bytes requested. The void\n                        cast is used to prevent byte alignment warnings from the\n                        compiler. */\npxNewBlockLink\n= (void*)(((uint8_t*)pxBlock) + xWantedSize);\nconfigASSERT(\n(((size_t)pxNewBlockLink) &amp; portBYTE_ALIGNMENT_MASK)\n== 0);\n\n/* Calculate the sizes of two blocks split from the\n                        single block. */\npxNewBlockLink-&gt;xBlockSize\n= pxBlock-&gt;xBlockSize - xWantedSize;\npxBlock-&gt;xBlockSize = xWantedSize;\n\n/* Insert the new block into the list of free blocks. */\nprvInsertBlockIntoFreeList(pxNewBlockLink);\n} else {\nmtCOVERAGE_TEST_MARKER();\n}\n\nxFreeBytesRemaining -= pxBlock-&gt;xBlockSize;\n\nif (xFreeBytesRemaining &lt; xMinimumEverFreeBytesRemaining) {\nxMinimumEverFreeBytesRemaining = xFreeBytesRemaining;\n} else {\nmtCOVERAGE_TEST_MARKER();\n}\n\n/* The block is being returned - it is allocated and owned\n                    by the application and has no \"next\" block. */\npxBlock-&gt;xBlockSize |= xBlockAllocatedBit;\npxBlock-&gt;pxNextFreeBlock = NULL;\nxNumberOfSuccessfulAllocations++;\n} else {\nmtCOVERAGE_TEST_MARKER();\n}\n} else {\nmtCOVERAGE_TEST_MARKER();\n}\n} else {\nmtCOVERAGE_TEST_MARKER();\n}\n\ntraceMALLOC(pvReturn, xWantedSize);\n}\n(void)xTaskResumeAll();\n\n#if (configUSE_MALLOC_FAILED_HOOK == 1)\n{\nif (pvReturn == NULL) {\nextern void vApplicationMallocFailedHook(void);\nvApplicationMallocFailedHook();\n} else {\nmtCOVERAGE_TEST_MARKER();\n}\n}\n#endif\n\nconfigASSERT((((size_t)pvReturn) &amp; (size_t)portBYTE_ALIGNMENT_MASK) == 0);\nreturn pvReturn;\n}\n/*-----------------------------------------------------------*/\n\nvoid vPortFree(void* pv) {\nuint8_t* puc = (uint8_t*)pv;\nBlockLink_t* pxLink;\n\nif (pv != NULL) {\n/* The memory being freed will have an BlockLink_t structure immediately\n        before it. */\npuc -= xHeapStructSize;\n\n/* This casting is to keep the compiler from issuing warnings. */\npxLink = (void*)puc;\n\n/* Check the block is actually allocated. */\nconfigASSERT((pxLink-&gt;xBlockSize &amp; xBlockAllocatedBit) != 0);\nconfigASSERT(pxLink-&gt;pxNextFreeBlock == NULL);\n\nif ((pxLink-&gt;xBlockSize &amp; xBlockAllocatedBit) != 0) {\nif (pxLink-&gt;pxNextFreeBlock == NULL) {\n/* The block is being returned to the heap - it is no longer\n                allocated. */\npxLink-&gt;xBlockSize &amp;= ~xBlockAllocatedBit;\n\nvTaskSuspendAll();\n{\n/* Add this block to the list of free blocks. */\nxFreeBytesRemaining += pxLink-&gt;xBlockSize;\ntraceFREE(pv, pxLink-&gt;xBlockSize);\nprvInsertBlockIntoFreeList(((BlockLink_t*)pxLink));\nxNumberOfSuccessfulFrees++;\n}\n(void)xTaskResumeAll();\n} else {\nmtCOVERAGE_TEST_MARKER();\n}\n} else {\nmtCOVERAGE_TEST_MARKER();\n}\n}\n}\n/*-----------------------------------------------------------*/\n\nsize_t xPortGetFreeHeapSize(void) { return xFreeBytesRemaining; }\n/*-----------------------------------------------------------*/\n\nsize_t xPortGetMinimumEverFreeHeapSize(void) {\nreturn xMinimumEverFreeBytesRemaining;\n}\n/*-----------------------------------------------------------*/\n\nvoid vPortInitialiseBlocks(void) {\n/* This just exists to keep the linker quiet. */\n}\n/*-----------------------------------------------------------*/\n\nstatic void prvHeapInit(void) {\nBlockLink_t* pxFirstFreeBlock;\nuint8_t* pucAlignedHeap;\nsize_t uxAddress;\nsize_t xTotalHeapSize = configTOTAL_HEAP_SIZE;\n\n/* Ensure the heap starts on a correctly aligned boundary. */\nuxAddress = (size_t)ucHeap;\n\nif ((uxAddress &amp; portBYTE_ALIGNMENT_MASK) != 0) {\nuxAddress += (portBYTE_ALIGNMENT - 1);\nuxAddress &amp;= ~((size_t)portBYTE_ALIGNMENT_MASK);\nxTotalHeapSize -= uxAddress - (size_t)ucHeap;\n}\n\npucAlignedHeap = (uint8_t*)uxAddress;\n\n/* xStart is used to hold a pointer to the first item in the list of free\n    blocks.  The void cast is used to prevent compiler warnings. */\nxStart.pxNextFreeBlock = (void*)pucAlignedHeap;\nxStart.xBlockSize = (size_t)0;\n\n/* pxEnd is used to mark the end of the list of free blocks and is inserted\n    at the end of the heap space. */\nuxAddress = ((size_t)pucAlignedHeap) + xTotalHeapSize;\nuxAddress -= xHeapStructSize;\nuxAddress &amp;= ~((size_t)portBYTE_ALIGNMENT_MASK);\npxEnd = (void*)uxAddress;\npxEnd-&gt;xBlockSize = 0;\npxEnd-&gt;pxNextFreeBlock = NULL;\n\n/* To start with there is a single free block that is sized to take up the\n    entire heap space, minus the space taken by pxEnd. */\npxFirstFreeBlock = (void*)pucAlignedHeap;\npxFirstFreeBlock-&gt;xBlockSize = uxAddress - (size_t)pxFirstFreeBlock;\npxFirstFreeBlock-&gt;pxNextFreeBlock = pxEnd;\n\n/* Only one block exists - and it covers the entire usable heap space. */\nxMinimumEverFreeBytesRemaining = pxFirstFreeBlock-&gt;xBlockSize;\nxFreeBytesRemaining = pxFirstFreeBlock-&gt;xBlockSize;\n\n/* Work out the position of the top bit in a size_t variable. */\nxBlockAllocatedBit = ((size_t)1)\n&lt;&lt; ((sizeof(size_t) * heapBITS_PER_BYTE) - 1);\n}\n/*-----------------------------------------------------------*/\n\nstatic void prvInsertBlockIntoFreeList(BlockLink_t* pxBlockToInsert) {\nBlockLink_t* pxIterator;\nuint8_t* puc;\n\n/* Iterate through the list until a block is found that has a higher address\n    than the block being inserted. */\nfor (pxIterator = &amp;xStart; pxIterator-&gt;pxNextFreeBlock &lt; pxBlockToInsert;\npxIterator = pxIterator-&gt;pxNextFreeBlock) {\n/* Nothing to do here, just iterate to the right position. */\n}\n\n/* Do the block being inserted, and the block it is being inserted after\n    make a contiguous block of memory? */\npuc = (uint8_t*)pxIterator;\nif ((puc + pxIterator-&gt;xBlockSize) == (uint8_t*)pxBlockToInsert) {\npxIterator-&gt;xBlockSize += pxBlockToInsert-&gt;xBlockSize;\npxBlockToInsert = pxIterator;\n} else {\nmtCOVERAGE_TEST_MARKER();\n}\n\n/* Do the block being inserted, and the block it is being inserted before\n    make a contiguous block of memory? */\npuc = (uint8_t*)pxBlockToInsert;\nif ((puc + pxBlockToInsert-&gt;xBlockSize)\n== (uint8_t*)pxIterator-&gt;pxNextFreeBlock) {\nif (pxIterator-&gt;pxNextFreeBlock != pxEnd) {\n/* Form one big block from the two blocks. */\npxBlockToInsert-&gt;xBlockSize\n+= pxIterator-&gt;pxNextFreeBlock-&gt;xBlockSize;\npxBlockToInsert-&gt;pxNextFreeBlock\n= pxIterator-&gt;pxNextFreeBlock-&gt;pxNextFreeBlock;\n} else {\npxBlockToInsert-&gt;pxNextFreeBlock = pxEnd;\n}\n} else {\npxBlockToInsert-&gt;pxNextFreeBlock = pxIterator-&gt;pxNextFreeBlock;\n}\n\n/* If the block being inserted plugged a gab, so was merged with the block\n    before and the block after, then it's pxNextFreeBlock pointer will have\n    already been set, and should not be set here as that would make it point\n    to itself. */\nif (pxIterator != pxBlockToInsert) {\npxIterator-&gt;pxNextFreeBlock = pxBlockToInsert;\n} else {\nmtCOVERAGE_TEST_MARKER();\n}\n}\n/*-----------------------------------------------------------*/\n\nvoid vPortGetHeapStats(HeapStats_t* pxHeapStats) {\nBlockLink_t* pxBlock;\nsize_t xBlocks = 0, xMaxSize = 0,\nxMinSize\n= portMAX_DELAY; /* portMAX_DELAY used as a portable way of getting the maximum value. */\n\nvTaskSuspendAll();\n{\npxBlock = xStart.pxNextFreeBlock;\n\n/* pxBlock will be NULL if the heap has not been initialised.  The heap\n        is initialised automatically when the first allocation is made. */\nif (pxBlock != NULL) {\ndo {\n/* Increment the number of blocks and record the largest block seen\n                so far. */\nxBlocks++;\n\nif (pxBlock-&gt;xBlockSize &gt; xMaxSize) {\nxMaxSize = pxBlock-&gt;xBlockSize;\n}\n\nif (pxBlock-&gt;xBlockSize &lt; xMinSize) {\nxMinSize = pxBlock-&gt;xBlockSize;\n}\n\n/* Move to the next block in the chain until the last block is\n                reached. */\npxBlock = pxBlock-&gt;pxNextFreeBlock;\n} while (pxBlock != pxEnd);\n}\n}\nxTaskResumeAll();\n\npxHeapStats-&gt;xSizeOfLargestFreeBlockInBytes = xMaxSize;\npxHeapStats-&gt;xSizeOfSmallestFreeBlockInBytes = xMinSize;\npxHeapStats-&gt;xNumberOfFreeBlocks = xBlocks;\n\ntaskENTER_CRITICAL();\n{\npxHeapStats-&gt;xAvailableHeapSpaceInBytes = xFreeBytesRemaining;\npxHeapStats-&gt;xNumberOfSuccessfulAllocations\n= xNumberOfSuccessfulAllocations;\npxHeapStats-&gt;xNumberOfSuccessfulFrees = xNumberOfSuccessfulFrees;\npxHeapStats-&gt;xMinimumEverFreeBytesRemaining\n= xMinimumEverFreeBytesRemaining;\n}\ntaskEXIT_CRITICAL();\n}\n</code></pre>"},{"location":"apiStm/list_8c/","title":"File list.c","text":"<p>FileList &gt; FreeRTOS &gt; src &gt; list.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"list.h\"</code></li> </ul>"},{"location":"apiStm/list_8c/#public-functions","title":"Public Functions","text":"Type Name UBaseType_t uxListRemove (ListItem_t *const pxItemToRemove)  void vListInitialise (List_t *const pxList)  void vListInitialiseItem (ListItem_t *const pxItem)  void vListInsert (List_t *const pxList, ListItem_t *const pxNewListItem)  void vListInsertEnd (List_t *const pxList, ListItem_t *const pxNewListItem)"},{"location":"apiStm/list_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/list_8c/#function-uxlistremove","title":"function uxListRemove","text":"<pre><code>UBaseType_t uxListRemove (\nListItem_t *const pxItemToRemove\n) </code></pre>"},{"location":"apiStm/list_8c/#function-vlistinitialise","title":"function vListInitialise","text":"<pre><code>void vListInitialise (\nList_t *const pxList\n) </code></pre>"},{"location":"apiStm/list_8c/#function-vlistinitialiseitem","title":"function vListInitialiseItem","text":"<pre><code>void vListInitialiseItem (\nListItem_t *const pxItem\n) </code></pre>"},{"location":"apiStm/list_8c/#function-vlistinsert","title":"function vListInsert","text":"<pre><code>void vListInsert (\nList_t *const pxList,\nListItem_t *const pxNewListItem\n) </code></pre>"},{"location":"apiStm/list_8c/#function-vlistinsertend","title":"function vListInsertEnd","text":"<pre><code>void vListInsertEnd (\nList_t *const pxList,\nListItem_t *const pxNewListItem\n) </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/src/list.c</code></p>"},{"location":"apiStm/list_8c_source/","title":"File list.c","text":"<p>File List &gt; FreeRTOS &gt; src &gt; list.c</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n\n#include &lt;stdlib.h&gt;\n#include \"FreeRTOS.h\"\n#include \"list.h\"\n\n/*-----------------------------------------------------------\n * PUBLIC LIST API documented in list.h\n *----------------------------------------------------------*/\n\nvoid vListInitialise( List_t * const pxList )\n{\n/* The list structure contains a list item which is used to mark the\n    end of the list.  To initialise the list the list end is inserted\n    as the only list entry. */\npxList-&gt;pxIndex = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd );           /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */\n\n/* The list end value is the highest possible value in the list to\n    ensure it remains at the end of the list. */\npxList-&gt;xListEnd.xItemValue = portMAX_DELAY;\n\n/* The list end next and previous pointers point to itself so we know\n    when the list is empty. */\npxList-&gt;xListEnd.pxNext = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd );   /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */\npxList-&gt;xListEnd.pxPrevious = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */\n\npxList-&gt;uxNumberOfItems = ( UBaseType_t ) 0U;\n\n/* Write known values into the list if\n    configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */\nlistSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );\nlistSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );\n}\n/*-----------------------------------------------------------*/\n\nvoid vListInitialiseItem( ListItem_t * const pxItem )\n{\n/* Make sure the list item is not recorded as being on a list. */\npxItem-&gt;pxContainer = NULL;\n\n/* Write known values into the list item if\n    configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */\nlistSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );\nlistSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );\n}\n/*-----------------------------------------------------------*/\n\nvoid vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )\n{\nListItem_t * const pxIndex = pxList-&gt;pxIndex;\n\n/* Only effective when configASSERT() is also defined, these tests may catch\n    the list data structures being overwritten in memory.  They will not catch\n    data errors caused by incorrect configuration or use of FreeRTOS. */\nlistTEST_LIST_INTEGRITY( pxList );\nlistTEST_LIST_ITEM_INTEGRITY( pxNewListItem );\n\n/* Insert a new list item into pxList, but rather than sort the list,\n    makes the new list item the last item to be removed by a call to\n    listGET_OWNER_OF_NEXT_ENTRY(). */\npxNewListItem-&gt;pxNext = pxIndex;\npxNewListItem-&gt;pxPrevious = pxIndex-&gt;pxPrevious;\n\n/* Only used during decision coverage testing. */\nmtCOVERAGE_TEST_DELAY();\n\npxIndex-&gt;pxPrevious-&gt;pxNext = pxNewListItem;\npxIndex-&gt;pxPrevious = pxNewListItem;\n\n/* Remember which list the item is in. */\npxNewListItem-&gt;pxContainer = pxList;\n\n( pxList-&gt;uxNumberOfItems )++;\n}\n/*-----------------------------------------------------------*/\n\nvoid vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )\n{\nListItem_t *pxIterator;\nconst TickType_t xValueOfInsertion = pxNewListItem-&gt;xItemValue;\n\n/* Only effective when configASSERT() is also defined, these tests may catch\n    the list data structures being overwritten in memory.  They will not catch\n    data errors caused by incorrect configuration or use of FreeRTOS. */\nlistTEST_LIST_INTEGRITY( pxList );\nlistTEST_LIST_ITEM_INTEGRITY( pxNewListItem );\n\n/* Insert the new list item into the list, sorted in xItemValue order.\n\n    If the list already contains a list item with the same item value then the\n    new list item should be placed after it.  This ensures that TCBs which are\n    stored in ready lists (all of which have the same xItemValue value) get a\n    share of the CPU.  However, if the xItemValue is the same as the back marker\n    the iteration loop below will not end.  Therefore the value is checked\n    first, and the algorithm slightly modified if necessary. */\nif( xValueOfInsertion == portMAX_DELAY )\n{\npxIterator = pxList-&gt;xListEnd.pxPrevious;\n}\nelse\n{\n/* *** NOTE ***********************************************************\n        If you find your application is crashing here then likely causes are\n        listed below.  In addition see https://www.freertos.org/FAQHelp.html for\n        more tips, and ensure configASSERT() is defined!\n        https://www.freertos.org/a00110.html#configASSERT\n\n            1) Stack overflow -\n               see https://www.freertos.org/Stacks-and-stack-overflow-checking.html\n            2) Incorrect interrupt priority assignment, especially on Cortex-M\n               parts where numerically high priority values denote low actual\n               interrupt priorities, which can seem counter intuitive.  See\n               https://www.freertos.org/RTOS-Cortex-M3-M4.html and the definition\n               of configMAX_SYSCALL_INTERRUPT_PRIORITY on\n               https://www.freertos.org/a00110.html\n            3) Calling an API function from within a critical section or when\n               the scheduler is suspended, or calling an API function that does\n               not end in \"FromISR\" from an interrupt.\n            4) Using a queue or semaphore before it has been initialised or\n               before the scheduler has been started (are interrupts firing\n               before vTaskStartScheduler() has been called?).\n        **********************************************************************/\n\nfor( pxIterator = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd ); pxIterator-&gt;pxNext-&gt;xItemValue &lt;= xValueOfInsertion; pxIterator = pxIterator-&gt;pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */\n{\n/* There is nothing to do here, just iterating to the wanted\n            insertion position. */\n}\n}\n\npxNewListItem-&gt;pxNext = pxIterator-&gt;pxNext;\npxNewListItem-&gt;pxNext-&gt;pxPrevious = pxNewListItem;\npxNewListItem-&gt;pxPrevious = pxIterator;\npxIterator-&gt;pxNext = pxNewListItem;\n\n/* Remember which list the item is in.  This allows fast removal of the\n    item later. */\npxNewListItem-&gt;pxContainer = pxList;\n\n( pxList-&gt;uxNumberOfItems )++;\n}\n/*-----------------------------------------------------------*/\n\nUBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )\n{\n/* The list item knows which list it is in.  Obtain the list from the list\nitem. */\nList_t * const pxList = pxItemToRemove-&gt;pxContainer;\n\npxItemToRemove-&gt;pxNext-&gt;pxPrevious = pxItemToRemove-&gt;pxPrevious;\npxItemToRemove-&gt;pxPrevious-&gt;pxNext = pxItemToRemove-&gt;pxNext;\n\n/* Only used during decision coverage testing. */\nmtCOVERAGE_TEST_DELAY();\n\n/* Make sure the index is left pointing to a valid item. */\nif( pxList-&gt;pxIndex == pxItemToRemove )\n{\npxList-&gt;pxIndex = pxItemToRemove-&gt;pxPrevious;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\npxItemToRemove-&gt;pxContainer = NULL;\n( pxList-&gt;uxNumberOfItems )--;\n\nreturn pxList-&gt;uxNumberOfItems;\n}\n/*-----------------------------------------------------------*/\n</code></pre>"},{"location":"apiStm/mpu__wrappers_8c/","title":"File mpu_wrappers.c","text":"<p>FileList &gt; FreeRTOS &gt; src &gt; mpu_wrappers.c</p> <p>Go to the source code of this file.</p> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/src/mpu_wrappers.c</code></p>"},{"location":"apiStm/mpu__wrappers_8c_source/","title":"File mpu_wrappers.c","text":"<p>File List &gt; FreeRTOS &gt; src &gt; mpu_wrappers.c</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n#ifdef portUSING_MPU_WRAPPERS\n\n/*\n * Implementation of the wrapper functions used to raise the processor privilege\n * before calling a standard FreeRTOS API function.\n */\n\n/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining\nall the API functions to use the MPU wrappers.  That should only be done when\ntask.h is included from an application file. */\n#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE\n\n/* Scheduler includes. */\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n#include \"queue.h\"\n#include \"timers.h\"\n#include \"event_groups.h\"\n#include \"stream_buffer.h\"\n#include \"mpu_prototypes.h\"\n\n#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE\n\nBaseType_t xPortRaisePrivilege( void ) FREERTOS_SYSTEM_CALL;\n\nvoid vPortResetPrivilege( BaseType_t xRunningPrivileged );\n/*-----------------------------------------------------------*/\n\nBaseType_t xPortRaisePrivilege( void ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged;\n\n/* Check whether the processor is already privileged. */\nxRunningPrivileged = portIS_PRIVILEGED();\n\n/* If the processor is not already privileged, raise privilege. */\nif( xRunningPrivileged != pdTRUE )\n{\nportRAISE_PRIVILEGE();\n}\n\nreturn xRunningPrivileged;\n}\n/*-----------------------------------------------------------*/\n\nvoid vPortResetPrivilege( BaseType_t xRunningPrivileged )\n{\nif( xRunningPrivileged != pdTRUE )\n{\nportRESET_PRIVILEGE();\n}\n}\n/*-----------------------------------------------------------*/\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\nBaseType_t MPU_xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTaskCreateRestricted( pxTaskDefinition, pxCreatedTask );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif /* conifgSUPPORT_DYNAMIC_ALLOCATION */\n/*-----------------------------------------------------------*/\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\nBaseType_t MPU_xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTaskCreateRestrictedStatic( pxTaskDefinition, pxCreatedTask );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif /* conifgSUPPORT_DYNAMIC_ALLOCATION */\n/*-----------------------------------------------------------*/\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\nBaseType_t MPU_xTaskCreate( TaskFunction_t pvTaskCode, const char * const pcName, uint16_t usStackDepth, void *pvParameters, UBaseType_t uxPriority, TaskHandle_t *pxCreatedTask ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTaskCreate( pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif /* configSUPPORT_DYNAMIC_ALLOCATION */\n/*-----------------------------------------------------------*/\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\nTaskHandle_t MPU_xTaskCreateStatic( TaskFunction_t pxTaskCode, const char * const pcName, const uint32_t ulStackDepth, void * const pvParameters, UBaseType_t uxPriority, StackType_t * const puxStackBuffer, StaticTask_t * const pxTaskBuffer ) /* FREERTOS_SYSTEM_CALL */\n{\nTaskHandle_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTaskCreateStatic( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, puxStackBuffer, pxTaskBuffer );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n/*-----------------------------------------------------------*/\n\nvoid MPU_vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const xRegions ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nvTaskAllocateMPURegions( xTask, xRegions );\nvPortResetPrivilege( xRunningPrivileged );\n}\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_vTaskDelete == 1 )\nvoid MPU_vTaskDelete( TaskHandle_t pxTaskToDelete ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nvTaskDelete( pxTaskToDelete );\nvPortResetPrivilege( xRunningPrivileged );\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_vTaskDelayUntil == 1 )\nvoid MPU_vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, TickType_t xTimeIncrement ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nvTaskDelayUntil( pxPreviousWakeTime, xTimeIncrement );\nvPortResetPrivilege( xRunningPrivileged );\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_xTaskAbortDelay == 1 )\nBaseType_t MPU_xTaskAbortDelay( TaskHandle_t xTask ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTaskAbortDelay( xTask );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_vTaskDelay == 1 )\nvoid MPU_vTaskDelay( TickType_t xTicksToDelay ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nvTaskDelay( xTicksToDelay );\nvPortResetPrivilege( xRunningPrivileged );\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_uxTaskPriorityGet == 1 )\nUBaseType_t MPU_uxTaskPriorityGet( const TaskHandle_t pxTask ) /* FREERTOS_SYSTEM_CALL */\n{\nUBaseType_t uxReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nuxReturn = uxTaskPriorityGet( pxTask );\nvPortResetPrivilege( xRunningPrivileged );\nreturn uxReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_vTaskPrioritySet == 1 )\nvoid MPU_vTaskPrioritySet( TaskHandle_t pxTask, UBaseType_t uxNewPriority ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nvTaskPrioritySet( pxTask, uxNewPriority );\nvPortResetPrivilege( xRunningPrivileged );\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_eTaskGetState == 1 )\neTaskState MPU_eTaskGetState( TaskHandle_t pxTask ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\neTaskState eReturn;\n\neReturn = eTaskGetState( pxTask );\nvPortResetPrivilege( xRunningPrivileged );\nreturn eReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TRACE_FACILITY == 1 )\nvoid MPU_vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nvTaskGetInfo( xTask, pxTaskStatus, xGetFreeStackSpace, eState );\nvPortResetPrivilege( xRunningPrivileged );\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )\nTaskHandle_t MPU_xTaskGetIdleTaskHandle( void ) /* FREERTOS_SYSTEM_CALL */\n{\nTaskHandle_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTaskGetIdleTaskHandle();\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_vTaskSuspend == 1 )\nvoid MPU_vTaskSuspend( TaskHandle_t pxTaskToSuspend ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nvTaskSuspend( pxTaskToSuspend );\nvPortResetPrivilege( xRunningPrivileged );\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_vTaskSuspend == 1 )\nvoid MPU_vTaskResume( TaskHandle_t pxTaskToResume ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nvTaskResume( pxTaskToResume );\nvPortResetPrivilege( xRunningPrivileged );\n}\n#endif\n/*-----------------------------------------------------------*/\n\nvoid MPU_vTaskSuspendAll( void ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nvTaskSuspendAll();\nvPortResetPrivilege( xRunningPrivileged );\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t MPU_xTaskResumeAll( void ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTaskResumeAll();\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nTickType_t MPU_xTaskGetTickCount( void ) /* FREERTOS_SYSTEM_CALL */\n{\nTickType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTaskGetTickCount();\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nUBaseType_t MPU_uxTaskGetNumberOfTasks( void ) /* FREERTOS_SYSTEM_CALL */\n{\nUBaseType_t uxReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nuxReturn = uxTaskGetNumberOfTasks();\nvPortResetPrivilege( xRunningPrivileged );\nreturn uxReturn;\n}\n/*-----------------------------------------------------------*/\n\nchar * MPU_pcTaskGetName( TaskHandle_t xTaskToQuery ) /* FREERTOS_SYSTEM_CALL */\n{\nchar *pcReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\npcReturn = pcTaskGetName( xTaskToQuery );\nvPortResetPrivilege( xRunningPrivileged );\nreturn pcReturn;\n}\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_xTaskGetHandle == 1 )\nTaskHandle_t MPU_xTaskGetHandle( const char *pcNameToQuery ) /* FREERTOS_SYSTEM_CALL */\n{\nTaskHandle_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTaskGetHandle( pcNameToQuery );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( ( configUSE_TRACE_FACILITY == 1 ) &amp;&amp; ( configUSE_STATS_FORMATTING_FUNCTIONS &gt; 0 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )\nvoid MPU_vTaskList( char *pcWriteBuffer ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nvTaskList( pcWriteBuffer );\nvPortResetPrivilege( xRunningPrivileged );\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( ( configGENERATE_RUN_TIME_STATS == 1 ) &amp;&amp; ( configUSE_STATS_FORMATTING_FUNCTIONS &gt; 0 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )\nvoid MPU_vTaskGetRunTimeStats( char *pcWriteBuffer ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nvTaskGetRunTimeStats( pcWriteBuffer );\nvPortResetPrivilege( xRunningPrivileged );\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( ( configGENERATE_RUN_TIME_STATS == 1 ) &amp;&amp; ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) )\nuint32_t MPU_ulTaskGetIdleRunTimeCounter( void ) /* FREERTOS_SYSTEM_CALL */\n{\nuint32_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = ulTaskGetIdleRunTimeCounter();\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_APPLICATION_TASK_TAG == 1 )\nvoid MPU_vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxTagValue ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nvTaskSetApplicationTaskTag( xTask, pxTagValue );\nvPortResetPrivilege( xRunningPrivileged );\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_APPLICATION_TASK_TAG == 1 )\nTaskHookFunction_t MPU_xTaskGetApplicationTaskTag( TaskHandle_t xTask ) /* FREERTOS_SYSTEM_CALL */\n{\nTaskHookFunction_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTaskGetApplicationTaskTag( xTask );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )\nvoid MPU_vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nvTaskSetThreadLocalStoragePointer( xTaskToSet, xIndex, pvValue );\nvPortResetPrivilege( xRunningPrivileged );\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )\nvoid *MPU_pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) /* FREERTOS_SYSTEM_CALL */\n{\nvoid *pvReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\npvReturn = pvTaskGetThreadLocalStoragePointer( xTaskToQuery, xIndex );\nvPortResetPrivilege( xRunningPrivileged );\nreturn pvReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_APPLICATION_TASK_TAG == 1 )\nBaseType_t MPU_xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTaskCallApplicationTaskHook( xTask, pvParameter );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_TRACE_FACILITY == 1 )\nUBaseType_t MPU_uxTaskGetSystemState( TaskStatus_t *pxTaskStatusArray, UBaseType_t uxArraySize, uint32_t *pulTotalRunTime ) /* FREERTOS_SYSTEM_CALL */\n{\nUBaseType_t uxReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nuxReturn = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, pulTotalRunTime );\nvPortResetPrivilege( xRunningPrivileged );\nreturn uxReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\nBaseType_t MPU_xTaskCatchUpTicks( TickType_t xTicksToCatchUp ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTaskCatchUpTicks( xTicksToCatchUp );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )\nUBaseType_t MPU_uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) /* FREERTOS_SYSTEM_CALL */\n{\nUBaseType_t uxReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nuxReturn = uxTaskGetStackHighWaterMark( xTask );\nvPortResetPrivilege( xRunningPrivileged );\nreturn uxReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 )\nconfigSTACK_DEPTH_TYPE MPU_uxTaskGetStackHighWaterMark2( TaskHandle_t xTask ) /* FREERTOS_SYSTEM_CALL */\n{\nconfigSTACK_DEPTH_TYPE uxReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nuxReturn = uxTaskGetStackHighWaterMark2( xTask );\nvPortResetPrivilege( xRunningPrivileged );\nreturn uxReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_xTaskGetCurrentTaskHandle == 1 )\nTaskHandle_t MPU_xTaskGetCurrentTaskHandle( void ) /* FREERTOS_SYSTEM_CALL */\n{\nTaskHandle_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTaskGetCurrentTaskHandle();\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_xTaskGetSchedulerState == 1 )\nBaseType_t MPU_xTaskGetSchedulerState( void ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTaskGetSchedulerState();\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\nvoid MPU_vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nvTaskSetTimeOutState( pxTimeOut );\nvPortResetPrivilege( xRunningPrivileged );\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t MPU_xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTaskCheckForTimeOut( pxTimeOut, pxTicksToWait );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TASK_NOTIFICATIONS == 1 )\nBaseType_t MPU_xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTaskGenericNotify( xTaskToNotify, ulValue, eAction, pulPreviousNotificationValue );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TASK_NOTIFICATIONS == 1 )\nBaseType_t MPU_xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTaskNotifyWait( ulBitsToClearOnEntry, ulBitsToClearOnExit, pulNotificationValue, xTicksToWait );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TASK_NOTIFICATIONS == 1 )\nuint32_t MPU_ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */\n{\nuint32_t ulReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nulReturn = ulTaskNotifyTake( xClearCountOnExit, xTicksToWait );\nvPortResetPrivilege( xRunningPrivileged );\nreturn ulReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TASK_NOTIFICATIONS == 1 )\nBaseType_t MPU_xTaskNotifyStateClear( TaskHandle_t xTask ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTaskNotifyStateClear( xTask );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TASK_NOTIFICATIONS == 1 )\nuint32_t MPU_ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear ) /* FREERTOS_SYSTEM_CALL */\n{\nuint32_t ulReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nulReturn = ulTaskNotifyValueClear( xTask, ulBitsToClear );\nvPortResetPrivilege( xRunningPrivileged );\nreturn ulReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\nQueueHandle_t MPU_xQueueGenericCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize, uint8_t ucQueueType ) /* FREERTOS_SYSTEM_CALL */\n{\nQueueHandle_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xQueueGenericCreate( uxQueueLength, uxItemSize, ucQueueType );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\nQueueHandle_t MPU_xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType ) /* FREERTOS_SYSTEM_CALL */\n{\nQueueHandle_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xQueueGenericCreateStatic( uxQueueLength, uxItemSize, pucQueueStorage, pxStaticQueue, ucQueueType );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\nBaseType_t MPU_xQueueGenericReset( QueueHandle_t pxQueue, BaseType_t xNewQueue ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xQueueGenericReset( pxQueue, xNewQueue );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t MPU_xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, BaseType_t xCopyPosition ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xQueueGenericSend( xQueue, pvItemToQueue, xTicksToWait, xCopyPosition );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nUBaseType_t MPU_uxQueueMessagesWaiting( const QueueHandle_t pxQueue ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\nUBaseType_t uxReturn;\n\nuxReturn = uxQueueMessagesWaiting( pxQueue );\nvPortResetPrivilege( xRunningPrivileged );\nreturn uxReturn;\n}\n/*-----------------------------------------------------------*/\n\nUBaseType_t MPU_uxQueueSpacesAvailable( const QueueHandle_t xQueue ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\nUBaseType_t uxReturn;\n\nuxReturn = uxQueueSpacesAvailable( xQueue );\nvPortResetPrivilege( xRunningPrivileged );\nreturn uxReturn;\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t MPU_xQueueReceive( QueueHandle_t pxQueue, void * const pvBuffer, TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\nBaseType_t xReturn;\n\nxReturn = xQueueReceive( pxQueue, pvBuffer, xTicksToWait );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t MPU_xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\nBaseType_t xReturn;\n\nxReturn = xQueuePeek( xQueue, pvBuffer, xTicksToWait );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t MPU_xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\nBaseType_t xReturn;\n\nxReturn = xQueueSemaphoreTake( xQueue, xTicksToWait );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\n#if ( ( configUSE_MUTEXES == 1 ) &amp;&amp; ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )\nTaskHandle_t MPU_xQueueGetMutexHolder( QueueHandle_t xSemaphore ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\nvoid * xReturn;\n\nxReturn = xQueueGetMutexHolder( xSemaphore );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( ( configUSE_MUTEXES == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )\nQueueHandle_t MPU_xQueueCreateMutex( const uint8_t ucQueueType ) /* FREERTOS_SYSTEM_CALL */\n{\nQueueHandle_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xQueueCreateMutex( ucQueueType );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( ( configUSE_MUTEXES == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) )\nQueueHandle_t MPU_xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue ) /* FREERTOS_SYSTEM_CALL */\n{\nQueueHandle_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xQueueCreateMutexStatic( ucQueueType, pxStaticQueue );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )\nQueueHandle_t MPU_xQueueCreateCountingSemaphore( UBaseType_t uxCountValue, UBaseType_t uxInitialCount ) /* FREERTOS_SYSTEM_CALL */\n{\nQueueHandle_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xQueueCreateCountingSemaphore( uxCountValue, uxInitialCount );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) )\n\nQueueHandle_t MPU_xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue ) /* FREERTOS_SYSTEM_CALL */\n{\nQueueHandle_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xQueueCreateCountingSemaphoreStatic( uxMaxCount, uxInitialCount, pxStaticQueue );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_RECURSIVE_MUTEXES == 1 )\nBaseType_t MPU_xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xBlockTime ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xQueueTakeMutexRecursive( xMutex, xBlockTime );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_RECURSIVE_MUTEXES == 1 )\nBaseType_t MPU_xQueueGiveMutexRecursive( QueueHandle_t xMutex ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xQueueGiveMutexRecursive( xMutex );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( ( configUSE_QUEUE_SETS == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )\nQueueSetHandle_t MPU_xQueueCreateSet( UBaseType_t uxEventQueueLength ) /* FREERTOS_SYSTEM_CALL */\n{\nQueueSetHandle_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xQueueCreateSet( uxEventQueueLength );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_QUEUE_SETS == 1 )\nQueueSetMemberHandle_t MPU_xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t xBlockTimeTicks ) /* FREERTOS_SYSTEM_CALL */\n{\nQueueSetMemberHandle_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xQueueSelectFromSet( xQueueSet, xBlockTimeTicks );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_QUEUE_SETS == 1 )\nBaseType_t MPU_xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xQueueAddToSet( xQueueOrSemaphore, xQueueSet );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_QUEUE_SETS == 1 )\nBaseType_t MPU_xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xQueueRemoveFromSet( xQueueOrSemaphore, xQueueSet );\nvPortResetPrivilege( xRunningPrivileged );\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if configQUEUE_REGISTRY_SIZE &gt; 0\nvoid MPU_vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcName ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nvQueueAddToRegistry( xQueue, pcName );\n\nvPortResetPrivilege( xRunningPrivileged );\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if configQUEUE_REGISTRY_SIZE &gt; 0\nvoid MPU_vQueueUnregisterQueue( QueueHandle_t xQueue ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nvQueueUnregisterQueue( xQueue );\n\nvPortResetPrivilege( xRunningPrivileged );\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if configQUEUE_REGISTRY_SIZE &gt; 0\nconst char *MPU_pcQueueGetName( QueueHandle_t xQueue ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\nconst char *pcReturn;\n\npcReturn = pcQueueGetName( xQueue );\n\nvPortResetPrivilege( xRunningPrivileged );\nreturn pcReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\nvoid MPU_vQueueDelete( QueueHandle_t xQueue ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nvQueueDelete( xQueue );\n\nvPortResetPrivilege( xRunningPrivileged );\n}\n/*-----------------------------------------------------------*/\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\nvoid *MPU_pvPortMalloc( size_t xSize ) /* FREERTOS_SYSTEM_CALL */\n{\nvoid *pvReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\npvReturn = pvPortMalloc( xSize );\n\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn pvReturn;\n}\n#endif /* configSUPPORT_DYNAMIC_ALLOCATION */\n/*-----------------------------------------------------------*/\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\nvoid MPU_vPortFree( void *pv ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nvPortFree( pv );\n\nvPortResetPrivilege( xRunningPrivileged );\n}\n#endif /* configSUPPORT_DYNAMIC_ALLOCATION */\n/*-----------------------------------------------------------*/\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\nvoid MPU_vPortInitialiseBlocks( void ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nvPortInitialiseBlocks();\n\nvPortResetPrivilege( xRunningPrivileged );\n}\n#endif /* configSUPPORT_DYNAMIC_ALLOCATION */\n/*-----------------------------------------------------------*/\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\nsize_t MPU_xPortGetFreeHeapSize( void ) /* FREERTOS_SYSTEM_CALL */\n{\nsize_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xPortGetFreeHeapSize();\n\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n#endif /* configSUPPORT_DYNAMIC_ALLOCATION */\n/*-----------------------------------------------------------*/\n\n#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) &amp;&amp; ( configUSE_TIMERS == 1 ) )\nTimerHandle_t MPU_xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) /* FREERTOS_SYSTEM_CALL */\n{\nTimerHandle_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTimerCreate( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction );\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp; ( configUSE_TIMERS == 1 ) )\nTimerHandle_t MPU_xTimerCreateStatic( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t *pxTimerBuffer ) /* FREERTOS_SYSTEM_CALL */\n{\nTimerHandle_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTimerCreateStatic( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxTimerBuffer );\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TIMERS == 1 )\nvoid *MPU_pvTimerGetTimerID( const TimerHandle_t xTimer ) /* FREERTOS_SYSTEM_CALL */\n{\nvoid * pvReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\npvReturn = pvTimerGetTimerID( xTimer );\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn pvReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TIMERS == 1 )\nvoid MPU_vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nvTimerSetTimerID( xTimer, pvNewID );\nvPortResetPrivilege( xRunningPrivileged );\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TIMERS == 1 )\nBaseType_t MPU_xTimerIsTimerActive( TimerHandle_t xTimer ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTimerIsTimerActive( xTimer );\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TIMERS == 1 )\nTaskHandle_t MPU_xTimerGetTimerDaemonTaskHandle( void ) /* FREERTOS_SYSTEM_CALL */\n{\nTaskHandle_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTimerGetTimerDaemonTaskHandle();\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( ( INCLUDE_xTimerPendFunctionCall == 1 ) &amp;&amp; ( configUSE_TIMERS == 1 ) )\nBaseType_t MPU_xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTimerPendFunctionCall( xFunctionToPend, pvParameter1, ulParameter2, xTicksToWait );\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TIMERS == 1 )\nvoid MPU_vTimerSetReloadMode( TimerHandle_t xTimer, const UBaseType_t uxAutoReload ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nvTimerSetReloadMode( xTimer, uxAutoReload );\nvPortResetPrivilege( xRunningPrivileged );\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TIMERS == 1 )\nUBaseType_t MPU_uxTimerGetReloadMode( TimerHandle_t xTimer )\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\nUBaseType_t uxReturn;\n\nuxReturn = uxTimerGetReloadMode( xTimer );\nvPortResetPrivilege( xRunningPrivileged );\nreturn uxReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TIMERS == 1 )\nconst char * MPU_pcTimerGetName( TimerHandle_t xTimer ) /* FREERTOS_SYSTEM_CALL */\n{\nconst char * pcReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\npcReturn = pcTimerGetName( xTimer );\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn pcReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TIMERS == 1 )\nTickType_t MPU_xTimerGetPeriod( TimerHandle_t xTimer ) /* FREERTOS_SYSTEM_CALL */\n{\nTickType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTimerGetPeriod( xTimer );\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TIMERS == 1 )\nTickType_t MPU_xTimerGetExpiryTime( TimerHandle_t xTimer ) /* FREERTOS_SYSTEM_CALL */\n{\nTickType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTimerGetExpiryTime( xTimer );\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TIMERS == 1 )\nBaseType_t MPU_xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xTimerGenericCommand( xTimer, xCommandID, xOptionalValue, pxHigherPriorityTaskWoken, xTicksToWait );\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\nEventGroupHandle_t MPU_xEventGroupCreate( void ) /* FREERTOS_SYSTEM_CALL */\n{\nEventGroupHandle_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xEventGroupCreate();\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\nEventGroupHandle_t MPU_xEventGroupCreateStatic( StaticEventGroup_t *pxEventGroupBuffer ) /* FREERTOS_SYSTEM_CALL */\n{\nEventGroupHandle_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xEventGroupCreateStatic( pxEventGroupBuffer );\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n#endif\n/*-----------------------------------------------------------*/\n\nEventBits_t MPU_xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */\n{\nEventBits_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xEventGroupWaitBits( xEventGroup, uxBitsToWaitFor, xClearOnExit, xWaitForAllBits, xTicksToWait );\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nEventBits_t MPU_xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear ) /* FREERTOS_SYSTEM_CALL */\n{\nEventBits_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xEventGroupClearBits( xEventGroup, uxBitsToClear );\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nEventBits_t MPU_xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet ) /* FREERTOS_SYSTEM_CALL */\n{\nEventBits_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xEventGroupSetBits( xEventGroup, uxBitsToSet );\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nEventBits_t MPU_xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */\n{\nEventBits_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xEventGroupSync( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTicksToWait );\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nvoid MPU_vEventGroupDelete( EventGroupHandle_t xEventGroup ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nvEventGroupDelete( xEventGroup );\nvPortResetPrivilege( xRunningPrivileged );\n}\n/*-----------------------------------------------------------*/\n\nsize_t MPU_xStreamBufferSend( StreamBufferHandle_t xStreamBuffer, const void *pvTxData, size_t xDataLengthBytes, TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */\n{\nsize_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xStreamBufferSend( xStreamBuffer, pvTxData, xDataLengthBytes, xTicksToWait );\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nsize_t MPU_xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer ) /* FREERTOS_SYSTEM_CALL */\n{\nsize_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xStreamBufferNextMessageLengthBytes( xStreamBuffer );\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nsize_t MPU_xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer, void *pvRxData, size_t xBufferLengthBytes, TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */\n{\nsize_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xStreamBufferReceive( xStreamBuffer, pvRxData, xBufferLengthBytes, xTicksToWait );\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nvoid MPU_vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nvStreamBufferDelete( xStreamBuffer );\nvPortResetPrivilege( xRunningPrivileged );\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t MPU_xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xStreamBufferIsFull( xStreamBuffer );\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t MPU_xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xStreamBufferIsEmpty( xStreamBuffer );\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t MPU_xStreamBufferReset( StreamBufferHandle_t xStreamBuffer ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xStreamBufferReset( xStreamBuffer );\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nsize_t MPU_xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer ) /* FREERTOS_SYSTEM_CALL */\n{\nsize_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xStreamBufferSpacesAvailable( xStreamBuffer );\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nsize_t MPU_xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer ) /* FREERTOS_SYSTEM_CALL */\n{\nsize_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xStreamBufferBytesAvailable( xStreamBuffer );\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t MPU_xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel ) /* FREERTOS_SYSTEM_CALL */\n{\nBaseType_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xStreamBufferSetTriggerLevel( xStreamBuffer, xTriggerLevel );\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\nStreamBufferHandle_t MPU_xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer ) /* FREERTOS_SYSTEM_CALL */\n{\nStreamBufferHandle_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xStreamBufferGenericCreate( xBufferSizeBytes, xTriggerLevelBytes, xIsMessageBuffer );\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n#endif /* configSUPPORT_DYNAMIC_ALLOCATION */\n/*-----------------------------------------------------------*/\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\nStreamBufferHandle_t MPU_xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer, uint8_t * const pucStreamBufferStorageArea, StaticStreamBuffer_t * const pxStaticStreamBuffer ) /* FREERTOS_SYSTEM_CALL */\n{\nStreamBufferHandle_t xReturn;\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\nxReturn = xStreamBufferGenericCreateStatic( xBufferSizeBytes, xTriggerLevelBytes, xIsMessageBuffer, pucStreamBufferStorageArea, pxStaticStreamBuffer );\nvPortResetPrivilege( xRunningPrivileged );\n\nreturn xReturn;\n}\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n/*-----------------------------------------------------------*/\n\n\n/* Functions that the application writer wants to execute in privileged mode\ncan be defined in application_defined_privileged_functions.h.  The functions\nmust take the same format as those above whereby the privilege state on exit\nequals the privilege state on entry.  For example:\n\nvoid MPU_FunctionName( [parameters ] )\n{\nBaseType_t xRunningPrivileged = xPortRaisePrivilege();\n\n    FunctionName( [parameters ] );\n\n    vPortResetPrivilege( xRunningPrivileged );\n}\n*/\n\n#if configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS == 1\n#include \"application_defined_privileged_functions.h\"\n#endif\n\n#endif // #ifdef portUSING_MPU_WRAPPERS\n</code></pre>"},{"location":"apiStm/port_8c/","title":"File port.c","text":"<p>FileList &gt; FreeRTOS &gt; src &gt; port.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"task.h\"</code></li> </ul>"},{"location":"apiStm/port_8c/#public-functions","title":"Public Functions","text":"Type Name __attribute__ ((weak))  void vPortEndScheduler (void)  void vPortEnterCritical (void)  void vPortExitCritical (void)  void vPortSVCHandler (void)  void vPortSetupTimerInterrupt (void)  void xPortPendSVHandler (void xPortSysTickHandler void void)  void xPortPendSVHandler (void)  BaseType_t xPortStartScheduler (void)  void xPortSysTickHandler (void)"},{"location":"apiStm/port_8c/#public-static-functions","title":"Public Static Functions","text":"Type Name void prvPortStartFirstTask (void)  void prvTaskExitError (void)"},{"location":"apiStm/port_8c/#macros","title":"Macros","text":"Type Name define configKERNEL_INTERRUPT_PRIORITY  255 define configSYSTICK_CLOCK_HZ  configCPU_CLOCK_HZ define portAIRCR_REG  ( * ( ( volatile uint32_t * ) 0xE000ED0C ) ) define portFIRST_USER_INTERRUPT_NUMBER  ( 16 ) define portINITIAL_XPSR  ( 0x01000000UL ) define portMAX_24_BIT_NUMBER  ( 0xffffffUL ) define portMAX_8_BIT_VALUE  ( ( uint8_t ) 0xff ) define portMAX_PRIGROUP_BITS  ( ( uint8_t ) 7 ) define portMISSED_COUNTS_FACTOR  ( 45UL ) define portNVIC_IP_REGISTERS_OFFSET_16  ( 0xE000E3F0 ) define portNVIC_PENDSVCLEAR_BIT  ( 1UL &lt;&lt; 27UL ) define portNVIC_PENDSV_PRI  ( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) &lt;&lt; 16UL ) define portNVIC_PEND_SYSTICK_CLEAR_BIT  ( 1UL &lt;&lt; 25UL ) define portNVIC_SYSPRI2_REG  ( * ( ( volatile uint32_t * ) 0xe000ed20 ) ) define portNVIC_SYSTICK_CLK_BIT  ( 1UL &lt;&lt; 2UL ) define portNVIC_SYSTICK_COUNT_FLAG_BIT  ( 1UL &lt;&lt; 16UL ) define portNVIC_SYSTICK_CTRL_REG  ( * ( ( volatile uint32_t * ) 0xe000e010 ) ) define portNVIC_SYSTICK_CURRENT_VALUE_REG  ( * ( ( volatile uint32_t * ) 0xe000e018 ) ) define portNVIC_SYSTICK_ENABLE_BIT  ( 1UL &lt;&lt; 0UL ) define portNVIC_SYSTICK_INT_BIT  ( 1UL &lt;&lt; 1UL ) define portNVIC_SYSTICK_LOAD_REG  ( * ( ( volatile uint32_t * ) 0xe000e014 ) ) define portNVIC_SYSTICK_PRI  ( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) &lt;&lt; 24UL ) define portPRIGROUP_SHIFT  ( 8UL ) define portPRIORITY_GROUP_MASK  ( 0x07UL &lt;&lt; 8UL ) define portSTART_ADDRESS_MASK  ( ( StackType_t ) 0xfffffffeUL ) define portTASK_RETURN_ADDRESS  prvTaskExitError define portTOP_BIT_OF_BYTE  ( ( uint8_t ) 0x80 ) define portVECTACTIVE_MASK  ( 0xFFUL )"},{"location":"apiStm/port_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/port_8c/#function-__attribute__","title":"function __attribute__","text":"<pre><code>__attribute__ (\n(weak)\n) </code></pre>"},{"location":"apiStm/port_8c/#function-vportendscheduler","title":"function vPortEndScheduler","text":"<pre><code>void vPortEndScheduler (\nvoid\n) </code></pre>"},{"location":"apiStm/port_8c/#function-vportentercritical","title":"function vPortEnterCritical","text":"<pre><code>void vPortEnterCritical (\nvoid\n) </code></pre>"},{"location":"apiStm/port_8c/#function-vportexitcritical","title":"function vPortExitCritical","text":"<pre><code>void vPortExitCritical (\nvoid\n) </code></pre>"},{"location":"apiStm/port_8c/#function-vportsvchandler","title":"function vPortSVCHandler","text":"<pre><code>void vPortSVCHandler (\nvoid\n) </code></pre>"},{"location":"apiStm/port_8c/#function-vportsetuptimerinterrupt","title":"function vPortSetupTimerInterrupt","text":"<pre><code>void vPortSetupTimerInterrupt (\nvoid\n) </code></pre>"},{"location":"apiStm/port_8c/#function-xportpendsvhandler","title":"function xPortPendSVHandler","text":"<pre><code>void xPortPendSVHandler (\nvoid xPortSysTickHandler void void\n) </code></pre>"},{"location":"apiStm/port_8c/#function-xportpendsvhandler_1","title":"function xPortPendSVHandler","text":"<pre><code>void xPortPendSVHandler (\nvoid\n) </code></pre>"},{"location":"apiStm/port_8c/#function-xportstartscheduler","title":"function xPortStartScheduler","text":"<pre><code>BaseType_t xPortStartScheduler (\nvoid\n) </code></pre>"},{"location":"apiStm/port_8c/#function-xportsystickhandler","title":"function xPortSysTickHandler","text":"<pre><code>void xPortSysTickHandler (\nvoid\n) </code></pre>"},{"location":"apiStm/port_8c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"apiStm/port_8c/#function-prvportstartfirsttask","title":"function prvPortStartFirstTask","text":"<pre><code>static void prvPortStartFirstTask (\nvoid\n) </code></pre>"},{"location":"apiStm/port_8c/#function-prvtaskexiterror","title":"function prvTaskExitError","text":"<pre><code>static void prvTaskExitError (\nvoid\n) </code></pre>"},{"location":"apiStm/port_8c/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/port_8c/#define-configkernel_interrupt_priority","title":"define configKERNEL_INTERRUPT_PRIORITY","text":"<pre><code>#define configKERNEL_INTERRUPT_PRIORITY 255\n</code></pre>"},{"location":"apiStm/port_8c/#define-configsystick_clock_hz","title":"define configSYSTICK_CLOCK_HZ","text":"<pre><code>#define configSYSTICK_CLOCK_HZ configCPU_CLOCK_HZ\n</code></pre>"},{"location":"apiStm/port_8c/#define-portaircr_reg","title":"define portAIRCR_REG","text":"<pre><code>#define portAIRCR_REG ( * ( ( volatile uint32_t * ) 0xE000ED0C ) )\n</code></pre>"},{"location":"apiStm/port_8c/#define-portfirst_user_interrupt_number","title":"define portFIRST_USER_INTERRUPT_NUMBER","text":"<pre><code>#define portFIRST_USER_INTERRUPT_NUMBER ( 16 )\n</code></pre>"},{"location":"apiStm/port_8c/#define-portinitial_xpsr","title":"define portINITIAL_XPSR","text":"<pre><code>#define portINITIAL_XPSR ( 0x01000000UL )\n</code></pre>"},{"location":"apiStm/port_8c/#define-portmax_24_bit_number","title":"define portMAX_24_BIT_NUMBER","text":"<pre><code>#define portMAX_24_BIT_NUMBER ( 0xffffffUL )\n</code></pre>"},{"location":"apiStm/port_8c/#define-portmax_8_bit_value","title":"define portMAX_8_BIT_VALUE","text":"<pre><code>#define portMAX_8_BIT_VALUE ( ( uint8_t ) 0xff )\n</code></pre>"},{"location":"apiStm/port_8c/#define-portmax_prigroup_bits","title":"define portMAX_PRIGROUP_BITS","text":"<pre><code>#define portMAX_PRIGROUP_BITS ( ( uint8_t ) 7 )\n</code></pre>"},{"location":"apiStm/port_8c/#define-portmissed_counts_factor","title":"define portMISSED_COUNTS_FACTOR","text":"<pre><code>#define portMISSED_COUNTS_FACTOR ( 45UL )\n</code></pre>"},{"location":"apiStm/port_8c/#define-portnvic_ip_registers_offset_16","title":"define portNVIC_IP_REGISTERS_OFFSET_16","text":"<pre><code>#define portNVIC_IP_REGISTERS_OFFSET_16 ( 0xE000E3F0 )\n</code></pre>"},{"location":"apiStm/port_8c/#define-portnvic_pendsvclear_bit","title":"define portNVIC_PENDSVCLEAR_BIT","text":"<pre><code>#define portNVIC_PENDSVCLEAR_BIT ( 1UL &lt;&lt; 27UL )\n</code></pre>"},{"location":"apiStm/port_8c/#define-portnvic_pendsv_pri","title":"define portNVIC_PENDSV_PRI","text":"<pre><code>#define portNVIC_PENDSV_PRI ( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) &lt;&lt; 16UL )\n</code></pre>"},{"location":"apiStm/port_8c/#define-portnvic_pend_systick_clear_bit","title":"define portNVIC_PEND_SYSTICK_CLEAR_BIT","text":"<pre><code>#define portNVIC_PEND_SYSTICK_CLEAR_BIT ( 1UL &lt;&lt; 25UL )\n</code></pre>"},{"location":"apiStm/port_8c/#define-portnvic_syspri2_reg","title":"define portNVIC_SYSPRI2_REG","text":"<pre><code>#define portNVIC_SYSPRI2_REG ( * ( ( volatile uint32_t * ) 0xe000ed20 ) )\n</code></pre>"},{"location":"apiStm/port_8c/#define-portnvic_systick_clk_bit","title":"define portNVIC_SYSTICK_CLK_BIT","text":"<pre><code>#define portNVIC_SYSTICK_CLK_BIT ( 1UL &lt;&lt; 2UL )\n</code></pre>"},{"location":"apiStm/port_8c/#define-portnvic_systick_count_flag_bit","title":"define portNVIC_SYSTICK_COUNT_FLAG_BIT","text":"<pre><code>#define portNVIC_SYSTICK_COUNT_FLAG_BIT ( 1UL &lt;&lt; 16UL )\n</code></pre>"},{"location":"apiStm/port_8c/#define-portnvic_systick_ctrl_reg","title":"define portNVIC_SYSTICK_CTRL_REG","text":"<pre><code>#define portNVIC_SYSTICK_CTRL_REG ( * ( ( volatile uint32_t * ) 0xe000e010 ) )\n</code></pre>"},{"location":"apiStm/port_8c/#define-portnvic_systick_current_value_reg","title":"define portNVIC_SYSTICK_CURRENT_VALUE_REG","text":"<pre><code>#define portNVIC_SYSTICK_CURRENT_VALUE_REG ( * ( ( volatile uint32_t * ) 0xe000e018 ) )\n</code></pre>"},{"location":"apiStm/port_8c/#define-portnvic_systick_enable_bit","title":"define portNVIC_SYSTICK_ENABLE_BIT","text":"<pre><code>#define portNVIC_SYSTICK_ENABLE_BIT ( 1UL &lt;&lt; 0UL )\n</code></pre>"},{"location":"apiStm/port_8c/#define-portnvic_systick_int_bit","title":"define portNVIC_SYSTICK_INT_BIT","text":"<pre><code>#define portNVIC_SYSTICK_INT_BIT ( 1UL &lt;&lt; 1UL )\n</code></pre>"},{"location":"apiStm/port_8c/#define-portnvic_systick_load_reg","title":"define portNVIC_SYSTICK_LOAD_REG","text":"<pre><code>#define portNVIC_SYSTICK_LOAD_REG ( * ( ( volatile uint32_t * ) 0xe000e014 ) )\n</code></pre>"},{"location":"apiStm/port_8c/#define-portnvic_systick_pri","title":"define portNVIC_SYSTICK_PRI","text":"<pre><code>#define portNVIC_SYSTICK_PRI ( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) &lt;&lt; 24UL )\n</code></pre>"},{"location":"apiStm/port_8c/#define-portprigroup_shift","title":"define portPRIGROUP_SHIFT","text":"<pre><code>#define portPRIGROUP_SHIFT ( 8UL )\n</code></pre>"},{"location":"apiStm/port_8c/#define-portpriority_group_mask","title":"define portPRIORITY_GROUP_MASK","text":"<pre><code>#define portPRIORITY_GROUP_MASK ( 0x07UL &lt;&lt; 8UL )\n</code></pre>"},{"location":"apiStm/port_8c/#define-portstart_address_mask","title":"define portSTART_ADDRESS_MASK","text":"<pre><code>#define portSTART_ADDRESS_MASK ( ( StackType_t ) 0xfffffffeUL )\n</code></pre>"},{"location":"apiStm/port_8c/#define-porttask_return_address","title":"define portTASK_RETURN_ADDRESS","text":"<pre><code>#define portTASK_RETURN_ADDRESS prvTaskExitError\n</code></pre>"},{"location":"apiStm/port_8c/#define-porttop_bit_of_byte","title":"define portTOP_BIT_OF_BYTE","text":"<pre><code>#define portTOP_BIT_OF_BYTE ( ( uint8_t ) 0x80 )\n</code></pre>"},{"location":"apiStm/port_8c/#define-portvectactive_mask","title":"define portVECTACTIVE_MASK","text":"<pre><code>#define portVECTACTIVE_MASK ( 0xFFUL )\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/src/port.c</code></p>"},{"location":"apiStm/port_8c_source/","title":"File port.c","text":"<p>File List &gt; FreeRTOS &gt; src &gt; port.c</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n/*-----------------------------------------------------------\n * Implementation of functions defined in portable.h for the ARM CM3 port.\n *----------------------------------------------------------*/\n\n/* Scheduler includes. */\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n\n/* For backward compatibility, ensure configKERNEL_INTERRUPT_PRIORITY is\ndefined.  The value should also ensure backward compatibility.\nFreeRTOS.org versions prior to V4.4.0 did not include this definition. */\n#ifndef configKERNEL_INTERRUPT_PRIORITY\n#define configKERNEL_INTERRUPT_PRIORITY 255\n#endif\n\n#ifndef configSYSTICK_CLOCK_HZ\n#define configSYSTICK_CLOCK_HZ configCPU_CLOCK_HZ\n/* Ensure the SysTick is clocked at the same frequency as the core. */\n#define portNVIC_SYSTICK_CLK_BIT    ( 1UL &lt;&lt; 2UL )\n#else\n/* The way the SysTick is clocked is not modified in case it is not the same\n    as the core. */\n#define portNVIC_SYSTICK_CLK_BIT    ( 0 )\n#endif\n\n/* Constants required to manipulate the core.  Registers first... */\n#define portNVIC_SYSTICK_CTRL_REG           ( * ( ( volatile uint32_t * ) 0xe000e010 ) )\n#define portNVIC_SYSTICK_LOAD_REG           ( * ( ( volatile uint32_t * ) 0xe000e014 ) )\n#define portNVIC_SYSTICK_CURRENT_VALUE_REG  ( * ( ( volatile uint32_t * ) 0xe000e018 ) )\n#define portNVIC_SYSPRI2_REG                ( * ( ( volatile uint32_t * ) 0xe000ed20 ) )\n/* ...then bits in the registers. */\n#define portNVIC_SYSTICK_INT_BIT            ( 1UL &lt;&lt; 1UL )\n#define portNVIC_SYSTICK_ENABLE_BIT         ( 1UL &lt;&lt; 0UL )\n#define portNVIC_SYSTICK_COUNT_FLAG_BIT     ( 1UL &lt;&lt; 16UL )\n#define portNVIC_PENDSVCLEAR_BIT            ( 1UL &lt;&lt; 27UL )\n#define portNVIC_PEND_SYSTICK_CLEAR_BIT     ( 1UL &lt;&lt; 25UL )\n\n#define portNVIC_PENDSV_PRI                 ( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) &lt;&lt; 16UL )\n#define portNVIC_SYSTICK_PRI                ( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) &lt;&lt; 24UL )\n\n/* Constants required to check the validity of an interrupt priority. */\n#define portFIRST_USER_INTERRUPT_NUMBER     ( 16 )\n#define portNVIC_IP_REGISTERS_OFFSET_16     ( 0xE000E3F0 )\n#define portAIRCR_REG                       ( * ( ( volatile uint32_t * ) 0xE000ED0C ) )\n#define portMAX_8_BIT_VALUE                 ( ( uint8_t ) 0xff )\n#define portTOP_BIT_OF_BYTE                 ( ( uint8_t ) 0x80 )\n#define portMAX_PRIGROUP_BITS               ( ( uint8_t ) 7 )\n#define portPRIORITY_GROUP_MASK             ( 0x07UL &lt;&lt; 8UL )\n#define portPRIGROUP_SHIFT                  ( 8UL )\n\n/* Masks off all bits but the VECTACTIVE bits in the ICSR register. */\n#define portVECTACTIVE_MASK                 ( 0xFFUL )\n\n/* Constants required to set up the initial stack. */\n#define portINITIAL_XPSR                    ( 0x01000000UL )\n\n/* The systick is a 24-bit counter. */\n#define portMAX_24_BIT_NUMBER               ( 0xffffffUL )\n\n/* A fiddle factor to estimate the number of SysTick counts that would have\noccurred while the SysTick counter is stopped during tickless idle\ncalculations. */\n#define portMISSED_COUNTS_FACTOR            ( 45UL )\n\n/* For strict compliance with the Cortex-M spec the task start address should\nhave bit-0 clear, as it is loaded into the PC on exit from an ISR. */\n#define portSTART_ADDRESS_MASK              ( ( StackType_t ) 0xfffffffeUL )\n\n/* Let the user override the pre-loading of the initial LR with the address of\nprvTaskExitError() in case it messes up unwinding of the stack in the\ndebugger. */\n#ifdef configTASK_RETURN_ADDRESS\n#define portTASK_RETURN_ADDRESS configTASK_RETURN_ADDRESS\n#else\n#define portTASK_RETURN_ADDRESS prvTaskExitError\n#endif\n\n/*\n * Setup the timer to generate the tick interrupts.  The implementation in this\n * file is weak to allow application writers to change the timer used to\n * generate the tick interrupt.\n */\nvoid vPortSetupTimerInterrupt( void );\n\n/*\n * Exception handlers.\n */\nvoid xPortPendSVHandler( void ) __attribute__ (( naked ));\nvoid xPortSysTickHandler( void );\nvoid vPortSVCHandler( void ) __attribute__ (( naked ));\n\n/*\n * Start first task is a separate function so it can be tested in isolation.\n */\nstatic void prvPortStartFirstTask( void ) __attribute__ (( naked ));\n\n/*\n * Used to catch tasks that attempt to return from their implementing function.\n */\nstatic void prvTaskExitError( void );\n\n/*-----------------------------------------------------------*/\n\n/* Each task maintains its own interrupt status in the critical nesting\nvariable. */\nstatic UBaseType_t uxCriticalNesting = 0xaaaaaaaa;\n\n/*\n * The number of SysTick increments that make up one tick period.\n */\n#if( configUSE_TICKLESS_IDLE == 1 )\nstatic uint32_t ulTimerCountsForOneTick = 0;\n#endif /* configUSE_TICKLESS_IDLE */\n\n/*\n * The maximum number of tick periods that can be suppressed is limited by the\n * 24 bit resolution of the SysTick timer.\n */\n#if( configUSE_TICKLESS_IDLE == 1 )\nstatic uint32_t xMaximumPossibleSuppressedTicks = 0;\n#endif /* configUSE_TICKLESS_IDLE */\n\n/*\n * Compensate for the CPU cycles that pass while the SysTick is stopped (low\n * power functionality only.\n */\n#if( configUSE_TICKLESS_IDLE == 1 )\nstatic uint32_t ulStoppedTimerCompensation = 0;\n#endif /* configUSE_TICKLESS_IDLE */\n\n/*\n * Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure\n * FreeRTOS API functions are not called from interrupts that have been assigned\n * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.\n */\n#if( configASSERT_DEFINED == 1 )\nstatic uint8_t ucMaxSysCallPriority = 0;\nstatic uint32_t ulMaxPRIGROUPValue = 0;\nstatic const volatile uint8_t * const pcInterruptPriorityRegisters = ( const volatile uint8_t * const ) portNVIC_IP_REGISTERS_OFFSET_16;\n#endif /* configASSERT_DEFINED */\n\n/*-----------------------------------------------------------*/\n\n/*\n * See header file for description.\n */\nStackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )\n{\n/* Simulate the stack frame as it would be created by a context switch\n    interrupt. */\npxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */\n*pxTopOfStack = portINITIAL_XPSR;   /* xPSR */\npxTopOfStack--;\n*pxTopOfStack = ( ( StackType_t ) pxCode ) &amp; portSTART_ADDRESS_MASK;    /* PC */\npxTopOfStack--;\n*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;    /* LR */\npxTopOfStack -= 5;  /* R12, R3, R2 and R1. */\n*pxTopOfStack = ( StackType_t ) pvParameters;   /* R0 */\npxTopOfStack -= 8;  /* R11, R10, R9, R8, R7, R6, R5 and R4. */\n\nreturn pxTopOfStack;\n}\n/*-----------------------------------------------------------*/\n\nstatic void prvTaskExitError( void )\n{\nvolatile uint32_t ulDummy = 0UL;\n\n/* A function that implements a task must not exit or attempt to return to\n    its caller as there is nothing to return to.  If a task wants to exit it\n    should instead call vTaskDelete( NULL ).\n\n    Artificially force an assert() to be triggered if configASSERT() is\n    defined, then stop here so application writers can catch the error. */\nconfigASSERT( uxCriticalNesting == ~0UL );\nportDISABLE_INTERRUPTS();\nwhile( ulDummy == 0 )\n{\n/* This file calls prvTaskExitError() after the scheduler has been\n        started to remove a compiler warning about the function being defined\n        but never called.  ulDummy is used purely to quieten other warnings\n        about code appearing after this function is called - making ulDummy\n        volatile makes the compiler think the function could return and\n        therefore not output an 'unreachable code' warning for code that appears\n        after it. */\n}\n}\n/*-----------------------------------------------------------*/\n\nvoid vPortSVCHandler( void )\n{\n__asm volatile (\n\"   ldr r3, pxCurrentTCBConst2      \\n\" /* Restore the context. */\n\"   ldr r1, [r3]                    \\n\" /* Use pxCurrentTCBConst to get the pxCurrentTCB address. */\n\"   ldr r0, [r1]                    \\n\" /* The first item in pxCurrentTCB is the task top of stack. */\n\"   ldmia r0!, {r4-r11}             \\n\" /* Pop the registers that are not automatically saved on exception entry and the critical nesting count. */\n\"   msr psp, r0                     \\n\" /* Restore the task stack pointer. */\n\"   isb                             \\n\"\n\"   mov r0, #0                      \\n\"\n\"   msr basepri, r0                 \\n\"\n\"   orr r14, #0xd                   \\n\"\n\"   bx r14                          \\n\"\n\"                                   \\n\"\n\"   .align 4                        \\n\"\n\"pxCurrentTCBConst2: .word pxCurrentTCB             \\n\"\n);\n}\n/*-----------------------------------------------------------*/\n\nstatic void prvPortStartFirstTask( void )\n{\n__asm volatile(\n\" ldr r0, =0xE000ED08   \\n\" /* Use the NVIC offset register to locate the stack. */\n\" ldr r0, [r0]          \\n\"\n\" ldr r0, [r0]          \\n\"\n\" msr msp, r0           \\n\" /* Set the msp back to the start of the stack. */\n\" cpsie i               \\n\" /* Globally enable interrupts. */\n\" cpsie f               \\n\"\n\" dsb                   \\n\"\n\" isb                   \\n\"\n\" svc 0                 \\n\" /* System call to start first task. */\n\" nop                   \\n\"\n);\n}\n/*-----------------------------------------------------------*/\n\n/*\n * See header file for description.\n */\nBaseType_t xPortStartScheduler( void )\n{\n/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.\n    See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */\nconfigASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );\n\n#if( configASSERT_DEFINED == 1 )\n{\nvolatile uint32_t ulOriginalPriority;\nvolatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );\nvolatile uint8_t ucMaxPriorityValue;\n\n/* Determine the maximum priority from which ISR safe FreeRTOS API\n        functions can be called.  ISR safe functions are those that end in\n        \"FromISR\".  FreeRTOS maintains separate thread and ISR API functions to\n        ensure interrupt entry is as fast and simple as possible.\n\n        Save the interrupt priority value that is about to be clobbered. */\nulOriginalPriority = *pucFirstUserPriorityRegister;\n\n/* Determine the number of priority bits available.  First write to all\n        possible bits. */\n*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;\n\n/* Read the value back to see how many bits stuck. */\nucMaxPriorityValue = *pucFirstUserPriorityRegister;\n\n/* Use the same mask on the maximum system call priority. */\nucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY &amp; ucMaxPriorityValue;\n\n/* Calculate the maximum acceptable priority group value for the number\n        of bits read back. */\nulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;\nwhile( ( ucMaxPriorityValue &amp; portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )\n{\nulMaxPRIGROUPValue--;\nucMaxPriorityValue &lt;&lt;= ( uint8_t ) 0x01;\n}\n\n#ifdef __NVIC_PRIO_BITS\n{\n/* Check the CMSIS configuration that defines the number of\n            priority bits matches the number of priority bits actually queried\n            from the hardware. */\nconfigASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );\n}\n#endif\n\n#ifdef configPRIO_BITS\n{\n/* Check the FreeRTOS configuration that defines the number of\n            priority bits matches the number of priority bits actually queried\n            from the hardware. */\nconfigASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );\n}\n#endif\n\n/* Shift the priority group value back to its position within the AIRCR\n        register. */\nulMaxPRIGROUPValue &lt;&lt;= portPRIGROUP_SHIFT;\nulMaxPRIGROUPValue &amp;= portPRIORITY_GROUP_MASK;\n\n/* Restore the clobbered interrupt priority register to its original\n        value. */\n*pucFirstUserPriorityRegister = ulOriginalPriority;\n}\n#endif /* conifgASSERT_DEFINED */\n\n/* Make PendSV and SysTick the lowest priority interrupts. */\nportNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;\nportNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;\n\n/* Start the timer that generates the tick ISR.  Interrupts are disabled\n    here already. */\nvPortSetupTimerInterrupt();\n\n/* Initialise the critical nesting count ready for the first task. */\nuxCriticalNesting = 0;\n\n/* Start the first task. */\nprvPortStartFirstTask();\n\n/* Should never get here as the tasks will now be executing!  Call the task\n    exit error function to prevent compiler warnings about a static function\n    not being called in the case that the application writer overrides this\n    functionality by defining configTASK_RETURN_ADDRESS.  Call\n    vTaskSwitchContext() so link time optimisation does not remove the\n    symbol. */\nvTaskSwitchContext();\nprvTaskExitError();\n\n/* Should not get here! */\nreturn 0;\n}\n/*-----------------------------------------------------------*/\n\nvoid vPortEndScheduler( void )\n{\n/* Not implemented in ports where there is nothing to return to.\n    Artificially force an assert. */\nconfigASSERT( uxCriticalNesting == 1000UL );\n}\n/*-----------------------------------------------------------*/\n\nvoid vPortEnterCritical( void )\n{\nportDISABLE_INTERRUPTS();\nuxCriticalNesting++;\n\n/* This is not the interrupt safe version of the enter critical function so\n    assert() if it is being called from an interrupt context.  Only API\n    functions that end in \"FromISR\" can be used in an interrupt.  Only assert if\n    the critical nesting count is 1 to protect against recursive calls if the\n    assert function also uses a critical section. */\nif( uxCriticalNesting == 1 )\n{\nconfigASSERT( ( portNVIC_INT_CTRL_REG &amp; portVECTACTIVE_MASK ) == 0 );\n}\n}\n/*-----------------------------------------------------------*/\n\nvoid vPortExitCritical( void )\n{\nconfigASSERT( uxCriticalNesting );\nuxCriticalNesting--;\nif( uxCriticalNesting == 0 )\n{\nportENABLE_INTERRUPTS();\n}\n}\n/*-----------------------------------------------------------*/\n\nvoid xPortPendSVHandler( void )\n{\n/* This is a naked function. */\n\n__asm volatile\n(\n\"   mrs r0, psp                         \\n\"\n\"   isb                                 \\n\"\n\"                                       \\n\"\n\"   ldr r3, pxCurrentTCBConst           \\n\" /* Get the location of the current TCB. */\n\"   ldr r2, [r3]                        \\n\"\n\"                                       \\n\"\n\"   stmdb r0!, {r4-r11}                 \\n\" /* Save the remaining registers. */\n\"   str r0, [r2]                        \\n\" /* Save the new top of stack into the first member of the TCB. */\n\"                                       \\n\"\n\"   stmdb sp!, {r3, r14}                \\n\"\n\"   mov r0, %0                          \\n\"\n\"   msr basepri, r0                     \\n\"\n\"   bl vTaskSwitchContext               \\n\"\n\"   mov r0, #0                          \\n\"\n\"   msr basepri, r0                     \\n\"\n\"   ldmia sp!, {r3, r14}                \\n\"\n\"                                       \\n\" /* Restore the context, including the critical nesting count. */\n\"   ldr r1, [r3]                        \\n\"\n\"   ldr r0, [r1]                        \\n\" /* The first item in pxCurrentTCB is the task top of stack. */\n\"   ldmia r0!, {r4-r11}                 \\n\" /* Pop the registers. */\n\"   msr psp, r0                         \\n\"\n\"   isb                                 \\n\"\n\"   bx r14                              \\n\"\n\"                                       \\n\"\n\"   .align 4                            \\n\"\n\"pxCurrentTCBConst: .word pxCurrentTCB  \\n\"\n::\"i\"(configMAX_SYSCALL_INTERRUPT_PRIORITY)\n);\n}\n/*-----------------------------------------------------------*/\n\nvoid xPortSysTickHandler( void )\n{\n/* The SysTick runs at the lowest interrupt priority, so when this interrupt\n    executes all interrupts must be unmasked.  There is therefore no need to\n    save and then restore the interrupt mask value as its value is already\n    known. */\nportDISABLE_INTERRUPTS();\n{\n/* Increment the RTOS tick. */\nif( xTaskIncrementTick() != pdFALSE )\n{\n/* A context switch is required.  Context switching is performed in\n            the PendSV interrupt.  Pend the PendSV interrupt. */\nportNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;\n}\n}\nportENABLE_INTERRUPTS();\n}\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TICKLESS_IDLE == 1 )\n\n__attribute__((weak)) void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )\n{\nuint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;\nTickType_t xModifiableIdleTime;\n\n/* Make sure the SysTick reload value does not overflow the counter. */\nif( xExpectedIdleTime &gt; xMaximumPossibleSuppressedTicks )\n{\nxExpectedIdleTime = xMaximumPossibleSuppressedTicks;\n}\n\n/* Stop the SysTick momentarily.  The time the SysTick is stopped for\n        is accounted for as best it can be, but using the tickless mode will\n        inevitably result in some tiny drift of the time maintained by the\n        kernel with respect to calendar time. */\nportNVIC_SYSTICK_CTRL_REG &amp;= ~portNVIC_SYSTICK_ENABLE_BIT;\n\n/* Calculate the reload value required to wait xExpectedIdleTime\n        tick periods.  -1 is used because this code will execute part way\n        through one of the tick periods. */\nulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );\nif( ulReloadValue &gt; ulStoppedTimerCompensation )\n{\nulReloadValue -= ulStoppedTimerCompensation;\n}\n\n/* Enter a critical section but don't use the taskENTER_CRITICAL()\n        method as that will mask interrupts that should exit sleep mode. */\n__asm volatile( \"cpsid i\" ::: \"memory\" );\n__asm volatile( \"dsb\" );\n__asm volatile( \"isb\" );\n\n/* If a context switch is pending or a task is waiting for the scheduler\n        to be unsuspended then abandon the low power entry. */\nif( eTaskConfirmSleepModeStatus() == eAbortSleep )\n{\n/* Restart from whatever is left in the count register to complete\n            this tick period. */\nportNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;\n\n/* Restart SysTick. */\nportNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;\n\n/* Reset the reload register to the value required for normal tick\n            periods. */\nportNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;\n\n/* Re-enable interrupts - see comments above the cpsid instruction()\n            above. */\n__asm volatile( \"cpsie i\" ::: \"memory\" );\n}\nelse\n{\n/* Set the new reload value. */\nportNVIC_SYSTICK_LOAD_REG = ulReloadValue;\n\n/* Clear the SysTick count flag and set the count value back to\n            zero. */\nportNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;\n\n/* Restart SysTick. */\nportNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;\n\n/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can\n            set its parameter to 0 to indicate that its implementation contains\n            its own wait for interrupt or wait for event instruction, and so wfi\n            should not be executed again.  However, the original expected idle\n            time variable must remain unmodified, so a copy is taken. */\nxModifiableIdleTime = xExpectedIdleTime;\nconfigPRE_SLEEP_PROCESSING( xModifiableIdleTime );\nif( xModifiableIdleTime &gt; 0 )\n{\n__asm volatile( \"dsb\" ::: \"memory\" );\n__asm volatile( \"wfi\" );\n__asm volatile( \"isb\" );\n}\nconfigPOST_SLEEP_PROCESSING( xExpectedIdleTime );\n\n/* Re-enable interrupts to allow the interrupt that brought the MCU\n            out of sleep mode to execute immediately.  see comments above\n            __disable_interrupt() call above. */\n__asm volatile( \"cpsie i\" ::: \"memory\" );\n__asm volatile( \"dsb\" );\n__asm volatile( \"isb\" );\n\n/* Disable interrupts again because the clock is about to be stopped\n            and interrupts that execute while the clock is stopped will increase\n            any slippage between the time maintained by the RTOS and calendar\n            time. */\n__asm volatile( \"cpsid i\" ::: \"memory\" );\n__asm volatile( \"dsb\" );\n__asm volatile( \"isb\" );\n\n/* Disable the SysTick clock without reading the\n            portNVIC_SYSTICK_CTRL_REG register to ensure the\n            portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.  Again,\n            the time the SysTick is stopped for is accounted for as best it can\n            be, but using the tickless mode will inevitably result in some tiny\n            drift of the time maintained by the kernel with respect to calendar\n            time*/\nportNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );\n\n/* Determine if the SysTick clock has already counted to zero and\n            been set back to the current reload value (the reload back being\n            correct for the entire expected idle time) or if the SysTick is yet\n            to count to zero (in which case an interrupt other than the SysTick\n            must have brought the system out of sleep mode). */\nif( ( portNVIC_SYSTICK_CTRL_REG &amp; portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )\n{\nuint32_t ulCalculatedLoadValue;\n\n/* The tick interrupt is already pending, and the SysTick count\n                reloaded with ulReloadValue.  Reset the\n                portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick\n                period. */\nulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );\n\n/* Don't allow a tiny value, or values that have somehow\n                underflowed because the post sleep hook did something\n                that took too long. */\nif( ( ulCalculatedLoadValue &lt; ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue &gt; ulTimerCountsForOneTick ) )\n{\nulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );\n}\n\nportNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;\n\n/* As the pending tick will be processed as soon as this\n                function exits, the tick value maintained by the tick is stepped\n                forward by one less than the time spent waiting. */\nulCompleteTickPeriods = xExpectedIdleTime - 1UL;\n}\nelse\n{\n/* Something other than the tick interrupt ended the sleep.\n                Work out how long the sleep lasted rounded to complete tick\n                periods (not the ulReload value which accounted for part\n                ticks). */\nulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;\n\n/* How many complete tick periods passed while the processor\n                was waiting? */\nulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;\n\n/* The reload value is set to whatever fraction of a single tick\n                period remains. */\nportNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;\n}\n\n/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG\n            again, then set portNVIC_SYSTICK_LOAD_REG back to its standard\n            value. */\nportNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;\nportNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;\nvTaskStepTick( ulCompleteTickPeriods );\nportNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;\n\n/* Exit with interrupts enabled. */\n__asm volatile( \"cpsie i\" ::: \"memory\" );\n}\n}\n\n#endif /* configUSE_TICKLESS_IDLE */\n/*-----------------------------------------------------------*/\n\n/*\n * Setup the systick timer to generate the tick interrupts at the required\n * frequency.\n */\n__attribute__(( weak )) void vPortSetupTimerInterrupt( void )\n{\n/* Calculate the constants required to configure the tick interrupt. */\n#if( configUSE_TICKLESS_IDLE == 1 )\n{\nulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );\nxMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;\nulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );\n}\n#endif /* configUSE_TICKLESS_IDLE */\n\n/* Stop and clear the SysTick. */\nportNVIC_SYSTICK_CTRL_REG = 0UL;\nportNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;\n\n/* Configure SysTick to interrupt at the requested rate. */\nportNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;\nportNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );\n}\n/*-----------------------------------------------------------*/\n\n#if( configASSERT_DEFINED == 1 )\n\nvoid vPortValidateInterruptPriority( void )\n{\nuint32_t ulCurrentInterrupt;\nuint8_t ucCurrentPriority;\n\n/* Obtain the number of the currently executing interrupt. */\n__asm volatile( \"mrs %0, ipsr\" : \"=r\"( ulCurrentInterrupt ) :: \"memory\" );\n\n/* Is the interrupt number a user defined interrupt? */\nif( ulCurrentInterrupt &gt;= portFIRST_USER_INTERRUPT_NUMBER )\n{\n/* Look up the interrupt's priority. */\nucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];\n\n/* The following assertion will fail if a service routine (ISR) for\n            an interrupt that has been assigned a priority above\n            configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API\n            function.  ISR safe FreeRTOS API functions must *only* be called\n            from interrupts that have been assigned a priority at or below\n            configMAX_SYSCALL_INTERRUPT_PRIORITY.\n\n            Numerically low interrupt priority numbers represent logically high\n            interrupt priorities, therefore the priority of the interrupt must\n            be set to a value equal to or numerically *higher* than\n            configMAX_SYSCALL_INTERRUPT_PRIORITY.\n\n            Interrupts that use the FreeRTOS API must not be left at their\n            default priority of zero as that is the highest possible priority,\n            which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,\n            and therefore also guaranteed to be invalid.\n\n            FreeRTOS maintains separate thread and ISR API functions to ensure\n            interrupt entry is as fast and simple as possible.\n\n            The following links provide detailed information:\n            http://www.freertos.org/RTOS-Cortex-M3-M4.html\n            http://www.freertos.org/FAQHelp.html */\nconfigASSERT( ucCurrentPriority &gt;= ucMaxSysCallPriority );\n}\n\n/* Priority grouping:  The interrupt controller (NVIC) allows the bits\n        that define each interrupt's priority to be split between bits that\n        define the interrupt's pre-emption priority bits and bits that define\n        the interrupt's sub-priority.  For simplicity all bits must be defined\n        to be pre-emption priority bits.  The following assertion will fail if\n        this is not the case (if some bits represent a sub-priority).\n\n        If the application only uses CMSIS libraries for interrupt\n        configuration then the correct setting can be achieved on all Cortex-M\n        devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the\n        scheduler.  Note however that some vendor specific peripheral libraries\n        assume a non-zero priority group setting, in which cases using a value\n        of zero will result in unpredictable behaviour. */\nconfigASSERT( ( portAIRCR_REG &amp; portPRIORITY_GROUP_MASK ) &lt;= ulMaxPRIGROUPValue );\n}\n\n#endif /* configASSERT_DEFINED */\n</code></pre>"},{"location":"apiStm/portmacro_8h/","title":"File portmacro.h","text":"<p>FileList &gt; FreeRTOS &gt; src &gt; portmacro.h</p> <p>Go to the source code of this file.</p>"},{"location":"apiStm/portmacro_8h/#public-types","title":"Public Types","text":"Type Name typedef long BaseType_t typedef portSTACK_TYPE StackType_t typedef uint32_t TickType_t typedef unsigned long UBaseType_t"},{"location":"apiStm/portmacro_8h/#public-functions","title":"Public Functions","text":"Type Name __attribute__ ((always_inline))  void vPortEnterCritical (void)  void vPortExitCritical (void)  void vPortSuppressTicksAndSleep (TickType_t xExpectedIdleTime)"},{"location":"apiStm/portmacro_8h/#public-static-functions","title":"Public Static Functions","text":"Type Name portFORCE_INLINE uint32_t ulPortRaiseBASEPRI (void)  portFORCE_INLINE void vPortRaiseBASEPRI (void)  portFORCE_INLINE void vPortSetBASEPRI (uint32_t ulNewMaskValue)  portFORCE_INLINE BaseType_t xPortIsInsideInterrupt (void)"},{"location":"apiStm/portmacro_8h/#macros","title":"Macros","text":"Type Name define configUSE_PORT_OPTIMISED_TASK_SELECTION  1 define portBASE_TYPE  long define portBYTE_ALIGNMENT  8 define portCHAR  char define portCLEAR_INTERRUPT_MASK_FROM_ISR (x) vPortSetBASEPRI(x) define portDISABLE_INTERRUPTS () vPortRaiseBASEPRI() define portDOUBLE  double define portENABLE_INTERRUPTS () vPortSetBASEPRI(0) define portEND_SWITCHING_ISR (xSwitchRequired) if( xSwitchRequired != pdFALSE ) portYIELD() define portENTER_CRITICAL () vPortEnterCritical() define portEXIT_CRITICAL () vPortExitCritical() define portFLOAT  float define portFORCE_INLINE  inline __attribute__(( always_inline)) define portGET_HIGHEST_PRIORITY (uxTopPriority, uxReadyPriorities) uxTopPriority = ( 31UL - ( uint32_t ) ucPortCountLeadingZeros( ( uxReadyPriorities ) ) ) define portINLINE  __inline define portLONG  long define portMAX_DELAY  ( TickType_t ) 0xffffffffUL define portMEMORY_BARRIER () __asm volatile( \"\" ::: \"memory\" ) define portNOP ()  define portNVIC_INT_CTRL_REG  ( * ( ( volatile uint32_t * ) 0xe000ed04 ) ) define portNVIC_PENDSVSET_BIT  ( 1UL &lt;&lt; 28UL ) define portRECORD_READY_PRIORITY (uxPriority, uxReadyPriorities) ( uxReadyPriorities ) |= ( 1UL &lt;&lt; ( uxPriority ) ) define portRESET_READY_PRIORITY (uxPriority, uxReadyPriorities) ( uxReadyPriorities ) &amp;= ~( 1UL &lt;&lt; ( uxPriority ) ) define portSET_INTERRUPT_MASK_FROM_ISR () ulPortRaiseBASEPRI() define portSHORT  short define portSTACK_GROWTH  ( -1 ) define portSTACK_TYPE  uint32_t define portSUPPRESS_TICKS_AND_SLEEP (xExpectedIdleTime) vPortSuppressTicksAndSleep( xExpectedIdleTime ) define portTASK_FUNCTION (vFunction, pvParameters) void vFunction( void *pvParameters ) define portTASK_FUNCTION_PROTO (vFunction, pvParameters) void vFunction( void *pvParameters ) define portTICK_PERIOD_MS  ( ( TickType_t ) 1000 / configTICK_RATE_HZ ) define portTICK_TYPE_IS_ATOMIC  1 define portYIELD ()  define portYIELD_FROM_ISR (x) portEND_SWITCHING_ISR( x )"},{"location":"apiStm/portmacro_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/portmacro_8h/#typedef-basetype_t","title":"typedef BaseType_t","text":"<pre><code>typedef long BaseType_t;\n</code></pre>"},{"location":"apiStm/portmacro_8h/#typedef-stacktype_t","title":"typedef StackType_t","text":"<pre><code>typedef portSTACK_TYPE StackType_t;\n</code></pre>"},{"location":"apiStm/portmacro_8h/#typedef-ticktype_t","title":"typedef TickType_t","text":"<pre><code>typedef uint32_t TickType_t;\n</code></pre>"},{"location":"apiStm/portmacro_8h/#typedef-ubasetype_t","title":"typedef UBaseType_t","text":"<pre><code>typedef unsigned long UBaseType_t;\n</code></pre>"},{"location":"apiStm/portmacro_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/portmacro_8h/#function-__attribute__","title":"function __attribute__","text":"<pre><code>__attribute__ (\n(always_inline)\n) </code></pre>"},{"location":"apiStm/portmacro_8h/#function-vportentercritical","title":"function vPortEnterCritical","text":"<pre><code>void vPortEnterCritical (\nvoid\n) </code></pre>"},{"location":"apiStm/portmacro_8h/#function-vportexitcritical","title":"function vPortExitCritical","text":"<pre><code>void vPortExitCritical (\nvoid\n) </code></pre>"},{"location":"apiStm/portmacro_8h/#function-vportsuppressticksandsleep","title":"function vPortSuppressTicksAndSleep","text":"<pre><code>void vPortSuppressTicksAndSleep (\nTickType_t xExpectedIdleTime\n) </code></pre>"},{"location":"apiStm/portmacro_8h/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"apiStm/portmacro_8h/#function-ulportraisebasepri","title":"function ulPortRaiseBASEPRI","text":"<pre><code>static portFORCE_INLINE uint32_t ulPortRaiseBASEPRI (\nvoid\n) </code></pre>"},{"location":"apiStm/portmacro_8h/#function-vportraisebasepri","title":"function vPortRaiseBASEPRI","text":"<pre><code>static portFORCE_INLINE void vPortRaiseBASEPRI (\nvoid\n) </code></pre>"},{"location":"apiStm/portmacro_8h/#function-vportsetbasepri","title":"function vPortSetBASEPRI","text":"<pre><code>static portFORCE_INLINE void vPortSetBASEPRI (\nuint32_t ulNewMaskValue\n) </code></pre>"},{"location":"apiStm/portmacro_8h/#function-xportisinsideinterrupt","title":"function xPortIsInsideInterrupt","text":"<pre><code>static portFORCE_INLINE BaseType_t xPortIsInsideInterrupt (\nvoid\n) </code></pre>"},{"location":"apiStm/portmacro_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/portmacro_8h/#define-configuse_port_optimised_task_selection","title":"define configUSE_PORT_OPTIMISED_TASK_SELECTION","text":"<pre><code>#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portbase_type","title":"define portBASE_TYPE","text":"<pre><code>#define portBASE_TYPE long\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portbyte_alignment","title":"define portBYTE_ALIGNMENT","text":"<pre><code>#define portBYTE_ALIGNMENT 8\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portchar","title":"define portCHAR","text":"<pre><code>#define portCHAR char\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portclear_interrupt_mask_from_isr","title":"define portCLEAR_INTERRUPT_MASK_FROM_ISR","text":"<pre><code>#define portCLEAR_INTERRUPT_MASK_FROM_ISR (\nx\n) vPortSetBASEPRI(x)\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portdisable_interrupts","title":"define portDISABLE_INTERRUPTS","text":"<pre><code>#define portDISABLE_INTERRUPTS (\n\n) vPortRaiseBASEPRI()\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portdouble","title":"define portDOUBLE","text":"<pre><code>#define portDOUBLE double\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portenable_interrupts","title":"define portENABLE_INTERRUPTS","text":"<pre><code>#define portENABLE_INTERRUPTS (\n\n) vPortSetBASEPRI(0)\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portend_switching_isr","title":"define portEND_SWITCHING_ISR","text":"<pre><code>#define portEND_SWITCHING_ISR (\nxSwitchRequired\n) if( xSwitchRequired != pdFALSE ) portYIELD()\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portenter_critical","title":"define portENTER_CRITICAL","text":"<pre><code>#define portENTER_CRITICAL (\n\n) vPortEnterCritical()\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portexit_critical","title":"define portEXIT_CRITICAL","text":"<pre><code>#define portEXIT_CRITICAL (\n\n) vPortExitCritical()\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portfloat","title":"define portFLOAT","text":"<pre><code>#define portFLOAT float\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portforce_inline","title":"define portFORCE_INLINE","text":"<pre><code>#define portFORCE_INLINE inline __attribute__(( always_inline))\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portget_highest_priority","title":"define portGET_HIGHEST_PRIORITY","text":"<pre><code>#define portGET_HIGHEST_PRIORITY (\nuxTopPriority,\nuxReadyPriorities\n) uxTopPriority = ( 31UL - ( uint32_t ) ucPortCountLeadingZeros( ( uxReadyPriorities ) ) )\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portinline","title":"define portINLINE","text":"<pre><code>#define portINLINE __inline\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portlong","title":"define portLONG","text":"<pre><code>#define portLONG long\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portmax_delay","title":"define portMAX_DELAY","text":"<pre><code>#define portMAX_DELAY ( TickType_t ) 0xffffffffUL\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portmemory_barrier","title":"define portMEMORY_BARRIER","text":"<pre><code>#define portMEMORY_BARRIER (\n\n) __asm volatile( \"\" ::: \"memory\" )\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portnop","title":"define portNOP","text":"<pre><code>#define portNOP (\n\n) </code></pre>"},{"location":"apiStm/portmacro_8h/#define-portnvic_int_ctrl_reg","title":"define portNVIC_INT_CTRL_REG","text":"<pre><code>#define portNVIC_INT_CTRL_REG ( * ( ( volatile uint32_t * ) 0xe000ed04 ) )\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portnvic_pendsvset_bit","title":"define portNVIC_PENDSVSET_BIT","text":"<pre><code>#define portNVIC_PENDSVSET_BIT ( 1UL &lt;&lt; 28UL )\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portrecord_ready_priority","title":"define portRECORD_READY_PRIORITY","text":"<pre><code>#define portRECORD_READY_PRIORITY (\nuxPriority,\nuxReadyPriorities\n) ( uxReadyPriorities ) |= ( 1UL &lt;&lt; ( uxPriority ) )\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portreset_ready_priority","title":"define portRESET_READY_PRIORITY","text":"<pre><code>#define portRESET_READY_PRIORITY (\nuxPriority,\nuxReadyPriorities\n) ( uxReadyPriorities ) &amp;= ~( 1UL &lt;&lt; ( uxPriority ) )\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portset_interrupt_mask_from_isr","title":"define portSET_INTERRUPT_MASK_FROM_ISR","text":"<pre><code>#define portSET_INTERRUPT_MASK_FROM_ISR (\n\n) ulPortRaiseBASEPRI()\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portshort","title":"define portSHORT","text":"<pre><code>#define portSHORT short\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portstack_growth","title":"define portSTACK_GROWTH","text":"<pre><code>#define portSTACK_GROWTH ( -1 )\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portstack_type","title":"define portSTACK_TYPE","text":"<pre><code>#define portSTACK_TYPE uint32_t\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portsuppress_ticks_and_sleep","title":"define portSUPPRESS_TICKS_AND_SLEEP","text":"<pre><code>#define portSUPPRESS_TICKS_AND_SLEEP (\nxExpectedIdleTime\n) vPortSuppressTicksAndSleep( xExpectedIdleTime )\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-porttask_function","title":"define portTASK_FUNCTION","text":"<pre><code>#define portTASK_FUNCTION (\nvFunction,\npvParameters\n) void vFunction( void *pvParameters )\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-porttask_function_proto","title":"define portTASK_FUNCTION_PROTO","text":"<pre><code>#define portTASK_FUNCTION_PROTO (\nvFunction,\npvParameters\n) void vFunction( void *pvParameters )\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-porttick_period_ms","title":"define portTICK_PERIOD_MS","text":"<pre><code>#define portTICK_PERIOD_MS ( ( TickType_t ) 1000 / configTICK_RATE_HZ )\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-porttick_type_is_atomic","title":"define portTICK_TYPE_IS_ATOMIC","text":"<pre><code>#define portTICK_TYPE_IS_ATOMIC 1\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portyield","title":"define portYIELD","text":"<pre><code>#define portYIELD (\n\n) {                                                                             \\\n    /* Set a PendSV to request a context switch. */                             \\\n    portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;                             \\\n                                                                                \\\n    /* Barriers are normally not required but do ensure the code is completely  \\\n    within the specified behaviour for the architecture. */                     \\\n    __asm volatile( \"dsb\" ::: \"memory\" );                                       \\\n    __asm volatile( \"isb\" );                                                    \\\n}\n</code></pre>"},{"location":"apiStm/portmacro_8h/#define-portyield_from_isr","title":"define portYIELD_FROM_ISR","text":"<pre><code>#define portYIELD_FROM_ISR (\nx\n) portEND_SWITCHING_ISR( x )\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/src/portmacro.h</code></p>"},{"location":"apiStm/portmacro_8h_source/","title":"File portmacro.h","text":"<p>File List &gt; FreeRTOS &gt; src &gt; portmacro.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n\n#ifndef PORTMACRO_H\n#define PORTMACRO_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*-----------------------------------------------------------\n * Port specific definitions.\n *\n * The settings in this file configure FreeRTOS correctly for the\n * given hardware and compiler.\n *\n * These settings should not be altered.\n *-----------------------------------------------------------\n */\n\n/* Type definitions. */\n#define portCHAR        char\n#define portFLOAT       float\n#define portDOUBLE      double\n#define portLONG        long\n#define portSHORT       short\n#define portSTACK_TYPE  uint32_t\n#define portBASE_TYPE   long\n\ntypedef portSTACK_TYPE StackType_t;\ntypedef long BaseType_t;\ntypedef unsigned long UBaseType_t;\n\n#if( configUSE_16_BIT_TICKS == 1 )\ntypedef uint16_t TickType_t;\n#define portMAX_DELAY ( TickType_t ) 0xffff\n#else\ntypedef uint32_t TickType_t;\n#define portMAX_DELAY ( TickType_t ) 0xffffffffUL\n\n/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do\n    not need to be guarded with a critical section. */\n#define portTICK_TYPE_IS_ATOMIC 1\n#endif\n/*-----------------------------------------------------------*/\n\n/* Architecture specifics. */\n#define portSTACK_GROWTH            ( -1 )\n#define portTICK_PERIOD_MS          ( ( TickType_t ) 1000 / configTICK_RATE_HZ )\n#define portBYTE_ALIGNMENT          8\n/*-----------------------------------------------------------*/\n\n/* Scheduler utilities. */\n#define portYIELD()                                                             \\\n{                                                                               \\\n/* Set a PendSV to request a context switch. */                             \\\n    portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;                             \\\n                                                                                \\\n/* Barriers are normally not required but do ensure the code is completely  \\\n    within the specified behaviour for the architecture. */                     \\\n    __asm volatile( \"dsb\" ::: \"memory\" );                                       \\\n    __asm volatile( \"isb\" );                                                    \\\n}\n\n#define portNVIC_INT_CTRL_REG       ( * ( ( volatile uint32_t * ) 0xe000ed04 ) )\n#define portNVIC_PENDSVSET_BIT      ( 1UL &lt;&lt; 28UL )\n#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()\n#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )\n/*-----------------------------------------------------------*/\n\n/* Critical section management. */\nextern void vPortEnterCritical( void );\nextern void vPortExitCritical( void );\n#define portSET_INTERRUPT_MASK_FROM_ISR()       ulPortRaiseBASEPRI()\n#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)    vPortSetBASEPRI(x)\n#define portDISABLE_INTERRUPTS()                vPortRaiseBASEPRI()\n#define portENABLE_INTERRUPTS()                 vPortSetBASEPRI(0)\n#define portENTER_CRITICAL()                    vPortEnterCritical()\n#define portEXIT_CRITICAL()                     vPortExitCritical()\n\n/*-----------------------------------------------------------*/\n\n/* Task function macros as described on the FreeRTOS.org WEB site.  These are\nnot necessary for to use this port.  They are defined so the common demo files\n(which build with all the ports) will build. */\n#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )\n#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )\n/*-----------------------------------------------------------*/\n\n/* Tickless idle/low power functionality. */\n#ifndef portSUPPRESS_TICKS_AND_SLEEP\nextern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );\n#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )\n#endif\n/*-----------------------------------------------------------*/\n\n/* Architecture specific optimisations. */\n#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION\n#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1\n#endif\n\n#if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1\n\n/* Generic helper function. */\n__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )\n{\nuint8_t ucReturn;\n\n__asm volatile ( \"clz %0, %1\" : \"=r\" ( ucReturn ) : \"r\" ( ulBitmap ) : \"memory\" );\nreturn ucReturn;\n}\n\n/* Check the configuration. */\n#if( configMAX_PRIORITIES &gt; 32 )\n#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.\n#endif\n\n/* Store/clear the ready priorities in a bit map. */\n#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL &lt;&lt; ( uxPriority ) )\n#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &amp;= ~( 1UL &lt;&lt; ( uxPriority ) )\n\n/*-----------------------------------------------------------*/\n\n#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( uint32_t ) ucPortCountLeadingZeros( ( uxReadyPriorities ) ) )\n\n#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */\n\n/*-----------------------------------------------------------*/\n\n#ifdef configASSERT\nvoid vPortValidateInterruptPriority( void );\n#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()  vPortValidateInterruptPriority()\n#endif\n\n/* portNOP() is not required by this port. */\n#define portNOP()\n\n#define portINLINE  __inline\n\n#ifndef portFORCE_INLINE\n#define portFORCE_INLINE inline __attribute__(( always_inline))\n#endif\n\n/*-----------------------------------------------------------*/\n\nportFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )\n{\nuint32_t ulCurrentInterrupt;\nBaseType_t xReturn;\n\n/* Obtain the number of the currently executing interrupt. */\n__asm volatile( \"mrs %0, ipsr\" : \"=r\"( ulCurrentInterrupt ) :: \"memory\" );\n\nif( ulCurrentInterrupt == 0 )\n{\nxReturn = pdFALSE;\n}\nelse\n{\nxReturn = pdTRUE;\n}\n\nreturn xReturn;\n}\n\n/*-----------------------------------------------------------*/\n\nportFORCE_INLINE static void vPortRaiseBASEPRI( void )\n{\nuint32_t ulNewBASEPRI;\n\n__asm volatile\n(\n\"   mov %0, %1                                              \\n\" \\\n        \"   msr basepri, %0                                         \\n\" \\\n        \"   isb                                                     \\n\" \\\n        \"   dsb                                                     \\n\" \\\n        :\"=r\" (ulNewBASEPRI) : \"i\" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : \"memory\"\n);\n}\n\n/*-----------------------------------------------------------*/\n\nportFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )\n{\nuint32_t ulOriginalBASEPRI, ulNewBASEPRI;\n\n__asm volatile\n(\n\"   mrs %0, basepri                                         \\n\" \\\n        \"   mov %1, %2                                              \\n\" \\\n        \"   msr basepri, %1                                         \\n\" \\\n        \"   isb                                                     \\n\" \\\n        \"   dsb                                                     \\n\" \\\n        :\"=r\" (ulOriginalBASEPRI), \"=r\" (ulNewBASEPRI) : \"i\" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : \"memory\"\n);\n\n/* This return will not be reached but is necessary to prevent compiler\n    warnings. */\nreturn ulOriginalBASEPRI;\n}\n/*-----------------------------------------------------------*/\n\nportFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )\n{\n__asm volatile\n(\n\"   msr basepri, %0 \" :: \"r\" ( ulNewMaskValue ) : \"memory\"\n);\n}\n/*-----------------------------------------------------------*/\n\n#define portMEMORY_BARRIER() __asm volatile( \"\" ::: \"memory\" )\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* PORTMACRO_H */\n</code></pre>"},{"location":"apiStm/queue_8c/","title":"File queue.c","text":"<p>FileList &gt; FreeRTOS &gt; src &gt; queue.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include &lt;string.h&gt;</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"task.h\"</code></li> <li><code>#include \"queue.h\"</code></li> </ul>"},{"location":"apiStm/queue_8c/#classes","title":"Classes","text":"Type Name struct QueueDefinition struct QueuePointers struct SemaphoreData"},{"location":"apiStm/queue_8c/#public-types","title":"Public Types","text":"Type Name typedef struct QueuePointers QueuePointers_t typedef xQUEUE Queue_t typedef struct SemaphoreData SemaphoreData_t typedef struct QueueDefinition xQUEUE"},{"location":"apiStm/queue_8c/#public-functions","title":"Public Functions","text":"Type Name UBaseType_t uxQueueMessagesWaiting (const QueueHandle_t xQueue)  UBaseType_t uxQueueMessagesWaitingFromISR (const QueueHandle_t xQueue)  UBaseType_t uxQueueSpacesAvailable (const QueueHandle_t xQueue)  void vQueueDelete (QueueHandle_t xQueue)  BaseType_t xQueueGenericReset (QueueHandle_t xQueue, BaseType_t xNewQueue)  BaseType_t xQueueGenericSend (QueueHandle_t xQueue, const void *const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition)  BaseType_t xQueueGenericSendFromISR (QueueHandle_t xQueue, const void *const pvItemToQueue, BaseType_t *const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition)  BaseType_t xQueueGiveFromISR (QueueHandle_t xQueue, BaseType_t *const pxHigherPriorityTaskWoken)  BaseType_t xQueueIsQueueEmptyFromISR (const QueueHandle_t xQueue)  BaseType_t xQueueIsQueueFullFromISR (const QueueHandle_t xQueue)  BaseType_t xQueuePeek (QueueHandle_t xQueue, void *const pvBuffer, TickType_t xTicksToWait)  BaseType_t xQueuePeekFromISR (QueueHandle_t xQueue, void *const pvBuffer)  BaseType_t xQueueReceive (QueueHandle_t xQueue, void *const pvBuffer, TickType_t xTicksToWait)  BaseType_t xQueueReceiveFromISR (QueueHandle_t xQueue, void *const pvBuffer, BaseType_t *const pxHigherPriorityTaskWoken)  BaseType_t xQueueSemaphoreTake (QueueHandle_t xQueue, TickType_t xTicksToWait)"},{"location":"apiStm/queue_8c/#public-static-functions","title":"Public Static Functions","text":"Type Name void prvCopyDataFromQueue (Queue_t *const pxQueue, void *const pvBuffer)  BaseType_t prvCopyDataToQueue (Queue_t *const pxQueue, const void * pvItemToQueue, const BaseType_t xPosition)  void prvInitialiseNewQueue (const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t * pucQueueStorage, const uint8_t ucQueueType, Queue_t * pxNewQueue)  BaseType_t prvIsQueueEmpty (const Queue_t * pxQueue)  BaseType_t prvIsQueueFull (const Queue_t * pxQueue)  void prvUnlockQueue (Queue_t *const pxQueue)"},{"location":"apiStm/queue_8c/#macros","title":"Macros","text":"Type Name define MPU_WRAPPERS_INCLUDED_FROM_API_FILE define prvLockQueue (pxQueue)  define queueLOCKED_UNMODIFIED  ( ( int8_t ) 0 ) define queueMUTEX_GIVE_BLOCK_TIME  ( ( TickType_t ) 0U ) define queueQUEUE_IS_MUTEX  NULL define queueSEMAPHORE_QUEUE_ITEM_LENGTH  ( ( UBaseType_t ) 0 ) define queueUNLOCKED  ( ( int8_t ) -1 ) define queueYIELD_IF_USING_PREEMPTION ()  define uxQueueType  pcHead"},{"location":"apiStm/queue_8c/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/queue_8c/#typedef-queuepointers_t","title":"typedef QueuePointers_t","text":"<pre><code>typedef struct QueuePointers QueuePointers_t;\n</code></pre>"},{"location":"apiStm/queue_8c/#typedef-queue_t","title":"typedef Queue_t","text":"<pre><code>typedef xQUEUE Queue_t;\n</code></pre>"},{"location":"apiStm/queue_8c/#typedef-semaphoredata_t","title":"typedef SemaphoreData_t","text":"<pre><code>typedef struct SemaphoreData SemaphoreData_t;\n</code></pre>"},{"location":"apiStm/queue_8c/#typedef-xqueue","title":"typedef xQUEUE","text":"<pre><code>typedef struct QueueDefinition xQUEUE;\n</code></pre>"},{"location":"apiStm/queue_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/queue_8c/#function-uxqueuemessageswaiting","title":"function uxQueueMessagesWaiting","text":"<pre><code>UBaseType_t uxQueueMessagesWaiting (\nconst QueueHandle_t xQueue\n) </code></pre>"},{"location":"apiStm/queue_8c/#function-uxqueuemessageswaitingfromisr","title":"function uxQueueMessagesWaitingFromISR","text":"<pre><code>UBaseType_t uxQueueMessagesWaitingFromISR (\nconst QueueHandle_t xQueue\n) </code></pre>"},{"location":"apiStm/queue_8c/#function-uxqueuespacesavailable","title":"function uxQueueSpacesAvailable","text":"<pre><code>UBaseType_t uxQueueSpacesAvailable (\nconst QueueHandle_t xQueue\n) </code></pre>"},{"location":"apiStm/queue_8c/#function-vqueuedelete","title":"function vQueueDelete","text":"<pre><code>void vQueueDelete (\nQueueHandle_t xQueue\n) </code></pre>"},{"location":"apiStm/queue_8c/#function-xqueuegenericreset","title":"function xQueueGenericReset","text":"<pre><code>BaseType_t xQueueGenericReset (\nQueueHandle_t xQueue,\nBaseType_t xNewQueue\n) </code></pre>"},{"location":"apiStm/queue_8c/#function-xqueuegenericsend","title":"function xQueueGenericSend","text":"<pre><code>BaseType_t xQueueGenericSend (\nQueueHandle_t xQueue,\nconst void *const pvItemToQueue,\nTickType_t xTicksToWait,\nconst BaseType_t xCopyPosition\n) </code></pre>"},{"location":"apiStm/queue_8c/#function-xqueuegenericsendfromisr","title":"function xQueueGenericSendFromISR","text":"<pre><code>BaseType_t xQueueGenericSendFromISR (\nQueueHandle_t xQueue,\nconst void *const pvItemToQueue,\nBaseType_t *const pxHigherPriorityTaskWoken,\nconst BaseType_t xCopyPosition\n) </code></pre>"},{"location":"apiStm/queue_8c/#function-xqueuegivefromisr","title":"function xQueueGiveFromISR","text":"<pre><code>BaseType_t xQueueGiveFromISR (\nQueueHandle_t xQueue,\nBaseType_t *const pxHigherPriorityTaskWoken\n) </code></pre>"},{"location":"apiStm/queue_8c/#function-xqueueisqueueemptyfromisr","title":"function xQueueIsQueueEmptyFromISR","text":"<pre><code>BaseType_t xQueueIsQueueEmptyFromISR (\nconst QueueHandle_t xQueue\n) </code></pre>"},{"location":"apiStm/queue_8c/#function-xqueueisqueuefullfromisr","title":"function xQueueIsQueueFullFromISR","text":"<pre><code>BaseType_t xQueueIsQueueFullFromISR (\nconst QueueHandle_t xQueue\n) </code></pre>"},{"location":"apiStm/queue_8c/#function-xqueuepeek","title":"function xQueuePeek","text":"<pre><code>BaseType_t xQueuePeek (\nQueueHandle_t xQueue,\nvoid *const pvBuffer,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/queue_8c/#function-xqueuepeekfromisr","title":"function xQueuePeekFromISR","text":"<pre><code>BaseType_t xQueuePeekFromISR (\nQueueHandle_t xQueue,\nvoid *const pvBuffer\n) </code></pre>"},{"location":"apiStm/queue_8c/#function-xqueuereceive","title":"function xQueueReceive","text":"<pre><code>BaseType_t xQueueReceive (\nQueueHandle_t xQueue,\nvoid *const pvBuffer,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/queue_8c/#function-xqueuereceivefromisr","title":"function xQueueReceiveFromISR","text":"<pre><code>BaseType_t xQueueReceiveFromISR (\nQueueHandle_t xQueue,\nvoid *const pvBuffer,\nBaseType_t *const pxHigherPriorityTaskWoken\n) </code></pre>"},{"location":"apiStm/queue_8c/#function-xqueuesemaphoretake","title":"function xQueueSemaphoreTake","text":"<pre><code>BaseType_t xQueueSemaphoreTake (\nQueueHandle_t xQueue,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/queue_8c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"apiStm/queue_8c/#function-prvcopydatafromqueue","title":"function prvCopyDataFromQueue","text":"<pre><code>static void prvCopyDataFromQueue (\nQueue_t *const pxQueue,\nvoid *const pvBuffer\n) </code></pre>"},{"location":"apiStm/queue_8c/#function-prvcopydatatoqueue","title":"function prvCopyDataToQueue","text":"<pre><code>static BaseType_t prvCopyDataToQueue (\nQueue_t *const pxQueue,\nconst void * pvItemToQueue,\nconst BaseType_t xPosition\n) </code></pre>"},{"location":"apiStm/queue_8c/#function-prvinitialisenewqueue","title":"function prvInitialiseNewQueue","text":"<pre><code>static void prvInitialiseNewQueue (\nconst UBaseType_t uxQueueLength,\nconst UBaseType_t uxItemSize,\nuint8_t * pucQueueStorage,\nconst uint8_t ucQueueType,\nQueue_t * pxNewQueue\n) </code></pre>"},{"location":"apiStm/queue_8c/#function-prvisqueueempty","title":"function prvIsQueueEmpty","text":"<pre><code>static BaseType_t prvIsQueueEmpty (\nconst Queue_t * pxQueue\n) </code></pre>"},{"location":"apiStm/queue_8c/#function-prvisqueuefull","title":"function prvIsQueueFull","text":"<pre><code>static BaseType_t prvIsQueueFull (\nconst Queue_t * pxQueue\n) </code></pre>"},{"location":"apiStm/queue_8c/#function-prvunlockqueue","title":"function prvUnlockQueue","text":"<pre><code>static void prvUnlockQueue (\nQueue_t *const pxQueue\n) </code></pre>"},{"location":"apiStm/queue_8c/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/queue_8c/#define-mpu_wrappers_included_from_api_file","title":"define MPU_WRAPPERS_INCLUDED_FROM_API_FILE","text":"<pre><code>#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE \n</code></pre>"},{"location":"apiStm/queue_8c/#define-prvlockqueue","title":"define prvLockQueue","text":"<pre><code>#define prvLockQueue (\npxQueue\n) taskENTER_CRITICAL();                                 \\\n    {                                                       \\\n        if( ( pxQueue )-&gt;cRxLock == queueUNLOCKED )         \\\n        {                                                   \\\n            ( pxQueue )-&gt;cRxLock = queueLOCKED_UNMODIFIED;  \\\n        }                                                   \\\n        if( ( pxQueue )-&gt;cTxLock == queueUNLOCKED )         \\\n        {                                                   \\\n            ( pxQueue )-&gt;cTxLock = queueLOCKED_UNMODIFIED;  \\\n        }                                                   \\\n    }                                                       \\\n    taskEXIT_CRITICAL()\n</code></pre>"},{"location":"apiStm/queue_8c/#define-queuelocked_unmodified","title":"define queueLOCKED_UNMODIFIED","text":"<pre><code>#define queueLOCKED_UNMODIFIED ( ( int8_t ) 0 )\n</code></pre>"},{"location":"apiStm/queue_8c/#define-queuemutex_give_block_time","title":"define queueMUTEX_GIVE_BLOCK_TIME","text":"<pre><code>#define queueMUTEX_GIVE_BLOCK_TIME ( ( TickType_t ) 0U )\n</code></pre>"},{"location":"apiStm/queue_8c/#define-queuequeue_is_mutex","title":"define queueQUEUE_IS_MUTEX","text":"<pre><code>#define queueQUEUE_IS_MUTEX NULL\n</code></pre>"},{"location":"apiStm/queue_8c/#define-queuesemaphore_queue_item_length","title":"define queueSEMAPHORE_QUEUE_ITEM_LENGTH","text":"<pre><code>#define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )\n</code></pre>"},{"location":"apiStm/queue_8c/#define-queueunlocked","title":"define queueUNLOCKED","text":"<pre><code>#define queueUNLOCKED ( ( int8_t ) -1 )\n</code></pre>"},{"location":"apiStm/queue_8c/#define-queueyield_if_using_preemption","title":"define queueYIELD_IF_USING_PREEMPTION","text":"<pre><code>#define queueYIELD_IF_USING_PREEMPTION (\n\n) </code></pre>"},{"location":"apiStm/queue_8c/#define-uxqueuetype","title":"define uxQueueType","text":"<pre><code>#define uxQueueType pcHead\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/src/queue.c</code></p>"},{"location":"apiStm/queue_8c_source/","title":"File queue.c","text":"<p>File List &gt; FreeRTOS &gt; src &gt; queue.c</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining\nall the API functions to use the MPU wrappers.  That should only be done when\ntask.h is included from an application file. */\n#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE\n\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n#include \"queue.h\"\n\n#if ( configUSE_CO_ROUTINES == 1 )\n#include \"croutine.h\"\n#endif\n\n/* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified\nbecause the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined\nfor the header files above, but not in this file, in order to generate the\ncorrect privileged Vs unprivileged linkage and placement. */\n#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */\n\n\n/* Constants used with the cRxLock and cTxLock structure members. */\n#define queueUNLOCKED                   ( ( int8_t ) -1 )\n#define queueLOCKED_UNMODIFIED          ( ( int8_t ) 0 )\n\n/* When the Queue_t structure is used to represent a base queue its pcHead and\npcTail members are used as pointers into the queue storage area.  When the\nQueue_t structure is used to represent a mutex pcHead and pcTail pointers are\nnot necessary, and the pcHead pointer is set to NULL to indicate that the\nstructure instead holds a pointer to the mutex holder (if any).  Map alternative\nnames to the pcHead and structure member to ensure the readability of the code\nis maintained.  The QueuePointers_t and SemaphoreData_t types are used to form\na union as their usage is mutually exclusive dependent on what the queue is\nbeing used for. */\n#define uxQueueType                     pcHead\n#define queueQUEUE_IS_MUTEX             NULL\n\ntypedef struct QueuePointers\n{\nint8_t *pcTail;                 /*&lt; Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */\nint8_t *pcReadFrom;             /*&lt; Points to the last place that a queued item was read from when the structure is used as a queue. */\n} QueuePointers_t;\n\ntypedef struct SemaphoreData\n{\nTaskHandle_t xMutexHolder;       /*&lt; The handle of the task that holds the mutex. */\nUBaseType_t uxRecursiveCallCount;/*&lt; Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. */\n} SemaphoreData_t;\n\n/* Semaphores do not actually store or copy data, so have an item size of\nzero. */\n#define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )\n#define queueMUTEX_GIVE_BLOCK_TIME       ( ( TickType_t ) 0U )\n\n#if( configUSE_PREEMPTION == 0 )\n/* If the cooperative scheduler is being used then a yield should not be\n    performed just because a higher priority task has been woken. */\n#define queueYIELD_IF_USING_PREEMPTION()\n#else\n#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()\n#endif\n\n/*\n * Definition of the queue used by the scheduler.\n * Items are queued by copy, not reference.  See the following link for the\n * rationale: https://www.freertos.org/Embedded-RTOS-Queues.html\n */\ntypedef struct QueueDefinition      /* The old naming convention is used to prevent breaking kernel aware debuggers. */\n{\nint8_t *pcHead;                 /*&lt; Points to the beginning of the queue storage area. */\nint8_t *pcWriteTo;              /*&lt; Points to the free next place in the storage area. */\n\nunion\n{\nQueuePointers_t xQueue;     /*&lt; Data required exclusively when this structure is used as a queue. */\nSemaphoreData_t xSemaphore; /*&lt; Data required exclusively when this structure is used as a semaphore. */\n} u;\n\nList_t xTasksWaitingToSend;     /*&lt; List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */\nList_t xTasksWaitingToReceive;  /*&lt; List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */\n\nvolatile UBaseType_t uxMessagesWaiting;/*&lt; The number of items currently in the queue. */\nUBaseType_t uxLength;           /*&lt; The length of the queue defined as the number of items it will hold, not the number of bytes. */\nUBaseType_t uxItemSize;         /*&lt; The size of each items that the queue will hold. */\n\nvolatile int8_t cRxLock;        /*&lt; Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */\nvolatile int8_t cTxLock;        /*&lt; Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */\n\n#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )\nuint8_t ucStaticallyAllocated;  /*&lt; Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. */\n#endif\n\n#if ( configUSE_QUEUE_SETS == 1 )\nstruct QueueDefinition *pxQueueSetContainer;\n#endif\n\n#if ( configUSE_TRACE_FACILITY == 1 )\nUBaseType_t uxQueueNumber;\nuint8_t ucQueueType;\n#endif\n\n} xQUEUE;\n\n/* The old xQUEUE name is maintained above then typedefed to the new Queue_t\nname below to enable the use of older kernel aware debuggers. */\ntypedef xQUEUE Queue_t;\n\n/*-----------------------------------------------------------*/\n\n/*\n * The queue registry is just a means for kernel aware debuggers to locate\n * queue structures.  It has no other purpose so is an optional component.\n */\n#if ( configQUEUE_REGISTRY_SIZE &gt; 0 )\n\n/* The type stored within the queue registry array.  This allows a name\n    to be assigned to each queue making kernel aware debugging a little\n    more user friendly. */\ntypedef struct QUEUE_REGISTRY_ITEM\n{\nconst char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\nQueueHandle_t xHandle;\n} xQueueRegistryItem;\n\n/* The old xQueueRegistryItem name is maintained above then typedefed to the\n    new xQueueRegistryItem name below to enable the use of older kernel aware\n    debuggers. */\ntypedef xQueueRegistryItem QueueRegistryItem_t;\n\n/* The queue registry is simply an array of QueueRegistryItem_t structures.\n    The pcQueueName member of a structure being NULL is indicative of the\n    array position being vacant. */\nPRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];\n\n#endif /* configQUEUE_REGISTRY_SIZE */\n\n/*\n * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not\n * prevent an ISR from adding or removing items to the queue, but does prevent\n * an ISR from removing tasks from the queue event lists.  If an ISR finds a\n * queue is locked it will instead increment the appropriate queue lock count\n * to indicate that a task may require unblocking.  When the queue in unlocked\n * these lock counts are inspected, and the appropriate action taken.\n */\nstatic void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;\n\n/*\n * Uses a critical section to determine if there is any data in a queue.\n *\n * @return pdTRUE if the queue contains no items, otherwise pdFALSE.\n */\nstatic BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;\n\n/*\n * Uses a critical section to determine if there is any space in a queue.\n *\n * @return pdTRUE if there is no space, otherwise pdFALSE;\n */\nstatic BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;\n\n/*\n * Copies an item into the queue, either at the front of the queue or the\n * back of the queue.\n */\nstatic BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition ) PRIVILEGED_FUNCTION;\n\n/*\n * Copies an item out of a queue.\n */\nstatic void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;\n\n#if ( configUSE_QUEUE_SETS == 1 )\n/*\n     * Checks to see if a queue is a member of a queue set, and if so, notifies\n     * the queue set that the queue contains data.\n     */\nstatic BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;\n#endif\n\n/*\n * Called after a Queue_t structure has been allocated either statically or\n * dynamically to fill in the structure's members.\n */\nstatic void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;\n\n/*\n * Mutexes are a special type of queue.  When a mutex is created, first the\n * queue is created, then prvInitialiseMutex() is called to configure the queue\n * as a mutex.\n */\n#if( configUSE_MUTEXES == 1 )\nstatic void prvInitialiseMutex( Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;\n#endif\n\n#if( configUSE_MUTEXES == 1 )\n/*\n     * If a task waiting for a mutex causes the mutex holder to inherit a\n     * priority, but the waiting task times out, then the holder should\n     * disinherit the priority - but only down to the highest priority of any\n     * other tasks that are waiting for the same mutex.  This function returns\n     * that priority.\n     */\nstatic UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;\n#endif\n/*-----------------------------------------------------------*/\n\n/*\n * Macro to mark a queue as locked.  Locking a queue prevents an ISR from\n * accessing the queue event lists.\n */\n#define prvLockQueue( pxQueue )                             \\\n    taskENTER_CRITICAL();                                   \\\n    {                                                       \\\n        if( ( pxQueue )-&gt;cRxLock == queueUNLOCKED )         \\\n        {                                                   \\\n            ( pxQueue )-&gt;cRxLock = queueLOCKED_UNMODIFIED;  \\\n        }                                                   \\\n        if( ( pxQueue )-&gt;cTxLock == queueUNLOCKED )         \\\n        {                                                   \\\n            ( pxQueue )-&gt;cTxLock = queueLOCKED_UNMODIFIED;  \\\n        }                                                   \\\n    }                                                       \\\n    taskEXIT_CRITICAL()\n/*-----------------------------------------------------------*/\n\nBaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )\n{\nQueue_t * const pxQueue = xQueue;\n\nconfigASSERT( pxQueue );\n\ntaskENTER_CRITICAL();\n{\npxQueue-&gt;u.xQueue.pcTail = pxQueue-&gt;pcHead + ( pxQueue-&gt;uxLength * pxQueue-&gt;uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */\npxQueue-&gt;uxMessagesWaiting = ( UBaseType_t ) 0U;\npxQueue-&gt;pcWriteTo = pxQueue-&gt;pcHead;\npxQueue-&gt;u.xQueue.pcReadFrom = pxQueue-&gt;pcHead + ( ( pxQueue-&gt;uxLength - 1U ) * pxQueue-&gt;uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */\npxQueue-&gt;cRxLock = queueUNLOCKED;\npxQueue-&gt;cTxLock = queueUNLOCKED;\n\nif( xNewQueue == pdFALSE )\n{\n/* If there are tasks blocked waiting to read from the queue, then\n            the tasks will remain blocked as after this function exits the queue\n            will still be empty.  If there are tasks blocked waiting to write to\n            the queue, then one should be unblocked as after this function exits\n            it will be possible to write to it. */\nif( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE )\n{\nif( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE )\n{\nqueueYIELD_IF_USING_PREEMPTION();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\n/* Ensure the event queues start in the correct state. */\nvListInitialise( &amp;( pxQueue-&gt;xTasksWaitingToSend ) );\nvListInitialise( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) );\n}\n}\ntaskEXIT_CRITICAL();\n\n/* A value is returned for calling semantic consistency with previous\n    versions. */\nreturn pdPASS;\n}\n/*-----------------------------------------------------------*/\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n\nQueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType )\n{\nQueue_t *pxNewQueue;\n\nconfigASSERT( uxQueueLength &gt; ( UBaseType_t ) 0 );\n\n/* The StaticQueue_t structure and the queue storage area must be\n        supplied. */\nconfigASSERT( pxStaticQueue != NULL );\n\n/* A queue storage area should be provided if the item size is not 0, and\n        should not be provided if the item size is 0. */\nconfigASSERT( !( ( pucQueueStorage != NULL ) &amp;&amp; ( uxItemSize == 0 ) ) );\nconfigASSERT( !( ( pucQueueStorage == NULL ) &amp;&amp; ( uxItemSize != 0 ) ) );\n\n#if( configASSERT_DEFINED == 1 )\n{\n/* Sanity check that the size of the structure used to declare a\n            variable of type StaticQueue_t or StaticSemaphore_t equals the size of\n            the real queue and semaphore structures. */\nvolatile size_t xSize = sizeof( StaticQueue_t );\nconfigASSERT( xSize == sizeof( Queue_t ) );\n( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */\n}\n#endif /* configASSERT_DEFINED */\n\n/* The address of a statically allocated queue was passed in, use it.\n        The address of a statically allocated storage area was also passed in\n        but is already set. */\npxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */\n\nif( pxNewQueue != NULL )\n{\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n{\n/* Queues can be allocated wither statically or dynamically, so\n                note this queue was allocated statically in case the queue is\n                later deleted. */\npxNewQueue-&gt;ucStaticallyAllocated = pdTRUE;\n}\n#endif /* configSUPPORT_DYNAMIC_ALLOCATION */\n\nprvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );\n}\nelse\n{\ntraceQUEUE_CREATE_FAILED( ucQueueType );\nmtCOVERAGE_TEST_MARKER();\n}\n\nreturn pxNewQueue;\n}\n\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n/*-----------------------------------------------------------*/\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n\nQueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )\n{\nQueue_t *pxNewQueue;\nsize_t xQueueSizeInBytes;\nuint8_t *pucQueueStorage;\n\nconfigASSERT( uxQueueLength &gt; ( UBaseType_t ) 0 );\n\n/* Allocate enough space to hold the maximum number of items that\n        can be in the queue at any time.  It is valid for uxItemSize to be\n        zero in the case the queue is used as a semaphore. */\nxQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\n\n/* Allocate the queue and storage area.  Justification for MISRA\n        deviation as follows:  pvPortMalloc() always ensures returned memory\n        blocks are aligned per the requirements of the MCU stack.  In this case\n        pvPortMalloc() must return a pointer that is guaranteed to meet the\n        alignment requirements of the Queue_t structure - which in this case\n        is an int8_t *.  Therefore, whenever the stack alignment requirements\n        are greater than or equal to the pointer to char requirements the cast\n        is safe.  In other cases alignment requirements are not strict (one or\n        two bytes). */\npxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */\n\nif( pxNewQueue != NULL )\n{\n/* Jump past the queue structure to find the location of the queue\n            storage area. */\npucQueueStorage = ( uint8_t * ) pxNewQueue;\npucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n{\n/* Queues can be created either statically or dynamically, so\n                note this task was created dynamically in case it is later\n                deleted. */\npxNewQueue-&gt;ucStaticallyAllocated = pdFALSE;\n}\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n\nprvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );\n}\nelse\n{\ntraceQUEUE_CREATE_FAILED( ucQueueType );\nmtCOVERAGE_TEST_MARKER();\n}\n\nreturn pxNewQueue;\n}\n\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n/*-----------------------------------------------------------*/\n\nstatic void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )\n{\n/* Remove compiler warnings about unused parameters should\n    configUSE_TRACE_FACILITY not be set to 1. */\n( void ) ucQueueType;\n\nif( uxItemSize == ( UBaseType_t ) 0 )\n{\n/* No RAM was allocated for the queue storage area, but PC head cannot\n        be set to NULL because NULL is used as a key to say the queue is used as\n        a mutex.  Therefore just set pcHead to point to the queue as a benign\n        value that is known to be within the memory map. */\npxNewQueue-&gt;pcHead = ( int8_t * ) pxNewQueue;\n}\nelse\n{\n/* Set the head to the start of the queue storage area. */\npxNewQueue-&gt;pcHead = ( int8_t * ) pucQueueStorage;\n}\n\n/* Initialise the queue members as described where the queue type is\n    defined. */\npxNewQueue-&gt;uxLength = uxQueueLength;\npxNewQueue-&gt;uxItemSize = uxItemSize;\n( void ) xQueueGenericReset( pxNewQueue, pdTRUE );\n\n#if ( configUSE_TRACE_FACILITY == 1 )\n{\npxNewQueue-&gt;ucQueueType = ucQueueType;\n}\n#endif /* configUSE_TRACE_FACILITY */\n\n#if( configUSE_QUEUE_SETS == 1 )\n{\npxNewQueue-&gt;pxQueueSetContainer = NULL;\n}\n#endif /* configUSE_QUEUE_SETS */\n\ntraceQUEUE_CREATE( pxNewQueue );\n}\n/*-----------------------------------------------------------*/\n\n#if( configUSE_MUTEXES == 1 )\n\nstatic void prvInitialiseMutex( Queue_t *pxNewQueue )\n{\nif( pxNewQueue != NULL )\n{\n/* The queue create function will set all the queue structure members\n            correctly for a generic queue, but this function is creating a\n            mutex.  Overwrite those members that need to be set differently -\n            in particular the information required for priority inheritance. */\npxNewQueue-&gt;u.xSemaphore.xMutexHolder = NULL;\npxNewQueue-&gt;uxQueueType = queueQUEUE_IS_MUTEX;\n\n/* In case this is a recursive mutex. */\npxNewQueue-&gt;u.xSemaphore.uxRecursiveCallCount = 0;\n\ntraceCREATE_MUTEX( pxNewQueue );\n\n/* Start with the semaphore in the expected state. */\n( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );\n}\nelse\n{\ntraceCREATE_MUTEX_FAILED();\n}\n}\n\n#endif /* configUSE_MUTEXES */\n/*-----------------------------------------------------------*/\n\n#if( ( configUSE_MUTEXES == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )\n\nQueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )\n{\nQueueHandle_t xNewQueue;\nconst UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;\n\nxNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );\nprvInitialiseMutex( ( Queue_t * ) xNewQueue );\n\nreturn xNewQueue;\n}\n\n#endif /* configUSE_MUTEXES */\n/*-----------------------------------------------------------*/\n\n#if( ( configUSE_MUTEXES == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) )\n\nQueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )\n{\nQueueHandle_t xNewQueue;\nconst UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;\n\n/* Prevent compiler warnings about unused parameters if\n        configUSE_TRACE_FACILITY does not equal 1. */\n( void ) ucQueueType;\n\nxNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );\nprvInitialiseMutex( ( Queue_t * ) xNewQueue );\n\nreturn xNewQueue;\n}\n\n#endif /* configUSE_MUTEXES */\n/*-----------------------------------------------------------*/\n\n#if ( ( configUSE_MUTEXES == 1 ) &amp;&amp; ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )\n\nTaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )\n{\nTaskHandle_t pxReturn;\nQueue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;\n\n/* This function is called by xSemaphoreGetMutexHolder(), and should not\n        be called directly.  Note:  This is a good way of determining if the\n        calling task is the mutex holder, but not a good way of determining the\n        identity of the mutex holder, as the holder may change between the\n        following critical section exiting and the function returning. */\ntaskENTER_CRITICAL();\n{\nif( pxSemaphore-&gt;uxQueueType == queueQUEUE_IS_MUTEX )\n{\npxReturn = pxSemaphore-&gt;u.xSemaphore.xMutexHolder;\n}\nelse\n{\npxReturn = NULL;\n}\n}\ntaskEXIT_CRITICAL();\n\nreturn pxReturn;\n} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */\n\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( ( configUSE_MUTEXES == 1 ) &amp;&amp; ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )\n\nTaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )\n{\nTaskHandle_t pxReturn;\n\nconfigASSERT( xSemaphore );\n\n/* Mutexes cannot be used in interrupt service routines, so the mutex\n        holder should not change in an ISR, and therefore a critical section is\n        not required here. */\nif( ( ( Queue_t * ) xSemaphore )-&gt;uxQueueType == queueQUEUE_IS_MUTEX )\n{\npxReturn = ( ( Queue_t * ) xSemaphore )-&gt;u.xSemaphore.xMutexHolder;\n}\nelse\n{\npxReturn = NULL;\n}\n\nreturn pxReturn;\n} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */\n\n#endif\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_RECURSIVE_MUTEXES == 1 )\n\nBaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )\n{\nBaseType_t xReturn;\nQueue_t * const pxMutex = ( Queue_t * ) xMutex;\n\nconfigASSERT( pxMutex );\n\n/* If this is the task that holds the mutex then xMutexHolder will not\n        change outside of this task.  If this task does not hold the mutex then\n        pxMutexHolder can never coincidentally equal the tasks handle, and as\n        this is the only condition we are interested in it does not matter if\n        pxMutexHolder is accessed simultaneously by another task.  Therefore no\n        mutual exclusion is required to test the pxMutexHolder variable. */\nif( pxMutex-&gt;u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )\n{\ntraceGIVE_MUTEX_RECURSIVE( pxMutex );\n\n/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to\n            the task handle, therefore no underflow check is required.  Also,\n            uxRecursiveCallCount is only modified by the mutex holder, and as\n            there can only be one, no mutual exclusion is required to modify the\n            uxRecursiveCallCount member. */\n( pxMutex-&gt;u.xSemaphore.uxRecursiveCallCount )--;\n\n/* Has the recursive call count unwound to 0? */\nif( pxMutex-&gt;u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )\n{\n/* Return the mutex.  This will automatically unblock any other\n                task that might be waiting to access the mutex. */\n( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nxReturn = pdPASS;\n}\nelse\n{\n/* The mutex cannot be given because the calling task is not the\n            holder. */\nxReturn = pdFAIL;\n\ntraceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );\n}\n\nreturn xReturn;\n}\n\n#endif /* configUSE_RECURSIVE_MUTEXES */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_RECURSIVE_MUTEXES == 1 )\n\nBaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )\n{\nBaseType_t xReturn;\nQueue_t * const pxMutex = ( Queue_t * ) xMutex;\n\nconfigASSERT( pxMutex );\n\n/* Comments regarding mutual exclusion as per those within\n        xQueueGiveMutexRecursive(). */\n\ntraceTAKE_MUTEX_RECURSIVE( pxMutex );\n\nif( pxMutex-&gt;u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )\n{\n( pxMutex-&gt;u.xSemaphore.uxRecursiveCallCount )++;\nxReturn = pdPASS;\n}\nelse\n{\nxReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );\n\n/* pdPASS will only be returned if the mutex was successfully\n            obtained.  The calling task may have entered the Blocked state\n            before reaching here. */\nif( xReturn != pdFAIL )\n{\n( pxMutex-&gt;u.xSemaphore.uxRecursiveCallCount )++;\n}\nelse\n{\ntraceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );\n}\n}\n\nreturn xReturn;\n}\n\n#endif /* configUSE_RECURSIVE_MUTEXES */\n/*-----------------------------------------------------------*/\n\n#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) )\n\nQueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue )\n{\nQueueHandle_t xHandle;\n\nconfigASSERT( uxMaxCount != 0 );\nconfigASSERT( uxInitialCount &lt;= uxMaxCount );\n\nxHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticQueue, queueQUEUE_TYPE_COUNTING_SEMAPHORE );\n\nif( xHandle != NULL )\n{\n( ( Queue_t * ) xHandle )-&gt;uxMessagesWaiting = uxInitialCount;\n\ntraceCREATE_COUNTING_SEMAPHORE();\n}\nelse\n{\ntraceCREATE_COUNTING_SEMAPHORE_FAILED();\n}\n\nreturn xHandle;\n}\n\n#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */\n/*-----------------------------------------------------------*/\n\n#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )\n\nQueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )\n{\nQueueHandle_t xHandle;\n\nconfigASSERT( uxMaxCount != 0 );\nconfigASSERT( uxInitialCount &lt;= uxMaxCount );\n\nxHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );\n\nif( xHandle != NULL )\n{\n( ( Queue_t * ) xHandle )-&gt;uxMessagesWaiting = uxInitialCount;\n\ntraceCREATE_COUNTING_SEMAPHORE();\n}\nelse\n{\ntraceCREATE_COUNTING_SEMAPHORE_FAILED();\n}\n\nreturn xHandle;\n}\n\n#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */\n/*-----------------------------------------------------------*/\n\nBaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )\n{\nBaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;\nTimeOut_t xTimeOut;\nQueue_t * const pxQueue = xQueue;\n\nconfigASSERT( pxQueue );\nconfigASSERT( !( ( pvItemToQueue == NULL ) &amp;&amp; ( pxQueue-&gt;uxItemSize != ( UBaseType_t ) 0U ) ) );\nconfigASSERT( !( ( xCopyPosition == queueOVERWRITE ) &amp;&amp; ( pxQueue-&gt;uxLength != 1 ) ) );\n#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )\n{\nconfigASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) &amp;&amp; ( xTicksToWait != 0 ) ) );\n}\n#endif\n\n\n/*lint -save -e904 This function relaxes the coding standard somewhat to\n    allow return statements within the function itself.  This is done in the\n    interest of execution time efficiency. */\nfor( ;; )\n{\ntaskENTER_CRITICAL();\n{\n/* Is there room on the queue now?  The running task must be the\n            highest priority task wanting to access the queue.  If the head item\n            in the queue is to be overwritten then it does not matter if the\n            queue is full. */\nif( ( pxQueue-&gt;uxMessagesWaiting &lt; pxQueue-&gt;uxLength ) || ( xCopyPosition == queueOVERWRITE ) )\n{\ntraceQUEUE_SEND( pxQueue );\n\n#if ( configUSE_QUEUE_SETS == 1 )\n{\nconst UBaseType_t uxPreviousMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;\n\nxYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );\n\nif( pxQueue-&gt;pxQueueSetContainer != NULL )\n{\nif( ( xCopyPosition == queueOVERWRITE ) &amp;&amp; ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )\n{\n/* Do not notify the queue set as an existing item\n                            was overwritten in the queue so the number of items\n                            in the queue has not changed. */\nmtCOVERAGE_TEST_MARKER();\n}\nelse if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )\n{\n/* The queue is a member of a queue set, and posting\n                            to the queue set caused a higher priority task to\n                            unblock. A context switch is required. */\nqueueYIELD_IF_USING_PREEMPTION();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\n/* If there was a task waiting for data to arrive on the\n                        queue then unblock it now. */\nif( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )\n{\nif( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )\n{\n/* The unblocked task has a priority higher than\n                                our own so yield immediately.  Yes it is ok to\n                                do this from within the critical section - the\n                                kernel takes care of that. */\nqueueYIELD_IF_USING_PREEMPTION();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse if( xYieldRequired != pdFALSE )\n{\n/* This path is a special case that will only get\n                            executed if the task was holding multiple mutexes\n                            and the mutexes were given back in an order that is\n                            different to that in which they were taken. */\nqueueYIELD_IF_USING_PREEMPTION();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n}\n#else /* configUSE_QUEUE_SETS */\n{\nxYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );\n\n/* If there was a task waiting for data to arrive on the\n                    queue then unblock it now. */\nif( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )\n{\nif( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )\n{\n/* The unblocked task has a priority higher than\n                            our own so yield immediately.  Yes it is ok to do\n                            this from within the critical section - the kernel\n                            takes care of that. */\nqueueYIELD_IF_USING_PREEMPTION();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse if( xYieldRequired != pdFALSE )\n{\n/* This path is a special case that will only get\n                        executed if the task was holding multiple mutexes and\n                        the mutexes were given back in an order that is\n                        different to that in which they were taken. */\nqueueYIELD_IF_USING_PREEMPTION();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n#endif /* configUSE_QUEUE_SETS */\n\ntaskEXIT_CRITICAL();\nreturn pdPASS;\n}\nelse\n{\nif( xTicksToWait == ( TickType_t ) 0 )\n{\n/* The queue was full and no block time is specified (or\n                    the block time has expired) so leave now. */\ntaskEXIT_CRITICAL();\n\n/* Return to the original privilege level before exiting\n                    the function. */\ntraceQUEUE_SEND_FAILED( pxQueue );\nreturn errQUEUE_FULL;\n}\nelse if( xEntryTimeSet == pdFALSE )\n{\n/* The queue was full and a block time was specified so\n                    configure the timeout structure. */\nvTaskInternalSetTimeOutState( &amp;xTimeOut );\nxEntryTimeSet = pdTRUE;\n}\nelse\n{\n/* Entry time was already set. */\nmtCOVERAGE_TEST_MARKER();\n}\n}\n}\ntaskEXIT_CRITICAL();\n\n/* Interrupts and other tasks can send to and receive from the queue\n        now the critical section has been exited. */\n\nvTaskSuspendAll();\nprvLockQueue( pxQueue );\n\n/* Update the timeout state to see if it has expired yet. */\nif( xTaskCheckForTimeOut( &amp;xTimeOut, &amp;xTicksToWait ) == pdFALSE )\n{\nif( prvIsQueueFull( pxQueue ) != pdFALSE )\n{\ntraceBLOCKING_ON_QUEUE_SEND( pxQueue );\nvTaskPlaceOnEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ), xTicksToWait );\n\n/* Unlocking the queue means queue events can effect the\n                event list.  It is possible that interrupts occurring now\n                remove this task from the event list again - but as the\n                scheduler is suspended the task will go onto the pending\n                ready last instead of the actual ready list. */\nprvUnlockQueue( pxQueue );\n\n/* Resuming the scheduler will move tasks from the pending\n                ready list into the ready list - so it is feasible that this\n                task is already in a ready list before it yields - in which\n                case the yield will not cause a context switch unless there\n                is also a higher priority task in the pending ready list. */\nif( xTaskResumeAll() == pdFALSE )\n{\nportYIELD_WITHIN_API();\n}\n}\nelse\n{\n/* Try again. */\nprvUnlockQueue( pxQueue );\n( void ) xTaskResumeAll();\n}\n}\nelse\n{\n/* The timeout has expired. */\nprvUnlockQueue( pxQueue );\n( void ) xTaskResumeAll();\n\ntraceQUEUE_SEND_FAILED( pxQueue );\nreturn errQUEUE_FULL;\n}\n} /*lint -restore */\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )\n{\nBaseType_t xReturn;\nUBaseType_t uxSavedInterruptStatus;\nQueue_t * const pxQueue = xQueue;\n\nconfigASSERT( pxQueue );\nconfigASSERT( !( ( pvItemToQueue == NULL ) &amp;&amp; ( pxQueue-&gt;uxItemSize != ( UBaseType_t ) 0U ) ) );\nconfigASSERT( !( ( xCopyPosition == queueOVERWRITE ) &amp;&amp; ( pxQueue-&gt;uxLength != 1 ) ) );\n\n/* RTOS ports that support interrupt nesting have the concept of a maximum\n    system call (or maximum API call) interrupt priority.  Interrupts that are\n    above the maximum system call priority are kept permanently enabled, even\n    when the RTOS kernel is in a critical section, but cannot make any calls to\n    FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h\n    then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion\n    failure if a FreeRTOS API function is called from an interrupt that has been\n    assigned a priority above the configured maximum system call priority.\n    Only FreeRTOS functions that end in FromISR can be called from interrupts\n    that have been assigned a priority at or (logically) below the maximum\n    system call interrupt priority.  FreeRTOS maintains a separate interrupt\n    safe API to ensure interrupt entry is as fast and as simple as possible.\n    More information (albeit Cortex-M specific) is provided on the following\n    link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */\nportASSERT_IF_INTERRUPT_PRIORITY_INVALID();\n\n/* Similar to xQueueGenericSend, except without blocking if there is no room\n    in the queue.  Also don't directly wake a task that was blocked on a queue\n    read, instead return a flag to say whether a context switch is required or\n    not (i.e. has a task with a higher priority than us been woken by this\n    post). */\nuxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();\n{\nif( ( pxQueue-&gt;uxMessagesWaiting &lt; pxQueue-&gt;uxLength ) || ( xCopyPosition == queueOVERWRITE ) )\n{\nconst int8_t cTxLock = pxQueue-&gt;cTxLock;\nconst UBaseType_t uxPreviousMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;\n\ntraceQUEUE_SEND_FROM_ISR( pxQueue );\n\n/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a\n            semaphore or mutex.  That means prvCopyDataToQueue() cannot result\n            in a task disinheriting a priority and prvCopyDataToQueue() can be\n            called here even though the disinherit function does not check if\n            the scheduler is suspended before accessing the ready lists. */\n( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );\n\n/* The event list is not altered if the queue is locked.  This will\n            be done when the queue is unlocked later. */\nif( cTxLock == queueUNLOCKED )\n{\n#if ( configUSE_QUEUE_SETS == 1 )\n{\nif( pxQueue-&gt;pxQueueSetContainer != NULL )\n{\nif( ( xCopyPosition == queueOVERWRITE ) &amp;&amp; ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )\n{\n/* Do not notify the queue set as an existing item\n                            was overwritten in the queue so the number of items\n                            in the queue has not changed. */\nmtCOVERAGE_TEST_MARKER();\n}\nelse if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )\n{\n/* The queue is a member of a queue set, and posting\n                            to the queue set caused a higher priority task to\n                            unblock.  A context switch is required. */\nif( pxHigherPriorityTaskWoken != NULL )\n{\n*pxHigherPriorityTaskWoken = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nif( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )\n{\nif( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )\n{\n/* The task waiting has a higher priority so\n                                record that a context switch is required. */\nif( pxHigherPriorityTaskWoken != NULL )\n{\n*pxHigherPriorityTaskWoken = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n}\n#else /* configUSE_QUEUE_SETS */\n{\nif( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )\n{\nif( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )\n{\n/* The task waiting has a higher priority so record that a\n                            context switch is required. */\nif( pxHigherPriorityTaskWoken != NULL )\n{\n*pxHigherPriorityTaskWoken = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\n/* Not used in this path. */\n( void ) uxPreviousMessagesWaiting;\n}\n#endif /* configUSE_QUEUE_SETS */\n}\nelse\n{\n/* Increment the lock count so the task that unlocks the queue\n                knows that data was posted while it was locked. */\npxQueue-&gt;cTxLock = ( int8_t ) ( cTxLock + 1 );\n}\n\nxReturn = pdPASS;\n}\nelse\n{\ntraceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );\nxReturn = errQUEUE_FULL;\n}\n}\nportCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )\n{\nBaseType_t xReturn;\nUBaseType_t uxSavedInterruptStatus;\nQueue_t * const pxQueue = xQueue;\n\n/* Similar to xQueueGenericSendFromISR() but used with semaphores where the\n    item size is 0.  Don't directly wake a task that was blocked on a queue\n    read, instead return a flag to say whether a context switch is required or\n    not (i.e. has a task with a higher priority than us been woken by this\n    post). */\n\nconfigASSERT( pxQueue );\n\n/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()\n    if the item size is not 0. */\nconfigASSERT( pxQueue-&gt;uxItemSize == 0 );\n\n/* Normally a mutex would not be given from an interrupt, especially if\n    there is a mutex holder, as priority inheritance makes no sense for an\n    interrupts, only tasks. */\nconfigASSERT( !( ( pxQueue-&gt;uxQueueType == queueQUEUE_IS_MUTEX ) &amp;&amp; ( pxQueue-&gt;u.xSemaphore.xMutexHolder != NULL ) ) );\n\n/* RTOS ports that support interrupt nesting have the concept of a maximum\n    system call (or maximum API call) interrupt priority.  Interrupts that are\n    above the maximum system call priority are kept permanently enabled, even\n    when the RTOS kernel is in a critical section, but cannot make any calls to\n    FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h\n    then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion\n    failure if a FreeRTOS API function is called from an interrupt that has been\n    assigned a priority above the configured maximum system call priority.\n    Only FreeRTOS functions that end in FromISR can be called from interrupts\n    that have been assigned a priority at or (logically) below the maximum\n    system call interrupt priority.  FreeRTOS maintains a separate interrupt\n    safe API to ensure interrupt entry is as fast and as simple as possible.\n    More information (albeit Cortex-M specific) is provided on the following\n    link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */\nportASSERT_IF_INTERRUPT_PRIORITY_INVALID();\n\nuxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();\n{\nconst UBaseType_t uxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;\n\n/* When the queue is used to implement a semaphore no data is ever\n        moved through the queue but it is still valid to see if the queue 'has\n        space'. */\nif( uxMessagesWaiting &lt; pxQueue-&gt;uxLength )\n{\nconst int8_t cTxLock = pxQueue-&gt;cTxLock;\n\ntraceQUEUE_SEND_FROM_ISR( pxQueue );\n\n/* A task can only have an inherited priority if it is a mutex\n            holder - and if there is a mutex holder then the mutex cannot be\n            given from an ISR.  As this is the ISR version of the function it\n            can be assumed there is no mutex holder and no need to determine if\n            priority disinheritance is needed.  Simply increase the count of\n            messages (semaphores) available. */\npxQueue-&gt;uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;\n\n/* The event list is not altered if the queue is locked.  This will\n            be done when the queue is unlocked later. */\nif( cTxLock == queueUNLOCKED )\n{\n#if ( configUSE_QUEUE_SETS == 1 )\n{\nif( pxQueue-&gt;pxQueueSetContainer != NULL )\n{\nif( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )\n{\n/* The semaphore is a member of a queue set, and\n                            posting to the queue set caused a higher priority\n                            task to unblock.  A context switch is required. */\nif( pxHigherPriorityTaskWoken != NULL )\n{\n*pxHigherPriorityTaskWoken = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nif( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )\n{\nif( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )\n{\n/* The task waiting has a higher priority so\n                                record that a context switch is required. */\nif( pxHigherPriorityTaskWoken != NULL )\n{\n*pxHigherPriorityTaskWoken = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n}\n#else /* configUSE_QUEUE_SETS */\n{\nif( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )\n{\nif( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )\n{\n/* The task waiting has a higher priority so record that a\n                            context switch is required. */\nif( pxHigherPriorityTaskWoken != NULL )\n{\n*pxHigherPriorityTaskWoken = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n#endif /* configUSE_QUEUE_SETS */\n}\nelse\n{\n/* Increment the lock count so the task that unlocks the queue\n                knows that data was posted while it was locked. */\npxQueue-&gt;cTxLock = ( int8_t ) ( cTxLock + 1 );\n}\n\nxReturn = pdPASS;\n}\nelse\n{\ntraceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );\nxReturn = errQUEUE_FULL;\n}\n}\nportCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )\n{\nBaseType_t xEntryTimeSet = pdFALSE;\nTimeOut_t xTimeOut;\nQueue_t * const pxQueue = xQueue;\n\n/* Check the pointer is not NULL. */\nconfigASSERT( ( pxQueue ) );\n\n/* The buffer into which data is received can only be NULL if the data size\n    is zero (so no data is copied into the buffer. */\nconfigASSERT( !( ( ( pvBuffer ) == NULL ) &amp;&amp; ( ( pxQueue )-&gt;uxItemSize != ( UBaseType_t ) 0U ) ) );\n\n/* Cannot block if the scheduler is suspended. */\n#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )\n{\nconfigASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) &amp;&amp; ( xTicksToWait != 0 ) ) );\n}\n#endif\n\n\n/*lint -save -e904  This function relaxes the coding standard somewhat to\n    allow return statements within the function itself.  This is done in the\n    interest of execution time efficiency. */\nfor( ;; )\n{\ntaskENTER_CRITICAL();\n{\nconst UBaseType_t uxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;\n\n/* Is there data in the queue now?  To be running the calling task\n            must be the highest priority task wanting to access the queue. */\nif( uxMessagesWaiting &gt; ( UBaseType_t ) 0 )\n{\n/* Data available, remove one item. */\nprvCopyDataFromQueue( pxQueue, pvBuffer );\ntraceQUEUE_RECEIVE( pxQueue );\npxQueue-&gt;uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;\n\n/* There is now space in the queue, were any tasks waiting to\n                post to the queue?  If so, unblock the highest priority waiting\n                task. */\nif( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE )\n{\nif( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE )\n{\nqueueYIELD_IF_USING_PREEMPTION();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\ntaskEXIT_CRITICAL();\nreturn pdPASS;\n}\nelse\n{\nif( xTicksToWait == ( TickType_t ) 0 )\n{\n/* The queue was empty and no block time is specified (or\n                    the block time has expired) so leave now. */\ntaskEXIT_CRITICAL();\ntraceQUEUE_RECEIVE_FAILED( pxQueue );\nreturn errQUEUE_EMPTY;\n}\nelse if( xEntryTimeSet == pdFALSE )\n{\n/* The queue was empty and a block time was specified so\n                    configure the timeout structure. */\nvTaskInternalSetTimeOutState( &amp;xTimeOut );\nxEntryTimeSet = pdTRUE;\n}\nelse\n{\n/* Entry time was already set. */\nmtCOVERAGE_TEST_MARKER();\n}\n}\n}\ntaskEXIT_CRITICAL();\n\n/* Interrupts and other tasks can send to and receive from the queue\n        now the critical section has been exited. */\n\nvTaskSuspendAll();\nprvLockQueue( pxQueue );\n\n/* Update the timeout state to see if it has expired yet. */\nif( xTaskCheckForTimeOut( &amp;xTimeOut, &amp;xTicksToWait ) == pdFALSE )\n{\n/* The timeout has not expired.  If the queue is still empty place\n            the task on the list of tasks waiting to receive from the queue. */\nif( prvIsQueueEmpty( pxQueue ) != pdFALSE )\n{\ntraceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );\nvTaskPlaceOnEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ), xTicksToWait );\nprvUnlockQueue( pxQueue );\nif( xTaskResumeAll() == pdFALSE )\n{\nportYIELD_WITHIN_API();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\n/* The queue contains data again.  Loop back to try and read the\n                data. */\nprvUnlockQueue( pxQueue );\n( void ) xTaskResumeAll();\n}\n}\nelse\n{\n/* Timed out.  If there is no data in the queue exit, otherwise loop\n            back and attempt to read the data. */\nprvUnlockQueue( pxQueue );\n( void ) xTaskResumeAll();\n\nif( prvIsQueueEmpty( pxQueue ) != pdFALSE )\n{\ntraceQUEUE_RECEIVE_FAILED( pxQueue );\nreturn errQUEUE_EMPTY;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n} /*lint -restore */\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )\n{\nBaseType_t xEntryTimeSet = pdFALSE;\nTimeOut_t xTimeOut;\nQueue_t * const pxQueue = xQueue;\n\n#if( configUSE_MUTEXES == 1 )\nBaseType_t xInheritanceOccurred = pdFALSE;\n#endif\n\n/* Check the queue pointer is not NULL. */\nconfigASSERT( ( pxQueue ) );\n\n/* Check this really is a semaphore, in which case the item size will be\n    0. */\nconfigASSERT( pxQueue-&gt;uxItemSize == 0 );\n\n/* Cannot block if the scheduler is suspended. */\n#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )\n{\nconfigASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) &amp;&amp; ( xTicksToWait != 0 ) ) );\n}\n#endif\n\n\n/*lint -save -e904 This function relaxes the coding standard somewhat to allow return\n    statements within the function itself.  This is done in the interest\n    of execution time efficiency. */\nfor( ;; )\n{\ntaskENTER_CRITICAL();\n{\n/* Semaphores are queues with an item size of 0, and where the\n            number of messages in the queue is the semaphore's count value. */\nconst UBaseType_t uxSemaphoreCount = pxQueue-&gt;uxMessagesWaiting;\n\n/* Is there data in the queue now?  To be running the calling task\n            must be the highest priority task wanting to access the queue. */\nif( uxSemaphoreCount &gt; ( UBaseType_t ) 0 )\n{\ntraceQUEUE_RECEIVE( pxQueue );\n\n/* Semaphores are queues with a data size of zero and where the\n                messages waiting is the semaphore's count.  Reduce the count. */\npxQueue-&gt;uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;\n\n#if ( configUSE_MUTEXES == 1 )\n{\nif( pxQueue-&gt;uxQueueType == queueQUEUE_IS_MUTEX )\n{\n/* Record the information required to implement\n                        priority inheritance should it become necessary. */\npxQueue-&gt;u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n#endif /* configUSE_MUTEXES */\n\n/* Check to see if other tasks are blocked waiting to give the\n                semaphore, and if so, unblock the highest priority such task. */\nif( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE )\n{\nif( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE )\n{\nqueueYIELD_IF_USING_PREEMPTION();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\ntaskEXIT_CRITICAL();\nreturn pdPASS;\n}\nelse\n{\nif( xTicksToWait == ( TickType_t ) 0 )\n{\n/* For inheritance to have occurred there must have been an\n                    initial timeout, and an adjusted timeout cannot become 0, as\n                    if it were 0 the function would have exited. */\n#if( configUSE_MUTEXES == 1 )\n{\nconfigASSERT( xInheritanceOccurred == pdFALSE );\n}\n#endif /* configUSE_MUTEXES */\n\n/* The semaphore count was 0 and no block time is specified\n                    (or the block time has expired) so exit now. */\ntaskEXIT_CRITICAL();\ntraceQUEUE_RECEIVE_FAILED( pxQueue );\nreturn errQUEUE_EMPTY;\n}\nelse if( xEntryTimeSet == pdFALSE )\n{\n/* The semaphore count was 0 and a block time was specified\n                    so configure the timeout structure ready to block. */\nvTaskInternalSetTimeOutState( &amp;xTimeOut );\nxEntryTimeSet = pdTRUE;\n}\nelse\n{\n/* Entry time was already set. */\nmtCOVERAGE_TEST_MARKER();\n}\n}\n}\ntaskEXIT_CRITICAL();\n\n/* Interrupts and other tasks can give to and take from the semaphore\n        now the critical section has been exited. */\n\nvTaskSuspendAll();\nprvLockQueue( pxQueue );\n\n/* Update the timeout state to see if it has expired yet. */\nif( xTaskCheckForTimeOut( &amp;xTimeOut, &amp;xTicksToWait ) == pdFALSE )\n{\n/* A block time is specified and not expired.  If the semaphore\n            count is 0 then enter the Blocked state to wait for a semaphore to\n            become available.  As semaphores are implemented with queues the\n            queue being empty is equivalent to the semaphore count being 0. */\nif( prvIsQueueEmpty( pxQueue ) != pdFALSE )\n{\ntraceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );\n\n#if ( configUSE_MUTEXES == 1 )\n{\nif( pxQueue-&gt;uxQueueType == queueQUEUE_IS_MUTEX )\n{\ntaskENTER_CRITICAL();\n{\nxInheritanceOccurred = xTaskPriorityInherit( pxQueue-&gt;u.xSemaphore.xMutexHolder );\n}\ntaskEXIT_CRITICAL();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n#endif\n\nvTaskPlaceOnEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ), xTicksToWait );\nprvUnlockQueue( pxQueue );\nif( xTaskResumeAll() == pdFALSE )\n{\nportYIELD_WITHIN_API();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\n/* There was no timeout and the semaphore count was not 0, so\n                attempt to take the semaphore again. */\nprvUnlockQueue( pxQueue );\n( void ) xTaskResumeAll();\n}\n}\nelse\n{\n/* Timed out. */\nprvUnlockQueue( pxQueue );\n( void ) xTaskResumeAll();\n\n/* If the semaphore count is 0 exit now as the timeout has\n            expired.  Otherwise return to attempt to take the semaphore that is\n            known to be available.  As semaphores are implemented by queues the\n            queue being empty is equivalent to the semaphore count being 0. */\nif( prvIsQueueEmpty( pxQueue ) != pdFALSE )\n{\n#if ( configUSE_MUTEXES == 1 )\n{\n/* xInheritanceOccurred could only have be set if\n                    pxQueue-&gt;uxQueueType == queueQUEUE_IS_MUTEX so no need to\n                    test the mutex type again to check it is actually a mutex. */\nif( xInheritanceOccurred != pdFALSE )\n{\ntaskENTER_CRITICAL();\n{\nUBaseType_t uxHighestWaitingPriority;\n\n/* This task blocking on the mutex caused another\n                            task to inherit this task's priority.  Now this task\n                            has timed out the priority should be disinherited\n                            again, but only as low as the next highest priority\n                            task that is waiting for the same mutex. */\nuxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );\nvTaskPriorityDisinheritAfterTimeout( pxQueue-&gt;u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );\n}\ntaskEXIT_CRITICAL();\n}\n}\n#endif /* configUSE_MUTEXES */\n\ntraceQUEUE_RECEIVE_FAILED( pxQueue );\nreturn errQUEUE_EMPTY;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n} /*lint -restore */\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )\n{\nBaseType_t xEntryTimeSet = pdFALSE;\nTimeOut_t xTimeOut;\nint8_t *pcOriginalReadPosition;\nQueue_t * const pxQueue = xQueue;\n\n/* Check the pointer is not NULL. */\nconfigASSERT( ( pxQueue ) );\n\n/* The buffer into which data is received can only be NULL if the data size\n    is zero (so no data is copied into the buffer. */\nconfigASSERT( !( ( ( pvBuffer ) == NULL ) &amp;&amp; ( ( pxQueue )-&gt;uxItemSize != ( UBaseType_t ) 0U ) ) );\n\n/* Cannot block if the scheduler is suspended. */\n#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )\n{\nconfigASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) &amp;&amp; ( xTicksToWait != 0 ) ) );\n}\n#endif\n\n\n/*lint -save -e904  This function relaxes the coding standard somewhat to\n    allow return statements within the function itself.  This is done in the\n    interest of execution time efficiency. */\nfor( ;; )\n{\ntaskENTER_CRITICAL();\n{\nconst UBaseType_t uxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;\n\n/* Is there data in the queue now?  To be running the calling task\n            must be the highest priority task wanting to access the queue. */\nif( uxMessagesWaiting &gt; ( UBaseType_t ) 0 )\n{\n/* Remember the read position so it can be reset after the data\n                is read from the queue as this function is only peeking the\n                data, not removing it. */\npcOriginalReadPosition = pxQueue-&gt;u.xQueue.pcReadFrom;\n\nprvCopyDataFromQueue( pxQueue, pvBuffer );\ntraceQUEUE_PEEK( pxQueue );\n\n/* The data is not being removed, so reset the read pointer. */\npxQueue-&gt;u.xQueue.pcReadFrom = pcOriginalReadPosition;\n\n/* The data is being left in the queue, so see if there are\n                any other tasks waiting for the data. */\nif( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )\n{\nif( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )\n{\n/* The task waiting has a higher priority than this task. */\nqueueYIELD_IF_USING_PREEMPTION();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\ntaskEXIT_CRITICAL();\nreturn pdPASS;\n}\nelse\n{\nif( xTicksToWait == ( TickType_t ) 0 )\n{\n/* The queue was empty and no block time is specified (or\n                    the block time has expired) so leave now. */\ntaskEXIT_CRITICAL();\ntraceQUEUE_PEEK_FAILED( pxQueue );\nreturn errQUEUE_EMPTY;\n}\nelse if( xEntryTimeSet == pdFALSE )\n{\n/* The queue was empty and a block time was specified so\n                    configure the timeout structure ready to enter the blocked\n                    state. */\nvTaskInternalSetTimeOutState( &amp;xTimeOut );\nxEntryTimeSet = pdTRUE;\n}\nelse\n{\n/* Entry time was already set. */\nmtCOVERAGE_TEST_MARKER();\n}\n}\n}\ntaskEXIT_CRITICAL();\n\n/* Interrupts and other tasks can send to and receive from the queue\n        now the critical section has been exited. */\n\nvTaskSuspendAll();\nprvLockQueue( pxQueue );\n\n/* Update the timeout state to see if it has expired yet. */\nif( xTaskCheckForTimeOut( &amp;xTimeOut, &amp;xTicksToWait ) == pdFALSE )\n{\n/* Timeout has not expired yet, check to see if there is data in the\n            queue now, and if not enter the Blocked state to wait for data. */\nif( prvIsQueueEmpty( pxQueue ) != pdFALSE )\n{\ntraceBLOCKING_ON_QUEUE_PEEK( pxQueue );\nvTaskPlaceOnEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ), xTicksToWait );\nprvUnlockQueue( pxQueue );\nif( xTaskResumeAll() == pdFALSE )\n{\nportYIELD_WITHIN_API();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\n/* There is data in the queue now, so don't enter the blocked\n                state, instead return to try and obtain the data. */\nprvUnlockQueue( pxQueue );\n( void ) xTaskResumeAll();\n}\n}\nelse\n{\n/* The timeout has expired.  If there is still no data in the queue\n            exit, otherwise go back and try to read the data again. */\nprvUnlockQueue( pxQueue );\n( void ) xTaskResumeAll();\n\nif( prvIsQueueEmpty( pxQueue ) != pdFALSE )\n{\ntraceQUEUE_PEEK_FAILED( pxQueue );\nreturn errQUEUE_EMPTY;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n} /*lint -restore */\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )\n{\nBaseType_t xReturn;\nUBaseType_t uxSavedInterruptStatus;\nQueue_t * const pxQueue = xQueue;\n\nconfigASSERT( pxQueue );\nconfigASSERT( !( ( pvBuffer == NULL ) &amp;&amp; ( pxQueue-&gt;uxItemSize != ( UBaseType_t ) 0U ) ) );\n\n/* RTOS ports that support interrupt nesting have the concept of a maximum\n    system call (or maximum API call) interrupt priority.  Interrupts that are\n    above the maximum system call priority are kept permanently enabled, even\n    when the RTOS kernel is in a critical section, but cannot make any calls to\n    FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h\n    then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion\n    failure if a FreeRTOS API function is called from an interrupt that has been\n    assigned a priority above the configured maximum system call priority.\n    Only FreeRTOS functions that end in FromISR can be called from interrupts\n    that have been assigned a priority at or (logically) below the maximum\n    system call interrupt priority.  FreeRTOS maintains a separate interrupt\n    safe API to ensure interrupt entry is as fast and as simple as possible.\n    More information (albeit Cortex-M specific) is provided on the following\n    link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */\nportASSERT_IF_INTERRUPT_PRIORITY_INVALID();\n\nuxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();\n{\nconst UBaseType_t uxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;\n\n/* Cannot block in an ISR, so check there is data available. */\nif( uxMessagesWaiting &gt; ( UBaseType_t ) 0 )\n{\nconst int8_t cRxLock = pxQueue-&gt;cRxLock;\n\ntraceQUEUE_RECEIVE_FROM_ISR( pxQueue );\n\nprvCopyDataFromQueue( pxQueue, pvBuffer );\npxQueue-&gt;uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;\n\n/* If the queue is locked the event list will not be modified.\n            Instead update the lock count so the task that unlocks the queue\n            will know that an ISR has removed data while the queue was\n            locked. */\nif( cRxLock == queueUNLOCKED )\n{\nif( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE )\n{\nif( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE )\n{\n/* The task waiting has a higher priority than us so\n                        force a context switch. */\nif( pxHigherPriorityTaskWoken != NULL )\n{\n*pxHigherPriorityTaskWoken = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\n/* Increment the lock count so the task that unlocks the queue\n                knows that data was removed while it was locked. */\npxQueue-&gt;cRxLock = ( int8_t ) ( cRxLock + 1 );\n}\n\nxReturn = pdPASS;\n}\nelse\n{\nxReturn = pdFAIL;\ntraceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );\n}\n}\nportCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )\n{\nBaseType_t xReturn;\nUBaseType_t uxSavedInterruptStatus;\nint8_t *pcOriginalReadPosition;\nQueue_t * const pxQueue = xQueue;\n\nconfigASSERT( pxQueue );\nconfigASSERT( !( ( pvBuffer == NULL ) &amp;&amp; ( pxQueue-&gt;uxItemSize != ( UBaseType_t ) 0U ) ) );\nconfigASSERT( pxQueue-&gt;uxItemSize != 0 ); /* Can't peek a semaphore. */\n\n/* RTOS ports that support interrupt nesting have the concept of a maximum\n    system call (or maximum API call) interrupt priority.  Interrupts that are\n    above the maximum system call priority are kept permanently enabled, even\n    when the RTOS kernel is in a critical section, but cannot make any calls to\n    FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h\n    then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion\n    failure if a FreeRTOS API function is called from an interrupt that has been\n    assigned a priority above the configured maximum system call priority.\n    Only FreeRTOS functions that end in FromISR can be called from interrupts\n    that have been assigned a priority at or (logically) below the maximum\n    system call interrupt priority.  FreeRTOS maintains a separate interrupt\n    safe API to ensure interrupt entry is as fast and as simple as possible.\n    More information (albeit Cortex-M specific) is provided on the following\n    link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */\nportASSERT_IF_INTERRUPT_PRIORITY_INVALID();\n\nuxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();\n{\n/* Cannot block in an ISR, so check there is data available. */\nif( pxQueue-&gt;uxMessagesWaiting &gt; ( UBaseType_t ) 0 )\n{\ntraceQUEUE_PEEK_FROM_ISR( pxQueue );\n\n/* Remember the read position so it can be reset as nothing is\n            actually being removed from the queue. */\npcOriginalReadPosition = pxQueue-&gt;u.xQueue.pcReadFrom;\nprvCopyDataFromQueue( pxQueue, pvBuffer );\npxQueue-&gt;u.xQueue.pcReadFrom = pcOriginalReadPosition;\n\nxReturn = pdPASS;\n}\nelse\n{\nxReturn = pdFAIL;\ntraceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );\n}\n}\nportCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nUBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )\n{\nUBaseType_t uxReturn;\n\nconfigASSERT( xQueue );\n\ntaskENTER_CRITICAL();\n{\nuxReturn = ( ( Queue_t * ) xQueue )-&gt;uxMessagesWaiting;\n}\ntaskEXIT_CRITICAL();\n\nreturn uxReturn;\n} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */\n/*-----------------------------------------------------------*/\n\nUBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )\n{\nUBaseType_t uxReturn;\nQueue_t * const pxQueue = xQueue;\n\nconfigASSERT( pxQueue );\n\ntaskENTER_CRITICAL();\n{\nuxReturn = pxQueue-&gt;uxLength - pxQueue-&gt;uxMessagesWaiting;\n}\ntaskEXIT_CRITICAL();\n\nreturn uxReturn;\n} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */\n/*-----------------------------------------------------------*/\n\nUBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )\n{\nUBaseType_t uxReturn;\nQueue_t * const pxQueue = xQueue;\n\nconfigASSERT( pxQueue );\nuxReturn = pxQueue-&gt;uxMessagesWaiting;\n\nreturn uxReturn;\n} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */\n/*-----------------------------------------------------------*/\n\nvoid vQueueDelete( QueueHandle_t xQueue )\n{\nQueue_t * const pxQueue = xQueue;\n\nconfigASSERT( pxQueue );\ntraceQUEUE_DELETE( pxQueue );\n\n#if ( configQUEUE_REGISTRY_SIZE &gt; 0 )\n{\nvQueueUnregisterQueue( pxQueue );\n}\n#endif\n\n#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 0 ) )\n{\n/* The queue can only have been allocated dynamically - free it\n        again. */\nvPortFree( pxQueue );\n}\n#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) )\n{\n/* The queue could have been allocated statically or dynamically, so\n        check before attempting to free the memory. */\nif( pxQueue-&gt;ucStaticallyAllocated == ( uint8_t ) pdFALSE )\n{\nvPortFree( pxQueue );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n#else\n{\n/* The queue must have been statically allocated, so is not going to be\n        deleted.  Avoid compiler warnings about the unused parameter. */\n( void ) pxQueue;\n}\n#endif /* configSUPPORT_DYNAMIC_ALLOCATION */\n}\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_TRACE_FACILITY == 1 )\n\nUBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )\n{\nreturn ( ( Queue_t * ) xQueue )-&gt;uxQueueNumber;\n}\n\n#endif /* configUSE_TRACE_FACILITY */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_TRACE_FACILITY == 1 )\n\nvoid vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )\n{\n( ( Queue_t * ) xQueue )-&gt;uxQueueNumber = uxQueueNumber;\n}\n\n#endif /* configUSE_TRACE_FACILITY */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_TRACE_FACILITY == 1 )\n\nuint8_t ucQueueGetQueueType( QueueHandle_t xQueue )\n{\nreturn ( ( Queue_t * ) xQueue )-&gt;ucQueueType;\n}\n\n#endif /* configUSE_TRACE_FACILITY */\n/*-----------------------------------------------------------*/\n\n#if( configUSE_MUTEXES == 1 )\n\nstatic UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )\n{\nUBaseType_t uxHighestPriorityOfWaitingTasks;\n\n/* If a task waiting for a mutex causes the mutex holder to inherit a\n        priority, but the waiting task times out, then the holder should\n        disinherit the priority - but only down to the highest priority of any\n        other tasks that are waiting for the same mutex.  For this purpose,\n        return the priority of the highest priority task that is waiting for the\n        mutex. */\nif( listCURRENT_LIST_LENGTH( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) &gt; 0U )\n{\nuxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) );\n}\nelse\n{\nuxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;\n}\n\nreturn uxHighestPriorityOfWaitingTasks;\n}\n\n#endif /* configUSE_MUTEXES */\n/*-----------------------------------------------------------*/\n\nstatic BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )\n{\nBaseType_t xReturn = pdFALSE;\nUBaseType_t uxMessagesWaiting;\n\n/* This function is called from a critical section. */\n\nuxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;\n\nif( pxQueue-&gt;uxItemSize == ( UBaseType_t ) 0 )\n{\n#if ( configUSE_MUTEXES == 1 )\n{\nif( pxQueue-&gt;uxQueueType == queueQUEUE_IS_MUTEX )\n{\n/* The mutex is no longer being held. */\nxReturn = xTaskPriorityDisinherit( pxQueue-&gt;u.xSemaphore.xMutexHolder );\npxQueue-&gt;u.xSemaphore.xMutexHolder = NULL;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n#endif /* configUSE_MUTEXES */\n}\nelse if( xPosition == queueSEND_TO_BACK )\n{\n( void ) memcpy( ( void * ) pxQueue-&gt;pcWriteTo, pvItemToQueue, ( size_t ) pxQueue-&gt;uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */\npxQueue-&gt;pcWriteTo += pxQueue-&gt;uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */\nif( pxQueue-&gt;pcWriteTo &gt;= pxQueue-&gt;u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */\n{\npxQueue-&gt;pcWriteTo = pxQueue-&gt;pcHead;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\n( void ) memcpy( ( void * ) pxQueue-&gt;u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue-&gt;uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */\npxQueue-&gt;u.xQueue.pcReadFrom -= pxQueue-&gt;uxItemSize;\nif( pxQueue-&gt;u.xQueue.pcReadFrom &lt; pxQueue-&gt;pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */\n{\npxQueue-&gt;u.xQueue.pcReadFrom = ( pxQueue-&gt;u.xQueue.pcTail - pxQueue-&gt;uxItemSize );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nif( xPosition == queueOVERWRITE )\n{\nif( uxMessagesWaiting &gt; ( UBaseType_t ) 0 )\n{\n/* An item is not being added but overwritten, so subtract\n                one from the recorded number of items in the queue so when\n                one is added again below the number of recorded items remains\n                correct. */\n--uxMessagesWaiting;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n\npxQueue-&gt;uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nstatic void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )\n{\nif( pxQueue-&gt;uxItemSize != ( UBaseType_t ) 0 )\n{\npxQueue-&gt;u.xQueue.pcReadFrom += pxQueue-&gt;uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */\nif( pxQueue-&gt;u.xQueue.pcReadFrom &gt;= pxQueue-&gt;u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */\n{\npxQueue-&gt;u.xQueue.pcReadFrom = pxQueue-&gt;pcHead;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue-&gt;u.xQueue.pcReadFrom, ( size_t ) pxQueue-&gt;uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */\n}\n}\n/*-----------------------------------------------------------*/\n\nstatic void prvUnlockQueue( Queue_t * const pxQueue )\n{\n/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */\n\n/* The lock counts contains the number of extra data items placed or\n    removed from the queue while the queue was locked.  When a queue is\n    locked items can be added or removed, but the event lists cannot be\n    updated. */\ntaskENTER_CRITICAL();\n{\nint8_t cTxLock = pxQueue-&gt;cTxLock;\n\n/* See if data was added to the queue while it was locked. */\nwhile( cTxLock &gt; queueLOCKED_UNMODIFIED )\n{\n/* Data was posted while the queue was locked.  Are any tasks\n            blocked waiting for data to become available? */\n#if ( configUSE_QUEUE_SETS == 1 )\n{\nif( pxQueue-&gt;pxQueueSetContainer != NULL )\n{\nif( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )\n{\n/* The queue is a member of a queue set, and posting to\n                        the queue set caused a higher priority task to unblock.\n                        A context switch is required. */\nvTaskMissedYield();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\n/* Tasks that are removed from the event list will get\n                    added to the pending ready list as the scheduler is still\n                    suspended. */\nif( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )\n{\nif( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )\n{\n/* The task waiting has a higher priority so record that a\n                            context switch is required. */\nvTaskMissedYield();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nbreak;\n}\n}\n}\n#else /* configUSE_QUEUE_SETS */\n{\n/* Tasks that are removed from the event list will get added to\n                the pending ready list as the scheduler is still suspended. */\nif( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )\n{\nif( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )\n{\n/* The task waiting has a higher priority so record that\n                        a context switch is required. */\nvTaskMissedYield();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nbreak;\n}\n}\n#endif /* configUSE_QUEUE_SETS */\n\n--cTxLock;\n}\n\npxQueue-&gt;cTxLock = queueUNLOCKED;\n}\ntaskEXIT_CRITICAL();\n\n/* Do the same for the Rx lock. */\ntaskENTER_CRITICAL();\n{\nint8_t cRxLock = pxQueue-&gt;cRxLock;\n\nwhile( cRxLock &gt; queueLOCKED_UNMODIFIED )\n{\nif( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE )\n{\nif( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE )\n{\nvTaskMissedYield();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\n--cRxLock;\n}\nelse\n{\nbreak;\n}\n}\n\npxQueue-&gt;cRxLock = queueUNLOCKED;\n}\ntaskEXIT_CRITICAL();\n}\n/*-----------------------------------------------------------*/\n\nstatic BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )\n{\nBaseType_t xReturn;\n\ntaskENTER_CRITICAL();\n{\nif( pxQueue-&gt;uxMessagesWaiting == ( UBaseType_t )  0 )\n{\nxReturn = pdTRUE;\n}\nelse\n{\nxReturn = pdFALSE;\n}\n}\ntaskEXIT_CRITICAL();\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )\n{\nBaseType_t xReturn;\nQueue_t * const pxQueue = xQueue;\n\nconfigASSERT( pxQueue );\nif( pxQueue-&gt;uxMessagesWaiting == ( UBaseType_t ) 0 )\n{\nxReturn = pdTRUE;\n}\nelse\n{\nxReturn = pdFALSE;\n}\n\nreturn xReturn;\n} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */\n/*-----------------------------------------------------------*/\n\nstatic BaseType_t prvIsQueueFull( const Queue_t *pxQueue )\n{\nBaseType_t xReturn;\n\ntaskENTER_CRITICAL();\n{\nif( pxQueue-&gt;uxMessagesWaiting == pxQueue-&gt;uxLength )\n{\nxReturn = pdTRUE;\n}\nelse\n{\nxReturn = pdFALSE;\n}\n}\ntaskEXIT_CRITICAL();\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )\n{\nBaseType_t xReturn;\nQueue_t * const pxQueue = xQueue;\n\nconfigASSERT( pxQueue );\nif( pxQueue-&gt;uxMessagesWaiting == pxQueue-&gt;uxLength )\n{\nxReturn = pdTRUE;\n}\nelse\n{\nxReturn = pdFALSE;\n}\n\nreturn xReturn;\n} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_CO_ROUTINES == 1 )\n\nBaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )\n{\nBaseType_t xReturn;\nQueue_t * const pxQueue = xQueue;\n\n/* If the queue is already full we may have to block.  A critical section\n        is required to prevent an interrupt removing something from the queue\n        between the check to see if the queue is full and blocking on the queue. */\nportDISABLE_INTERRUPTS();\n{\nif( prvIsQueueFull( pxQueue ) != pdFALSE )\n{\n/* The queue is full - do we want to block or just leave without\n                posting? */\nif( xTicksToWait &gt; ( TickType_t ) 0 )\n{\n/* As this is called from a coroutine we cannot block directly, but\n                    return indicating that we need to block. */\nvCoRoutineAddToDelayedList( xTicksToWait, &amp;( pxQueue-&gt;xTasksWaitingToSend ) );\nportENABLE_INTERRUPTS();\nreturn errQUEUE_BLOCKED;\n}\nelse\n{\nportENABLE_INTERRUPTS();\nreturn errQUEUE_FULL;\n}\n}\n}\nportENABLE_INTERRUPTS();\n\nportDISABLE_INTERRUPTS();\n{\nif( pxQueue-&gt;uxMessagesWaiting &lt; pxQueue-&gt;uxLength )\n{\n/* There is room in the queue, copy the data into the queue. */\nprvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );\nxReturn = pdPASS;\n\n/* Were any co-routines waiting for data to become available? */\nif( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )\n{\n/* In this instance the co-routine could be placed directly\n                    into the ready list as we are within a critical section.\n                    Instead the same pending ready list mechanism is used as if\n                    the event were caused from within an interrupt. */\nif( xCoRoutineRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )\n{\n/* The co-routine waiting has a higher priority so record\n                        that a yield might be appropriate. */\nxReturn = errQUEUE_YIELD;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nxReturn = errQUEUE_FULL;\n}\n}\nportENABLE_INTERRUPTS();\n\nreturn xReturn;\n}\n\n#endif /* configUSE_CO_ROUTINES */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_CO_ROUTINES == 1 )\n\nBaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )\n{\nBaseType_t xReturn;\nQueue_t * const pxQueue = xQueue;\n\n/* If the queue is already empty we may have to block.  A critical section\n        is required to prevent an interrupt adding something to the queue\n        between the check to see if the queue is empty and blocking on the queue. */\nportDISABLE_INTERRUPTS();\n{\nif( pxQueue-&gt;uxMessagesWaiting == ( UBaseType_t ) 0 )\n{\n/* There are no messages in the queue, do we want to block or just\n                leave with nothing? */\nif( xTicksToWait &gt; ( TickType_t ) 0 )\n{\n/* As this is a co-routine we cannot block directly, but return\n                    indicating that we need to block. */\nvCoRoutineAddToDelayedList( xTicksToWait, &amp;( pxQueue-&gt;xTasksWaitingToReceive ) );\nportENABLE_INTERRUPTS();\nreturn errQUEUE_BLOCKED;\n}\nelse\n{\nportENABLE_INTERRUPTS();\nreturn errQUEUE_FULL;\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nportENABLE_INTERRUPTS();\n\nportDISABLE_INTERRUPTS();\n{\nif( pxQueue-&gt;uxMessagesWaiting &gt; ( UBaseType_t ) 0 )\n{\n/* Data is available from the queue. */\npxQueue-&gt;u.xQueue.pcReadFrom += pxQueue-&gt;uxItemSize;\nif( pxQueue-&gt;u.xQueue.pcReadFrom &gt;= pxQueue-&gt;u.xQueue.pcTail )\n{\npxQueue-&gt;u.xQueue.pcReadFrom = pxQueue-&gt;pcHead;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n--( pxQueue-&gt;uxMessagesWaiting );\n( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue-&gt;u.xQueue.pcReadFrom, ( unsigned ) pxQueue-&gt;uxItemSize );\n\nxReturn = pdPASS;\n\n/* Were any co-routines waiting for space to become available? */\nif( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE )\n{\n/* In this instance the co-routine could be placed directly\n                    into the ready list as we are within a critical section.\n                    Instead the same pending ready list mechanism is used as if\n                    the event were caused from within an interrupt. */\nif( xCoRoutineRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE )\n{\nxReturn = errQUEUE_YIELD;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nxReturn = pdFAIL;\n}\n}\nportENABLE_INTERRUPTS();\n\nreturn xReturn;\n}\n\n#endif /* configUSE_CO_ROUTINES */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_CO_ROUTINES == 1 )\n\nBaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )\n{\nQueue_t * const pxQueue = xQueue;\n\n/* Cannot block within an ISR so if there is no space on the queue then\n        exit without doing anything. */\nif( pxQueue-&gt;uxMessagesWaiting &lt; pxQueue-&gt;uxLength )\n{\nprvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );\n\n/* We only want to wake one co-routine per ISR, so check that a\n            co-routine has not already been woken. */\nif( xCoRoutinePreviouslyWoken == pdFALSE )\n{\nif( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )\n{\nif( xCoRoutineRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )\n{\nreturn pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nreturn xCoRoutinePreviouslyWoken;\n}\n\n#endif /* configUSE_CO_ROUTINES */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_CO_ROUTINES == 1 )\n\nBaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )\n{\nBaseType_t xReturn;\nQueue_t * const pxQueue = xQueue;\n\n/* We cannot block from an ISR, so check there is data available. If\n        not then just leave without doing anything. */\nif( pxQueue-&gt;uxMessagesWaiting &gt; ( UBaseType_t ) 0 )\n{\n/* Copy the data from the queue. */\npxQueue-&gt;u.xQueue.pcReadFrom += pxQueue-&gt;uxItemSize;\nif( pxQueue-&gt;u.xQueue.pcReadFrom &gt;= pxQueue-&gt;u.xQueue.pcTail )\n{\npxQueue-&gt;u.xQueue.pcReadFrom = pxQueue-&gt;pcHead;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n--( pxQueue-&gt;uxMessagesWaiting );\n( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue-&gt;u.xQueue.pcReadFrom, ( unsigned ) pxQueue-&gt;uxItemSize );\n\nif( ( *pxCoRoutineWoken ) == pdFALSE )\n{\nif( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE )\n{\nif( xCoRoutineRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE )\n{\n*pxCoRoutineWoken = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nxReturn = pdPASS;\n}\nelse\n{\nxReturn = pdFAIL;\n}\n\nreturn xReturn;\n}\n\n#endif /* configUSE_CO_ROUTINES */\n/*-----------------------------------------------------------*/\n\n#if ( configQUEUE_REGISTRY_SIZE &gt; 0 )\n\nvoid vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n{\nUBaseType_t ux;\n\n/* See if there is an empty space in the registry.  A NULL name denotes\n        a free slot. */\nfor( ux = ( UBaseType_t ) 0U; ux &lt; ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )\n{\nif( xQueueRegistry[ ux ].pcQueueName == NULL )\n{\n/* Store the information on this queue. */\nxQueueRegistry[ ux ].pcQueueName = pcQueueName;\nxQueueRegistry[ ux ].xHandle = xQueue;\n\ntraceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );\nbreak;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n}\n\n#endif /* configQUEUE_REGISTRY_SIZE */\n/*-----------------------------------------------------------*/\n\n#if ( configQUEUE_REGISTRY_SIZE &gt; 0 )\n\nconst char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n{\nUBaseType_t ux;\nconst char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\n/* Note there is nothing here to protect against another task adding or\n        removing entries from the registry while it is being searched. */\nfor( ux = ( UBaseType_t ) 0U; ux &lt; ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )\n{\nif( xQueueRegistry[ ux ].xHandle == xQueue )\n{\npcReturn = xQueueRegistry[ ux ].pcQueueName;\nbreak;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n\nreturn pcReturn;\n} /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */\n\n#endif /* configQUEUE_REGISTRY_SIZE */\n/*-----------------------------------------------------------*/\n\n#if ( configQUEUE_REGISTRY_SIZE &gt; 0 )\n\nvoid vQueueUnregisterQueue( QueueHandle_t xQueue )\n{\nUBaseType_t ux;\n\n/* See if the handle of the queue being unregistered in actually in the\n        registry. */\nfor( ux = ( UBaseType_t ) 0U; ux &lt; ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )\n{\nif( xQueueRegistry[ ux ].xHandle == xQueue )\n{\n/* Set the name to NULL to show that this slot if free again. */\nxQueueRegistry[ ux ].pcQueueName = NULL;\n\n/* Set the handle to NULL to ensure the same queue handle cannot\n                appear in the registry twice if it is added, removed, then\n                added again. */\nxQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;\nbreak;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n\n} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */\n\n#endif /* configQUEUE_REGISTRY_SIZE */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_TIMERS == 1 )\n\nvoid vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )\n{\nQueue_t * const pxQueue = xQueue;\n\n/* This function should not be called by application code hence the\n        'Restricted' in its name.  It is not part of the public API.  It is\n        designed for use by kernel code, and has special calling requirements.\n        It can result in vListInsert() being called on a list that can only\n        possibly ever have one item in it, so the list will be fast, but even\n        so it should be called with the scheduler locked and not from a critical\n        section. */\n\n/* Only do anything if there are no messages in the queue.  This function\n        will not actually cause the task to block, just place it on a blocked\n        list.  It will not block until the scheduler is unlocked - at which\n        time a yield will be performed.  If an item is added to the queue while\n        the queue is locked, and the calling task blocks on the queue, then the\n        calling task will be immediately unblocked when the queue is unlocked. */\nprvLockQueue( pxQueue );\nif( pxQueue-&gt;uxMessagesWaiting == ( UBaseType_t ) 0U )\n{\n/* There is nothing in the queue, block for the specified period. */\nvTaskPlaceOnEventListRestricted( &amp;( pxQueue-&gt;xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\nprvUnlockQueue( pxQueue );\n}\n\n#endif /* configUSE_TIMERS */\n/*-----------------------------------------------------------*/\n\n#if( ( configUSE_QUEUE_SETS == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )\n\nQueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )\n{\nQueueSetHandle_t pxQueue;\n\npxQueue = xQueueGenericCreate( uxEventQueueLength, ( UBaseType_t ) sizeof( Queue_t * ), queueQUEUE_TYPE_SET );\n\nreturn pxQueue;\n}\n\n#endif /* configUSE_QUEUE_SETS */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_QUEUE_SETS == 1 )\n\nBaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )\n{\nBaseType_t xReturn;\n\ntaskENTER_CRITICAL();\n{\nif( ( ( Queue_t * ) xQueueOrSemaphore )-&gt;pxQueueSetContainer != NULL )\n{\n/* Cannot add a queue/semaphore to more than one queue set. */\nxReturn = pdFAIL;\n}\nelse if( ( ( Queue_t * ) xQueueOrSemaphore )-&gt;uxMessagesWaiting != ( UBaseType_t ) 0 )\n{\n/* Cannot add a queue/semaphore to a queue set if there are already\n                items in the queue/semaphore. */\nxReturn = pdFAIL;\n}\nelse\n{\n( ( Queue_t * ) xQueueOrSemaphore )-&gt;pxQueueSetContainer = xQueueSet;\nxReturn = pdPASS;\n}\n}\ntaskEXIT_CRITICAL();\n\nreturn xReturn;\n}\n\n#endif /* configUSE_QUEUE_SETS */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_QUEUE_SETS == 1 )\n\nBaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )\n{\nBaseType_t xReturn;\nQueue_t * const pxQueueOrSemaphore = ( Queue_t * ) xQueueOrSemaphore;\n\nif( pxQueueOrSemaphore-&gt;pxQueueSetContainer != xQueueSet )\n{\n/* The queue was not a member of the set. */\nxReturn = pdFAIL;\n}\nelse if( pxQueueOrSemaphore-&gt;uxMessagesWaiting != ( UBaseType_t ) 0 )\n{\n/* It is dangerous to remove a queue from a set when the queue is\n            not empty because the queue set will still hold pending events for\n            the queue. */\nxReturn = pdFAIL;\n}\nelse\n{\ntaskENTER_CRITICAL();\n{\n/* The queue is no longer contained in the set. */\npxQueueOrSemaphore-&gt;pxQueueSetContainer = NULL;\n}\ntaskEXIT_CRITICAL();\nxReturn = pdPASS;\n}\n\nreturn xReturn;\n} /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */\n\n#endif /* configUSE_QUEUE_SETS */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_QUEUE_SETS == 1 )\n\nQueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t const xTicksToWait )\n{\nQueueSetMemberHandle_t xReturn = NULL;\n\n( void ) xQueueReceive( ( QueueHandle_t ) xQueueSet, &amp;xReturn, xTicksToWait ); /*lint !e961 Casting from one typedef to another is not redundant. */\nreturn xReturn;\n}\n\n#endif /* configUSE_QUEUE_SETS */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_QUEUE_SETS == 1 )\n\nQueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )\n{\nQueueSetMemberHandle_t xReturn = NULL;\n\n( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &amp;xReturn, NULL ); /*lint !e961 Casting from one typedef to another is not redundant. */\nreturn xReturn;\n}\n\n#endif /* configUSE_QUEUE_SETS */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_QUEUE_SETS == 1 )\n\nstatic BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue )\n{\nQueue_t *pxQueueSetContainer = pxQueue-&gt;pxQueueSetContainer;\nBaseType_t xReturn = pdFALSE;\n\n/* This function must be called form a critical section. */\n\nconfigASSERT( pxQueueSetContainer );\nconfigASSERT( pxQueueSetContainer-&gt;uxMessagesWaiting &lt; pxQueueSetContainer-&gt;uxLength );\n\nif( pxQueueSetContainer-&gt;uxMessagesWaiting &lt; pxQueueSetContainer-&gt;uxLength )\n{\nconst int8_t cTxLock = pxQueueSetContainer-&gt;cTxLock;\n\ntraceQUEUE_SEND( pxQueueSetContainer );\n\n/* The data copied is the handle of the queue that contains data. */\nxReturn = prvCopyDataToQueue( pxQueueSetContainer, &amp;pxQueue, queueSEND_TO_BACK );\n\nif( cTxLock == queueUNLOCKED )\n{\nif( listLIST_IS_EMPTY( &amp;( pxQueueSetContainer-&gt;xTasksWaitingToReceive ) ) == pdFALSE )\n{\nif( xTaskRemoveFromEventList( &amp;( pxQueueSetContainer-&gt;xTasksWaitingToReceive ) ) != pdFALSE )\n{\n/* The task waiting has a higher priority. */\nxReturn = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\npxQueueSetContainer-&gt;cTxLock = ( int8_t ) ( cTxLock + 1 );\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nreturn xReturn;\n}\n\n#endif /* configUSE_QUEUE_SETS */\n</code></pre>"},{"location":"apiStm/stream__buffer_8c/","title":"File stream_buffer.c","text":"<p>FileList &gt; FreeRTOS &gt; src &gt; stream_buffer.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;string.h&gt;</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"task.h\"</code></li> <li><code>#include \"stream_buffer.h\"</code></li> </ul>"},{"location":"apiStm/stream__buffer_8c/#classes","title":"Classes","text":"Type Name struct StreamBufferDef_t"},{"location":"apiStm/stream__buffer_8c/#public-types","title":"Public Types","text":"Type Name typedef struct StreamBufferDef_t StreamBuffer_t"},{"location":"apiStm/stream__buffer_8c/#public-functions","title":"Public Functions","text":"Type Name void vStreamBufferDelete (StreamBufferHandle_t xStreamBuffer)  size_t xStreamBufferBytesAvailable (StreamBufferHandle_t xStreamBuffer)  BaseType_t xStreamBufferIsEmpty (StreamBufferHandle_t xStreamBuffer)  BaseType_t xStreamBufferIsFull (StreamBufferHandle_t xStreamBuffer)  size_t xStreamBufferNextMessageLengthBytes (StreamBufferHandle_t xStreamBuffer)  size_t xStreamBufferReceive (StreamBufferHandle_t xStreamBuffer, void * pvRxData, size_t xBufferLengthBytes, TickType_t xTicksToWait)  BaseType_t xStreamBufferReceiveCompletedFromISR (StreamBufferHandle_t xStreamBuffer, BaseType_t * pxHigherPriorityTaskWoken)  size_t xStreamBufferReceiveFromISR (StreamBufferHandle_t xStreamBuffer, void * pvRxData, size_t xBufferLengthBytes, BaseType_t *const pxHigherPriorityTaskWoken)  BaseType_t xStreamBufferReset (StreamBufferHandle_t xStreamBuffer)  size_t xStreamBufferSend (StreamBufferHandle_t xStreamBuffer, const void * pvTxData, size_t xDataLengthBytes, TickType_t xTicksToWait)  BaseType_t xStreamBufferSendCompletedFromISR (StreamBufferHandle_t xStreamBuffer, BaseType_t * pxHigherPriorityTaskWoken)  size_t xStreamBufferSendFromISR (StreamBufferHandle_t xStreamBuffer, const void * pvTxData, size_t xDataLengthBytes, BaseType_t *const pxHigherPriorityTaskWoken)  BaseType_t xStreamBufferSetTriggerLevel (StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel)  size_t xStreamBufferSpacesAvailable (StreamBufferHandle_t xStreamBuffer)"},{"location":"apiStm/stream__buffer_8c/#public-static-functions","title":"Public Static Functions","text":"Type Name size_t prvBytesInBuffer (const StreamBuffer_t *const pxStreamBuffer)  void prvInitialiseNewStreamBuffer (StreamBuffer_t *const pxStreamBuffer, uint8_t *const pucBuffer, size_t xBufferSizeBytes, size_t xTriggerLevelBytes, uint8_t ucFlags)  size_t prvReadBytesFromBuffer (StreamBuffer_t * pxStreamBuffer, uint8_t * pucData, size_t xMaxCount, size_t xBytesAvailable)  size_t prvReadMessageFromBuffer (StreamBuffer_t * pxStreamBuffer, void * pvRxData, size_t xBufferLengthBytes, size_t xBytesAvailable, size_t xBytesToStoreMessageLength)  size_t prvWriteBytesToBuffer (StreamBuffer_t *const pxStreamBuffer, const uint8_t * pucData, size_t xCount)  size_t prvWriteMessageToBuffer (StreamBuffer_t *const pxStreamBuffer, const void * pvTxData, size_t xDataLengthBytes, size_t xSpace, size_t xRequiredSpace)"},{"location":"apiStm/stream__buffer_8c/#macros","title":"Macros","text":"Type Name define MPU_WRAPPERS_INCLUDED_FROM_API_FILE define sbBYTES_TO_STORE_MESSAGE_LENGTH  ( sizeof( configMESSAGE_BUFFER_LENGTH_TYPE ) ) define sbFLAGS_IS_MESSAGE_BUFFER  ( ( uint8_t ) 1 ) /* Set if the stream buffer was created as a message buffer, in which case it holds discrete messages rather than a stream. */ define sbFLAGS_IS_STATICALLY_ALLOCATED  ( ( uint8_t ) 2 ) /* Set if the stream buffer was created using statically allocated memory. */ define sbRECEIVE_COMPLETED (pxStreamBuffer)  define sbRECEIVE_COMPLETED_FROM_ISR (pxStreamBuffer, pxHigherPriorityTaskWoken)  define sbSEND_COMPLETED (pxStreamBuffer)  define sbSEND_COMPLETE_FROM_ISR (pxStreamBuffer, pxHigherPriorityTaskWoken)"},{"location":"apiStm/stream__buffer_8c/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/stream__buffer_8c/#typedef-streambuffer_t","title":"typedef StreamBuffer_t","text":"<pre><code>typedef struct StreamBufferDef_t StreamBuffer_t;\n</code></pre>"},{"location":"apiStm/stream__buffer_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/stream__buffer_8c/#function-vstreambufferdelete","title":"function vStreamBufferDelete","text":"<pre><code>void vStreamBufferDelete (\nStreamBufferHandle_t xStreamBuffer\n) </code></pre>"},{"location":"apiStm/stream__buffer_8c/#function-xstreambufferbytesavailable","title":"function xStreamBufferBytesAvailable","text":"<pre><code>size_t xStreamBufferBytesAvailable (\nStreamBufferHandle_t xStreamBuffer\n) </code></pre>"},{"location":"apiStm/stream__buffer_8c/#function-xstreambufferisempty","title":"function xStreamBufferIsEmpty","text":"<pre><code>BaseType_t xStreamBufferIsEmpty (\nStreamBufferHandle_t xStreamBuffer\n) </code></pre>"},{"location":"apiStm/stream__buffer_8c/#function-xstreambufferisfull","title":"function xStreamBufferIsFull","text":"<pre><code>BaseType_t xStreamBufferIsFull (\nStreamBufferHandle_t xStreamBuffer\n) </code></pre>"},{"location":"apiStm/stream__buffer_8c/#function-xstreambuffernextmessagelengthbytes","title":"function xStreamBufferNextMessageLengthBytes","text":"<pre><code>size_t xStreamBufferNextMessageLengthBytes (\nStreamBufferHandle_t xStreamBuffer\n) </code></pre>"},{"location":"apiStm/stream__buffer_8c/#function-xstreambufferreceive","title":"function xStreamBufferReceive","text":"<pre><code>size_t xStreamBufferReceive (\nStreamBufferHandle_t xStreamBuffer,\nvoid * pvRxData,\nsize_t xBufferLengthBytes,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/stream__buffer_8c/#function-xstreambufferreceivecompletedfromisr","title":"function xStreamBufferReceiveCompletedFromISR","text":"<pre><code>BaseType_t xStreamBufferReceiveCompletedFromISR (\nStreamBufferHandle_t xStreamBuffer,\nBaseType_t * pxHigherPriorityTaskWoken\n) </code></pre>"},{"location":"apiStm/stream__buffer_8c/#function-xstreambufferreceivefromisr","title":"function xStreamBufferReceiveFromISR","text":"<pre><code>size_t xStreamBufferReceiveFromISR (\nStreamBufferHandle_t xStreamBuffer,\nvoid * pvRxData,\nsize_t xBufferLengthBytes,\nBaseType_t *const pxHigherPriorityTaskWoken\n) </code></pre>"},{"location":"apiStm/stream__buffer_8c/#function-xstreambufferreset","title":"function xStreamBufferReset","text":"<pre><code>BaseType_t xStreamBufferReset (\nStreamBufferHandle_t xStreamBuffer\n) </code></pre>"},{"location":"apiStm/stream__buffer_8c/#function-xstreambuffersend","title":"function xStreamBufferSend","text":"<pre><code>size_t xStreamBufferSend (\nStreamBufferHandle_t xStreamBuffer,\nconst void * pvTxData,\nsize_t xDataLengthBytes,\nTickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/stream__buffer_8c/#function-xstreambuffersendcompletedfromisr","title":"function xStreamBufferSendCompletedFromISR","text":"<pre><code>BaseType_t xStreamBufferSendCompletedFromISR (\nStreamBufferHandle_t xStreamBuffer,\nBaseType_t * pxHigherPriorityTaskWoken\n) </code></pre>"},{"location":"apiStm/stream__buffer_8c/#function-xstreambuffersendfromisr","title":"function xStreamBufferSendFromISR","text":"<pre><code>size_t xStreamBufferSendFromISR (\nStreamBufferHandle_t xStreamBuffer,\nconst void * pvTxData,\nsize_t xDataLengthBytes,\nBaseType_t *const pxHigherPriorityTaskWoken\n) </code></pre>"},{"location":"apiStm/stream__buffer_8c/#function-xstreambuffersettriggerlevel","title":"function xStreamBufferSetTriggerLevel","text":"<pre><code>BaseType_t xStreamBufferSetTriggerLevel (\nStreamBufferHandle_t xStreamBuffer,\nsize_t xTriggerLevel\n) </code></pre>"},{"location":"apiStm/stream__buffer_8c/#function-xstreambufferspacesavailable","title":"function xStreamBufferSpacesAvailable","text":"<pre><code>size_t xStreamBufferSpacesAvailable (\nStreamBufferHandle_t xStreamBuffer\n) </code></pre>"},{"location":"apiStm/stream__buffer_8c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"apiStm/stream__buffer_8c/#function-prvbytesinbuffer","title":"function prvBytesInBuffer","text":"<pre><code>static size_t prvBytesInBuffer (\nconst StreamBuffer_t *const pxStreamBuffer\n) </code></pre>"},{"location":"apiStm/stream__buffer_8c/#function-prvinitialisenewstreambuffer","title":"function prvInitialiseNewStreamBuffer","text":"<pre><code>static void prvInitialiseNewStreamBuffer (\nStreamBuffer_t *const pxStreamBuffer,\nuint8_t *const pucBuffer,\nsize_t xBufferSizeBytes,\nsize_t xTriggerLevelBytes,\nuint8_t ucFlags\n) </code></pre>"},{"location":"apiStm/stream__buffer_8c/#function-prvreadbytesfrombuffer","title":"function prvReadBytesFromBuffer","text":"<pre><code>static size_t prvReadBytesFromBuffer (\nStreamBuffer_t * pxStreamBuffer,\nuint8_t * pucData,\nsize_t xMaxCount,\nsize_t xBytesAvailable\n) </code></pre>"},{"location":"apiStm/stream__buffer_8c/#function-prvreadmessagefrombuffer","title":"function prvReadMessageFromBuffer","text":"<pre><code>static size_t prvReadMessageFromBuffer (\nStreamBuffer_t * pxStreamBuffer,\nvoid * pvRxData,\nsize_t xBufferLengthBytes,\nsize_t xBytesAvailable,\nsize_t xBytesToStoreMessageLength\n) </code></pre>"},{"location":"apiStm/stream__buffer_8c/#function-prvwritebytestobuffer","title":"function prvWriteBytesToBuffer","text":"<pre><code>static size_t prvWriteBytesToBuffer (\nStreamBuffer_t *const pxStreamBuffer,\nconst uint8_t * pucData,\nsize_t xCount\n) </code></pre>"},{"location":"apiStm/stream__buffer_8c/#function-prvwritemessagetobuffer","title":"function prvWriteMessageToBuffer","text":"<pre><code>static size_t prvWriteMessageToBuffer (\nStreamBuffer_t *const pxStreamBuffer,\nconst void * pvTxData,\nsize_t xDataLengthBytes,\nsize_t xSpace,\nsize_t xRequiredSpace\n) </code></pre>"},{"location":"apiStm/stream__buffer_8c/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/stream__buffer_8c/#define-mpu_wrappers_included_from_api_file","title":"define MPU_WRAPPERS_INCLUDED_FROM_API_FILE","text":"<pre><code>#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE \n</code></pre>"},{"location":"apiStm/stream__buffer_8c/#define-sbbytes_to_store_message_length","title":"define sbBYTES_TO_STORE_MESSAGE_LENGTH","text":"<pre><code>#define sbBYTES_TO_STORE_MESSAGE_LENGTH ( sizeof( configMESSAGE_BUFFER_LENGTH_TYPE ) )\n</code></pre>"},{"location":"apiStm/stream__buffer_8c/#define-sbflags_is_message_buffer","title":"define sbFLAGS_IS_MESSAGE_BUFFER","text":"<pre><code>#define sbFLAGS_IS_MESSAGE_BUFFER ( ( uint8_t ) 1 ) /* Set if the stream buffer was created as a message buffer, in which case it holds discrete messages rather than a stream. */\n</code></pre>"},{"location":"apiStm/stream__buffer_8c/#define-sbflags_is_statically_allocated","title":"define sbFLAGS_IS_STATICALLY_ALLOCATED","text":"<pre><code>#define sbFLAGS_IS_STATICALLY_ALLOCATED ( ( uint8_t ) 2 ) /* Set if the stream buffer was created using statically allocated memory. */\n</code></pre>"},{"location":"apiStm/stream__buffer_8c/#define-sbreceive_completed","title":"define sbRECEIVE_COMPLETED","text":"<pre><code>#define sbRECEIVE_COMPLETED (\npxStreamBuffer\n) vTaskSuspendAll();                                                                \\\n        {                                                                               \\\n            if( ( pxStreamBuffer )-&gt;xTaskWaitingToSend != NULL )                        \\\n            {                                                                           \\\n                ( void ) xTaskNotify( ( pxStreamBuffer )-&gt;xTaskWaitingToSend,           \\\n                                      ( uint32_t ) 0,                                   \\\n                                      eNoAction );                                      \\\n                ( pxStreamBuffer )-&gt;xTaskWaitingToSend = NULL;                          \\\n            }                                                                           \\\n        }                                                                               \\\n        ( void ) xTaskResumeAll();\n</code></pre>"},{"location":"apiStm/stream__buffer_8c/#define-sbreceive_completed_from_isr","title":"define sbRECEIVE_COMPLETED_FROM_ISR","text":"<pre><code>#define sbRECEIVE_COMPLETED_FROM_ISR (\npxStreamBuffer,\npxHigherPriorityTaskWoken\n) {                                                                                 \\\n    UBaseType_t uxSavedInterruptStatus;                                                 \\\n                                                                                        \\\n        uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();     \\\n        {                                                                               \\\n            if( ( pxStreamBuffer )-&gt;xTaskWaitingToSend != NULL )                        \\\n            {                                                                           \\\n                ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )-&gt;xTaskWaitingToSend,    \\\n                                             ( uint32_t ) 0,                            \\\n                                             eNoAction,                                 \\\n                                             pxHigherPriorityTaskWoken );               \\\n                ( pxStreamBuffer )-&gt;xTaskWaitingToSend = NULL;                          \\\n            }                                                                           \\\n        }                                                                               \\\n        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );                    \\\n    }\n</code></pre>"},{"location":"apiStm/stream__buffer_8c/#define-sbsend_completed","title":"define sbSEND_COMPLETED","text":"<pre><code>#define sbSEND_COMPLETED (\npxStreamBuffer\n) vTaskSuspendAll();                                                                \\\n        {                                                                               \\\n            if( ( pxStreamBuffer )-&gt;xTaskWaitingToReceive != NULL )                     \\\n            {                                                                           \\\n                ( void ) xTaskNotify( ( pxStreamBuffer )-&gt;xTaskWaitingToReceive,        \\\n                                      ( uint32_t ) 0,                                   \\\n                                      eNoAction );                                      \\\n                ( pxStreamBuffer )-&gt;xTaskWaitingToReceive = NULL;                       \\\n            }                                                                           \\\n        }                                                                               \\\n        ( void ) xTaskResumeAll();\n</code></pre>"},{"location":"apiStm/stream__buffer_8c/#define-sbsend_complete_from_isr","title":"define sbSEND_COMPLETE_FROM_ISR","text":"<pre><code>#define sbSEND_COMPLETE_FROM_ISR (\npxStreamBuffer,\npxHigherPriorityTaskWoken\n) {                                                                                 \\\n    UBaseType_t uxSavedInterruptStatus;                                                 \\\n                                                                                        \\\n        uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();     \\\n        {                                                                               \\\n            if( ( pxStreamBuffer )-&gt;xTaskWaitingToReceive != NULL )                     \\\n            {                                                                           \\\n                ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )-&gt;xTaskWaitingToReceive, \\\n                                             ( uint32_t ) 0,                            \\\n                                             eNoAction,                                 \\\n                                             pxHigherPriorityTaskWoken );               \\\n                ( pxStreamBuffer )-&gt;xTaskWaitingToReceive = NULL;                       \\\n            }                                                                           \\\n        }                                                                               \\\n        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );                    \\\n    }\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/src/stream_buffer.c</code></p>"},{"location":"apiStm/stream__buffer_8c_source/","title":"File stream_buffer.c","text":"<p>File List &gt; FreeRTOS &gt; src &gt; stream_buffer.c</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n/* Standard includes. */\n#include &lt;stdint.h&gt;\n#include &lt;string.h&gt;\n\n/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining\nall the API functions to use the MPU wrappers.  That should only be done when\ntask.h is included from an application file. */\n#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE\n\n/* FreeRTOS includes. */\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n#include \"stream_buffer.h\"\n\n#if( configUSE_TASK_NOTIFICATIONS != 1 )\n#error configUSE_TASK_NOTIFICATIONS must be set to 1 to build stream_buffer.c\n#endif\n\n/* Lint e961, e9021 and e750 are suppressed as a MISRA exception justified\nbecause the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined\nfor the header files above, but not in this file, in order to generate the\ncorrect privileged Vs unprivileged linkage and placement. */\n#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */\n\n/* If the user has not provided application specific Rx notification macros,\nor #defined the notification macros away, them provide default implementations\nthat uses task notifications. */\n/*lint -save -e9026 Function like macros allowed and needed here so they can be overidden. */\n#ifndef sbRECEIVE_COMPLETED\n#define sbRECEIVE_COMPLETED( pxStreamBuffer )                                       \\\n        vTaskSuspendAll();                                                              \\\n        {                                                                               \\\n            if( ( pxStreamBuffer )-&gt;xTaskWaitingToSend != NULL )                        \\\n            {                                                                           \\\n                ( void ) xTaskNotify( ( pxStreamBuffer )-&gt;xTaskWaitingToSend,           \\\n                                      ( uint32_t ) 0,                                   \\\n                                      eNoAction );                                      \\\n                ( pxStreamBuffer )-&gt;xTaskWaitingToSend = NULL;                          \\\n            }                                                                           \\\n        }                                                                               \\\n        ( void ) xTaskResumeAll();\n#endif /* sbRECEIVE_COMPLETED */\n\n#ifndef sbRECEIVE_COMPLETED_FROM_ISR\n#define sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer,                               \\\n                                          pxHigherPriorityTaskWoken )                   \\\n    {                                                                                   \\\n    UBaseType_t uxSavedInterruptStatus;                                                 \\\n                                                                                        \\\n        uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();     \\\n        {                                                                               \\\n            if( ( pxStreamBuffer )-&gt;xTaskWaitingToSend != NULL )                        \\\n            {                                                                           \\\n                ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )-&gt;xTaskWaitingToSend,    \\\n                                             ( uint32_t ) 0,                            \\\n                                             eNoAction,                                 \\\n                                             pxHigherPriorityTaskWoken );               \\\n                ( pxStreamBuffer )-&gt;xTaskWaitingToSend = NULL;                          \\\n            }                                                                           \\\n        }                                                                               \\\n        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );                    \\\n    }\n#endif /* sbRECEIVE_COMPLETED_FROM_ISR */\n\n/* If the user has not provided an application specific Tx notification macro,\nor #defined the notification macro away, them provide a default implementation\nthat uses task notifications. */\n#ifndef sbSEND_COMPLETED\n#define sbSEND_COMPLETED( pxStreamBuffer )                                          \\\n        vTaskSuspendAll();                                                              \\\n        {                                                                               \\\n            if( ( pxStreamBuffer )-&gt;xTaskWaitingToReceive != NULL )                     \\\n            {                                                                           \\\n                ( void ) xTaskNotify( ( pxStreamBuffer )-&gt;xTaskWaitingToReceive,        \\\n                                      ( uint32_t ) 0,                                   \\\n                                      eNoAction );                                      \\\n                ( pxStreamBuffer )-&gt;xTaskWaitingToReceive = NULL;                       \\\n            }                                                                           \\\n        }                                                                               \\\n        ( void ) xTaskResumeAll();\n#endif /* sbSEND_COMPLETED */\n\n#ifndef sbSEND_COMPLETE_FROM_ISR\n#define sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken )       \\\n    {                                                                                   \\\n    UBaseType_t uxSavedInterruptStatus;                                                 \\\n                                                                                        \\\n        uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();     \\\n        {                                                                               \\\n            if( ( pxStreamBuffer )-&gt;xTaskWaitingToReceive != NULL )                     \\\n            {                                                                           \\\n                ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )-&gt;xTaskWaitingToReceive, \\\n                                             ( uint32_t ) 0,                            \\\n                                             eNoAction,                                 \\\n                                             pxHigherPriorityTaskWoken );               \\\n                ( pxStreamBuffer )-&gt;xTaskWaitingToReceive = NULL;                       \\\n            }                                                                           \\\n        }                                                                               \\\n        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );                    \\\n    }\n#endif /* sbSEND_COMPLETE_FROM_ISR */\n/*lint -restore (9026) */\n\n/* The number of bytes used to hold the length of a message in the buffer. */\n#define sbBYTES_TO_STORE_MESSAGE_LENGTH ( sizeof( configMESSAGE_BUFFER_LENGTH_TYPE ) )\n\n/* Bits stored in the ucFlags field of the stream buffer. */\n#define sbFLAGS_IS_MESSAGE_BUFFER       ( ( uint8_t ) 1 ) /* Set if the stream buffer was created as a message buffer, in which case it holds discrete messages rather than a stream. */\n#define sbFLAGS_IS_STATICALLY_ALLOCATED ( ( uint8_t ) 2 ) /* Set if the stream buffer was created using statically allocated memory. */\n\n/*-----------------------------------------------------------*/\n\n/* Structure that hold state information on the buffer. */\ntypedef struct StreamBufferDef_t /*lint !e9058 Style convention uses tag. */\n{\nvolatile size_t xTail;              /* Index to the next item to read within the buffer. */\nvolatile size_t xHead;              /* Index to the next item to write within the buffer. */\nsize_t xLength;                     /* The length of the buffer pointed to by pucBuffer. */\nsize_t xTriggerLevelBytes;          /* The number of bytes that must be in the stream buffer before a task that is waiting for data is unblocked. */\nvolatile TaskHandle_t xTaskWaitingToReceive; /* Holds the handle of a task waiting for data, or NULL if no tasks are waiting. */\nvolatile TaskHandle_t xTaskWaitingToSend;   /* Holds the handle of a task waiting to send data to a message buffer that is full. */\nuint8_t *pucBuffer;                 /* Points to the buffer itself - that is - the RAM that stores the data passed through the buffer. */\nuint8_t ucFlags;\n\n#if ( configUSE_TRACE_FACILITY == 1 )\nUBaseType_t uxStreamBufferNumber;       /* Used for tracing purposes. */\n#endif\n} StreamBuffer_t;\n\n/*\n * The number of bytes available to be read from the buffer.\n */\nstatic size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer ) PRIVILEGED_FUNCTION;\n\n/*\n * Add xCount bytes from pucData into the pxStreamBuffer message buffer.\n * Returns the number of bytes written, which will either equal xCount in the\n * success case, or 0 if there was not enough space in the buffer (in which case\n * no data is written into the buffer).\n */\nstatic size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount ) PRIVILEGED_FUNCTION;\n\n/*\n * If the stream buffer is being used as a message buffer, then reads an entire\n * message out of the buffer.  If the stream buffer is being used as a stream\n * buffer then read as many bytes as possible from the buffer.\n * prvReadBytesFromBuffer() is called to actually extract the bytes from the\n * buffer's data storage area.\n */\nstatic size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,\nvoid *pvRxData,\nsize_t xBufferLengthBytes,\nsize_t xBytesAvailable,\nsize_t xBytesToStoreMessageLength ) PRIVILEGED_FUNCTION;\n\n/*\n * If the stream buffer is being used as a message buffer, then writes an entire\n * message to the buffer.  If the stream buffer is being used as a stream\n * buffer then write as many bytes as possible to the buffer.\n * prvWriteBytestoBuffer() is called to actually send the bytes to the buffer's\n * data storage area.\n */\nstatic size_t prvWriteMessageToBuffer(  StreamBuffer_t * const pxStreamBuffer,\nconst void * pvTxData,\nsize_t xDataLengthBytes,\nsize_t xSpace,\nsize_t xRequiredSpace ) PRIVILEGED_FUNCTION;\n\n/*\n * Read xMaxCount bytes from the pxStreamBuffer message buffer and write them\n * to pucData.\n */\nstatic size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer,\nuint8_t *pucData,\nsize_t xMaxCount,\nsize_t xBytesAvailable ) PRIVILEGED_FUNCTION;\n\n/*\n * Called by both pxStreamBufferCreate() and pxStreamBufferCreateStatic() to\n * initialise the members of the newly created stream buffer structure.\n */\nstatic void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,\nuint8_t * const pucBuffer,\nsize_t xBufferSizeBytes,\nsize_t xTriggerLevelBytes,\nuint8_t ucFlags ) PRIVILEGED_FUNCTION;\n\n/*-----------------------------------------------------------*/\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n\nStreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )\n{\nuint8_t *pucAllocatedMemory;\nuint8_t ucFlags;\n\n/* In case the stream buffer is going to be used as a message buffer\n        (that is, it will hold discrete messages with a little meta data that\n        says how big the next message is) check the buffer will be large enough\n        to hold at least one message. */\nif( xIsMessageBuffer == pdTRUE )\n{\n/* Is a message buffer but not statically allocated. */\nucFlags = sbFLAGS_IS_MESSAGE_BUFFER;\nconfigASSERT( xBufferSizeBytes &gt; sbBYTES_TO_STORE_MESSAGE_LENGTH );\n}\nelse\n{\n/* Not a message buffer and not statically allocated. */\nucFlags = 0;\nconfigASSERT( xBufferSizeBytes &gt; 0 );\n}\nconfigASSERT( xTriggerLevelBytes &lt;= xBufferSizeBytes );\n\n/* A trigger level of 0 would cause a waiting task to unblock even when\n        the buffer was empty. */\nif( xTriggerLevelBytes == ( size_t ) 0 )\n{\nxTriggerLevelBytes = ( size_t ) 1;\n}\n\n/* A stream buffer requires a StreamBuffer_t structure and a buffer.\n        Both are allocated in a single call to pvPortMalloc().  The\n        StreamBuffer_t structure is placed at the start of the allocated memory\n        and the buffer follows immediately after.  The requested size is\n        incremented so the free space is returned as the user would expect -\n        this is a quirk of the implementation that means otherwise the free\n        space would be reported as one byte smaller than would be logically\n        expected. */\nxBufferSizeBytes++;\npucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */\n\nif( pucAllocatedMemory != NULL )\n{\nprvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */\npucAllocatedMemory + sizeof( StreamBuffer_t ),  /* Storage area follows. */ /*lint !e9016 Indexing past structure valid for uint8_t pointer, also storage area has no alignment requirement. */\nxBufferSizeBytes,\nxTriggerLevelBytes,\nucFlags );\n\ntraceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );\n}\nelse\n{\ntraceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );\n}\n\nreturn ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */\n}\n\n#endif /* configSUPPORT_DYNAMIC_ALLOCATION */\n/*-----------------------------------------------------------*/\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n\nStreamBufferHandle_t xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes,\nsize_t xTriggerLevelBytes,\nBaseType_t xIsMessageBuffer,\nuint8_t * const pucStreamBufferStorageArea,\nStaticStreamBuffer_t * const pxStaticStreamBuffer )\n{\nStreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) pxStaticStreamBuffer; /*lint !e740 !e9087 Safe cast as StaticStreamBuffer_t is opaque Streambuffer_t. */\nStreamBufferHandle_t xReturn;\nuint8_t ucFlags;\n\nconfigASSERT( pucStreamBufferStorageArea );\nconfigASSERT( pxStaticStreamBuffer );\nconfigASSERT( xTriggerLevelBytes &lt;= xBufferSizeBytes );\n\n/* A trigger level of 0 would cause a waiting task to unblock even when\n        the buffer was empty. */\nif( xTriggerLevelBytes == ( size_t ) 0 )\n{\nxTriggerLevelBytes = ( size_t ) 1;\n}\n\nif( xIsMessageBuffer != pdFALSE )\n{\n/* Statically allocated message buffer. */\nucFlags = sbFLAGS_IS_MESSAGE_BUFFER | sbFLAGS_IS_STATICALLY_ALLOCATED;\n}\nelse\n{\n/* Statically allocated stream buffer. */\nucFlags = sbFLAGS_IS_STATICALLY_ALLOCATED;\n}\n\n/* In case the stream buffer is going to be used as a message buffer\n        (that is, it will hold discrete messages with a little meta data that\n        says how big the next message is) check the buffer will be large enough\n        to hold at least one message. */\nconfigASSERT( xBufferSizeBytes &gt; sbBYTES_TO_STORE_MESSAGE_LENGTH );\n\n#if( configASSERT_DEFINED == 1 )\n{\n/* Sanity check that the size of the structure used to declare a\n            variable of type StaticStreamBuffer_t equals the size of the real\n            message buffer structure. */\nvolatile size_t xSize = sizeof( StaticStreamBuffer_t );\nconfigASSERT( xSize == sizeof( StreamBuffer_t ) );\n} /*lint !e529 xSize is referenced is configASSERT() is defined. */\n#endif /* configASSERT_DEFINED */\n\nif( ( pucStreamBufferStorageArea != NULL ) &amp;&amp; ( pxStaticStreamBuffer != NULL ) )\n{\nprvInitialiseNewStreamBuffer( pxStreamBuffer,\npucStreamBufferStorageArea,\nxBufferSizeBytes,\nxTriggerLevelBytes,\nucFlags );\n\n/* Remember this was statically allocated in case it is ever deleted\n            again. */\npxStreamBuffer-&gt;ucFlags |= sbFLAGS_IS_STATICALLY_ALLOCATED;\n\ntraceSTREAM_BUFFER_CREATE( pxStreamBuffer, xIsMessageBuffer );\n\nxReturn = ( StreamBufferHandle_t ) pxStaticStreamBuffer; /*lint !e9087 Data hiding requires cast to opaque type. */\n}\nelse\n{\nxReturn = NULL;\ntraceSTREAM_BUFFER_CREATE_STATIC_FAILED( xReturn, xIsMessageBuffer );\n}\n\nreturn xReturn;\n}\n\n#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */\n/*-----------------------------------------------------------*/\n\nvoid vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )\n{\nStreamBuffer_t * pxStreamBuffer = xStreamBuffer;\n\nconfigASSERT( pxStreamBuffer );\n\ntraceSTREAM_BUFFER_DELETE( xStreamBuffer );\n\nif( ( pxStreamBuffer-&gt;ucFlags &amp; sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )\n{\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n{\n/* Both the structure and the buffer were allocated using a single call\n            to pvPortMalloc(), hence only one call to vPortFree() is required. */\nvPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */\n}\n#else\n{\n/* Should not be possible to get here, ucFlags must be corrupt.\n            Force an assert. */\nconfigASSERT( xStreamBuffer == ( StreamBufferHandle_t ) ~0 );\n}\n#endif\n}\nelse\n{\n/* The structure and buffer were not allocated dynamically and cannot be\n        freed - just scrub the structure so future use will assert. */\n( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );\n}\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )\n{\nStreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\nBaseType_t xReturn = pdFAIL;\n\n#if( configUSE_TRACE_FACILITY == 1 )\nUBaseType_t uxStreamBufferNumber;\n#endif\n\nconfigASSERT( pxStreamBuffer );\n\n#if( configUSE_TRACE_FACILITY == 1 )\n{\n/* Store the stream buffer number so it can be restored after the\n        reset. */\nuxStreamBufferNumber = pxStreamBuffer-&gt;uxStreamBufferNumber;\n}\n#endif\n\n/* Can only reset a message buffer if there are no tasks blocked on it. */\ntaskENTER_CRITICAL();\n{\nif( pxStreamBuffer-&gt;xTaskWaitingToReceive == NULL )\n{\nif( pxStreamBuffer-&gt;xTaskWaitingToSend == NULL )\n{\nprvInitialiseNewStreamBuffer( pxStreamBuffer,\npxStreamBuffer-&gt;pucBuffer,\npxStreamBuffer-&gt;xLength,\npxStreamBuffer-&gt;xTriggerLevelBytes,\npxStreamBuffer-&gt;ucFlags );\nxReturn = pdPASS;\n\n#if( configUSE_TRACE_FACILITY == 1 )\n{\npxStreamBuffer-&gt;uxStreamBufferNumber = uxStreamBufferNumber;\n}\n#endif\n\ntraceSTREAM_BUFFER_RESET( xStreamBuffer );\n}\n}\n}\ntaskEXIT_CRITICAL();\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )\n{\nStreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\nBaseType_t xReturn;\n\nconfigASSERT( pxStreamBuffer );\n\n/* It is not valid for the trigger level to be 0. */\nif( xTriggerLevel == ( size_t ) 0 )\n{\nxTriggerLevel = ( size_t ) 1;\n}\n\n/* The trigger level is the number of bytes that must be in the stream\n    buffer before a task that is waiting for data is unblocked. */\nif( xTriggerLevel &lt;= pxStreamBuffer-&gt;xLength )\n{\npxStreamBuffer-&gt;xTriggerLevelBytes = xTriggerLevel;\nxReturn = pdPASS;\n}\nelse\n{\nxReturn = pdFALSE;\n}\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nsize_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )\n{\nconst StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\nsize_t xSpace;\n\nconfigASSERT( pxStreamBuffer );\n\nxSpace = pxStreamBuffer-&gt;xLength + pxStreamBuffer-&gt;xTail;\nxSpace -= pxStreamBuffer-&gt;xHead;\nxSpace -= ( size_t ) 1;\n\nif( xSpace &gt;= pxStreamBuffer-&gt;xLength )\n{\nxSpace -= pxStreamBuffer-&gt;xLength;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nreturn xSpace;\n}\n/*-----------------------------------------------------------*/\n\nsize_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )\n{\nconst StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\nsize_t xReturn;\n\nconfigASSERT( pxStreamBuffer );\n\nxReturn = prvBytesInBuffer( pxStreamBuffer );\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nsize_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,\nconst void *pvTxData,\nsize_t xDataLengthBytes,\nTickType_t xTicksToWait )\n{\nStreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\nsize_t xReturn, xSpace = 0;\nsize_t xRequiredSpace = xDataLengthBytes;\nTimeOut_t xTimeOut;\n\nconfigASSERT( pvTxData );\nconfigASSERT( pxStreamBuffer );\n\n/* This send function is used to write to both message buffers and stream\n    buffers.  If this is a message buffer then the space needed must be\n    increased by the amount of bytes needed to store the length of the\n    message. */\nif( ( pxStreamBuffer-&gt;ucFlags &amp; sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\n{\nxRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;\n\n/* Overflow? */\nconfigASSERT( xRequiredSpace &gt; xDataLengthBytes );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nif( xTicksToWait != ( TickType_t ) 0 )\n{\nvTaskSetTimeOutState( &amp;xTimeOut );\n\ndo\n{\n/* Wait until the required number of bytes are free in the message\n            buffer. */\ntaskENTER_CRITICAL();\n{\nxSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );\n\nif( xSpace &lt; xRequiredSpace )\n{\n/* Clear notification state as going to wait for space. */\n( void ) xTaskNotifyStateClear( NULL );\n\n/* Should only be one writer. */\nconfigASSERT( pxStreamBuffer-&gt;xTaskWaitingToSend == NULL );\npxStreamBuffer-&gt;xTaskWaitingToSend = xTaskGetCurrentTaskHandle();\n}\nelse\n{\ntaskEXIT_CRITICAL();\nbreak;\n}\n}\ntaskEXIT_CRITICAL();\n\ntraceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );\n( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );\npxStreamBuffer-&gt;xTaskWaitingToSend = NULL;\n\n} while( xTaskCheckForTimeOut( &amp;xTimeOut, &amp;xTicksToWait ) == pdFALSE );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nif( xSpace == ( size_t ) 0 )\n{\nxSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nxReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );\n\nif( xReturn &gt; ( size_t ) 0 )\n{\ntraceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );\n\n/* Was a task waiting for the data? */\nif( prvBytesInBuffer( pxStreamBuffer ) &gt;= pxStreamBuffer-&gt;xTriggerLevelBytes )\n{\nsbSEND_COMPLETED( pxStreamBuffer );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\ntraceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );\n}\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nsize_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,\nconst void *pvTxData,\nsize_t xDataLengthBytes,\nBaseType_t * const pxHigherPriorityTaskWoken )\n{\nStreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\nsize_t xReturn, xSpace;\nsize_t xRequiredSpace = xDataLengthBytes;\n\nconfigASSERT( pvTxData );\nconfigASSERT( pxStreamBuffer );\n\n/* This send function is used to write to both message buffers and stream\n    buffers.  If this is a message buffer then the space needed must be\n    increased by the amount of bytes needed to store the length of the\n    message. */\nif( ( pxStreamBuffer-&gt;ucFlags &amp; sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\n{\nxRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nxSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );\nxReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );\n\nif( xReturn &gt; ( size_t ) 0 )\n{\n/* Was a task waiting for the data? */\nif( prvBytesInBuffer( pxStreamBuffer ) &gt;= pxStreamBuffer-&gt;xTriggerLevelBytes )\n{\nsbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\ntraceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nstatic size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,\nconst void * pvTxData,\nsize_t xDataLengthBytes,\nsize_t xSpace,\nsize_t xRequiredSpace )\n{\nBaseType_t xShouldWrite;\nsize_t xReturn;\n\nif( xSpace == ( size_t ) 0 )\n{\n/* Doesn't matter if this is a stream buffer or a message buffer, there\n        is no space to write. */\nxShouldWrite = pdFALSE;\n}\nelse if( ( pxStreamBuffer-&gt;ucFlags &amp; sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )\n{\n/* This is a stream buffer, as opposed to a message buffer, so writing a\n        stream of bytes rather than discrete messages.  Write as many bytes as\n        possible. */\nxShouldWrite = pdTRUE;\nxDataLengthBytes = configMIN( xDataLengthBytes, xSpace );\n}\nelse if( xSpace &gt;= xRequiredSpace )\n{\n/* This is a message buffer, as opposed to a stream buffer, and there\n        is enough space to write both the message length and the message itself\n        into the buffer.  Start by writing the length of the data, the data\n        itself will be written later in this function. */\nxShouldWrite = pdTRUE;\n( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &amp;( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );\n}\nelse\n{\n/* There is space available, but not enough space. */\nxShouldWrite = pdFALSE;\n}\n\nif( xShouldWrite != pdFALSE )\n{\n/* Writes the data itself. */\nxReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */\n}\nelse\n{\nxReturn = 0;\n}\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nsize_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,\nvoid *pvRxData,\nsize_t xBufferLengthBytes,\nTickType_t xTicksToWait )\n{\nStreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\nsize_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;\n\nconfigASSERT( pvRxData );\nconfigASSERT( pxStreamBuffer );\n\n/* This receive function is used by both message buffers, which store\n    discrete messages, and stream buffers, which store a continuous stream of\n    bytes.  Discrete messages include an additional\n    sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the\n    message. */\nif( ( pxStreamBuffer-&gt;ucFlags &amp; sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\n{\nxBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;\n}\nelse\n{\nxBytesToStoreMessageLength = 0;\n}\n\nif( xTicksToWait != ( TickType_t ) 0 )\n{\n/* Checking if there is data and clearing the notification state must be\n        performed atomically. */\ntaskENTER_CRITICAL();\n{\nxBytesAvailable = prvBytesInBuffer( pxStreamBuffer );\n\n/* If this function was invoked by a message buffer read then\n            xBytesToStoreMessageLength holds the number of bytes used to hold\n            the length of the next discrete message.  If this function was\n            invoked by a stream buffer read then xBytesToStoreMessageLength will\n            be 0. */\nif( xBytesAvailable &lt;= xBytesToStoreMessageLength )\n{\n/* Clear notification state as going to wait for data. */\n( void ) xTaskNotifyStateClear( NULL );\n\n/* Should only be one reader. */\nconfigASSERT( pxStreamBuffer-&gt;xTaskWaitingToReceive == NULL );\npxStreamBuffer-&gt;xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\ntaskEXIT_CRITICAL();\n\nif( xBytesAvailable &lt;= xBytesToStoreMessageLength )\n{\n/* Wait for data to be available. */\ntraceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );\n( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );\npxStreamBuffer-&gt;xTaskWaitingToReceive = NULL;\n\n/* Recheck the data available after blocking. */\nxBytesAvailable = prvBytesInBuffer( pxStreamBuffer );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nxBytesAvailable = prvBytesInBuffer( pxStreamBuffer );\n}\n\n/* Whether receiving a discrete message (where xBytesToStoreMessageLength\n    holds the number of bytes used to store the message length) or a stream of\n    bytes (where xBytesToStoreMessageLength is zero), the number of bytes\n    available must be greater than xBytesToStoreMessageLength to be able to\n    read bytes from the buffer. */\nif( xBytesAvailable &gt; xBytesToStoreMessageLength )\n{\nxReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );\n\n/* Was a task waiting for space in the buffer? */\nif( xReceivedLength != ( size_t ) 0 )\n{\ntraceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );\nsbRECEIVE_COMPLETED( pxStreamBuffer );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\ntraceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );\nmtCOVERAGE_TEST_MARKER();\n}\n\nreturn xReceivedLength;\n}\n/*-----------------------------------------------------------*/\n\nsize_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )\n{\nStreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\nsize_t xReturn, xBytesAvailable, xOriginalTail;\nconfigMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;\n\nconfigASSERT( pxStreamBuffer );\n\n/* Ensure the stream buffer is being used as a message buffer. */\nif( ( pxStreamBuffer-&gt;ucFlags &amp; sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\n{\nxBytesAvailable = prvBytesInBuffer( pxStreamBuffer );\nif( xBytesAvailable &gt; sbBYTES_TO_STORE_MESSAGE_LENGTH )\n{\n/* The number of bytes available is greater than the number of bytes\n            required to hold the length of the next message, so another message\n            is available.  Return its length without removing the length bytes\n            from the buffer.  A copy of the tail is stored so the buffer can be\n            returned to its prior state as the message is not actually being\n            removed from the buffer. */\nxOriginalTail = pxStreamBuffer-&gt;xTail;\n( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &amp;xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );\nxReturn = ( size_t ) xTempReturn;\npxStreamBuffer-&gt;xTail = xOriginalTail;\n}\nelse\n{\n/* The minimum amount of bytes in a message buffer is\n            ( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is\n            less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid\n            value is 0. */\nconfigASSERT( xBytesAvailable == 0 );\nxReturn = 0;\n}\n}\nelse\n{\nxReturn = 0;\n}\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nsize_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,\nvoid *pvRxData,\nsize_t xBufferLengthBytes,\nBaseType_t * const pxHigherPriorityTaskWoken )\n{\nStreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\nsize_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;\n\nconfigASSERT( pvRxData );\nconfigASSERT( pxStreamBuffer );\n\n/* This receive function is used by both message buffers, which store\n    discrete messages, and stream buffers, which store a continuous stream of\n    bytes.  Discrete messages include an additional\n    sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the\n    message. */\nif( ( pxStreamBuffer-&gt;ucFlags &amp; sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\n{\nxBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;\n}\nelse\n{\nxBytesToStoreMessageLength = 0;\n}\n\nxBytesAvailable = prvBytesInBuffer( pxStreamBuffer );\n\n/* Whether receiving a discrete message (where xBytesToStoreMessageLength\n    holds the number of bytes used to store the message length) or a stream of\n    bytes (where xBytesToStoreMessageLength is zero), the number of bytes\n    available must be greater than xBytesToStoreMessageLength to be able to\n    read bytes from the buffer. */\nif( xBytesAvailable &gt; xBytesToStoreMessageLength )\n{\nxReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );\n\n/* Was a task waiting for space in the buffer? */\nif( xReceivedLength != ( size_t ) 0 )\n{\nsbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\ntraceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );\n\nreturn xReceivedLength;\n}\n/*-----------------------------------------------------------*/\n\nstatic size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,\nvoid *pvRxData,\nsize_t xBufferLengthBytes,\nsize_t xBytesAvailable,\nsize_t xBytesToStoreMessageLength )\n{\nsize_t xOriginalTail, xReceivedLength, xNextMessageLength;\nconfigMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;\n\nif( xBytesToStoreMessageLength != ( size_t ) 0 )\n{\n/* A discrete message is being received.  First receive the length\n        of the message.  A copy of the tail is stored so the buffer can be\n        returned to its prior state if the length of the message is too\n        large for the provided buffer. */\nxOriginalTail = pxStreamBuffer-&gt;xTail;\n( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &amp;xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );\nxNextMessageLength = ( size_t ) xTempNextMessageLength;\n\n/* Reduce the number of bytes available by the number of bytes just\n        read out. */\nxBytesAvailable -= xBytesToStoreMessageLength;\n\n/* Check there is enough space in the buffer provided by the\n        user. */\nif( xNextMessageLength &gt; xBufferLengthBytes )\n{\n/* The user has provided insufficient space to read the message\n            so return the buffer to its previous state (so the length of\n            the message is in the buffer again). */\npxStreamBuffer-&gt;xTail = xOriginalTail;\nxNextMessageLength = 0;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\n/* A stream of bytes is being received (as opposed to a discrete\n        message), so read as many bytes as possible. */\nxNextMessageLength = xBufferLengthBytes;\n}\n\n/* Read the actual data. */\nxReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */\n\nreturn xReceivedLength;\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )\n{\nconst StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\nBaseType_t xReturn;\nsize_t xTail;\n\nconfigASSERT( pxStreamBuffer );\n\n/* True if no bytes are available. */\nxTail = pxStreamBuffer-&gt;xTail;\nif( pxStreamBuffer-&gt;xHead == xTail )\n{\nxReturn = pdTRUE;\n}\nelse\n{\nxReturn = pdFALSE;\n}\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )\n{\nBaseType_t xReturn;\nsize_t xBytesToStoreMessageLength;\nconst StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\n\nconfigASSERT( pxStreamBuffer );\n\n/* This generic version of the receive function is used by both message\n    buffers, which store discrete messages, and stream buffers, which store a\n    continuous stream of bytes.  Discrete messages include an additional\n    sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */\nif( ( pxStreamBuffer-&gt;ucFlags &amp; sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\n{\nxBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;\n}\nelse\n{\nxBytesToStoreMessageLength = 0;\n}\n\n/* True if the available space equals zero. */\nif( xStreamBufferSpacesAvailable( xStreamBuffer ) &lt;= xBytesToStoreMessageLength )\n{\nxReturn = pdTRUE;\n}\nelse\n{\nxReturn = pdFALSE;\n}\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )\n{\nStreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\nBaseType_t xReturn;\nUBaseType_t uxSavedInterruptStatus;\n\nconfigASSERT( pxStreamBuffer );\n\nuxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();\n{\nif( ( pxStreamBuffer )-&gt;xTaskWaitingToReceive != NULL )\n{\n( void ) xTaskNotifyFromISR( ( pxStreamBuffer )-&gt;xTaskWaitingToReceive,\n( uint32_t ) 0,\neNoAction,\npxHigherPriorityTaskWoken );\n( pxStreamBuffer )-&gt;xTaskWaitingToReceive = NULL;\nxReturn = pdTRUE;\n}\nelse\n{\nxReturn = pdFALSE;\n}\n}\nportCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )\n{\nStreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\nBaseType_t xReturn;\nUBaseType_t uxSavedInterruptStatus;\n\nconfigASSERT( pxStreamBuffer );\n\nuxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();\n{\nif( ( pxStreamBuffer )-&gt;xTaskWaitingToSend != NULL )\n{\n( void ) xTaskNotifyFromISR( ( pxStreamBuffer )-&gt;xTaskWaitingToSend,\n( uint32_t ) 0,\neNoAction,\npxHigherPriorityTaskWoken );\n( pxStreamBuffer )-&gt;xTaskWaitingToSend = NULL;\nxReturn = pdTRUE;\n}\nelse\n{\nxReturn = pdFALSE;\n}\n}\nportCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nstatic size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )\n{\nsize_t xNextHead, xFirstLength;\n\nconfigASSERT( xCount &gt; ( size_t ) 0 );\n\nxNextHead = pxStreamBuffer-&gt;xHead;\n\n/* Calculate the number of bytes that can be added in the first write -\n    which may be less than the total number of bytes that need to be added if\n    the buffer will wrap back to the beginning. */\nxFirstLength = configMIN( pxStreamBuffer-&gt;xLength - xNextHead, xCount );\n\n/* Write as many bytes as can be written in the first write. */\nconfigASSERT( ( xNextHead + xFirstLength ) &lt;= pxStreamBuffer-&gt;xLength );\n( void ) memcpy( ( void* ) ( &amp;( pxStreamBuffer-&gt;pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */\n\n/* If the number of bytes written was less than the number that could be\n    written in the first write... */\nif( xCount &gt; xFirstLength )\n{\n/* ...then write the remaining bytes to the start of the buffer. */\nconfigASSERT( ( xCount - xFirstLength ) &lt;= pxStreamBuffer-&gt;xLength );\n( void ) memcpy( ( void * ) pxStreamBuffer-&gt;pucBuffer, ( const void * ) &amp;( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nxNextHead += xCount;\nif( xNextHead &gt;= pxStreamBuffer-&gt;xLength )\n{\nxNextHead -= pxStreamBuffer-&gt;xLength;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\npxStreamBuffer-&gt;xHead = xNextHead;\n\nreturn xCount;\n}\n/*-----------------------------------------------------------*/\n\nstatic size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )\n{\nsize_t xCount, xFirstLength, xNextTail;\n\n/* Use the minimum of the wanted bytes and the available bytes. */\nxCount = configMIN( xBytesAvailable, xMaxCount );\n\nif( xCount &gt; ( size_t ) 0 )\n{\nxNextTail = pxStreamBuffer-&gt;xTail;\n\n/* Calculate the number of bytes that can be read - which may be\n        less than the number wanted if the data wraps around to the start of\n        the buffer. */\nxFirstLength = configMIN( pxStreamBuffer-&gt;xLength - xNextTail, xCount );\n\n/* Obtain the number of bytes it is possible to obtain in the first\n        read.  Asserts check bounds of read and write. */\nconfigASSERT( xFirstLength &lt;= xMaxCount );\nconfigASSERT( ( xNextTail + xFirstLength ) &lt;= pxStreamBuffer-&gt;xLength );\n( void ) memcpy( ( void * ) pucData, ( const void * ) &amp;( pxStreamBuffer-&gt;pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */\n\n/* If the total number of wanted bytes is greater than the number\n        that could be read in the first read... */\nif( xCount &gt; xFirstLength )\n{\n/*...then read the remaining bytes from the start of the buffer. */\nconfigASSERT( xCount &lt;= xMaxCount );\n( void ) memcpy( ( void * ) &amp;( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer-&gt;pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\n/* Move the tail pointer to effectively remove the data read from\n        the buffer. */\nxNextTail += xCount;\n\nif( xNextTail &gt;= pxStreamBuffer-&gt;xLength )\n{\nxNextTail -= pxStreamBuffer-&gt;xLength;\n}\n\npxStreamBuffer-&gt;xTail = xNextTail;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nreturn xCount;\n}\n/*-----------------------------------------------------------*/\n\nstatic size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )\n{\n/* Returns the distance between xTail and xHead. */\nsize_t xCount;\n\nxCount = pxStreamBuffer-&gt;xLength + pxStreamBuffer-&gt;xHead;\nxCount -= pxStreamBuffer-&gt;xTail;\nif ( xCount &gt;= pxStreamBuffer-&gt;xLength )\n{\nxCount -= pxStreamBuffer-&gt;xLength;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nreturn xCount;\n}\n/*-----------------------------------------------------------*/\n\nstatic void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,\nuint8_t * const pucBuffer,\nsize_t xBufferSizeBytes,\nsize_t xTriggerLevelBytes,\nuint8_t ucFlags )\n{\n/* Assert here is deliberately writing to the entire buffer to ensure it can\n    be written to without generating exceptions, and is setting the buffer to a\n    known value to assist in development/debugging. */\n#if( configASSERT_DEFINED == 1 )\n{\n/* The value written just has to be identifiable when looking at the\n        memory.  Don't use 0xA5 as that is the stack fill value and could\n        result in confusion as to what is actually being observed. */\nconst BaseType_t xWriteValue = 0x55;\nconfigASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );\n} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */\n#endif\n\n( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */\npxStreamBuffer-&gt;pucBuffer = pucBuffer;\npxStreamBuffer-&gt;xLength = xBufferSizeBytes;\npxStreamBuffer-&gt;xTriggerLevelBytes = xTriggerLevelBytes;\npxStreamBuffer-&gt;ucFlags = ucFlags;\n}\n\n#if ( configUSE_TRACE_FACILITY == 1 )\n\nUBaseType_t uxStreamBufferGetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer )\n{\nreturn xStreamBuffer-&gt;uxStreamBufferNumber;\n}\n\n#endif /* configUSE_TRACE_FACILITY */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_TRACE_FACILITY == 1 )\n\nvoid vStreamBufferSetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer, UBaseType_t uxStreamBufferNumber )\n{\nxStreamBuffer-&gt;uxStreamBufferNumber = uxStreamBufferNumber;\n}\n\n#endif /* configUSE_TRACE_FACILITY */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_TRACE_FACILITY == 1 )\n\nuint8_t ucStreamBufferGetStreamBufferType( StreamBufferHandle_t xStreamBuffer )\n{\nreturn ( xStreamBuffer-&gt;ucFlags &amp; sbFLAGS_IS_MESSAGE_BUFFER );\n}\n\n#endif /* configUSE_TRACE_FACILITY */\n/*-----------------------------------------------------------*/\n</code></pre>"},{"location":"apiStm/tasks_8c/","title":"File tasks.c","text":"<p>FileList &gt; FreeRTOS &gt; src &gt; tasks.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include &lt;string.h&gt;</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"task.h\"</code></li> <li><code>#include \"timers.h\"</code></li> <li><code>#include \"stack_macros.h\"</code></li> </ul>"},{"location":"apiStm/tasks_8c/#classes","title":"Classes","text":"Type Name struct tskTaskControlBlock"},{"location":"apiStm/tasks_8c/#public-types","title":"Public Types","text":"Type Name typedef tskTCB TCB_t typedef struct tskTaskControlBlock tskTCB"},{"location":"apiStm/tasks_8c/#public-attributes","title":"Public Attributes","text":"Type Name PRIVILEGED_DATA TCB_t *volatile pxCurrentTCB   = = NULL"},{"location":"apiStm/tasks_8c/#public-static-attributes","title":"Public Static Attributes","text":"Type Name PRIVILEGED_DATA List_t *volatile pxDelayedTaskList PRIVILEGED_DATA List_t *volatile pxOverflowDelayedTaskList PRIVILEGED_DATA List_t pxReadyTasksLists PRIVILEGED_DATA volatile UBaseType_t uxCurrentNumberOfTasks   = = ( UBaseType_t ) 0U PRIVILEGED_DATA volatile UBaseType_t uxSchedulerSuspended   = = ( UBaseType_t ) pdFALSE PRIVILEGED_DATA UBaseType_t uxTaskNumber   = = ( UBaseType_t ) 0U PRIVILEGED_DATA volatile UBaseType_t uxTopReadyPriority   = = tskIDLE_PRIORITY PRIVILEGED_DATA List_t xDelayedTaskList1 PRIVILEGED_DATA List_t xDelayedTaskList2 PRIVILEGED_DATA TaskHandle_t xIdleTaskHandle   = = NULL PRIVILEGED_DATA volatile TickType_t xNextTaskUnblockTime   = = ( TickType_t ) 0U PRIVILEGED_DATA volatile BaseType_t xNumOfOverflows   = = ( BaseType_t ) 0 PRIVILEGED_DATA volatile TickType_t xPendedTicks   = = ( TickType_t ) 0U PRIVILEGED_DATA List_t xPendingReadyList PRIVILEGED_DATA volatile BaseType_t xSchedulerRunning   = = pdFALSE PRIVILEGED_DATA volatile TickType_t xTickCount   = = ( TickType_t ) configINITIAL_TICK_COUNT PRIVILEGED_DATA volatile BaseType_t xYieldPending   = = pdFALSE"},{"location":"apiStm/tasks_8c/#public-functions","title":"Public Functions","text":"Type Name char * pcTaskGetName (TaskHandle_t xTaskToQuery)  UBaseType_t uxTaskGetNumberOfTasks (void)  TickType_t uxTaskResetEventItemValue (void)  void vTaskEndScheduler (void)  void vTaskInternalSetTimeOutState (TimeOut_t *const pxTimeOut)  void vTaskMissedYield (void)  void vTaskPlaceOnEventList (List_t *const pxEventList, const TickType_t xTicksToWait)  void vTaskPlaceOnUnorderedEventList (List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait)  void vTaskRemoveFromUnorderedEventList (ListItem_t * pxEventListItem, const TickType_t xItemValue)  void vTaskSetTimeOutState (TimeOut_t *const pxTimeOut)  void vTaskStartScheduler (void)  void vTaskSuspendAll (void)  void vTaskSwitchContext (void)  BaseType_t xTaskCatchUpTicks (TickType_t xTicksToCatchUp)  BaseType_t xTaskCheckForTimeOut (TimeOut_t *const pxTimeOut, TickType_t *const pxTicksToWait)  TickType_t xTaskGetTickCount (void)  TickType_t xTaskGetTickCountFromISR (void)  BaseType_t xTaskIncrementTick (void)  BaseType_t xTaskRemoveFromEventList (const List_t *const pxEventList)  BaseType_t xTaskResumeAll (void)"},{"location":"apiStm/tasks_8c/#public-static-functions","title":"Public Static Functions","text":"Type Name static portTASK_FUNCTION (prvIdleTask, pvParameters)  void prvAddCurrentTaskToDelayedList (TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely)  void prvAddNewTaskToReadyList (TCB_t * pxNewTCB)  void prvCheckTasksWaitingTermination (void)  void prvInitialiseTaskLists (static void prvCheckTasksWaitingTermination void void)  void prvInitialiseTaskLists (void)  void prvResetNextTaskUnblockTime (void)"},{"location":"apiStm/tasks_8c/#macros","title":"Macros","text":"Type Name define MPU_WRAPPERS_INCLUDED_FROM_API_FILE define configIDLE_TASK_NAME  \"IDLE\" define portRESET_READY_PRIORITY (uxPriority, uxTopReadyPriority)  define prvAddTaskToReadyList (pxTCB)  define prvGetTCBFromHandle (pxHandle) ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) ) define taskEVENT_LIST_ITEM_VALUE_IN_USE  0x80000000UL define taskNOTIFICATION_RECEIVED  ( ( uint8_t ) 2 ) define taskNOT_WAITING_NOTIFICATION  ( ( uint8_t ) 0 ) define taskRECORD_READY_PRIORITY (uxPriority)  define taskRESET_READY_PRIORITY (uxPriority)  define taskSELECT_HIGHEST_PRIORITY_TASK ()  define taskSWITCH_DELAYED_LISTS ()  define taskWAITING_NOTIFICATION  ( ( uint8_t ) 1 ) define taskYIELD_IF_USING_PREEMPTION ()  define tskBLOCKED_CHAR  ( 'B' ) define tskDELETED_CHAR  ( 'D' ) define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB  ( ( uint8_t ) 0 ) define tskREADY_CHAR  ( 'R' ) define tskRUNNING_CHAR  ( 'X' ) define tskSET_NEW_STACKS_TO_KNOWN_VALUE  0 define tskSTACK_FILL_BYTE  ( 0xa5U ) define tskSTATICALLY_ALLOCATED_STACK_AND_TCB  ( ( uint8_t ) 2 ) define tskSTATICALLY_ALLOCATED_STACK_ONLY  ( ( uint8_t ) 1 ) define tskSUSPENDED_CHAR  ( 'S' )"},{"location":"apiStm/tasks_8c/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/tasks_8c/#typedef-tcb_t","title":"typedef TCB_t","text":"<pre><code>typedef tskTCB TCB_t;\n</code></pre>"},{"location":"apiStm/tasks_8c/#typedef-tsktcb","title":"typedef tskTCB","text":"<pre><code>typedef struct tskTaskControlBlock tskTCB;\n</code></pre>"},{"location":"apiStm/tasks_8c/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/tasks_8c/#variable-pxcurrenttcb","title":"variable pxCurrentTCB","text":"<pre><code>PRIVILEGED_DATA TCB_t* volatile pxCurrentTCB;\n</code></pre>"},{"location":"apiStm/tasks_8c/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"apiStm/tasks_8c/#variable-pxdelayedtasklist","title":"variable pxDelayedTaskList","text":"<pre><code>PRIVILEGED_DATA List_t* volatile pxDelayedTaskList;\n</code></pre>"},{"location":"apiStm/tasks_8c/#variable-pxoverflowdelayedtasklist","title":"variable pxOverflowDelayedTaskList","text":"<pre><code>PRIVILEGED_DATA List_t* volatile pxOverflowDelayedTaskList;\n</code></pre>"},{"location":"apiStm/tasks_8c/#variable-pxreadytaskslists","title":"variable pxReadyTasksLists","text":"<pre><code>PRIVILEGED_DATA List_t pxReadyTasksLists[configMAX_PRIORITIES];\n</code></pre>"},{"location":"apiStm/tasks_8c/#variable-uxcurrentnumberoftasks","title":"variable uxCurrentNumberOfTasks","text":"<pre><code>PRIVILEGED_DATA volatile UBaseType_t uxCurrentNumberOfTasks;\n</code></pre>"},{"location":"apiStm/tasks_8c/#variable-uxschedulersuspended","title":"variable uxSchedulerSuspended","text":"<pre><code>PRIVILEGED_DATA volatile UBaseType_t uxSchedulerSuspended;\n</code></pre>"},{"location":"apiStm/tasks_8c/#variable-uxtasknumber","title":"variable uxTaskNumber","text":"<pre><code>PRIVILEGED_DATA UBaseType_t uxTaskNumber;\n</code></pre>"},{"location":"apiStm/tasks_8c/#variable-uxtopreadypriority","title":"variable uxTopReadyPriority","text":"<pre><code>PRIVILEGED_DATA volatile UBaseType_t uxTopReadyPriority;\n</code></pre>"},{"location":"apiStm/tasks_8c/#variable-xdelayedtasklist1","title":"variable xDelayedTaskList1","text":"<pre><code>PRIVILEGED_DATA List_t xDelayedTaskList1;\n</code></pre>"},{"location":"apiStm/tasks_8c/#variable-xdelayedtasklist2","title":"variable xDelayedTaskList2","text":"<pre><code>PRIVILEGED_DATA List_t xDelayedTaskList2;\n</code></pre>"},{"location":"apiStm/tasks_8c/#variable-xidletaskhandle","title":"variable xIdleTaskHandle","text":"<pre><code>PRIVILEGED_DATA TaskHandle_t xIdleTaskHandle;\n</code></pre>"},{"location":"apiStm/tasks_8c/#variable-xnexttaskunblocktime","title":"variable xNextTaskUnblockTime","text":"<pre><code>PRIVILEGED_DATA volatile TickType_t xNextTaskUnblockTime;\n</code></pre>"},{"location":"apiStm/tasks_8c/#variable-xnumofoverflows","title":"variable xNumOfOverflows","text":"<pre><code>PRIVILEGED_DATA volatile BaseType_t xNumOfOverflows;\n</code></pre>"},{"location":"apiStm/tasks_8c/#variable-xpendedticks","title":"variable xPendedTicks","text":"<pre><code>PRIVILEGED_DATA volatile TickType_t xPendedTicks;\n</code></pre>"},{"location":"apiStm/tasks_8c/#variable-xpendingreadylist","title":"variable xPendingReadyList","text":"<pre><code>PRIVILEGED_DATA List_t xPendingReadyList;\n</code></pre>"},{"location":"apiStm/tasks_8c/#variable-xschedulerrunning","title":"variable xSchedulerRunning","text":"<pre><code>PRIVILEGED_DATA volatile BaseType_t xSchedulerRunning;\n</code></pre>"},{"location":"apiStm/tasks_8c/#variable-xtickcount","title":"variable xTickCount","text":"<pre><code>PRIVILEGED_DATA volatile TickType_t xTickCount;\n</code></pre>"},{"location":"apiStm/tasks_8c/#variable-xyieldpending","title":"variable xYieldPending","text":"<pre><code>PRIVILEGED_DATA volatile BaseType_t xYieldPending;\n</code></pre>"},{"location":"apiStm/tasks_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/tasks_8c/#function-pctaskgetname","title":"function pcTaskGetName","text":"<pre><code>char * pcTaskGetName (\nTaskHandle_t xTaskToQuery\n) </code></pre>"},{"location":"apiStm/tasks_8c/#function-uxtaskgetnumberoftasks","title":"function uxTaskGetNumberOfTasks","text":"<pre><code>UBaseType_t uxTaskGetNumberOfTasks (\nvoid\n) </code></pre>"},{"location":"apiStm/tasks_8c/#function-uxtaskreseteventitemvalue","title":"function uxTaskResetEventItemValue","text":"<pre><code>TickType_t uxTaskResetEventItemValue (\nvoid\n) </code></pre>"},{"location":"apiStm/tasks_8c/#function-vtaskendscheduler","title":"function vTaskEndScheduler","text":"<pre><code>void vTaskEndScheduler (\nvoid\n) </code></pre>"},{"location":"apiStm/tasks_8c/#function-vtaskinternalsettimeoutstate","title":"function vTaskInternalSetTimeOutState","text":"<pre><code>void vTaskInternalSetTimeOutState (\nTimeOut_t *const pxTimeOut\n) </code></pre>"},{"location":"apiStm/tasks_8c/#function-vtaskmissedyield","title":"function vTaskMissedYield","text":"<pre><code>void vTaskMissedYield (\nvoid\n) </code></pre>"},{"location":"apiStm/tasks_8c/#function-vtaskplaceoneventlist","title":"function vTaskPlaceOnEventList","text":"<pre><code>void vTaskPlaceOnEventList (\nList_t *const pxEventList,\nconst TickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/tasks_8c/#function-vtaskplaceonunorderedeventlist","title":"function vTaskPlaceOnUnorderedEventList","text":"<pre><code>void vTaskPlaceOnUnorderedEventList (\nList_t * pxEventList,\nconst TickType_t xItemValue,\nconst TickType_t xTicksToWait\n) </code></pre>"},{"location":"apiStm/tasks_8c/#function-vtaskremovefromunorderedeventlist","title":"function vTaskRemoveFromUnorderedEventList","text":"<pre><code>void vTaskRemoveFromUnorderedEventList (\nListItem_t * pxEventListItem,\nconst TickType_t xItemValue\n) </code></pre>"},{"location":"apiStm/tasks_8c/#function-vtasksettimeoutstate","title":"function vTaskSetTimeOutState","text":"<pre><code>void vTaskSetTimeOutState (\nTimeOut_t *const pxTimeOut\n) </code></pre>"},{"location":"apiStm/tasks_8c/#function-vtaskstartscheduler","title":"function vTaskStartScheduler","text":"<pre><code>void vTaskStartScheduler (\nvoid\n) </code></pre>"},{"location":"apiStm/tasks_8c/#function-vtasksuspendall","title":"function vTaskSuspendAll","text":"<pre><code>void vTaskSuspendAll (\nvoid\n) </code></pre>"},{"location":"apiStm/tasks_8c/#function-vtaskswitchcontext","title":"function vTaskSwitchContext","text":"<pre><code>void vTaskSwitchContext (\nvoid\n) </code></pre>"},{"location":"apiStm/tasks_8c/#function-xtaskcatchupticks","title":"function xTaskCatchUpTicks","text":"<pre><code>BaseType_t xTaskCatchUpTicks (\nTickType_t xTicksToCatchUp\n) </code></pre>"},{"location":"apiStm/tasks_8c/#function-xtaskcheckfortimeout","title":"function xTaskCheckForTimeOut","text":"<pre><code>BaseType_t xTaskCheckForTimeOut (\nTimeOut_t *const pxTimeOut,\nTickType_t *const pxTicksToWait\n) </code></pre>"},{"location":"apiStm/tasks_8c/#function-xtaskgettickcount","title":"function xTaskGetTickCount","text":"<pre><code>TickType_t xTaskGetTickCount (\nvoid\n) </code></pre>"},{"location":"apiStm/tasks_8c/#function-xtaskgettickcountfromisr","title":"function xTaskGetTickCountFromISR","text":"<pre><code>TickType_t xTaskGetTickCountFromISR (\nvoid\n) </code></pre>"},{"location":"apiStm/tasks_8c/#function-xtaskincrementtick","title":"function xTaskIncrementTick","text":"<pre><code>BaseType_t xTaskIncrementTick (\nvoid\n) </code></pre>"},{"location":"apiStm/tasks_8c/#function-xtaskremovefromeventlist","title":"function xTaskRemoveFromEventList","text":"<pre><code>BaseType_t xTaskRemoveFromEventList (\nconst List_t *const pxEventList\n) </code></pre>"},{"location":"apiStm/tasks_8c/#function-xtaskresumeall","title":"function xTaskResumeAll","text":"<pre><code>BaseType_t xTaskResumeAll (\nvoid\n) </code></pre>"},{"location":"apiStm/tasks_8c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"apiStm/tasks_8c/#function-porttask_function","title":"function portTASK_FUNCTION","text":"<pre><code>static static portTASK_FUNCTION (\nprvIdleTask,\npvParameters\n) </code></pre>"},{"location":"apiStm/tasks_8c/#function-prvaddcurrenttasktodelayedlist","title":"function prvAddCurrentTaskToDelayedList","text":"<pre><code>static void prvAddCurrentTaskToDelayedList (\nTickType_t xTicksToWait,\nconst BaseType_t xCanBlockIndefinitely\n) </code></pre>"},{"location":"apiStm/tasks_8c/#function-prvaddnewtasktoreadylist","title":"function prvAddNewTaskToReadyList","text":"<pre><code>static void prvAddNewTaskToReadyList (\nTCB_t * pxNewTCB\n) </code></pre>"},{"location":"apiStm/tasks_8c/#function-prvchecktaskswaitingtermination","title":"function prvCheckTasksWaitingTermination","text":"<pre><code>static void prvCheckTasksWaitingTermination (\nvoid\n) </code></pre>"},{"location":"apiStm/tasks_8c/#function-prvinitialisetasklists","title":"function prvInitialiseTaskLists","text":"<pre><code>static void prvInitialiseTaskLists (\nstatic void prvCheckTasksWaitingTermination void void\n) </code></pre> <p>Utility task that simply returns pdTRUE if the task referenced by xTask is currently in the Suspended state, or pdFALSE if the task referenced by xTask is in any other state. </p>"},{"location":"apiStm/tasks_8c/#function-prvinitialisetasklists_1","title":"function prvInitialiseTaskLists","text":"<pre><code>static void prvInitialiseTaskLists (\nvoid\n) </code></pre>"},{"location":"apiStm/tasks_8c/#function-prvresetnexttaskunblocktime","title":"function prvResetNextTaskUnblockTime","text":"<pre><code>static void prvResetNextTaskUnblockTime (\nvoid\n) </code></pre>"},{"location":"apiStm/tasks_8c/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/tasks_8c/#define-mpu_wrappers_included_from_api_file","title":"define MPU_WRAPPERS_INCLUDED_FROM_API_FILE","text":"<pre><code>#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE \n</code></pre>"},{"location":"apiStm/tasks_8c/#define-configidle_task_name","title":"define configIDLE_TASK_NAME","text":"<pre><code>#define configIDLE_TASK_NAME \"IDLE\"\n</code></pre>"},{"location":"apiStm/tasks_8c/#define-portreset_ready_priority","title":"define portRESET_READY_PRIORITY","text":"<pre><code>#define portRESET_READY_PRIORITY (\nuxPriority,\nuxTopReadyPriority\n) </code></pre>"},{"location":"apiStm/tasks_8c/#define-prvaddtasktoreadylist","title":"define prvAddTaskToReadyList","text":"<pre><code>#define prvAddTaskToReadyList (\npxTCB\n) traceMOVED_TASK_TO_READY_STATE( pxTCB );                                                      \\\n    taskRECORD_READY_PRIORITY( ( pxTCB )-&gt;uxPriority );                                             \\\n    vListInsertEnd( &amp;( pxReadyTasksLists[ ( pxTCB )-&gt;uxPriority ] ), &amp;( ( pxTCB )-&gt;xStateListItem ) ); \\\n    tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )\n</code></pre>"},{"location":"apiStm/tasks_8c/#define-prvgettcbfromhandle","title":"define prvGetTCBFromHandle","text":"<pre><code>#define prvGetTCBFromHandle (\npxHandle\n) ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )\n</code></pre>"},{"location":"apiStm/tasks_8c/#define-taskevent_list_item_value_in_use","title":"define taskEVENT_LIST_ITEM_VALUE_IN_USE","text":"<pre><code>#define taskEVENT_LIST_ITEM_VALUE_IN_USE 0x80000000UL\n</code></pre>"},{"location":"apiStm/tasks_8c/#define-tasknotification_received","title":"define taskNOTIFICATION_RECEIVED","text":"<pre><code>#define taskNOTIFICATION_RECEIVED ( ( uint8_t ) 2 )\n</code></pre>"},{"location":"apiStm/tasks_8c/#define-tasknot_waiting_notification","title":"define taskNOT_WAITING_NOTIFICATION","text":"<pre><code>#define taskNOT_WAITING_NOTIFICATION ( ( uint8_t ) 0 )\n</code></pre>"},{"location":"apiStm/tasks_8c/#define-taskrecord_ready_priority","title":"define taskRECORD_READY_PRIORITY","text":"<pre><code>#define taskRECORD_READY_PRIORITY (\nuxPriority\n) {                                                                                                 \\\n        if( ( uxPriority ) &gt; uxTopReadyPriority )                                                       \\\n        {                                                                                               \\\n            uxTopReadyPriority = ( uxPriority );                                                        \\\n        }                                                                                               \\\n    } /* taskRECORD_READY_PRIORITY */\n</code></pre>"},{"location":"apiStm/tasks_8c/#define-taskreset_ready_priority","title":"define taskRESET_READY_PRIORITY","text":"<pre><code>#define taskRESET_READY_PRIORITY (\nuxPriority\n) </code></pre>"},{"location":"apiStm/tasks_8c/#define-taskselect_highest_priority_task","title":"define taskSELECT_HIGHEST_PRIORITY_TASK","text":"<pre><code>#define taskSELECT_HIGHEST_PRIORITY_TASK (\n\n) {                                                                                                 \\\n    UBaseType_t uxTopPriority = uxTopReadyPriority;                                                     \\\n                                                                                                        \\\n        /* Find the highest priority queue that contains ready tasks. */                                \\\n        while( listLIST_IS_EMPTY( &amp;( pxReadyTasksLists[ uxTopPriority ] ) ) )                           \\\n        {                                                                                               \\\n            configASSERT( uxTopPriority );                                                              \\\n            --uxTopPriority;                                                                            \\\n        }                                                                                               \\\n                                                                                                        \\\n        /* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of                        \\\n        the same priority get an equal share of the processor time. */                                  \\\n        listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &amp;( pxReadyTasksLists[ uxTopPriority ] ) );           \\\n        uxTopReadyPriority = uxTopPriority;                                                             \\\n    } /* taskSELECT_HIGHEST_PRIORITY_TASK */\n</code></pre>"},{"location":"apiStm/tasks_8c/#define-taskswitch_delayed_lists","title":"define taskSWITCH_DELAYED_LISTS","text":"<pre><code>#define taskSWITCH_DELAYED_LISTS (\n\n) {                                                                                                 \\ List_t *pxTemp;                                                                                   \\\n                                                                                                    \\\n    /* The delayed tasks list should be empty when the lists are switched. */                       \\\n    configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );                                     \\\n                                                                                                    \\\n    pxTemp = pxDelayedTaskList;                                                                     \\\n    pxDelayedTaskList = pxOverflowDelayedTaskList;                                                  \\\n    pxOverflowDelayedTaskList = pxTemp;                                                             \\\n    xNumOfOverflows++;                                                                              \\\n    prvResetNextTaskUnblockTime();                                                                  \\\n}\n</code></pre>"},{"location":"apiStm/tasks_8c/#define-taskwaiting_notification","title":"define taskWAITING_NOTIFICATION","text":"<pre><code>#define taskWAITING_NOTIFICATION ( ( uint8_t ) 1 )\n</code></pre>"},{"location":"apiStm/tasks_8c/#define-taskyield_if_using_preemption","title":"define taskYIELD_IF_USING_PREEMPTION","text":"<pre><code>#define taskYIELD_IF_USING_PREEMPTION (\n\n) </code></pre>"},{"location":"apiStm/tasks_8c/#define-tskblocked_char","title":"define tskBLOCKED_CHAR","text":"<pre><code>#define tskBLOCKED_CHAR ( 'B' )\n</code></pre>"},{"location":"apiStm/tasks_8c/#define-tskdeleted_char","title":"define tskDELETED_CHAR","text":"<pre><code>#define tskDELETED_CHAR ( 'D' )\n</code></pre>"},{"location":"apiStm/tasks_8c/#define-tskdynamically_allocated_stack_and_tcb","title":"define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB","text":"<pre><code>#define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB ( ( uint8_t ) 0 )\n</code></pre>"},{"location":"apiStm/tasks_8c/#define-tskready_char","title":"define tskREADY_CHAR","text":"<pre><code>#define tskREADY_CHAR ( 'R' )\n</code></pre>"},{"location":"apiStm/tasks_8c/#define-tskrunning_char","title":"define tskRUNNING_CHAR","text":"<pre><code>#define tskRUNNING_CHAR ( 'X' )\n</code></pre>"},{"location":"apiStm/tasks_8c/#define-tskset_new_stacks_to_known_value","title":"define tskSET_NEW_STACKS_TO_KNOWN_VALUE","text":"<pre><code>#define tskSET_NEW_STACKS_TO_KNOWN_VALUE 0\n</code></pre>"},{"location":"apiStm/tasks_8c/#define-tskstack_fill_byte","title":"define tskSTACK_FILL_BYTE","text":"<pre><code>#define tskSTACK_FILL_BYTE ( 0xa5U )\n</code></pre>"},{"location":"apiStm/tasks_8c/#define-tskstatically_allocated_stack_and_tcb","title":"define tskSTATICALLY_ALLOCATED_STACK_AND_TCB","text":"<pre><code>#define tskSTATICALLY_ALLOCATED_STACK_AND_TCB ( ( uint8_t ) 2 )\n</code></pre>"},{"location":"apiStm/tasks_8c/#define-tskstatically_allocated_stack_only","title":"define tskSTATICALLY_ALLOCATED_STACK_ONLY","text":"<pre><code>#define tskSTATICALLY_ALLOCATED_STACK_ONLY ( ( uint8_t ) 1 )\n</code></pre>"},{"location":"apiStm/tasks_8c/#define-tsksuspended_char","title":"define tskSUSPENDED_CHAR","text":"<pre><code>#define tskSUSPENDED_CHAR ( 'S' )\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/src/tasks.c</code></p>"},{"location":"apiStm/tasks_8c_source/","title":"File tasks.c","text":"<p>File List &gt; FreeRTOS &gt; src &gt; tasks.c</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n/* Standard includes. */\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining\nall the API functions to use the MPU wrappers.  That should only be done when\ntask.h is included from an application file. */\n#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE\n\n/* FreeRTOS includes. */\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n#include \"timers.h\"\n#include \"stack_macros.h\"\n\n/* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified\nbecause the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined\nfor the header files above, but not in this file, in order to generate the\ncorrect privileged Vs unprivileged linkage and placement. */\n#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */\n\n/* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting\nfunctions but without including stdio.h here. */\n#if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )\n/* At the bottom of this file are two optional functions that can be used\n    to generate human readable text from the raw data generated by the\n    uxTaskGetSystemState() function.  Note the formatting functions are provided\n    for convenience only, and are NOT considered part of the kernel. */\n#include &lt;stdio.h&gt;\n#endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */\n\n#if( configUSE_PREEMPTION == 0 )\n/* If the cooperative scheduler is being used then a yield should not be\n    performed just because a higher priority task has been woken. */\n#define taskYIELD_IF_USING_PREEMPTION()\n#else\n#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()\n#endif\n\n/* Values that can be assigned to the ucNotifyState member of the TCB. */\n#define taskNOT_WAITING_NOTIFICATION    ( ( uint8_t ) 0 )\n#define taskWAITING_NOTIFICATION        ( ( uint8_t ) 1 )\n#define taskNOTIFICATION_RECEIVED       ( ( uint8_t ) 2 )\n\n/*\n * The value used to fill the stack of a task when the task is created.  This\n * is used purely for checking the high water mark for tasks.\n */\n#define tskSTACK_FILL_BYTE  ( 0xa5U )\n\n/* Bits used to recored how a task's stack and TCB were allocated. */\n#define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB      ( ( uint8_t ) 0 )\n#define tskSTATICALLY_ALLOCATED_STACK_ONLY          ( ( uint8_t ) 1 )\n#define tskSTATICALLY_ALLOCATED_STACK_AND_TCB       ( ( uint8_t ) 2 )\n\n/* If any of the following are set then task stacks are filled with a known\nvalue so the high water mark can be determined.  If none of the following are\nset then don't fill the stack so there is no unnecessary dependency on memset. */\n#if( ( configCHECK_FOR_STACK_OVERFLOW &gt; 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )\n#define tskSET_NEW_STACKS_TO_KNOWN_VALUE    1\n#else\n#define tskSET_NEW_STACKS_TO_KNOWN_VALUE    0\n#endif\n\n/*\n * Macros used by vListTask to indicate which state a task is in.\n */\n#define tskRUNNING_CHAR     ( 'X' )\n#define tskBLOCKED_CHAR     ( 'B' )\n#define tskREADY_CHAR       ( 'R' )\n#define tskDELETED_CHAR     ( 'D' )\n#define tskSUSPENDED_CHAR   ( 'S' )\n\n/*\n * Some kernel aware debuggers require the data the debugger needs access to be\n * global, rather than file scope.\n */\n#ifdef portREMOVE_STATIC_QUALIFIER\n#define static\n#endif\n\n/* The name allocated to the Idle task.  This can be overridden by defining\nconfigIDLE_TASK_NAME in FreeRTOSConfig.h. */\n#ifndef configIDLE_TASK_NAME\n#define configIDLE_TASK_NAME \"IDLE\"\n#endif\n\n#if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )\n\n/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is\n    performed in a generic way that is not optimised to any particular\n    microcontroller architecture. */\n\n/* uxTopReadyPriority holds the priority of the highest priority ready\n    state task. */\n#define taskRECORD_READY_PRIORITY( uxPriority )                                                     \\\n    {                                                                                                   \\\n        if( ( uxPriority ) &gt; uxTopReadyPriority )                                                       \\\n        {                                                                                               \\\n            uxTopReadyPriority = ( uxPriority );                                                        \\\n        }                                                                                               \\\n    } /* taskRECORD_READY_PRIORITY */\n\n/*-----------------------------------------------------------*/\n\n#define taskSELECT_HIGHEST_PRIORITY_TASK()                                                          \\\n    {                                                                                                   \\\n    UBaseType_t uxTopPriority = uxTopReadyPriority;                                                     \\\n                                                                                                        \\\n/* Find the highest priority queue that contains ready tasks. */                                \\\n        while( listLIST_IS_EMPTY( &amp;( pxReadyTasksLists[ uxTopPriority ] ) ) )                           \\\n        {                                                                                               \\\n            configASSERT( uxTopPriority );                                                              \\\n            --uxTopPriority;                                                                            \\\n        }                                                                                               \\\n                                                                                                        \\\n/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of                        \\\n        the same priority get an equal share of the processor time. */                                  \\\n        listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &amp;( pxReadyTasksLists[ uxTopPriority ] ) );           \\\n        uxTopReadyPriority = uxTopPriority;                                                             \\\n    } /* taskSELECT_HIGHEST_PRIORITY_TASK */\n\n/*-----------------------------------------------------------*/\n\n/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as\n    they are only required when a port optimised method of task selection is\n    being used. */\n#define taskRESET_READY_PRIORITY( uxPriority )\n#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )\n\n#else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */\n\n/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is\n    performed in a way that is tailored to the particular microcontroller\n    architecture being used. */\n\n/* A port optimised version is provided.  Call the port defined macros. */\n#define taskRECORD_READY_PRIORITY( uxPriority ) portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )\n\n/*-----------------------------------------------------------*/\n\n#define taskSELECT_HIGHEST_PRIORITY_TASK()                                                      \\\n    {                                                                                               \\\n    UBaseType_t uxTopPriority;                                                                      \\\n                                                                                                    \\\n/* Find the highest priority list that contains ready tasks. */                             \\\n        portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );                              \\\n        configASSERT( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ uxTopPriority ] ) ) &gt; 0 );     \\\n        listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &amp;( pxReadyTasksLists[ uxTopPriority ] ) );       \\\n    } /* taskSELECT_HIGHEST_PRIORITY_TASK() */\n\n/*-----------------------------------------------------------*/\n\n/* A port optimised version is provided, call it only if the TCB being reset\n    is being referenced from a ready list.  If it is referenced from a delayed\n    or suspended list then it won't be in a ready list. */\n#define taskRESET_READY_PRIORITY( uxPriority )                                                      \\\n    {                                                                                                   \\\n        if( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )  \\\n        {                                                                                               \\\n            portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );                         \\\n        }                                                                                               \\\n    }\n\n#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */\n\n/*-----------------------------------------------------------*/\n\n/* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick\ncount overflows. */\n#define taskSWITCH_DELAYED_LISTS()                                                                  \\\n{                                                                                                   \\\n    List_t *pxTemp;                                                                                 \\\n                                                                                                    \\\n/* The delayed tasks list should be empty when the lists are switched. */                       \\\n    configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );                                     \\\n                                                                                                    \\\n    pxTemp = pxDelayedTaskList;                                                                     \\\n    pxDelayedTaskList = pxOverflowDelayedTaskList;                                                  \\\n    pxOverflowDelayedTaskList = pxTemp;                                                             \\\n    xNumOfOverflows++;                                                                              \\\n    prvResetNextTaskUnblockTime();                                                                  \\\n}\n\n/*-----------------------------------------------------------*/\n\n/*\n * Place the task represented by pxTCB into the appropriate ready list for\n * the task.  It is inserted at the end of the list.\n */\n#define prvAddTaskToReadyList( pxTCB )                                                              \\\n    traceMOVED_TASK_TO_READY_STATE( pxTCB );                                                        \\\n    taskRECORD_READY_PRIORITY( ( pxTCB )-&gt;uxPriority );                                             \\\n    vListInsertEnd( &amp;( pxReadyTasksLists[ ( pxTCB )-&gt;uxPriority ] ), &amp;( ( pxTCB )-&gt;xStateListItem ) ); \\\n    tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )\n/*-----------------------------------------------------------*/\n\n/*\n * Several functions take an TaskHandle_t parameter that can optionally be NULL,\n * where NULL is used to indicate that the handle of the currently executing\n * task should be used in place of the parameter.  This macro simply checks to\n * see if the parameter is NULL and returns a pointer to the appropriate TCB.\n */\n#define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )\n\n/* The item value of the event list item is normally used to hold the priority\nof the task to which it belongs (coded to allow it to be held in reverse\npriority order).  However, it is occasionally borrowed for other purposes.  It\nis important its value is not updated due to a task priority change while it is\nbeing used for another purpose.  The following bit definition is used to inform\nthe scheduler that the value should not be changed - in which case it is the\nresponsibility of whichever module is using the value to ensure it gets set back\nto its original value when it is released. */\n#if( configUSE_16_BIT_TICKS == 1 )\n#define taskEVENT_LIST_ITEM_VALUE_IN_USE    0x8000U\n#else\n#define taskEVENT_LIST_ITEM_VALUE_IN_USE    0x80000000UL\n#endif\n\n/*\n * Task control block.  A task control block (TCB) is allocated for each task,\n * and stores task state information, including a pointer to the task's context\n * (the task's run time environment, including register values)\n */\ntypedef struct tskTaskControlBlock          /* The old naming convention is used to prevent breaking kernel aware debuggers. */\n{\nvolatile StackType_t    *pxTopOfStack;  /*&lt; Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */\n\n#if ( portUSING_MPU_WRAPPERS == 1 )\nxMPU_SETTINGS   xMPUSettings;       /*&lt; The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */\n#endif\n\nListItem_t          xStateListItem; /*&lt; The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */\nListItem_t          xEventListItem;     /*&lt; Used to reference a task from an event list. */\nUBaseType_t         uxPriority;         /*&lt; The priority of the task.  0 is the lowest priority. */\nStackType_t         *pxStack;           /*&lt; Points to the start of the stack. */\nchar                pcTaskName[ configMAX_TASK_NAME_LEN ];/*&lt; Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\n#if ( ( portSTACK_GROWTH &gt; 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )\nStackType_t     *pxEndOfStack;      /*&lt; Points to the highest valid address for the stack. */\n#endif\n\n#if ( portCRITICAL_NESTING_IN_TCB == 1 )\nUBaseType_t     uxCriticalNesting;  /*&lt; Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */\n#endif\n\n#if ( configUSE_TRACE_FACILITY == 1 )\nUBaseType_t     uxTCBNumber;        /*&lt; Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */\nUBaseType_t     uxTaskNumber;       /*&lt; Stores a number specifically for use by third party trace code. */\n#endif\n\n#if ( configUSE_MUTEXES == 1 )\nUBaseType_t     uxBasePriority;     /*&lt; The priority last assigned to the task - used by the priority inheritance mechanism. */\nUBaseType_t     uxMutexesHeld;\n#endif\n\n#if ( configUSE_APPLICATION_TASK_TAG == 1 )\nTaskHookFunction_t pxTaskTag;\n#endif\n\n#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 )\nvoid            *pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];\n#endif\n\n#if( configGENERATE_RUN_TIME_STATS == 1 )\nuint32_t        ulRunTimeCounter;   /*&lt; Stores the amount of time the task has spent in the Running state. */\n#endif\n\n#if ( configUSE_NEWLIB_REENTRANT == 1 )\n/* Allocate a Newlib reent structure that is specific to this task.\n        Note Newlib support has been included by popular demand, but is not\n        used by the FreeRTOS maintainers themselves.  FreeRTOS is not\n        responsible for resulting newlib operation.  User must be familiar with\n        newlib and must provide system-wide implementations of the necessary\n        stubs. Be warned that (at the time of writing) the current newlib design\n        implements a system-wide malloc() that must be provided with locks.\n\n        See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html\n        for additional information. */\nstruct  _reent xNewLib_reent;\n#endif\n\n#if( configUSE_TASK_NOTIFICATIONS == 1 )\nvolatile uint32_t ulNotifiedValue;\nvolatile uint8_t ucNotifyState;\n#endif\n\n/* See the comments in FreeRTOS.h with the definition of\n    tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */\n#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */\nuint8_t ucStaticallyAllocated;      /*&lt; Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */\n#endif\n\n#if( INCLUDE_xTaskAbortDelay == 1 )\nuint8_t ucDelayAborted;\n#endif\n\n#if( configUSE_POSIX_ERRNO == 1 )\nint iTaskErrno;\n#endif\n\n} tskTCB;\n\n/* The old tskTCB name is maintained above then typedefed to the new TCB_t name\nbelow to enable the use of older kernel aware debuggers. */\ntypedef tskTCB TCB_t;\n\n/*lint -save -e956 A manual analysis and inspection has been used to determine\nwhich static variables must be declared volatile. */\nPRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;\n\n/* Lists for ready and blocked tasks. --------------------\nxDelayedTaskList1 and xDelayedTaskList2 could be move to function scople but\ndoing so breaks some kernel aware debuggers and debuggers that rely on removing\nthe static qualifier. */\nPRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*&lt; Prioritised ready tasks. */\nPRIVILEGED_DATA static List_t xDelayedTaskList1;                        /*&lt; Delayed tasks. */\nPRIVILEGED_DATA static List_t xDelayedTaskList2;                        /*&lt; Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */\nPRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;             /*&lt; Points to the delayed task list currently being used. */\nPRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;     /*&lt; Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */\nPRIVILEGED_DATA static List_t xPendingReadyList;                        /*&lt; Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */\n\n#if( INCLUDE_vTaskDelete == 1 )\n\nPRIVILEGED_DATA static List_t xTasksWaitingTermination;             /*&lt; Tasks that have been deleted - but their memory not yet freed. */\nPRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;\n\n#endif\n\n#if ( INCLUDE_vTaskSuspend == 1 )\n\nPRIVILEGED_DATA static List_t xSuspendedTaskList;                   /*&lt; Tasks that are currently suspended. */\n\n#endif\n\n/* Global POSIX errno. Its value is changed upon context switching to match\nthe errno of the currently running task. */\n#if ( configUSE_POSIX_ERRNO == 1 )\nint FreeRTOS_errno = 0;\n#endif\n\n/* Other file private variables. --------------------------------*/\nPRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks  = ( UBaseType_t ) 0U;\nPRIVILEGED_DATA static volatile TickType_t xTickCount               = ( TickType_t ) configINITIAL_TICK_COUNT;\nPRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority      = tskIDLE_PRIORITY;\nPRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning        = pdFALSE;\nPRIVILEGED_DATA static volatile TickType_t xPendedTicks             = ( TickType_t ) 0U;\nPRIVILEGED_DATA static volatile BaseType_t xYieldPending            = pdFALSE;\nPRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows          = ( BaseType_t ) 0;\nPRIVILEGED_DATA static UBaseType_t uxTaskNumber                     = ( UBaseType_t ) 0U;\nPRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime     = ( TickType_t ) 0U; /* Initialised to portMAX_DELAY before the scheduler starts. */\nPRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle                 = NULL;         /*&lt; Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */\n\n/* Context switches are held pending while the scheduler is suspended.  Also,\ninterrupts must not manipulate the xStateListItem of a TCB, or any of the\nlists the xStateListItem can be referenced from, if the scheduler is suspended.\nIf an interrupt needs to unblock a task while the scheduler is suspended then it\nmoves the task's event list item into the xPendingReadyList, ready for the\nkernel to move the task from the pending ready list into the real ready list\nwhen the scheduler is unsuspended.  The pending ready list itself can only be\naccessed from a critical section. */\nPRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended    = ( UBaseType_t ) pdFALSE;\n\n#if ( configGENERATE_RUN_TIME_STATS == 1 )\n\n/* Do not move these variables to function scope as doing so prevents the\n    code working with debuggers that need to remove the static qualifier. */\nPRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL; /*&lt; Holds the value of a timer/counter the last time a task was switched in. */\nPRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;       /*&lt; Holds the total amount of execution time as defined by the run time counter clock. */\n\n#endif\n\n/*lint -restore */\n\n/*-----------------------------------------------------------*/\n\n/* Callback function prototypes. --------------------------*/\n#if(  configCHECK_FOR_STACK_OVERFLOW &gt; 0 )\n\nextern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );\n\n#endif\n\n#if( configUSE_TICK_HOOK &gt; 0 )\n\nextern void vApplicationTickHook( void ); /*lint !e526 Symbol not defined as it is an application callback. */\n\n#endif\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n\nextern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize ); /*lint !e526 Symbol not defined as it is an application callback. */\n\n#endif\n\n/* File private functions. --------------------------------*/\n\n#if ( INCLUDE_vTaskSuspend == 1 )\n\nstatic BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n#endif /* INCLUDE_vTaskSuspend */\n\n/*\n * Utility to ready all the lists used by the scheduler.  This is called\n * automatically upon the creation of the first task.\n */\nstatic void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;\n\n/*\n * The idle task, which as all tasks is implemented as a never ending loop.\n * The idle task is automatically created and added to the ready lists upon\n * creation of the first user task.\n *\n * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific\n * language extensions.  The equivalent prototype for this function is:\n *\n * void prvIdleTask( void *pvParameters );\n *\n */\nstatic portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );\n\n/*\n * Utility to free all memory allocated by the scheduler to hold a TCB,\n * including the stack pointed to by the TCB.\n *\n * This does not free memory allocated by the task itself (i.e. memory\n * allocated by calls to pvPortMalloc from within the tasks application code).\n */\n#if ( INCLUDE_vTaskDelete == 1 )\n\nstatic void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;\n\n#endif\n\n/*\n * Used only by the idle task.  This checks to see if anything has been placed\n * in the list of tasks waiting to be deleted.  If so the task is cleaned up\n * and its TCB deleted.\n */\nstatic void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;\n\n/*\n * The currently executing task is entering the Blocked state.  Add the task to\n * either the current or the overflow delayed task list.\n */\nstatic void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely ) PRIVILEGED_FUNCTION;\n\n/*\n * Fills an TaskStatus_t structure with information on each task that is\n * referenced from the pxList list (which may be a ready list, a delayed list,\n * a suspended list, etc.).\n *\n * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM\n * NORMAL APPLICATION CODE.\n */\n#if ( configUSE_TRACE_FACILITY == 1 )\n\nstatic UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState ) PRIVILEGED_FUNCTION;\n\n#endif\n\n/*\n * Searches pxList for a task with name pcNameToQuery - returning a handle to\n * the task if it is found, or NULL if the task is not found.\n */\n#if ( INCLUDE_xTaskGetHandle == 1 )\n\nstatic TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVILEGED_FUNCTION;\n\n#endif\n\n/*\n * When a task is created, the stack of the task is filled with a known value.\n * This function determines the 'high water mark' of the task stack by\n * determining how much of the stack remains at the original preset value.\n */\n#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )\n\nstatic configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;\n\n#endif\n\n/*\n * Return the amount of time, in ticks, that will pass before the kernel will\n * next move a task from the Blocked state to the Running state.\n *\n * This conditional compilation should use inequality to 0, not equality to 1.\n * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user\n * defined low power mode implementations require configUSE_TICKLESS_IDLE to be\n * set to a value other than 1.\n */\n#if ( configUSE_TICKLESS_IDLE != 0 )\n\nstatic TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;\n\n#endif\n\n/*\n * Set xNextTaskUnblockTime to the time at which the next Blocked state task\n * will exit the Blocked state.\n */\nstatic void prvResetNextTaskUnblockTime( void );\n\n#if ( ( configUSE_TRACE_FACILITY == 1 ) &amp;&amp; ( configUSE_STATS_FORMATTING_FUNCTIONS &gt; 0 ) )\n\n/*\n     * Helper function used to pad task names with spaces when printing out\n     * human readable tables of task information.\n     */\nstatic char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;\n\n#endif\n\n/*\n * Called after a Task_t structure has been allocated either statically or\n * dynamically to fill in the structure's members.\n */\nstatic void prvInitialiseNewTask(   TaskFunction_t pxTaskCode,\nconst char * const pcName,      /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\nconst uint32_t ulStackDepth,\nvoid * const pvParameters,\nUBaseType_t uxPriority,\nTaskHandle_t * const pxCreatedTask,\nTCB_t *pxNewTCB,\nconst MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;\n\n/*\n * Called after a new task has been created and initialised to place the task\n * under the control of the scheduler.\n */\nstatic void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;\n\n/*\n * freertos_tasks_c_additions_init() should only be called if the user definable\n * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro\n * called by the function.\n */\n#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT\n\nstatic void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;\n\n#endif\n\n/*-----------------------------------------------------------*/\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n\nTaskHandle_t xTaskCreateStatic( TaskFunction_t pxTaskCode,\nconst char * const pcName,      /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\nconst uint32_t ulStackDepth,\nvoid * const pvParameters,\nUBaseType_t uxPriority,\nStackType_t * const puxStackBuffer,\nStaticTask_t * const pxTaskBuffer )\n{\nTCB_t *pxNewTCB;\nTaskHandle_t xReturn;\n\nconfigASSERT( puxStackBuffer != NULL );\nconfigASSERT( pxTaskBuffer != NULL );\n\n#if( configASSERT_DEFINED == 1 )\n{\n/* Sanity check that the size of the structure used to declare a\n            variable of type StaticTask_t equals the size of the real task\n            structure. */\nvolatile size_t xSize = sizeof( StaticTask_t );\nconfigASSERT( xSize == sizeof( TCB_t ) );\n( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */\n}\n#endif /* configASSERT_DEFINED */\n\n\nif( ( pxTaskBuffer != NULL ) &amp;&amp; ( puxStackBuffer != NULL ) )\n{\n/* The memory used for the task's TCB and stack are passed into this\n            function - use them. */\npxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */\npxNewTCB-&gt;pxStack = ( StackType_t * ) puxStackBuffer;\n\n#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */\n{\n/* Tasks can be created statically or dynamically, so note this\n                task was created statically in case the task is later deleted. */\npxNewTCB-&gt;ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;\n}\n#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */\n\nprvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &amp;xReturn, pxNewTCB, NULL );\nprvAddNewTaskToReadyList( pxNewTCB );\n}\nelse\n{\nxReturn = NULL;\n}\n\nreturn xReturn;\n}\n\n#endif /* SUPPORT_STATIC_ALLOCATION */\n/*-----------------------------------------------------------*/\n\n#if( ( portUSING_MPU_WRAPPERS == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) )\n\nBaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask )\n{\nTCB_t *pxNewTCB;\nBaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;\n\nconfigASSERT( pxTaskDefinition-&gt;puxStackBuffer != NULL );\nconfigASSERT( pxTaskDefinition-&gt;pxTaskBuffer != NULL );\n\nif( ( pxTaskDefinition-&gt;puxStackBuffer != NULL ) &amp;&amp; ( pxTaskDefinition-&gt;pxTaskBuffer != NULL ) )\n{\n/* Allocate space for the TCB.  Where the memory comes from depends\n            on the implementation of the port malloc function and whether or\n            not static allocation is being used. */\npxNewTCB = ( TCB_t * ) pxTaskDefinition-&gt;pxTaskBuffer;\n\n/* Store the stack location in the TCB. */\npxNewTCB-&gt;pxStack = pxTaskDefinition-&gt;puxStackBuffer;\n\n#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )\n{\n/* Tasks can be created statically or dynamically, so note this\n                task was created statically in case the task is later deleted. */\npxNewTCB-&gt;ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;\n}\n#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */\n\nprvInitialiseNewTask(   pxTaskDefinition-&gt;pvTaskCode,\npxTaskDefinition-&gt;pcName,\n( uint32_t ) pxTaskDefinition-&gt;usStackDepth,\npxTaskDefinition-&gt;pvParameters,\npxTaskDefinition-&gt;uxPriority,\npxCreatedTask, pxNewTCB,\npxTaskDefinition-&gt;xRegions );\n\nprvAddNewTaskToReadyList( pxNewTCB );\nxReturn = pdPASS;\n}\n\nreturn xReturn;\n}\n\n#endif /* ( portUSING_MPU_WRAPPERS == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) */\n/*-----------------------------------------------------------*/\n\n#if( ( portUSING_MPU_WRAPPERS == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )\n\nBaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask )\n{\nTCB_t *pxNewTCB;\nBaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;\n\nconfigASSERT( pxTaskDefinition-&gt;puxStackBuffer );\n\nif( pxTaskDefinition-&gt;puxStackBuffer != NULL )\n{\n/* Allocate space for the TCB.  Where the memory comes from depends\n            on the implementation of the port malloc function and whether or\n            not static allocation is being used. */\npxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );\n\nif( pxNewTCB != NULL )\n{\n/* Store the stack location in the TCB. */\npxNewTCB-&gt;pxStack = pxTaskDefinition-&gt;puxStackBuffer;\n\n#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )\n{\n/* Tasks can be created statically or dynamically, so note\n                    this task had a statically allocated stack in case it is\n                    later deleted.  The TCB was allocated dynamically. */\npxNewTCB-&gt;ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;\n}\n#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */\n\nprvInitialiseNewTask(   pxTaskDefinition-&gt;pvTaskCode,\npxTaskDefinition-&gt;pcName,\n( uint32_t ) pxTaskDefinition-&gt;usStackDepth,\npxTaskDefinition-&gt;pvParameters,\npxTaskDefinition-&gt;uxPriority,\npxCreatedTask, pxNewTCB,\npxTaskDefinition-&gt;xRegions );\n\nprvAddNewTaskToReadyList( pxNewTCB );\nxReturn = pdPASS;\n}\n}\n\nreturn xReturn;\n}\n\n#endif /* portUSING_MPU_WRAPPERS */\n/*-----------------------------------------------------------*/\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n\nBaseType_t xTaskCreate( TaskFunction_t pxTaskCode,\nconst char * const pcName,      /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\nconst configSTACK_DEPTH_TYPE usStackDepth,\nvoid * const pvParameters,\nUBaseType_t uxPriority,\nTaskHandle_t * const pxCreatedTask )\n{\nTCB_t *pxNewTCB;\nBaseType_t xReturn;\n\n/* If the stack grows down then allocate the stack then the TCB so the stack\n        does not grow into the TCB.  Likewise if the stack grows up then allocate\n        the TCB then the stack. */\n#if( portSTACK_GROWTH &gt; 0 )\n{\n/* Allocate space for the TCB.  Where the memory comes from depends on\n            the implementation of the port malloc function and whether or not static\n            allocation is being used. */\npxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );\n\nif( pxNewTCB != NULL )\n{\n/* Allocate space for the stack used by the task being created.\n                The base of the stack memory stored in the TCB so the task can\n                be deleted later if required. */\npxNewTCB-&gt;pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\n\nif( pxNewTCB-&gt;pxStack == NULL )\n{\n/* Could not allocate the stack.  Delete the allocated TCB. */\nvPortFree( pxNewTCB );\npxNewTCB = NULL;\n}\n}\n}\n#else /* portSTACK_GROWTH */\n{\nStackType_t *pxStack;\n\n/* Allocate space for the stack used by the task being created. */\npxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */\n\nif( pxStack != NULL )\n{\n/* Allocate space for the TCB. */\npxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */\n\nif( pxNewTCB != NULL )\n{\n/* Store the stack location in the TCB. */\npxNewTCB-&gt;pxStack = pxStack;\n}\nelse\n{\n/* The stack cannot be used as the TCB was not created.  Free\n                    it again. */\nvPortFree( pxStack );\n}\n}\nelse\n{\npxNewTCB = NULL;\n}\n}\n#endif /* portSTACK_GROWTH */\n\nif( pxNewTCB != NULL )\n{\n#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consolidated for readability reasons. */\n{\n/* Tasks can be created statically or dynamically, so note this\n                task was created dynamically in case it is later deleted. */\npxNewTCB-&gt;ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;\n}\n#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */\n\nprvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );\nprvAddNewTaskToReadyList( pxNewTCB );\nxReturn = pdPASS;\n}\nelse\n{\nxReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;\n}\n\nreturn xReturn;\n}\n\n#endif /* configSUPPORT_DYNAMIC_ALLOCATION */\n/*-----------------------------------------------------------*/\n\nstatic void prvInitialiseNewTask(   TaskFunction_t pxTaskCode,\nconst char * const pcName,      /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\nconst uint32_t ulStackDepth,\nvoid * const pvParameters,\nUBaseType_t uxPriority,\nTaskHandle_t * const pxCreatedTask,\nTCB_t *pxNewTCB,\nconst MemoryRegion_t * const xRegions )\n{\nStackType_t *pxTopOfStack;\nUBaseType_t x;\n\n#if( portUSING_MPU_WRAPPERS == 1 )\n/* Should the task be created in privileged mode? */\nBaseType_t xRunPrivileged;\nif( ( uxPriority &amp; portPRIVILEGE_BIT ) != 0U )\n{\nxRunPrivileged = pdTRUE;\n}\nelse\n{\nxRunPrivileged = pdFALSE;\n}\nuxPriority &amp;= ~portPRIVILEGE_BIT;\n#endif /* portUSING_MPU_WRAPPERS == 1 */\n\n/* Avoid dependency on memset() if it is not required. */\n#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )\n{\n/* Fill the stack with a known value to assist debugging. */\n( void ) memset( pxNewTCB-&gt;pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );\n}\n#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */\n\n/* Calculate the top of stack address.  This depends on whether the stack\n    grows from high memory to low (as per the 80x86) or vice versa.\n    portSTACK_GROWTH is used to make the result positive or negative as required\n    by the port. */\n#if( portSTACK_GROWTH &lt; 0 )\n{\npxTopOfStack = &amp;( pxNewTCB-&gt;pxStack[ ulStackDepth - ( uint32_t ) 1 ] );\npxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */\n\n/* Check the alignment of the calculated top of stack is correct. */\nconfigASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack &amp; ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );\n\n#if( configRECORD_STACK_HIGH_ADDRESS == 1 )\n{\n/* Also record the stack's high address, which may assist\n            debugging. */\npxNewTCB-&gt;pxEndOfStack = pxTopOfStack;\n}\n#endif /* configRECORD_STACK_HIGH_ADDRESS */\n}\n#else /* portSTACK_GROWTH */\n{\npxTopOfStack = pxNewTCB-&gt;pxStack;\n\n/* Check the alignment of the stack buffer is correct. */\nconfigASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB-&gt;pxStack &amp; ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );\n\n/* The other extreme of the stack space is required if stack checking is\n        performed. */\npxNewTCB-&gt;pxEndOfStack = pxNewTCB-&gt;pxStack + ( ulStackDepth - ( uint32_t ) 1 );\n}\n#endif /* portSTACK_GROWTH */\n\n/* Store the task name in the TCB. */\nif( pcName != NULL )\n{\nfor( x = ( UBaseType_t ) 0; x &lt; ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )\n{\npxNewTCB-&gt;pcTaskName[ x ] = pcName[ x ];\n\n/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than\n            configMAX_TASK_NAME_LEN characters just in case the memory after the\n            string is not accessible (extremely unlikely). */\nif( pcName[ x ] == ( char ) 0x00 )\n{\nbreak;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n\n/* Ensure the name string is terminated in the case that the string length\n        was greater or equal to configMAX_TASK_NAME_LEN. */\npxNewTCB-&gt;pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\\0';\n}\nelse\n{\n/* The task has not been given a name, so just ensure there is a NULL\n        terminator when it is read out. */\npxNewTCB-&gt;pcTaskName[ 0 ] = 0x00;\n}\n\n/* This is used as an array index so must ensure it's not too large.  First\n    remove the privilege bit if one is present. */\nif( uxPriority &gt;= ( UBaseType_t ) configMAX_PRIORITIES )\n{\nuxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\npxNewTCB-&gt;uxPriority = uxPriority;\n#if ( configUSE_MUTEXES == 1 )\n{\npxNewTCB-&gt;uxBasePriority = uxPriority;\npxNewTCB-&gt;uxMutexesHeld = 0;\n}\n#endif /* configUSE_MUTEXES */\n\nvListInitialiseItem( &amp;( pxNewTCB-&gt;xStateListItem ) );\nvListInitialiseItem( &amp;( pxNewTCB-&gt;xEventListItem ) );\n\n/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get\n    back to the containing TCB from a generic item in a list. */\nlistSET_LIST_ITEM_OWNER( &amp;( pxNewTCB-&gt;xStateListItem ), pxNewTCB );\n\n/* Event lists are always in priority order. */\nlistSET_LIST_ITEM_VALUE( &amp;( pxNewTCB-&gt;xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\nlistSET_LIST_ITEM_OWNER( &amp;( pxNewTCB-&gt;xEventListItem ), pxNewTCB );\n\n#if ( portCRITICAL_NESTING_IN_TCB == 1 )\n{\npxNewTCB-&gt;uxCriticalNesting = ( UBaseType_t ) 0U;\n}\n#endif /* portCRITICAL_NESTING_IN_TCB */\n\n#if ( configUSE_APPLICATION_TASK_TAG == 1 )\n{\npxNewTCB-&gt;pxTaskTag = NULL;\n}\n#endif /* configUSE_APPLICATION_TASK_TAG */\n\n#if ( configGENERATE_RUN_TIME_STATS == 1 )\n{\npxNewTCB-&gt;ulRunTimeCounter = 0UL;\n}\n#endif /* configGENERATE_RUN_TIME_STATS */\n\n#if ( portUSING_MPU_WRAPPERS == 1 )\n{\nvPortStoreTaskMPUSettings( &amp;( pxNewTCB-&gt;xMPUSettings ), xRegions, pxNewTCB-&gt;pxStack, ulStackDepth );\n}\n#else\n{\n/* Avoid compiler warning about unreferenced parameter. */\n( void ) xRegions;\n}\n#endif\n\n#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )\n{\nfor( x = 0; x &lt; ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )\n{\npxNewTCB-&gt;pvThreadLocalStoragePointers[ x ] = NULL;\n}\n}\n#endif\n\n#if ( configUSE_TASK_NOTIFICATIONS == 1 )\n{\npxNewTCB-&gt;ulNotifiedValue = 0;\npxNewTCB-&gt;ucNotifyState = taskNOT_WAITING_NOTIFICATION;\n}\n#endif\n\n#if ( configUSE_NEWLIB_REENTRANT == 1 )\n{\n/* Initialise this task's Newlib reent structure.\n        See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html\n        for additional information. */\n_REENT_INIT_PTR( ( &amp;( pxNewTCB-&gt;xNewLib_reent ) ) );\n}\n#endif\n\n#if( INCLUDE_xTaskAbortDelay == 1 )\n{\npxNewTCB-&gt;ucDelayAborted = pdFALSE;\n}\n#endif\n\n/* Initialize the TCB stack to look as if the task was already running,\n    but had been interrupted by the scheduler.  The return address is set\n    to the start of the task function. Once the stack has been initialised\n    the top of stack variable is updated. */\n#if( portUSING_MPU_WRAPPERS == 1 )\n{\n/* If the port has capability to detect stack overflow,\n        pass the stack end address to the stack initialization\n        function as well. */\n#if( portHAS_STACK_OVERFLOW_CHECKING == 1 )\n{\n#if( portSTACK_GROWTH &lt; 0 )\n{\npxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB-&gt;pxStack, pxTaskCode, pvParameters, xRunPrivileged );\n}\n#else /* portSTACK_GROWTH */\n{\npxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB-&gt;pxEndOfStack, pxTaskCode, pvParameters, xRunPrivileged );\n}\n#endif /* portSTACK_GROWTH */\n}\n#else /* portHAS_STACK_OVERFLOW_CHECKING */\n{\npxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );\n}\n#endif /* portHAS_STACK_OVERFLOW_CHECKING */\n}\n#else /* portUSING_MPU_WRAPPERS */\n{\n/* If the port has capability to detect stack overflow,\n        pass the stack end address to the stack initialization\n        function as well. */\n#if( portHAS_STACK_OVERFLOW_CHECKING == 1 )\n{\n#if( portSTACK_GROWTH &lt; 0 )\n{\npxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB-&gt;pxStack, pxTaskCode, pvParameters );\n}\n#else /* portSTACK_GROWTH */\n{\npxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB-&gt;pxEndOfStack, pxTaskCode, pvParameters );\n}\n#endif /* portSTACK_GROWTH */\n}\n#else /* portHAS_STACK_OVERFLOW_CHECKING */\n{\npxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );\n}\n#endif /* portHAS_STACK_OVERFLOW_CHECKING */\n}\n#endif /* portUSING_MPU_WRAPPERS */\n\nif( pxCreatedTask != NULL )\n{\n/* Pass the handle out in an anonymous way.  The handle can be used to\n        change the created task's priority, delete the created task, etc.*/\n*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n/*-----------------------------------------------------------*/\n\nstatic void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )\n{\n/* Ensure interrupts don't access the task lists while the lists are being\n    updated. */\ntaskENTER_CRITICAL();\n{\nuxCurrentNumberOfTasks++;\nif( pxCurrentTCB == NULL )\n{\n/* There are no other tasks, or all the other tasks are in\n            the suspended state - make this the current task. */\npxCurrentTCB = pxNewTCB;\n\nif( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )\n{\n/* This is the first task to be created so do the preliminary\n                initialisation required.  We will not recover if this call\n                fails, but we will report the failure. */\nprvInitialiseTaskLists();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\n/* If the scheduler is not already running, make this task the\n            current task if it is the highest priority task to be created\n            so far. */\nif( xSchedulerRunning == pdFALSE )\n{\nif( pxCurrentTCB-&gt;uxPriority &lt;= pxNewTCB-&gt;uxPriority )\n{\npxCurrentTCB = pxNewTCB;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n\nuxTaskNumber++;\n\n#if ( configUSE_TRACE_FACILITY == 1 )\n{\n/* Add a counter into the TCB for tracing only. */\npxNewTCB-&gt;uxTCBNumber = uxTaskNumber;\n}\n#endif /* configUSE_TRACE_FACILITY */\ntraceTASK_CREATE( pxNewTCB );\n\nprvAddTaskToReadyList( pxNewTCB );\n\nportSETUP_TCB( pxNewTCB );\n}\ntaskEXIT_CRITICAL();\n\nif( xSchedulerRunning != pdFALSE )\n{\n/* If the created task is of a higher priority than the current task\n        then it should run now. */\nif( pxCurrentTCB-&gt;uxPriority &lt; pxNewTCB-&gt;uxPriority )\n{\ntaskYIELD_IF_USING_PREEMPTION();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_vTaskDelete == 1 )\n\nvoid vTaskDelete( TaskHandle_t xTaskToDelete )\n{\nTCB_t *pxTCB;\n\ntaskENTER_CRITICAL();\n{\n/* If null is passed in here then it is the calling task that is\n            being deleted. */\npxTCB = prvGetTCBFromHandle( xTaskToDelete );\n\n/* Remove task from the ready/delayed list. */\nif( uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) 0 )\n{\ntaskRESET_READY_PRIORITY( pxTCB-&gt;uxPriority );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\n/* Is the task waiting on an event also? */\nif( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != NULL )\n{\n( void ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\n/* Increment the uxTaskNumber also so kernel aware debuggers can\n            detect that the task lists need re-generating.  This is done before\n            portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will\n            not return. */\nuxTaskNumber++;\n\nif( pxTCB == pxCurrentTCB )\n{\n/* A task is deleting itself.  This cannot complete within the\n                task itself, as a context switch to another task is required.\n                Place the task in the termination list.  The idle task will\n                check the termination list and free up any memory allocated by\n                the scheduler for the TCB and stack of the deleted task. */\nvListInsertEnd( &amp;xTasksWaitingTermination, &amp;( pxTCB-&gt;xStateListItem ) );\n\n/* Increment the ucTasksDeleted variable so the idle task knows\n                there is a task that has been deleted and that it should therefore\n                check the xTasksWaitingTermination list. */\n++uxDeletedTasksWaitingCleanUp;\n\n/* Call the delete hook before portPRE_TASK_DELETE_HOOK() as\n                portPRE_TASK_DELETE_HOOK() does not return in the Win32 port. */\ntraceTASK_DELETE( pxTCB );\n\n/* The pre-delete hook is primarily for the Windows simulator,\n                in which Windows specific clean up operations are performed,\n                after which it is not possible to yield away from this task -\n                hence xYieldPending is used to latch that a context switch is\n                required. */\nportPRE_TASK_DELETE_HOOK( pxTCB, &amp;xYieldPending );\n}\nelse\n{\n--uxCurrentNumberOfTasks;\ntraceTASK_DELETE( pxTCB );\nprvDeleteTCB( pxTCB );\n\n/* Reset the next expected unblock time in case it referred to\n                the task that has just been deleted. */\nprvResetNextTaskUnblockTime();\n}\n}\ntaskEXIT_CRITICAL();\n\n/* Force a reschedule if it is the currently running task that has just\n        been deleted. */\nif( xSchedulerRunning != pdFALSE )\n{\nif( pxTCB == pxCurrentTCB )\n{\nconfigASSERT( uxSchedulerSuspended == 0 );\nportYIELD_WITHIN_API();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n}\n\n#endif /* INCLUDE_vTaskDelete */\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_vTaskDelayUntil == 1 )\n\nvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )\n{\nTickType_t xTimeToWake;\nBaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;\n\nconfigASSERT( pxPreviousWakeTime );\nconfigASSERT( ( xTimeIncrement &gt; 0U ) );\nconfigASSERT( uxSchedulerSuspended == 0 );\n\nvTaskSuspendAll();\n{\n/* Minor optimisation.  The tick count cannot change in this\n            block. */\nconst TickType_t xConstTickCount = xTickCount;\n\n/* Generate the tick time at which the task wants to wake. */\nxTimeToWake = *pxPreviousWakeTime + xTimeIncrement;\n\nif( xConstTickCount &lt; *pxPreviousWakeTime )\n{\n/* The tick count has overflowed since this function was\n                lasted called.  In this case the only time we should ever\n                actually delay is if the wake time has also overflowed,\n                and the wake time is greater than the tick time.  When this\n                is the case it is as if neither time had overflowed. */\nif( ( xTimeToWake &lt; *pxPreviousWakeTime ) &amp;&amp; ( xTimeToWake &gt; xConstTickCount ) )\n{\nxShouldDelay = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\n/* The tick time has not overflowed.  In this case we will\n                delay if either the wake time has overflowed, and/or the\n                tick time is less than the wake time. */\nif( ( xTimeToWake &lt; *pxPreviousWakeTime ) || ( xTimeToWake &gt; xConstTickCount ) )\n{\nxShouldDelay = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n\n/* Update the wake time ready for the next call. */\n*pxPreviousWakeTime = xTimeToWake;\n\nif( xShouldDelay != pdFALSE )\n{\ntraceTASK_DELAY_UNTIL( xTimeToWake );\n\n/* prvAddCurrentTaskToDelayedList() needs the block time, not\n                the time to wake, so subtract the current tick count. */\nprvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nxAlreadyYielded = xTaskResumeAll();\n\n/* Force a reschedule if xTaskResumeAll has not already done so, we may\n        have put ourselves to sleep. */\nif( xAlreadyYielded == pdFALSE )\n{\nportYIELD_WITHIN_API();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n\n#endif /* INCLUDE_vTaskDelayUntil */\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_vTaskDelay == 1 )\n\nvoid vTaskDelay( const TickType_t xTicksToDelay )\n{\nBaseType_t xAlreadyYielded = pdFALSE;\n\n/* A delay time of zero just forces a reschedule. */\nif( xTicksToDelay &gt; ( TickType_t ) 0U )\n{\nconfigASSERT( uxSchedulerSuspended == 0 );\nvTaskSuspendAll();\n{\ntraceTASK_DELAY();\n\n/* A task that is removed from the event list while the\n                scheduler is suspended will not get placed in the ready\n                list or removed from the blocked list until the scheduler\n                is resumed.\n\n                This task cannot be in an event list as it is the currently\n                executing task. */\nprvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );\n}\nxAlreadyYielded = xTaskResumeAll();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\n/* Force a reschedule if xTaskResumeAll has not already done so, we may\n        have put ourselves to sleep. */\nif( xAlreadyYielded == pdFALSE )\n{\nportYIELD_WITHIN_API();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n\n#endif /* INCLUDE_vTaskDelay */\n/*-----------------------------------------------------------*/\n\n#if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_xTaskAbortDelay == 1 ) )\n\neTaskState eTaskGetState( TaskHandle_t xTask )\n{\neTaskState eReturn;\nList_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;\nconst TCB_t * const pxTCB = xTask;\n\nconfigASSERT( pxTCB );\n\nif( pxTCB == pxCurrentTCB )\n{\n/* The task calling this function is querying its own state. */\neReturn = eRunning;\n}\nelse\n{\ntaskENTER_CRITICAL();\n{\npxStateList = listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xStateListItem ) );\npxDelayedList = pxDelayedTaskList;\npxOverflowedDelayedList = pxOverflowDelayedTaskList;\n}\ntaskEXIT_CRITICAL();\n\nif( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )\n{\n/* The task being queried is referenced from one of the Blocked\n                lists. */\neReturn = eBlocked;\n}\n\n#if ( INCLUDE_vTaskSuspend == 1 )\nelse if( pxStateList == &amp;xSuspendedTaskList )\n{\n/* The task being queried is referenced from the suspended\n                    list.  Is it genuinely suspended or is it blocked\n                    indefinitely? */\nif( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) == NULL )\n{\n#if( configUSE_TASK_NOTIFICATIONS == 1 )\n{\n/* The task does not appear on the event list item of\n                            and of the RTOS objects, but could still be in the\n                            blocked state if it is waiting on its notification\n                            rather than waiting on an object. */\nif( pxTCB-&gt;ucNotifyState == taskWAITING_NOTIFICATION )\n{\neReturn = eBlocked;\n}\nelse\n{\neReturn = eSuspended;\n}\n}\n#else\n{\neReturn = eSuspended;\n}\n#endif\n}\nelse\n{\neReturn = eBlocked;\n}\n}\n#endif\n\n#if ( INCLUDE_vTaskDelete == 1 )\nelse if( ( pxStateList == &amp;xTasksWaitingTermination ) || ( pxStateList == NULL ) )\n{\n/* The task being queried is referenced from the deleted\n                    tasks list, or it is not referenced from any lists at\n                    all. */\neReturn = eDeleted;\n}\n#endif\n\nelse /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */\n{\n/* If the task is not in any other state, it must be in the\n                Ready (including pending ready) state. */\neReturn = eReady;\n}\n}\n\nreturn eReturn;\n} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */\n\n#endif /* INCLUDE_eTaskGetState */\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_uxTaskPriorityGet == 1 )\n\nUBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )\n{\nTCB_t const *pxTCB;\nUBaseType_t uxReturn;\n\ntaskENTER_CRITICAL();\n{\n/* If null is passed in here then it is the priority of the task\n            that called uxTaskPriorityGet() that is being queried. */\npxTCB = prvGetTCBFromHandle( xTask );\nuxReturn = pxTCB-&gt;uxPriority;\n}\ntaskEXIT_CRITICAL();\n\nreturn uxReturn;\n}\n\n#endif /* INCLUDE_uxTaskPriorityGet */\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_uxTaskPriorityGet == 1 )\n\nUBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )\n{\nTCB_t const *pxTCB;\nUBaseType_t uxReturn, uxSavedInterruptState;\n\n/* RTOS ports that support interrupt nesting have the concept of a\n        maximum system call (or maximum API call) interrupt priority.\n        Interrupts that are above the maximum system call priority are keep\n        permanently enabled, even when the RTOS kernel is in a critical section,\n        but cannot make any calls to FreeRTOS API functions.  If configASSERT()\n        is defined in FreeRTOSConfig.h then\n        portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion\n        failure if a FreeRTOS API function is called from an interrupt that has\n        been assigned a priority above the configured maximum system call\n        priority.  Only FreeRTOS functions that end in FromISR can be called\n        from interrupts that have been assigned a priority at or (logically)\n        below the maximum system call interrupt priority.  FreeRTOS maintains a\n        separate interrupt safe API to ensure interrupt entry is as fast and as\n        simple as possible.  More information (albeit Cortex-M specific) is\n        provided on the following link:\n        https://www.freertos.org/RTOS-Cortex-M3-M4.html */\nportASSERT_IF_INTERRUPT_PRIORITY_INVALID();\n\nuxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();\n{\n/* If null is passed in here then it is the priority of the calling\n            task that is being queried. */\npxTCB = prvGetTCBFromHandle( xTask );\nuxReturn = pxTCB-&gt;uxPriority;\n}\nportCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );\n\nreturn uxReturn;\n}\n\n#endif /* INCLUDE_uxTaskPriorityGet */\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_vTaskPrioritySet == 1 )\n\nvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )\n{\nTCB_t *pxTCB;\nUBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;\nBaseType_t xYieldRequired = pdFALSE;\n\nconfigASSERT( ( uxNewPriority &lt; configMAX_PRIORITIES ) );\n\n/* Ensure the new priority is valid. */\nif( uxNewPriority &gt;= ( UBaseType_t ) configMAX_PRIORITIES )\n{\nuxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\ntaskENTER_CRITICAL();\n{\n/* If null is passed in here then it is the priority of the calling\n            task that is being changed. */\npxTCB = prvGetTCBFromHandle( xTask );\n\ntraceTASK_PRIORITY_SET( pxTCB, uxNewPriority );\n\n#if ( configUSE_MUTEXES == 1 )\n{\nuxCurrentBasePriority = pxTCB-&gt;uxBasePriority;\n}\n#else\n{\nuxCurrentBasePriority = pxTCB-&gt;uxPriority;\n}\n#endif\n\nif( uxCurrentBasePriority != uxNewPriority )\n{\n/* The priority change may have readied a task of higher\n                priority than the calling task. */\nif( uxNewPriority &gt; uxCurrentBasePriority )\n{\nif( pxTCB != pxCurrentTCB )\n{\n/* The priority of a task other than the currently\n                        running task is being raised.  Is the priority being\n                        raised above that of the running task? */\nif( uxNewPriority &gt;= pxCurrentTCB-&gt;uxPriority )\n{\nxYieldRequired = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\n/* The priority of the running task is being raised,\n                        but the running task must already be the highest\n                        priority task able to run so no yield is required. */\n}\n}\nelse if( pxTCB == pxCurrentTCB )\n{\n/* Setting the priority of the running task down means\n                    there may now be another task of higher priority that\n                    is ready to execute. */\nxYieldRequired = pdTRUE;\n}\nelse\n{\n/* Setting the priority of any other task down does not\n                    require a yield as the running task must be above the\n                    new priority of the task being modified. */\n}\n\n/* Remember the ready list the task might be referenced from\n                before its uxPriority member is changed so the\n                taskRESET_READY_PRIORITY() macro can function correctly. */\nuxPriorityUsedOnEntry = pxTCB-&gt;uxPriority;\n\n#if ( configUSE_MUTEXES == 1 )\n{\n/* Only change the priority being used if the task is not\n                    currently using an inherited priority. */\nif( pxTCB-&gt;uxBasePriority == pxTCB-&gt;uxPriority )\n{\npxTCB-&gt;uxPriority = uxNewPriority;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\n/* The base priority gets set whatever. */\npxTCB-&gt;uxBasePriority = uxNewPriority;\n}\n#else\n{\npxTCB-&gt;uxPriority = uxNewPriority;\n}\n#endif\n\n/* Only reset the event list item value if the value is not\n                being used for anything else. */\nif( ( listGET_LIST_ITEM_VALUE( &amp;( pxTCB-&gt;xEventListItem ) ) &amp; taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )\n{\nlistSET_LIST_ITEM_VALUE( &amp;( pxTCB-&gt;xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\n/* If the task is in the blocked or suspended list we need do\n                nothing more than change its priority variable. However, if\n                the task is in a ready list it needs to be removed and placed\n                in the list appropriate to its new priority. */\nif( listIS_CONTAINED_WITHIN( &amp;( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &amp;( pxTCB-&gt;xStateListItem ) ) != pdFALSE )\n{\n/* The task is currently in its ready list - remove before\n                    adding it to it's new ready list.  As we are in a critical\n                    section we can do this even if the scheduler is suspended. */\nif( uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) 0 )\n{\n/* It is known that the task is in its ready list so\n                        there is no need to check again and the port level\n                        reset macro can be called directly. */\nportRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\nprvAddTaskToReadyList( pxTCB );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nif( xYieldRequired != pdFALSE )\n{\ntaskYIELD_IF_USING_PREEMPTION();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\n/* Remove compiler warning about unused variables when the port\n                optimised task selection is not being used. */\n( void ) uxPriorityUsedOnEntry;\n}\n}\ntaskEXIT_CRITICAL();\n}\n\n#endif /* INCLUDE_vTaskPrioritySet */\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_vTaskSuspend == 1 )\n\nvoid vTaskSuspend( TaskHandle_t xTaskToSuspend )\n{\nTCB_t *pxTCB;\n\ntaskENTER_CRITICAL();\n{\n/* If null is passed in here then it is the running task that is\n            being suspended. */\npxTCB = prvGetTCBFromHandle( xTaskToSuspend );\n\ntraceTASK_SUSPEND( pxTCB );\n\n/* Remove task from the ready/delayed list and place in the\n            suspended list. */\nif( uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) 0 )\n{\ntaskRESET_READY_PRIORITY( pxTCB-&gt;uxPriority );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\n/* Is the task waiting on an event also? */\nif( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != NULL )\n{\n( void ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nvListInsertEnd( &amp;xSuspendedTaskList, &amp;( pxTCB-&gt;xStateListItem ) );\n\n#if( configUSE_TASK_NOTIFICATIONS == 1 )\n{\nif( pxTCB-&gt;ucNotifyState == taskWAITING_NOTIFICATION )\n{\n/* The task was blocked to wait for a notification, but is\n                    now suspended, so no notification was received. */\npxTCB-&gt;ucNotifyState = taskNOT_WAITING_NOTIFICATION;\n}\n}\n#endif\n}\ntaskEXIT_CRITICAL();\n\nif( xSchedulerRunning != pdFALSE )\n{\n/* Reset the next expected unblock time in case it referred to the\n            task that is now in the Suspended state. */\ntaskENTER_CRITICAL();\n{\nprvResetNextTaskUnblockTime();\n}\ntaskEXIT_CRITICAL();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nif( pxTCB == pxCurrentTCB )\n{\nif( xSchedulerRunning != pdFALSE )\n{\n/* The current task has just been suspended. */\nconfigASSERT( uxSchedulerSuspended == 0 );\nportYIELD_WITHIN_API();\n}\nelse\n{\n/* The scheduler is not running, but the task that was pointed\n                to by pxCurrentTCB has just been suspended and pxCurrentTCB\n                must be adjusted to point to a different task. */\nif( listCURRENT_LIST_LENGTH( &amp;xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */\n{\n/* No other tasks are ready, so set pxCurrentTCB back to\n                    NULL so when the next task is created pxCurrentTCB will\n                    be set to point to it no matter what its relative priority\n                    is. */\npxCurrentTCB = NULL;\n}\nelse\n{\nvTaskSwitchContext();\n}\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n\n#endif /* INCLUDE_vTaskSuspend */\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_vTaskSuspend == 1 )\n\nstatic BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )\n{\nBaseType_t xReturn = pdFALSE;\nconst TCB_t * const pxTCB = xTask;\n\n/* Accesses xPendingReadyList so must be called from a critical\n        section. */\n\n/* It does not make sense to check if the calling task is suspended. */\nconfigASSERT( xTask );\n\n/* Is the task being resumed actually in the suspended list? */\nif( listIS_CONTAINED_WITHIN( &amp;xSuspendedTaskList, &amp;( pxTCB-&gt;xStateListItem ) ) != pdFALSE )\n{\n/* Has the task already been resumed from within an ISR? */\nif( listIS_CONTAINED_WITHIN( &amp;xPendingReadyList, &amp;( pxTCB-&gt;xEventListItem ) ) == pdFALSE )\n{\n/* Is it in the suspended list because it is in the Suspended\n                state, or because is is blocked with no timeout? */\nif( listIS_CONTAINED_WITHIN( NULL, &amp;( pxTCB-&gt;xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */\n{\nxReturn = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nreturn xReturn;\n} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */\n\n#endif /* INCLUDE_vTaskSuspend */\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_vTaskSuspend == 1 )\n\nvoid vTaskResume( TaskHandle_t xTaskToResume )\n{\nTCB_t * const pxTCB = xTaskToResume;\n\n/* It does not make sense to resume the calling task. */\nconfigASSERT( xTaskToResume );\n\n/* The parameter cannot be NULL as it is impossible to resume the\n        currently executing task. */\nif( ( pxTCB != pxCurrentTCB ) &amp;&amp; ( pxTCB != NULL ) )\n{\ntaskENTER_CRITICAL();\n{\nif( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )\n{\ntraceTASK_RESUME( pxTCB );\n\n/* The ready list can be accessed even if the scheduler is\n                    suspended because this is inside a critical section. */\n( void ) uxListRemove(  &amp;( pxTCB-&gt;xStateListItem ) );\nprvAddTaskToReadyList( pxTCB );\n\n/* A higher priority task may have just been resumed. */\nif( pxTCB-&gt;uxPriority &gt;= pxCurrentTCB-&gt;uxPriority )\n{\n/* This yield may not cause the task just resumed to run,\n                        but will leave the lists in the correct state for the\n                        next yield. */\ntaskYIELD_IF_USING_PREEMPTION();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\ntaskEXIT_CRITICAL();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n\n#endif /* INCLUDE_vTaskSuspend */\n\n/*-----------------------------------------------------------*/\n\n#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) &amp;&amp; ( INCLUDE_vTaskSuspend == 1 ) )\n\nBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )\n{\nBaseType_t xYieldRequired = pdFALSE;\nTCB_t * const pxTCB = xTaskToResume;\nUBaseType_t uxSavedInterruptStatus;\n\nconfigASSERT( xTaskToResume );\n\n/* RTOS ports that support interrupt nesting have the concept of a\n        maximum system call (or maximum API call) interrupt priority.\n        Interrupts that are above the maximum system call priority are keep\n        permanently enabled, even when the RTOS kernel is in a critical section,\n        but cannot make any calls to FreeRTOS API functions.  If configASSERT()\n        is defined in FreeRTOSConfig.h then\n        portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion\n        failure if a FreeRTOS API function is called from an interrupt that has\n        been assigned a priority above the configured maximum system call\n        priority.  Only FreeRTOS functions that end in FromISR can be called\n        from interrupts that have been assigned a priority at or (logically)\n        below the maximum system call interrupt priority.  FreeRTOS maintains a\n        separate interrupt safe API to ensure interrupt entry is as fast and as\n        simple as possible.  More information (albeit Cortex-M specific) is\n        provided on the following link:\n        https://www.freertos.org/RTOS-Cortex-M3-M4.html */\nportASSERT_IF_INTERRUPT_PRIORITY_INVALID();\n\nuxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();\n{\nif( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )\n{\ntraceTASK_RESUME_FROM_ISR( pxTCB );\n\n/* Check the ready lists can be accessed. */\nif( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )\n{\n/* Ready lists can be accessed so move the task from the\n                    suspended list to the ready list directly. */\nif( pxTCB-&gt;uxPriority &gt;= pxCurrentTCB-&gt;uxPriority )\n{\nxYieldRequired = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\n( void ) uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) );\nprvAddTaskToReadyList( pxTCB );\n}\nelse\n{\n/* The delayed or ready lists cannot be accessed so the task\n                    is held in the pending ready list until the scheduler is\n                    unsuspended. */\nvListInsertEnd( &amp;( xPendingReadyList ), &amp;( pxTCB-&gt;xEventListItem ) );\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nportCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\n\nreturn xYieldRequired;\n}\n\n#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) &amp;&amp; ( INCLUDE_vTaskSuspend == 1 ) ) */\n/*-----------------------------------------------------------*/\n\nvoid vTaskStartScheduler( void )\n{\nBaseType_t xReturn;\n\n/* Add the idle task at the lowest priority. */\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n{\nStaticTask_t *pxIdleTaskTCBBuffer = NULL;\nStackType_t *pxIdleTaskStackBuffer = NULL;\nuint32_t ulIdleTaskStackSize;\n\n/* The Idle task is created using user provided RAM - obtain the\n        address of the RAM then create the idle task. */\nvApplicationGetIdleTaskMemory( &amp;pxIdleTaskTCBBuffer, &amp;pxIdleTaskStackBuffer, &amp;ulIdleTaskStackSize );\nxIdleTaskHandle = xTaskCreateStatic(    prvIdleTask,\nconfigIDLE_TASK_NAME,\nulIdleTaskStackSize,\n( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */\nportPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */\npxIdleTaskStackBuffer,\npxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */\n\nif( xIdleTaskHandle != NULL )\n{\nxReturn = pdPASS;\n}\nelse\n{\nxReturn = pdFAIL;\n}\n}\n#else\n{\n/* The Idle task is being created using dynamically allocated RAM. */\nxReturn = xTaskCreate(  prvIdleTask,\nconfigIDLE_TASK_NAME,\nconfigMINIMAL_STACK_SIZE,\n( void * ) NULL,\nportPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */\n&amp;xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */\n}\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n\n#if ( configUSE_TIMERS == 1 )\n{\nif( xReturn == pdPASS )\n{\nxReturn = xTimerCreateTimerTask();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n#endif /* configUSE_TIMERS */\n\nif( xReturn == pdPASS )\n{\n/* freertos_tasks_c_additions_init() should only be called if the user\n        definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is\n        the only macro called by the function. */\n#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT\n{\nfreertos_tasks_c_additions_init();\n}\n#endif\n\n/* Interrupts are turned off here, to ensure a tick does not occur\n        before or during the call to xPortStartScheduler().  The stacks of\n        the created tasks contain a status word with interrupts switched on\n        so interrupts will automatically get re-enabled when the first task\n        starts to run. */\nportDISABLE_INTERRUPTS();\n\n#if ( configUSE_NEWLIB_REENTRANT == 1 )\n{\n/* Switch Newlib's _impure_ptr variable to point to the _reent\n            structure specific to the task that will run first.\n            See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html\n            for additional information. */\n_impure_ptr = &amp;( pxCurrentTCB-&gt;xNewLib_reent );\n}\n#endif /* configUSE_NEWLIB_REENTRANT */\n\nxNextTaskUnblockTime = portMAX_DELAY;\nxSchedulerRunning = pdTRUE;\nxTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;\n\n/* If configGENERATE_RUN_TIME_STATS is defined then the following\n        macro must be defined to configure the timer/counter used to generate\n        the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS\n        is set to 0 and the following line fails to build then ensure you do not\n        have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your\n        FreeRTOSConfig.h file. */\nportCONFIGURE_TIMER_FOR_RUN_TIME_STATS();\n\ntraceTASK_SWITCHED_IN();\n\n/* Setting up the timer tick is hardware specific and thus in the\n        portable interface. */\nif( xPortStartScheduler() != pdFALSE )\n{\n/* Should not reach here as if the scheduler is running the\n            function will not return. */\n}\nelse\n{\n/* Should only reach here if a task calls xTaskEndScheduler(). */\n}\n}\nelse\n{\n/* This line will only be reached if the kernel could not be started,\n        because there was not enough FreeRTOS heap to create the idle task\n        or the timer task. */\nconfigASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );\n}\n\n/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,\n    meaning xIdleTaskHandle is not used anywhere else. */\n( void ) xIdleTaskHandle;\n}\n/*-----------------------------------------------------------*/\n\nvoid vTaskEndScheduler( void )\n{\n/* Stop the scheduler interrupts and call the portable scheduler end\n    routine so the original ISRs can be restored if necessary.  The port\n    layer must ensure interrupts enable bit is left in the correct state. */\nportDISABLE_INTERRUPTS();\nxSchedulerRunning = pdFALSE;\nvPortEndScheduler();\n}\n/*----------------------------------------------------------*/\n\nvoid vTaskSuspendAll( void )\n{\n/* A critical section is not required as the variable is of type\n    BaseType_t.  Please read Richard Barry's reply in the following link to a\n    post in the FreeRTOS support forum before reporting this as a bug! -\n    http://goo.gl/wu4acr */\n\n/* portSOFRWARE_BARRIER() is only implemented for emulated/simulated ports that\n    do not otherwise exhibit real time behaviour. */\nportSOFTWARE_BARRIER();\n\n/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment\n    is used to allow calls to vTaskSuspendAll() to nest. */\n++uxSchedulerSuspended;\n\n/* Enforces ordering for ports and optimised compilers that may otherwise place\n    the above increment elsewhere. */\nportMEMORY_BARRIER();\n}\n/*----------------------------------------------------------*/\n\n#if ( configUSE_TICKLESS_IDLE != 0 )\n\nstatic TickType_t prvGetExpectedIdleTime( void )\n{\nTickType_t xReturn;\nUBaseType_t uxHigherPriorityReadyTasks = pdFALSE;\n\n/* uxHigherPriorityReadyTasks takes care of the case where\n        configUSE_PREEMPTION is 0, so there may be tasks above the idle priority\n        task that are in the Ready state, even though the idle task is\n        running. */\n#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )\n{\nif( uxTopReadyPriority &gt; tskIDLE_PRIORITY )\n{\nuxHigherPriorityReadyTasks = pdTRUE;\n}\n}\n#else\n{\nconst UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;\n\n/* When port optimised task selection is used the uxTopReadyPriority\n            variable is used as a bit map.  If bits other than the least\n            significant bit are set then there are tasks that have a priority\n            above the idle priority that are in the Ready state.  This takes\n            care of the case where the co-operative scheduler is in use. */\nif( uxTopReadyPriority &gt; uxLeastSignificantBit )\n{\nuxHigherPriorityReadyTasks = pdTRUE;\n}\n}\n#endif\n\nif( pxCurrentTCB-&gt;uxPriority &gt; tskIDLE_PRIORITY )\n{\nxReturn = 0;\n}\nelse if( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) &gt; 1 )\n{\n/* There are other idle priority tasks in the ready state.  If\n            time slicing is used then the very next tick interrupt must be\n            processed. */\nxReturn = 0;\n}\nelse if( uxHigherPriorityReadyTasks != pdFALSE )\n{\n/* There are tasks in the Ready state that have a priority above the\n            idle priority.  This path can only be reached if\n            configUSE_PREEMPTION is 0. */\nxReturn = 0;\n}\nelse\n{\nxReturn = xNextTaskUnblockTime - xTickCount;\n}\n\nreturn xReturn;\n}\n\n#endif /* configUSE_TICKLESS_IDLE */\n/*----------------------------------------------------------*/\n\nBaseType_t xTaskResumeAll( void )\n{\nTCB_t *pxTCB = NULL;\nBaseType_t xAlreadyYielded = pdFALSE;\n\n/* If uxSchedulerSuspended is zero then this function does not match a\n    previous call to vTaskSuspendAll(). */\nconfigASSERT( uxSchedulerSuspended );\n\n/* It is possible that an ISR caused a task to be removed from an event\n    list while the scheduler was suspended.  If this was the case then the\n    removed task will have been added to the xPendingReadyList.  Once the\n    scheduler has been resumed it is safe to move all the pending ready\n    tasks from this list into their appropriate ready list. */\ntaskENTER_CRITICAL();\n{\n--uxSchedulerSuspended;\n\nif( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )\n{\nif( uxCurrentNumberOfTasks &gt; ( UBaseType_t ) 0U )\n{\n/* Move any readied tasks from the pending list into the\n                appropriate ready list. */\nwhile( listLIST_IS_EMPTY( &amp;xPendingReadyList ) == pdFALSE )\n{\npxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &amp;xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */\n( void ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) );\n( void ) uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) );\nprvAddTaskToReadyList( pxTCB );\n\n/* If the moved task has a priority higher than the current\n                    task then a yield must be performed. */\nif( pxTCB-&gt;uxPriority &gt;= pxCurrentTCB-&gt;uxPriority )\n{\nxYieldPending = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n\nif( pxTCB != NULL )\n{\n/* A task was unblocked while the scheduler was suspended,\n                    which may have prevented the next unblock time from being\n                    re-calculated, in which case re-calculate it now.  Mainly\n                    important for low power tickless implementations, where\n                    this can prevent an unnecessary exit from low power\n                    state. */\nprvResetNextTaskUnblockTime();\n}\n\n/* If any ticks occurred while the scheduler was suspended then\n                they should be processed now.  This ensures the tick count does\n                not slip, and that any delayed tasks are resumed at the correct\n                time. */\n{\nTickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */\n\nif( xPendedCounts &gt; ( TickType_t ) 0U )\n{\ndo\n{\nif( xTaskIncrementTick() != pdFALSE )\n{\nxYieldPending = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n--xPendedCounts;\n} while( xPendedCounts &gt; ( TickType_t ) 0U );\n\nxPendedTicks = 0;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n\nif( xYieldPending != pdFALSE )\n{\n#if( configUSE_PREEMPTION != 0 )\n{\nxAlreadyYielded = pdTRUE;\n}\n#endif\ntaskYIELD_IF_USING_PREEMPTION();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\ntaskEXIT_CRITICAL();\n\nreturn xAlreadyYielded;\n}\n/*-----------------------------------------------------------*/\n\nTickType_t xTaskGetTickCount( void )\n{\nTickType_t xTicks;\n\n/* Critical section required if running on a 16 bit processor. */\nportTICK_TYPE_ENTER_CRITICAL();\n{\nxTicks = xTickCount;\n}\nportTICK_TYPE_EXIT_CRITICAL();\n\nreturn xTicks;\n}\n/*-----------------------------------------------------------*/\n\nTickType_t xTaskGetTickCountFromISR( void )\n{\nTickType_t xReturn;\nUBaseType_t uxSavedInterruptStatus;\n\n/* RTOS ports that support interrupt nesting have the concept of a maximum\n    system call (or maximum API call) interrupt priority.  Interrupts that are\n    above the maximum system call priority are kept permanently enabled, even\n    when the RTOS kernel is in a critical section, but cannot make any calls to\n    FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h\n    then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion\n    failure if a FreeRTOS API function is called from an interrupt that has been\n    assigned a priority above the configured maximum system call priority.\n    Only FreeRTOS functions that end in FromISR can be called from interrupts\n    that have been assigned a priority at or (logically) below the maximum\n    system call interrupt priority.  FreeRTOS maintains a separate interrupt\n    safe API to ensure interrupt entry is as fast and as simple as possible.\n    More information (albeit Cortex-M specific) is provided on the following\n    link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */\nportASSERT_IF_INTERRUPT_PRIORITY_INVALID();\n\nuxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();\n{\nxReturn = xTickCount;\n}\nportTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nUBaseType_t uxTaskGetNumberOfTasks( void )\n{\n/* A critical section is not required because the variables are of type\n    BaseType_t. */\nreturn uxCurrentNumberOfTasks;\n}\n/*-----------------------------------------------------------*/\n\nchar *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n{\nTCB_t *pxTCB;\n\n/* If null is passed in here then the name of the calling task is being\n    queried. */\npxTCB = prvGetTCBFromHandle( xTaskToQuery );\nconfigASSERT( pxTCB );\nreturn &amp;( pxTCB-&gt;pcTaskName[ 0 ] );\n}\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_xTaskGetHandle == 1 )\n\nstatic TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )\n{\nTCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;\nUBaseType_t x;\nchar cNextChar;\nBaseType_t xBreakLoop;\n\n/* This function is called with the scheduler suspended. */\n\nif( listCURRENT_LIST_LENGTH( pxList ) &gt; ( UBaseType_t ) 0 )\n{\nlistGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );  /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */\n\ndo\n{\nlistGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */\n\n/* Check each character in the name looking for a match or\n                mismatch. */\nxBreakLoop = pdFALSE;\nfor( x = ( UBaseType_t ) 0; x &lt; ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )\n{\ncNextChar = pxNextTCB-&gt;pcTaskName[ x ];\n\nif( cNextChar != pcNameToQuery[ x ] )\n{\n/* Characters didn't match. */\nxBreakLoop = pdTRUE;\n}\nelse if( cNextChar == ( char ) 0x00 )\n{\n/* Both strings terminated, a match must have been\n                        found. */\npxReturn = pxNextTCB;\nxBreakLoop = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nif( xBreakLoop != pdFALSE )\n{\nbreak;\n}\n}\n\nif( pxReturn != NULL )\n{\n/* The handle has been found. */\nbreak;\n}\n\n} while( pxNextTCB != pxFirstTCB );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nreturn pxReturn;\n}\n\n#endif /* INCLUDE_xTaskGetHandle */\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_xTaskGetHandle == 1 )\n\nTaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n{\nUBaseType_t uxQueue = configMAX_PRIORITIES;\nTCB_t* pxTCB;\n\n/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */\nconfigASSERT( strlen( pcNameToQuery ) &lt; configMAX_TASK_NAME_LEN );\n\nvTaskSuspendAll();\n{\n/* Search the ready lists. */\ndo\n{\nuxQueue--;\npxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &amp;( pxReadyTasksLists[ uxQueue ] ), pcNameToQuery );\n\nif( pxTCB != NULL )\n{\n/* Found the handle. */\nbreak;\n}\n\n} while( uxQueue &gt; ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\n\n/* Search the delayed lists. */\nif( pxTCB == NULL )\n{\npxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );\n}\n\nif( pxTCB == NULL )\n{\npxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery );\n}\n\n#if ( INCLUDE_vTaskSuspend == 1 )\n{\nif( pxTCB == NULL )\n{\n/* Search the suspended list. */\npxTCB = prvSearchForNameWithinSingleList( &amp;xSuspendedTaskList, pcNameToQuery );\n}\n}\n#endif\n\n#if( INCLUDE_vTaskDelete == 1 )\n{\nif( pxTCB == NULL )\n{\n/* Search the deleted list. */\npxTCB = prvSearchForNameWithinSingleList( &amp;xTasksWaitingTermination, pcNameToQuery );\n}\n}\n#endif\n}\n( void ) xTaskResumeAll();\n\nreturn pxTCB;\n}\n\n#endif /* INCLUDE_xTaskGetHandle */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_TRACE_FACILITY == 1 )\n\nUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )\n{\nUBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;\n\nvTaskSuspendAll();\n{\n/* Is there a space in the array for each task in the system? */\nif( uxArraySize &gt;= uxCurrentNumberOfTasks )\n{\n/* Fill in an TaskStatus_t structure with information on each\n                task in the Ready state. */\ndo\n{\nuxQueue--;\nuxTask += prvListTasksWithinSingleList( &amp;( pxTaskStatusArray[ uxTask ] ), &amp;( pxReadyTasksLists[ uxQueue ] ), eReady );\n\n} while( uxQueue &gt; ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\n\n/* Fill in an TaskStatus_t structure with information on each\n                task in the Blocked state. */\nuxTask += prvListTasksWithinSingleList( &amp;( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );\nuxTask += prvListTasksWithinSingleList( &amp;( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );\n\n#if( INCLUDE_vTaskDelete == 1 )\n{\n/* Fill in an TaskStatus_t structure with information on\n                    each task that has been deleted but not yet cleaned up. */\nuxTask += prvListTasksWithinSingleList( &amp;( pxTaskStatusArray[ uxTask ] ), &amp;xTasksWaitingTermination, eDeleted );\n}\n#endif\n\n#if ( INCLUDE_vTaskSuspend == 1 )\n{\n/* Fill in an TaskStatus_t structure with information on\n                    each task in the Suspended state. */\nuxTask += prvListTasksWithinSingleList( &amp;( pxTaskStatusArray[ uxTask ] ), &amp;xSuspendedTaskList, eSuspended );\n}\n#endif\n\n#if ( configGENERATE_RUN_TIME_STATS == 1)\n{\nif( pulTotalRunTime != NULL )\n{\n#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE\nportALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );\n#else\n*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();\n#endif\n}\n}\n#else\n{\nif( pulTotalRunTime != NULL )\n{\n*pulTotalRunTime = 0;\n}\n}\n#endif\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n( void ) xTaskResumeAll();\n\nreturn uxTask;\n}\n\n#endif /* configUSE_TRACE_FACILITY */\n/*----------------------------------------------------------*/\n\n#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )\n\nTaskHandle_t xTaskGetIdleTaskHandle( void )\n{\n/* If xTaskGetIdleTaskHandle() is called before the scheduler has been\n        started, then xIdleTaskHandle will be NULL. */\nconfigASSERT( ( xIdleTaskHandle != NULL ) );\nreturn xIdleTaskHandle;\n}\n\n#endif /* INCLUDE_xTaskGetIdleTaskHandle */\n/*----------------------------------------------------------*/\n\n/* This conditional compilation should use inequality to 0, not equality to 1.\nThis is to ensure vTaskStepTick() is available when user defined low power mode\nimplementations require configUSE_TICKLESS_IDLE to be set to a value other than\n1. */\n#if ( configUSE_TICKLESS_IDLE != 0 )\n\nvoid vTaskStepTick( const TickType_t xTicksToJump )\n{\n/* Correct the tick count value after a period during which the tick\n        was suppressed.  Note this does *not* call the tick hook function for\n        each stepped tick. */\nconfigASSERT( ( xTickCount + xTicksToJump ) &lt;= xNextTaskUnblockTime );\nxTickCount += xTicksToJump;\ntraceINCREASE_TICK_COUNT( xTicksToJump );\n}\n\n#endif /* configUSE_TICKLESS_IDLE */\n/*----------------------------------------------------------*/\n\nBaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )\n{\nBaseType_t xYieldRequired = pdFALSE;\n\n/* Must not be called with the scheduler suspended as the implementation\n    relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */\nconfigASSERT( uxSchedulerSuspended == 0 );\n\n/* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when\n    the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */\nvTaskSuspendAll();\nxPendedTicks += xTicksToCatchUp;\nxYieldRequired = xTaskResumeAll();\n\nreturn xYieldRequired;\n}\n/*----------------------------------------------------------*/\n\n#if ( INCLUDE_xTaskAbortDelay == 1 )\n\nBaseType_t xTaskAbortDelay( TaskHandle_t xTask )\n{\nTCB_t *pxTCB = xTask;\nBaseType_t xReturn;\n\nconfigASSERT( pxTCB );\n\nvTaskSuspendAll();\n{\n/* A task can only be prematurely removed from the Blocked state if\n            it is actually in the Blocked state. */\nif( eTaskGetState( xTask ) == eBlocked )\n{\nxReturn = pdPASS;\n\n/* Remove the reference to the task from the blocked list.  An\n                interrupt won't touch the xStateListItem because the\n                scheduler is suspended. */\n( void ) uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) );\n\n/* Is the task waiting on an event also?  If so remove it from\n                the event list too.  Interrupts can touch the event list item,\n                even though the scheduler is suspended, so a critical section\n                is used. */\ntaskENTER_CRITICAL();\n{\nif( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != NULL )\n{\n( void ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) );\n\n/* This lets the task know it was forcibly removed from the\n                        blocked state so it should not re-evaluate its block time and\n                        then block again. */\npxTCB-&gt;ucDelayAborted = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\ntaskEXIT_CRITICAL();\n\n/* Place the unblocked task into the appropriate ready list. */\nprvAddTaskToReadyList( pxTCB );\n\n/* A task being unblocked cannot cause an immediate context\n                switch if preemption is turned off. */\n#if (  configUSE_PREEMPTION == 1 )\n{\n/* Preemption is on, but a context switch should only be\n                    performed if the unblocked task has a priority that is\n                    equal to or higher than the currently executing task. */\nif( pxTCB-&gt;uxPriority &gt; pxCurrentTCB-&gt;uxPriority )\n{\n/* Pend the yield to be performed when the scheduler\n                        is unsuspended. */\nxYieldPending = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n#endif /* configUSE_PREEMPTION */\n}\nelse\n{\nxReturn = pdFAIL;\n}\n}\n( void ) xTaskResumeAll();\n\nreturn xReturn;\n}\n\n#endif /* INCLUDE_xTaskAbortDelay */\n/*----------------------------------------------------------*/\n\nBaseType_t xTaskIncrementTick( void )\n{\nTCB_t * pxTCB;\nTickType_t xItemValue;\nBaseType_t xSwitchRequired = pdFALSE;\n\n/* Called by the portable layer each time a tick interrupt occurs.\n    Increments the tick then checks to see if the new tick value will cause any\n    tasks to be unblocked. */\ntraceTASK_INCREMENT_TICK( xTickCount );\nif( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )\n{\n/* Minor optimisation.  The tick count cannot change in this\n        block. */\nconst TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;\n\n/* Increment the RTOS tick, switching the delayed and overflowed\n        delayed lists if it wraps to 0. */\nxTickCount = xConstTickCount;\n\nif( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */\n{\ntaskSWITCH_DELAYED_LISTS();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\n/* See if this tick has made a timeout expire.  Tasks are stored in\n        the queue in the order of their wake time - meaning once one task\n        has been found whose block time has not expired there is no need to\n        look any further down the list. */\nif( xConstTickCount &gt;= xNextTaskUnblockTime )\n{\nfor( ;; )\n{\nif( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )\n{\n/* The delayed list is empty.  Set xNextTaskUnblockTime\n                    to the maximum possible value so it is extremely\n                    unlikely that the\n                    if( xTickCount &gt;= xNextTaskUnblockTime ) test will pass\n                    next time through. */\nxNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\nbreak;\n}\nelse\n{\n/* The delayed list is not empty, get the value of the\n                    item at the head of the delayed list.  This is the time\n                    at which the task at the head of the delayed list must\n                    be removed from the Blocked state. */\npxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */\nxItemValue = listGET_LIST_ITEM_VALUE( &amp;( pxTCB-&gt;xStateListItem ) );\n\nif( xConstTickCount &lt; xItemValue )\n{\n/* It is not time to unblock this item yet, but the\n                        item value is the time at which the task at the head\n                        of the blocked list must be removed from the Blocked\n                        state - so record the item value in\n                        xNextTaskUnblockTime. */\nxNextTaskUnblockTime = xItemValue;\nbreak; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\n/* It is time to remove the item from the Blocked state. */\n( void ) uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) );\n\n/* Is the task waiting on an event also?  If so remove\n                    it from the event list. */\nif( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != NULL )\n{\n( void ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\n/* Place the unblocked task into the appropriate ready\n                    list. */\nprvAddTaskToReadyList( pxTCB );\n\n/* A task being unblocked cannot cause an immediate\n                    context switch if preemption is turned off. */\n#if (  configUSE_PREEMPTION == 1 )\n{\n/* Preemption is on, but a context switch should\n                        only be performed if the unblocked task has a\n                        priority that is equal to or higher than the\n                        currently executing task. */\nif( pxTCB-&gt;uxPriority &gt;= pxCurrentTCB-&gt;uxPriority )\n{\nxSwitchRequired = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n#endif /* configUSE_PREEMPTION */\n}\n}\n}\n\n/* Tasks of equal priority to the currently running task will share\n        processing time (time slice) if preemption is on, and the application\n        writer has not explicitly turned time slicing off. */\n#if ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configUSE_TIME_SLICING == 1 ) )\n{\nif( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ pxCurrentTCB-&gt;uxPriority ] ) ) &gt; ( UBaseType_t ) 1 )\n{\nxSwitchRequired = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n#endif /* ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configUSE_TIME_SLICING == 1 ) ) */\n\n#if ( configUSE_TICK_HOOK == 1 )\n{\n/* Guard against the tick hook being called when the pended tick\n            count is being unwound (when the scheduler is being unlocked). */\nif( xPendedTicks == ( TickType_t ) 0 )\n{\nvApplicationTickHook();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n#endif /* configUSE_TICK_HOOK */\n\n#if ( configUSE_PREEMPTION == 1 )\n{\nif( xYieldPending != pdFALSE )\n{\nxSwitchRequired = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n#endif /* configUSE_PREEMPTION */\n}\nelse\n{\n++xPendedTicks;\n\n/* The tick hook gets called at regular intervals, even if the\n        scheduler is locked. */\n#if ( configUSE_TICK_HOOK == 1 )\n{\nvApplicationTickHook();\n}\n#endif\n}\n\nreturn xSwitchRequired;\n}\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_APPLICATION_TASK_TAG == 1 )\n\nvoid vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )\n{\nTCB_t *xTCB;\n\n/* If xTask is NULL then it is the task hook of the calling task that is\n        getting set. */\nif( xTask == NULL )\n{\nxTCB = ( TCB_t * ) pxCurrentTCB;\n}\nelse\n{\nxTCB = xTask;\n}\n\n/* Save the hook function in the TCB.  A critical section is required as\n        the value can be accessed from an interrupt. */\ntaskENTER_CRITICAL();\n{\nxTCB-&gt;pxTaskTag = pxHookFunction;\n}\ntaskEXIT_CRITICAL();\n}\n\n#endif /* configUSE_APPLICATION_TASK_TAG */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_APPLICATION_TASK_TAG == 1 )\n\nTaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )\n{\nTCB_t *pxTCB;\nTaskHookFunction_t xReturn;\n\n/* If xTask is NULL then set the calling task's hook. */\npxTCB = prvGetTCBFromHandle( xTask );\n\n/* Save the hook function in the TCB.  A critical section is required as\n        the value can be accessed from an interrupt. */\ntaskENTER_CRITICAL();\n{\nxReturn = pxTCB-&gt;pxTaskTag;\n}\ntaskEXIT_CRITICAL();\n\nreturn xReturn;\n}\n\n#endif /* configUSE_APPLICATION_TASK_TAG */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_APPLICATION_TASK_TAG == 1 )\n\nTaskHookFunction_t xTaskGetApplicationTaskTagFromISR( TaskHandle_t xTask )\n{\nTCB_t *pxTCB;\nTaskHookFunction_t xReturn;\nUBaseType_t uxSavedInterruptStatus;\n\n/* If xTask is NULL then set the calling task's hook. */\npxTCB = prvGetTCBFromHandle( xTask );\n\n/* Save the hook function in the TCB.  A critical section is required as\n        the value can be accessed from an interrupt. */\nuxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();\n{\nxReturn = pxTCB-&gt;pxTaskTag;\n}\nportCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\n\nreturn xReturn;\n}\n\n#endif /* configUSE_APPLICATION_TASK_TAG */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_APPLICATION_TASK_TAG == 1 )\n\nBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )\n{\nTCB_t *xTCB;\nBaseType_t xReturn;\n\n/* If xTask is NULL then we are calling our own task hook. */\nif( xTask == NULL )\n{\nxTCB = pxCurrentTCB;\n}\nelse\n{\nxTCB = xTask;\n}\n\nif( xTCB-&gt;pxTaskTag != NULL )\n{\nxReturn = xTCB-&gt;pxTaskTag( pvParameter );\n}\nelse\n{\nxReturn = pdFAIL;\n}\n\nreturn xReturn;\n}\n\n#endif /* configUSE_APPLICATION_TASK_TAG */\n/*-----------------------------------------------------------*/\n\nvoid vTaskSwitchContext( void )\n{\nif( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )\n{\n/* The scheduler is currently suspended - do not allow a context\n        switch. */\nxYieldPending = pdTRUE;\n}\nelse\n{\nxYieldPending = pdFALSE;\ntraceTASK_SWITCHED_OUT();\n\n#if ( configGENERATE_RUN_TIME_STATS == 1 )\n{\n#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE\nportALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );\n#else\nulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();\n#endif\n\n/* Add the amount of time the task has been running to the\n            accumulated time so far.  The time the task started running was\n            stored in ulTaskSwitchedInTime.  Note that there is no overflow\n            protection here so count values are only valid until the timer\n            overflows.  The guard against negative values is to protect\n            against suspect run time stat counter implementations - which\n            are provided by the application, not the kernel. */\nif( ulTotalRunTime &gt; ulTaskSwitchedInTime )\n{\npxCurrentTCB-&gt;ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\nulTaskSwitchedInTime = ulTotalRunTime;\n}\n#endif /* configGENERATE_RUN_TIME_STATS */\n\n/* Check for stack overflow, if configured. */\ntaskCHECK_FOR_STACK_OVERFLOW();\n\n/* Before the currently running task is switched out, save its errno. */\n#if( configUSE_POSIX_ERRNO == 1 )\n{\npxCurrentTCB-&gt;iTaskErrno = FreeRTOS_errno;\n}\n#endif\n\n/* Select a new task to run using either the generic C or port\n        optimised asm code. */\ntaskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */\ntraceTASK_SWITCHED_IN();\n\n/* After the new task is switched in, update the global errno. */\n#if( configUSE_POSIX_ERRNO == 1 )\n{\nFreeRTOS_errno = pxCurrentTCB-&gt;iTaskErrno;\n}\n#endif\n\n#if ( configUSE_NEWLIB_REENTRANT == 1 )\n{\n/* Switch Newlib's _impure_ptr variable to point to the _reent\n            structure specific to this task.\n            See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html\n            for additional information. */\n_impure_ptr = &amp;( pxCurrentTCB-&gt;xNewLib_reent );\n}\n#endif /* configUSE_NEWLIB_REENTRANT */\n}\n}\n/*-----------------------------------------------------------*/\n\nvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )\n{\nconfigASSERT( pxEventList );\n\n/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE\n    SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */\n\n/* Place the event list item of the TCB in the appropriate event list.\n    This is placed in the list in priority order so the highest priority task\n    is the first to be woken by the event.  The queue that contains the event\n    list is locked, preventing simultaneous access from interrupts. */\nvListInsert( pxEventList, &amp;( pxCurrentTCB-&gt;xEventListItem ) );\n\nprvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );\n}\n/*-----------------------------------------------------------*/\n\nvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )\n{\nconfigASSERT( pxEventList );\n\n/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by\n    the event groups implementation. */\nconfigASSERT( uxSchedulerSuspended != 0 );\n\n/* Store the item value in the event list item.  It is safe to access the\n    event list item here as interrupts won't access the event list item of a\n    task that is not in the Blocked state. */\nlistSET_LIST_ITEM_VALUE( &amp;( pxCurrentTCB-&gt;xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );\n\n/* Place the event list item of the TCB at the end of the appropriate event\n    list.  It is safe to access the event list here because it is part of an\n    event group implementation - and interrupts don't access event groups\n    directly (instead they access them indirectly by pending function calls to\n    the task level). */\nvListInsertEnd( pxEventList, &amp;( pxCurrentTCB-&gt;xEventListItem ) );\n\nprvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );\n}\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TIMERS == 1 )\n\nvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )\n{\nconfigASSERT( pxEventList );\n\n/* This function should not be called by application code hence the\n        'Restricted' in its name.  It is not part of the public API.  It is\n        designed for use by kernel code, and has special calling requirements -\n        it should be called with the scheduler suspended. */\n\n\n/* Place the event list item of the TCB in the appropriate event list.\n        In this case it is assume that this is the only task that is going to\n        be waiting on this event list, so the faster vListInsertEnd() function\n        can be used in place of vListInsert. */\nvListInsertEnd( pxEventList, &amp;( pxCurrentTCB-&gt;xEventListItem ) );\n\n/* If the task should block indefinitely then set the block time to a\n        value that will be recognised as an indefinite delay inside the\n        prvAddCurrentTaskToDelayedList() function. */\nif( xWaitIndefinitely != pdFALSE )\n{\nxTicksToWait = portMAX_DELAY;\n}\n\ntraceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );\nprvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );\n}\n\n#endif /* configUSE_TIMERS */\n/*-----------------------------------------------------------*/\n\nBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )\n{\nTCB_t *pxUnblockedTCB;\nBaseType_t xReturn;\n\n/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be\n    called from a critical section within an ISR. */\n\n/* The event list is sorted in priority order, so the first in the list can\n    be removed as it is known to be the highest priority.  Remove the TCB from\n    the delayed list, and add it to the ready list.\n\n    If an event is for a queue that is locked then this function will never\n    get called - the lock count on the queue will get modified instead.  This\n    means exclusive access to the event list is guaranteed here.\n\n    This function assumes that a check has already been made to ensure that\n    pxEventList is not empty. */\npxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */\nconfigASSERT( pxUnblockedTCB );\n( void ) uxListRemove( &amp;( pxUnblockedTCB-&gt;xEventListItem ) );\n\nif( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )\n{\n( void ) uxListRemove( &amp;( pxUnblockedTCB-&gt;xStateListItem ) );\nprvAddTaskToReadyList( pxUnblockedTCB );\n\n#if( configUSE_TICKLESS_IDLE != 0 )\n{\n/* If a task is blocked on a kernel object then xNextTaskUnblockTime\n            might be set to the blocked task's time out time.  If the task is\n            unblocked for a reason other than a timeout xNextTaskUnblockTime is\n            normally left unchanged, because it is automatically reset to a new\n            value when the tick count equals xNextTaskUnblockTime.  However if\n            tickless idling is used it might be more important to enter sleep mode\n            at the earliest possible time - so reset xNextTaskUnblockTime here to\n            ensure it is updated at the earliest possible time. */\nprvResetNextTaskUnblockTime();\n}\n#endif\n}\nelse\n{\n/* The delayed and ready lists cannot be accessed, so hold this task\n        pending until the scheduler is resumed. */\nvListInsertEnd( &amp;( xPendingReadyList ), &amp;( pxUnblockedTCB-&gt;xEventListItem ) );\n}\n\nif( pxUnblockedTCB-&gt;uxPriority &gt; pxCurrentTCB-&gt;uxPriority )\n{\n/* Return true if the task removed from the event list has a higher\n        priority than the calling task.  This allows the calling task to know if\n        it should force a context switch now. */\nxReturn = pdTRUE;\n\n/* Mark that a yield is pending in case the user is not using the\n        \"xHigherPriorityTaskWoken\" parameter to an ISR safe FreeRTOS function. */\nxYieldPending = pdTRUE;\n}\nelse\n{\nxReturn = pdFALSE;\n}\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nvoid vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )\n{\nTCB_t *pxUnblockedTCB;\n\n/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by\n    the event flags implementation. */\nconfigASSERT( uxSchedulerSuspended != pdFALSE );\n\n/* Store the new item value in the event list. */\nlistSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );\n\n/* Remove the event list form the event flag.  Interrupts do not access\n    event flags. */\npxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */\nconfigASSERT( pxUnblockedTCB );\n( void ) uxListRemove( pxEventListItem );\n\n#if( configUSE_TICKLESS_IDLE != 0 )\n{\n/* If a task is blocked on a kernel object then xNextTaskUnblockTime\n        might be set to the blocked task's time out time.  If the task is\n        unblocked for a reason other than a timeout xNextTaskUnblockTime is\n        normally left unchanged, because it is automatically reset to a new\n        value when the tick count equals xNextTaskUnblockTime.  However if\n        tickless idling is used it might be more important to enter sleep mode\n        at the earliest possible time - so reset xNextTaskUnblockTime here to\n        ensure it is updated at the earliest possible time. */\nprvResetNextTaskUnblockTime();\n}\n#endif\n\n/* Remove the task from the delayed list and add it to the ready list.  The\n    scheduler is suspended so interrupts will not be accessing the ready\n    lists. */\n( void ) uxListRemove( &amp;( pxUnblockedTCB-&gt;xStateListItem ) );\nprvAddTaskToReadyList( pxUnblockedTCB );\n\nif( pxUnblockedTCB-&gt;uxPriority &gt; pxCurrentTCB-&gt;uxPriority )\n{\n/* The unblocked task has a priority above that of the calling task, so\n        a context switch is required.  This function is called with the\n        scheduler suspended so xYieldPending is set so the context switch\n        occurs immediately that the scheduler is resumed (unsuspended). */\nxYieldPending = pdTRUE;\n}\n}\n/*-----------------------------------------------------------*/\n\nvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )\n{\nconfigASSERT( pxTimeOut );\ntaskENTER_CRITICAL();\n{\npxTimeOut-&gt;xOverflowCount = xNumOfOverflows;\npxTimeOut-&gt;xTimeOnEntering = xTickCount;\n}\ntaskEXIT_CRITICAL();\n}\n/*-----------------------------------------------------------*/\n\nvoid vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )\n{\n/* For internal use only as it does not use a critical section. */\npxTimeOut-&gt;xOverflowCount = xNumOfOverflows;\npxTimeOut-&gt;xTimeOnEntering = xTickCount;\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )\n{\nBaseType_t xReturn;\n\nconfigASSERT( pxTimeOut );\nconfigASSERT( pxTicksToWait );\n\ntaskENTER_CRITICAL();\n{\n/* Minor optimisation.  The tick count cannot change in this block. */\nconst TickType_t xConstTickCount = xTickCount;\nconst TickType_t xElapsedTime = xConstTickCount - pxTimeOut-&gt;xTimeOnEntering;\n\n#if( INCLUDE_xTaskAbortDelay == 1 )\nif( pxCurrentTCB-&gt;ucDelayAborted != ( uint8_t ) pdFALSE )\n{\n/* The delay was aborted, which is not the same as a time out,\n                but has the same result. */\npxCurrentTCB-&gt;ucDelayAborted = pdFALSE;\nxReturn = pdTRUE;\n}\nelse\n#endif\n\n#if ( INCLUDE_vTaskSuspend == 1 )\nif( *pxTicksToWait == portMAX_DELAY )\n{\n/* If INCLUDE_vTaskSuspend is set to 1 and the block time\n                specified is the maximum block time then the task should block\n                indefinitely, and therefore never time out. */\nxReturn = pdFALSE;\n}\nelse\n#endif\n\nif( ( xNumOfOverflows != pxTimeOut-&gt;xOverflowCount ) &amp;&amp; ( xConstTickCount &gt;= pxTimeOut-&gt;xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */\n{\n/* The tick count is greater than the time at which\n            vTaskSetTimeout() was called, but has also overflowed since\n            vTaskSetTimeOut() was called.  It must have wrapped all the way\n            around and gone past again. This passed since vTaskSetTimeout()\n            was called. */\nxReturn = pdTRUE;\n}\nelse if( xElapsedTime &lt; *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */\n{\n/* Not a genuine timeout. Adjust parameters for time remaining. */\n*pxTicksToWait -= xElapsedTime;\nvTaskInternalSetTimeOutState( pxTimeOut );\nxReturn = pdFALSE;\n}\nelse\n{\n*pxTicksToWait = 0;\nxReturn = pdTRUE;\n}\n}\ntaskEXIT_CRITICAL();\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nvoid vTaskMissedYield( void )\n{\nxYieldPending = pdTRUE;\n}\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_TRACE_FACILITY == 1 )\n\nUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )\n{\nUBaseType_t uxReturn;\nTCB_t const *pxTCB;\n\nif( xTask != NULL )\n{\npxTCB = xTask;\nuxReturn = pxTCB-&gt;uxTaskNumber;\n}\nelse\n{\nuxReturn = 0U;\n}\n\nreturn uxReturn;\n}\n\n#endif /* configUSE_TRACE_FACILITY */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_TRACE_FACILITY == 1 )\n\nvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )\n{\nTCB_t * pxTCB;\n\nif( xTask != NULL )\n{\npxTCB = xTask;\npxTCB-&gt;uxTaskNumber = uxHandle;\n}\n}\n\n#endif /* configUSE_TRACE_FACILITY */\n\n/*\n * -----------------------------------------------------------\n * The Idle task.\n * ----------------------------------------------------------\n *\n * The portTASK_FUNCTION() macro is used to allow port/compiler specific\n * language extensions.  The equivalent prototype for this function is:\n *\n * void prvIdleTask( void *pvParameters );\n *\n */\nstatic portTASK_FUNCTION( prvIdleTask, pvParameters )\n{\n/* Stop warnings. */\n( void ) pvParameters;\n\n/* In case a task that has a secure context deletes itself, in which case\n    the idle task is responsible for deleting the task's secure context, if\n    any. */\nportALLOCATE_SECURE_CONTEXT( configMINIMAL_SECURE_STACK_SIZE );\n\nfor( ;; )\n{\n/* See if any tasks have deleted themselves - if so then the idle task\n        is responsible for freeing the deleted task's TCB and stack. */\nprvCheckTasksWaitingTermination();\n\n#if ( configUSE_PREEMPTION == 0 )\n{\n/* If we are not using preemption we keep forcing a task switch to\n            see if any other task has become available.  If we are using\n            preemption we don't need to do this as any task becoming available\n            will automatically get the processor anyway. */\ntaskYIELD();\n}\n#endif /* configUSE_PREEMPTION */\n\n#if ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configIDLE_SHOULD_YIELD == 1 ) )\n{\n/* When using preemption tasks of equal priority will be\n            timesliced.  If a task that is sharing the idle priority is ready\n            to run then the idle task should yield before the end of the\n            timeslice.\n\n            A critical region is not required here as we are just reading from\n            the list, and an occasional incorrect value will not matter.  If\n            the ready list at the idle priority contains more than one task\n            then a task other than the idle task is ready to execute. */\nif( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) &gt; ( UBaseType_t ) 1 )\n{\ntaskYIELD();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n#endif /* ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configIDLE_SHOULD_YIELD == 1 ) ) */\n\n#if ( configUSE_IDLE_HOOK == 1 )\n{\nextern void vApplicationIdleHook( void );\n\n/* Call the user defined function from within the idle task.  This\n            allows the application designer to add background functionality\n            without the overhead of a separate task.\n            NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,\n            CALL A FUNCTION THAT MIGHT BLOCK. */\nvApplicationIdleHook();\n}\n#endif /* configUSE_IDLE_HOOK */\n\n/* This conditional compilation should use inequality to 0, not equality\n        to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when\n        user defined low power mode implementations require\n        configUSE_TICKLESS_IDLE to be set to a value other than 1. */\n#if ( configUSE_TICKLESS_IDLE != 0 )\n{\nTickType_t xExpectedIdleTime;\n\n/* It is not desirable to suspend then resume the scheduler on\n            each iteration of the idle task.  Therefore, a preliminary\n            test of the expected idle time is performed without the\n            scheduler suspended.  The result here is not necessarily\n            valid. */\nxExpectedIdleTime = prvGetExpectedIdleTime();\n\nif( xExpectedIdleTime &gt;= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )\n{\nvTaskSuspendAll();\n{\n/* Now the scheduler is suspended, the expected idle\n                    time can be sampled again, and this time its value can\n                    be used. */\nconfigASSERT( xNextTaskUnblockTime &gt;= xTickCount );\nxExpectedIdleTime = prvGetExpectedIdleTime();\n\n/* Define the following macro to set xExpectedIdleTime to 0\n                    if the application does not want\n                    portSUPPRESS_TICKS_AND_SLEEP() to be called. */\nconfigPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );\n\nif( xExpectedIdleTime &gt;= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )\n{\ntraceLOW_POWER_IDLE_BEGIN();\nportSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );\ntraceLOW_POWER_IDLE_END();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n( void ) xTaskResumeAll();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n#endif /* configUSE_TICKLESS_IDLE */\n}\n}\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TICKLESS_IDLE != 0 )\n\neSleepModeStatus eTaskConfirmSleepModeStatus( void )\n{\n/* The idle task exists in addition to the application tasks. */\nconst UBaseType_t uxNonApplicationTasks = 1;\neSleepModeStatus eReturn = eStandardSleep;\n\n/* This function must be called from a critical section. */\n\nif( listCURRENT_LIST_LENGTH( &amp;xPendingReadyList ) != 0 )\n{\n/* A task was made ready while the scheduler was suspended. */\neReturn = eAbortSleep;\n}\nelse if( xYieldPending != pdFALSE )\n{\n/* A yield was pended while the scheduler was suspended. */\neReturn = eAbortSleep;\n}\nelse\n{\n/* If all the tasks are in the suspended list (which might mean they\n            have an infinite block time rather than actually being suspended)\n            then it is safe to turn all clocks off and just wait for external\n            interrupts. */\nif( listCURRENT_LIST_LENGTH( &amp;xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )\n{\neReturn = eNoTasksWaitingTimeout;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n\nreturn eReturn;\n}\n\n#endif /* configUSE_TICKLESS_IDLE */\n/*-----------------------------------------------------------*/\n\n#if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )\n\nvoid vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue )\n{\nTCB_t *pxTCB;\n\nif( xIndex &lt; configNUM_THREAD_LOCAL_STORAGE_POINTERS )\n{\npxTCB = prvGetTCBFromHandle( xTaskToSet );\nconfigASSERT( pxTCB != NULL );\npxTCB-&gt;pvThreadLocalStoragePointers[ xIndex ] = pvValue;\n}\n}\n\n#endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */\n/*-----------------------------------------------------------*/\n\n#if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )\n\nvoid *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )\n{\nvoid *pvReturn = NULL;\nTCB_t *pxTCB;\n\nif( xIndex &lt; configNUM_THREAD_LOCAL_STORAGE_POINTERS )\n{\npxTCB = prvGetTCBFromHandle( xTaskToQuery );\npvReturn = pxTCB-&gt;pvThreadLocalStoragePointers[ xIndex ];\n}\nelse\n{\npvReturn = NULL;\n}\n\nreturn pvReturn;\n}\n\n#endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */\n/*-----------------------------------------------------------*/\n\n#if ( portUSING_MPU_WRAPPERS == 1 )\n\nvoid vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )\n{\nTCB_t *pxTCB;\n\n/* If null is passed in here then we are modifying the MPU settings of\n        the calling task. */\npxTCB = prvGetTCBFromHandle( xTaskToModify );\n\nvPortStoreTaskMPUSettings( &amp;( pxTCB-&gt;xMPUSettings ), xRegions, NULL, 0 );\n}\n\n#endif /* portUSING_MPU_WRAPPERS */\n/*-----------------------------------------------------------*/\n\nstatic void prvInitialiseTaskLists( void )\n{\nUBaseType_t uxPriority;\n\nfor( uxPriority = ( UBaseType_t ) 0U; uxPriority &lt; ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )\n{\nvListInitialise( &amp;( pxReadyTasksLists[ uxPriority ] ) );\n}\n\nvListInitialise( &amp;xDelayedTaskList1 );\nvListInitialise( &amp;xDelayedTaskList2 );\nvListInitialise( &amp;xPendingReadyList );\n\n#if ( INCLUDE_vTaskDelete == 1 )\n{\nvListInitialise( &amp;xTasksWaitingTermination );\n}\n#endif /* INCLUDE_vTaskDelete */\n\n#if ( INCLUDE_vTaskSuspend == 1 )\n{\nvListInitialise( &amp;xSuspendedTaskList );\n}\n#endif /* INCLUDE_vTaskSuspend */\n\n/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList\n    using list2. */\npxDelayedTaskList = &amp;xDelayedTaskList1;\npxOverflowDelayedTaskList = &amp;xDelayedTaskList2;\n}\n/*-----------------------------------------------------------*/\n\nstatic void prvCheckTasksWaitingTermination( void )\n{\n\n#if ( INCLUDE_vTaskDelete == 1 )\n{\nTCB_t *pxTCB;\n\n/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()\n        being called too often in the idle task. */\nwhile( uxDeletedTasksWaitingCleanUp &gt; ( UBaseType_t ) 0U )\n{\ntaskENTER_CRITICAL();\n{\npxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &amp;xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */\n( void ) uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) );\n--uxCurrentNumberOfTasks;\n--uxDeletedTasksWaitingCleanUp;\n}\ntaskEXIT_CRITICAL();\n\nprvDeleteTCB( pxTCB );\n}\n}\n#endif /* INCLUDE_vTaskDelete */\n}\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TRACE_FACILITY == 1 )\n\nvoid vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )\n{\nTCB_t *pxTCB;\n\n/* xTask is NULL then get the state of the calling task. */\npxTCB = prvGetTCBFromHandle( xTask );\n\npxTaskStatus-&gt;xHandle = ( TaskHandle_t ) pxTCB;\npxTaskStatus-&gt;pcTaskName = ( const char * ) &amp;( pxTCB-&gt;pcTaskName [ 0 ] );\npxTaskStatus-&gt;uxCurrentPriority = pxTCB-&gt;uxPriority;\npxTaskStatus-&gt;pxStackBase = pxTCB-&gt;pxStack;\npxTaskStatus-&gt;xTaskNumber = pxTCB-&gt;uxTCBNumber;\n\n#if ( configUSE_MUTEXES == 1 )\n{\npxTaskStatus-&gt;uxBasePriority = pxTCB-&gt;uxBasePriority;\n}\n#else\n{\npxTaskStatus-&gt;uxBasePriority = 0;\n}\n#endif\n\n#if ( configGENERATE_RUN_TIME_STATS == 1 )\n{\npxTaskStatus-&gt;ulRunTimeCounter = pxTCB-&gt;ulRunTimeCounter;\n}\n#else\n{\npxTaskStatus-&gt;ulRunTimeCounter = 0;\n}\n#endif\n\n/* Obtaining the task state is a little fiddly, so is only done if the\n        value of eState passed into this function is eInvalid - otherwise the\n        state is just set to whatever is passed in. */\nif( eState != eInvalid )\n{\nif( pxTCB == pxCurrentTCB )\n{\npxTaskStatus-&gt;eCurrentState = eRunning;\n}\nelse\n{\npxTaskStatus-&gt;eCurrentState = eState;\n\n#if ( INCLUDE_vTaskSuspend == 1 )\n{\n/* If the task is in the suspended list then there is a\n                    chance it is actually just blocked indefinitely - so really\n                    it should be reported as being in the Blocked state. */\nif( eState == eSuspended )\n{\nvTaskSuspendAll();\n{\nif( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != NULL )\n{\npxTaskStatus-&gt;eCurrentState = eBlocked;\n}\n}\n( void ) xTaskResumeAll();\n}\n}\n#endif /* INCLUDE_vTaskSuspend */\n}\n}\nelse\n{\npxTaskStatus-&gt;eCurrentState = eTaskGetState( pxTCB );\n}\n\n/* Obtaining the stack space takes some time, so the xGetFreeStackSpace\n        parameter is provided to allow it to be skipped. */\nif( xGetFreeStackSpace != pdFALSE )\n{\n#if ( portSTACK_GROWTH &gt; 0 )\n{\npxTaskStatus-&gt;usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB-&gt;pxEndOfStack );\n}\n#else\n{\npxTaskStatus-&gt;usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB-&gt;pxStack );\n}\n#endif\n}\nelse\n{\npxTaskStatus-&gt;usStackHighWaterMark = 0;\n}\n}\n\n#endif /* configUSE_TRACE_FACILITY */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_TRACE_FACILITY == 1 )\n\nstatic UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )\n{\nconfigLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;\nUBaseType_t uxTask = 0;\n\nif( listCURRENT_LIST_LENGTH( pxList ) &gt; ( UBaseType_t ) 0 )\n{\nlistGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */\n\n/* Populate an TaskStatus_t structure within the\n            pxTaskStatusArray array for each task that is referenced from\n            pxList.  See the definition of TaskStatus_t in task.h for the\n            meaning of each TaskStatus_t structure member. */\ndo\n{\nlistGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */\nvTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &amp;( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );\nuxTask++;\n} while( pxNextTCB != pxFirstTCB );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nreturn uxTask;\n}\n\n#endif /* configUSE_TRACE_FACILITY */\n/*-----------------------------------------------------------*/\n\n#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )\n\nstatic configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )\n{\nuint32_t ulCount = 0U;\n\nwhile( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )\n{\npucStackByte -= portSTACK_GROWTH;\nulCount++;\n}\n\nulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */\n\nreturn ( configSTACK_DEPTH_TYPE ) ulCount;\n}\n\n#endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) ) */\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 )\n\n/* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the\n    same except for their return type.  Using configSTACK_DEPTH_TYPE allows the\n    user to determine the return type.  It gets around the problem of the value\n    overflowing on 8-bit types without breaking backward compatibility for\n    applications that expect an 8-bit return type. */\nconfigSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask )\n{\nTCB_t *pxTCB;\nuint8_t *pucEndOfStack;\nconfigSTACK_DEPTH_TYPE uxReturn;\n\n/* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are\n        the same except for their return type.  Using configSTACK_DEPTH_TYPE\n        allows the user to determine the return type.  It gets around the\n        problem of the value overflowing on 8-bit types without breaking\n        backward compatibility for applications that expect an 8-bit return\n        type. */\n\npxTCB = prvGetTCBFromHandle( xTask );\n\n#if portSTACK_GROWTH &lt; 0\n{\npucEndOfStack = ( uint8_t * ) pxTCB-&gt;pxStack;\n}\n#else\n{\npucEndOfStack = ( uint8_t * ) pxTCB-&gt;pxEndOfStack;\n}\n#endif\n\nuxReturn = prvTaskCheckFreeStackSpace( pucEndOfStack );\n\nreturn uxReturn;\n}\n\n#endif /* INCLUDE_uxTaskGetStackHighWaterMark2 */\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )\n\nUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )\n{\nTCB_t *pxTCB;\nuint8_t *pucEndOfStack;\nUBaseType_t uxReturn;\n\npxTCB = prvGetTCBFromHandle( xTask );\n\n#if portSTACK_GROWTH &lt; 0\n{\npucEndOfStack = ( uint8_t * ) pxTCB-&gt;pxStack;\n}\n#else\n{\npucEndOfStack = ( uint8_t * ) pxTCB-&gt;pxEndOfStack;\n}\n#endif\n\nuxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );\n\nreturn uxReturn;\n}\n\n#endif /* INCLUDE_uxTaskGetStackHighWaterMark */\n/*-----------------------------------------------------------*/\n\n#if ( INCLUDE_vTaskDelete == 1 )\n\nstatic void prvDeleteTCB( TCB_t *pxTCB )\n{\n/* This call is required specifically for the TriCore port.  It must be\n        above the vPortFree() calls.  The call is also used by ports/demos that\n        want to allocate and clean RAM statically. */\nportCLEAN_UP_TCB( pxTCB );\n\n/* Free up the memory allocated by the scheduler for the task.  It is up\n        to the task to free any memory allocated at the application level.\n        See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html\n        for additional information. */\n#if ( configUSE_NEWLIB_REENTRANT == 1 )\n{\n_reclaim_reent( &amp;( pxTCB-&gt;xNewLib_reent ) );\n}\n#endif /* configUSE_NEWLIB_REENTRANT */\n\n#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 0 ) &amp;&amp; ( portUSING_MPU_WRAPPERS == 0 ) )\n{\n/* The task can only have been allocated dynamically - free both\n            the stack and TCB. */\nvPortFree( pxTCB-&gt;pxStack );\nvPortFree( pxTCB );\n}\n#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */\n{\n/* The task could have been allocated statically or dynamically, so\n            check what was statically allocated before trying to free the\n            memory. */\nif( pxTCB-&gt;ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )\n{\n/* Both the stack and TCB were allocated dynamically, so both\n                must be freed. */\nvPortFree( pxTCB-&gt;pxStack );\nvPortFree( pxTCB );\n}\nelse if( pxTCB-&gt;ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )\n{\n/* Only the stack was statically allocated, so the TCB is the\n                only memory that must be freed. */\nvPortFree( pxTCB );\n}\nelse\n{\n/* Neither the stack nor the TCB were allocated dynamically, so\n                nothing needs to be freed. */\nconfigASSERT( pxTCB-&gt;ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );\nmtCOVERAGE_TEST_MARKER();\n}\n}\n#endif /* configSUPPORT_DYNAMIC_ALLOCATION */\n}\n\n#endif /* INCLUDE_vTaskDelete */\n/*-----------------------------------------------------------*/\n\nstatic void prvResetNextTaskUnblockTime( void )\n{\nTCB_t *pxTCB;\n\nif( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )\n{\n/* The new current delayed list is empty.  Set xNextTaskUnblockTime to\n        the maximum possible value so it is extremely unlikely that the\n        if( xTickCount &gt;= xNextTaskUnblockTime ) test will pass until\n        there is an item in the delayed list. */\nxNextTaskUnblockTime = portMAX_DELAY;\n}\nelse\n{\n/* The new current delayed list is not empty, get the value of\n        the item at the head of the delayed list.  This is the time at\n        which the task at the head of the delayed list should be removed\n        from the Blocked state. */\n( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */\nxNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &amp;( ( pxTCB )-&gt;xStateListItem ) );\n}\n}\n/*-----------------------------------------------------------*/\n\n#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )\n\nTaskHandle_t xTaskGetCurrentTaskHandle( void )\n{\nTaskHandle_t xReturn;\n\n/* A critical section is not required as this is not called from\n        an interrupt and the current TCB will always be the same for any\n        individual execution thread. */\nxReturn = pxCurrentTCB;\n\nreturn xReturn;\n}\n\n#endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */\n/*-----------------------------------------------------------*/\n\n#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )\n\nBaseType_t xTaskGetSchedulerState( void )\n{\nBaseType_t xReturn;\n\nif( xSchedulerRunning == pdFALSE )\n{\nxReturn = taskSCHEDULER_NOT_STARTED;\n}\nelse\n{\nif( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )\n{\nxReturn = taskSCHEDULER_RUNNING;\n}\nelse\n{\nxReturn = taskSCHEDULER_SUSPENDED;\n}\n}\n\nreturn xReturn;\n}\n\n#endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_MUTEXES == 1 )\n\nBaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )\n{\nTCB_t * const pxMutexHolderTCB = pxMutexHolder;\nBaseType_t xReturn = pdFALSE;\n\n/* If the mutex was given back by an interrupt while the queue was\n        locked then the mutex holder might now be NULL.  _RB_ Is this still\n        needed as interrupts can no longer use mutexes? */\nif( pxMutexHolder != NULL )\n{\n/* If the holder of the mutex has a priority below the priority of\n            the task attempting to obtain the mutex then it will temporarily\n            inherit the priority of the task attempting to obtain the mutex. */\nif( pxMutexHolderTCB-&gt;uxPriority &lt; pxCurrentTCB-&gt;uxPriority )\n{\n/* Adjust the mutex holder state to account for its new\n                priority.  Only reset the event list item value if the value is\n                not being used for anything else. */\nif( ( listGET_LIST_ITEM_VALUE( &amp;( pxMutexHolderTCB-&gt;xEventListItem ) ) &amp; taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )\n{\nlistSET_LIST_ITEM_VALUE( &amp;( pxMutexHolderTCB-&gt;xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB-&gt;uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\n/* If the task being modified is in the ready state it will need\n                to be moved into a new list. */\nif( listIS_CONTAINED_WITHIN( &amp;( pxReadyTasksLists[ pxMutexHolderTCB-&gt;uxPriority ] ), &amp;( pxMutexHolderTCB-&gt;xStateListItem ) ) != pdFALSE )\n{\nif( uxListRemove( &amp;( pxMutexHolderTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) 0 )\n{\n/* It is known that the task is in its ready list so\n                        there is no need to check again and the port level\n                        reset macro can be called directly. */\nportRESET_READY_PRIORITY( pxMutexHolderTCB-&gt;uxPriority, uxTopReadyPriority );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\n/* Inherit the priority before being moved into the new list. */\npxMutexHolderTCB-&gt;uxPriority = pxCurrentTCB-&gt;uxPriority;\nprvAddTaskToReadyList( pxMutexHolderTCB );\n}\nelse\n{\n/* Just inherit the priority. */\npxMutexHolderTCB-&gt;uxPriority = pxCurrentTCB-&gt;uxPriority;\n}\n\ntraceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB-&gt;uxPriority );\n\n/* Inheritance occurred. */\nxReturn = pdTRUE;\n}\nelse\n{\nif( pxMutexHolderTCB-&gt;uxBasePriority &lt; pxCurrentTCB-&gt;uxPriority )\n{\n/* The base priority of the mutex holder is lower than the\n                    priority of the task attempting to take the mutex, but the\n                    current priority of the mutex holder is not lower than the\n                    priority of the task attempting to take the mutex.\n                    Therefore the mutex holder must have already inherited a\n                    priority, but inheritance would have occurred if that had\n                    not been the case. */\nxReturn = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nreturn xReturn;\n}\n\n#endif /* configUSE_MUTEXES */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_MUTEXES == 1 )\n\nBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )\n{\nTCB_t * const pxTCB = pxMutexHolder;\nBaseType_t xReturn = pdFALSE;\n\nif( pxMutexHolder != NULL )\n{\n/* A task can only have an inherited priority if it holds the mutex.\n            If the mutex is held by a task then it cannot be given from an\n            interrupt, and if a mutex is given by the holding task then it must\n            be the running state task. */\nconfigASSERT( pxTCB == pxCurrentTCB );\nconfigASSERT( pxTCB-&gt;uxMutexesHeld );\n( pxTCB-&gt;uxMutexesHeld )--;\n\n/* Has the holder of the mutex inherited the priority of another\n            task? */\nif( pxTCB-&gt;uxPriority != pxTCB-&gt;uxBasePriority )\n{\n/* Only disinherit if no other mutexes are held. */\nif( pxTCB-&gt;uxMutexesHeld == ( UBaseType_t ) 0 )\n{\n/* A task can only have an inherited priority if it holds\n                    the mutex.  If the mutex is held by a task then it cannot be\n                    given from an interrupt, and if a mutex is given by the\n                    holding task then it must be the running state task.  Remove\n                    the holding task from the ready/delayed list. */\nif( uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) 0 )\n{\ntaskRESET_READY_PRIORITY( pxTCB-&gt;uxPriority );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\n/* Disinherit the priority before adding the task into the\n                    new ready list. */\ntraceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB-&gt;uxBasePriority );\npxTCB-&gt;uxPriority = pxTCB-&gt;uxBasePriority;\n\n/* Reset the event list item value.  It cannot be in use for\n                    any other purpose if this task is running, and it must be\n                    running to give back the mutex. */\nlistSET_LIST_ITEM_VALUE( &amp;( pxTCB-&gt;xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB-&gt;uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\nprvAddTaskToReadyList( pxTCB );\n\n/* Return true to indicate that a context switch is required.\n                    This is only actually required in the corner case whereby\n                    multiple mutexes were held and the mutexes were given back\n                    in an order different to that in which they were taken.\n                    If a context switch did not occur when the first mutex was\n                    returned, even if a task was waiting on it, then a context\n                    switch should occur when the last mutex is returned whether\n                    a task is waiting on it or not. */\nxReturn = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nreturn xReturn;\n}\n\n#endif /* configUSE_MUTEXES */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_MUTEXES == 1 )\n\nvoid vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )\n{\nTCB_t * const pxTCB = pxMutexHolder;\nUBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;\nconst UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;\n\nif( pxMutexHolder != NULL )\n{\n/* If pxMutexHolder is not NULL then the holder must hold at least\n            one mutex. */\nconfigASSERT( pxTCB-&gt;uxMutexesHeld );\n\n/* Determine the priority to which the priority of the task that\n            holds the mutex should be set.  This will be the greater of the\n            holding task's base priority and the priority of the highest\n            priority task that is waiting to obtain the mutex. */\nif( pxTCB-&gt;uxBasePriority &lt; uxHighestPriorityWaitingTask )\n{\nuxPriorityToUse = uxHighestPriorityWaitingTask;\n}\nelse\n{\nuxPriorityToUse = pxTCB-&gt;uxBasePriority;\n}\n\n/* Does the priority need to change? */\nif( pxTCB-&gt;uxPriority != uxPriorityToUse )\n{\n/* Only disinherit if no other mutexes are held.  This is a\n                simplification in the priority inheritance implementation.  If\n                the task that holds the mutex is also holding other mutexes then\n                the other mutexes may have caused the priority inheritance. */\nif( pxTCB-&gt;uxMutexesHeld == uxOnlyOneMutexHeld )\n{\n/* If a task has timed out because it already holds the\n                    mutex it was trying to obtain then it cannot of inherited\n                    its own priority. */\nconfigASSERT( pxTCB != pxCurrentTCB );\n\n/* Disinherit the priority, remembering the previous\n                    priority to facilitate determining the subject task's\n                    state. */\ntraceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB-&gt;uxBasePriority );\nuxPriorityUsedOnEntry = pxTCB-&gt;uxPriority;\npxTCB-&gt;uxPriority = uxPriorityToUse;\n\n/* Only reset the event list item value if the value is not\n                    being used for anything else. */\nif( ( listGET_LIST_ITEM_VALUE( &amp;( pxTCB-&gt;xEventListItem ) ) &amp; taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )\n{\nlistSET_LIST_ITEM_VALUE( &amp;( pxTCB-&gt;xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\n/* If the running task is not the task that holds the mutex\n                    then the task that holds the mutex could be in either the\n                    Ready, Blocked or Suspended states.  Only remove the task\n                    from its current state list if it is in the Ready state as\n                    the task's priority is going to change and there is one\n                    Ready list per priority. */\nif( listIS_CONTAINED_WITHIN( &amp;( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &amp;( pxTCB-&gt;xStateListItem ) ) != pdFALSE )\n{\nif( uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) 0 )\n{\n/* It is known that the task is in its ready list so\n                            there is no need to check again and the port level\n                            reset macro can be called directly. */\nportRESET_READY_PRIORITY( pxTCB-&gt;uxPriority, uxTopReadyPriority );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nprvAddTaskToReadyList( pxTCB );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n\n#endif /* configUSE_MUTEXES */\n/*-----------------------------------------------------------*/\n\n#if ( portCRITICAL_NESTING_IN_TCB == 1 )\n\nvoid vTaskEnterCritical( void )\n{\nportDISABLE_INTERRUPTS();\n\nif( xSchedulerRunning != pdFALSE )\n{\n( pxCurrentTCB-&gt;uxCriticalNesting )++;\n\n/* This is not the interrupt safe version of the enter critical\n            function so assert() if it is being called from an interrupt\n            context.  Only API functions that end in \"FromISR\" can be used in an\n            interrupt.  Only assert if the critical nesting count is 1 to\n            protect against recursive calls if the assert function also uses a\n            critical section. */\nif( pxCurrentTCB-&gt;uxCriticalNesting == 1 )\n{\nportASSERT_IF_IN_ISR();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n\n#endif /* portCRITICAL_NESTING_IN_TCB */\n/*-----------------------------------------------------------*/\n\n#if ( portCRITICAL_NESTING_IN_TCB == 1 )\n\nvoid vTaskExitCritical( void )\n{\nif( xSchedulerRunning != pdFALSE )\n{\nif( pxCurrentTCB-&gt;uxCriticalNesting &gt; 0U )\n{\n( pxCurrentTCB-&gt;uxCriticalNesting )--;\n\nif( pxCurrentTCB-&gt;uxCriticalNesting == 0U )\n{\nportENABLE_INTERRUPTS();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n\n#endif /* portCRITICAL_NESTING_IN_TCB */\n/*-----------------------------------------------------------*/\n\n#if ( ( configUSE_TRACE_FACILITY == 1 ) &amp;&amp; ( configUSE_STATS_FORMATTING_FUNCTIONS &gt; 0 ) )\n\nstatic char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )\n{\nsize_t x;\n\n/* Start by copying the entire string. */\nstrcpy( pcBuffer, pcTaskName );\n\n/* Pad the end of the string with spaces to ensure columns line up when\n        printed out. */\nfor( x = strlen( pcBuffer ); x &lt; ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )\n{\npcBuffer[ x ] = ' ';\n}\n\n/* Terminate. */\npcBuffer[ x ] = ( char ) 0x00;\n\n/* Return the new end of string. */\nreturn &amp;( pcBuffer[ x ] );\n}\n\n#endif /* ( configUSE_TRACE_FACILITY == 1 ) &amp;&amp; ( configUSE_STATS_FORMATTING_FUNCTIONS &gt; 0 ) */\n/*-----------------------------------------------------------*/\n\n#if ( ( configUSE_TRACE_FACILITY == 1 ) &amp;&amp; ( configUSE_STATS_FORMATTING_FUNCTIONS &gt; 0 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )\n\nvoid vTaskList( char * pcWriteBuffer )\n{\nTaskStatus_t *pxTaskStatusArray;\nUBaseType_t uxArraySize, x;\nchar cStatus;\n\n/*\n         * PLEASE NOTE:\n         *\n         * This function is provided for convenience only, and is used by many\n         * of the demo applications.  Do not consider it to be part of the\n         * scheduler.\n         *\n         * vTaskList() calls uxTaskGetSystemState(), then formats part of the\n         * uxTaskGetSystemState() output into a human readable table that\n         * displays task names, states and stack usage.\n         *\n         * vTaskList() has a dependency on the sprintf() C library function that\n         * might bloat the code size, use a lot of stack, and provide different\n         * results on different platforms.  An alternative, tiny, third party,\n         * and limited functionality implementation of sprintf() is provided in\n         * many of the FreeRTOS/Demo sub-directories in a file called\n         * printf-stdarg.c (note printf-stdarg.c does not provide a full\n         * snprintf() implementation!).\n         *\n         * It is recommended that production systems call uxTaskGetSystemState()\n         * directly to get access to raw stats data, rather than indirectly\n         * through a call to vTaskList().\n         */\n\n\n/* Make sure the write buffer does not contain a string. */\n*pcWriteBuffer = ( char ) 0x00;\n\n/* Take a snapshot of the number of tasks in case it changes while this\n        function is executing. */\nuxArraySize = uxCurrentNumberOfTasks;\n\n/* Allocate an array index for each task.  NOTE!  if\n        configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will\n        equate to NULL. */\npxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */\n\nif( pxTaskStatusArray != NULL )\n{\n/* Generate the (binary) data. */\nuxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );\n\n/* Create a human readable table from the binary data. */\nfor( x = 0; x &lt; uxArraySize; x++ )\n{\nswitch( pxTaskStatusArray[ x ].eCurrentState )\n{\ncase eRunning:      cStatus = tskRUNNING_CHAR;\nbreak;\n\ncase eReady:        cStatus = tskREADY_CHAR;\nbreak;\n\ncase eBlocked:      cStatus = tskBLOCKED_CHAR;\nbreak;\n\ncase eSuspended:    cStatus = tskSUSPENDED_CHAR;\nbreak;\n\ncase eDeleted:      cStatus = tskDELETED_CHAR;\nbreak;\n\ncase eInvalid:      /* Fall through. */\ndefault:            /* Should not get here, but it is included\n                                        to prevent static checking errors. */\ncStatus = ( char ) 0x00;\nbreak;\n}\n\n/* Write the task name to the string, padding with spaces so it\n                can be printed in tabular form more easily. */\npcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );\n\n/* Write the rest of the string. */\nsprintf( pcWriteBuffer, \"\\t%c\\t%u\\t%u\\t%u\\r\\n\", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */\npcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */\n}\n\n/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION\n            is 0 then vPortFree() will be #defined to nothing. */\nvPortFree( pxTaskStatusArray );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n\n#endif /* ( ( configUSE_TRACE_FACILITY == 1 ) &amp;&amp; ( configUSE_STATS_FORMATTING_FUNCTIONS &gt; 0 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */\n/*----------------------------------------------------------*/\n\n#if ( ( configGENERATE_RUN_TIME_STATS == 1 ) &amp;&amp; ( configUSE_STATS_FORMATTING_FUNCTIONS &gt; 0 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )\n\nvoid vTaskGetRunTimeStats( char *pcWriteBuffer )\n{\nTaskStatus_t *pxTaskStatusArray;\nUBaseType_t uxArraySize, x;\nuint32_t ulTotalTime, ulStatsAsPercentage;\n\n#if( configUSE_TRACE_FACILITY != 1 )\n{\n#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().\n}\n#endif\n\n/*\n         * PLEASE NOTE:\n         *\n         * This function is provided for convenience only, and is used by many\n         * of the demo applications.  Do not consider it to be part of the\n         * scheduler.\n         *\n         * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part\n         * of the uxTaskGetSystemState() output into a human readable table that\n         * displays the amount of time each task has spent in the Running state\n         * in both absolute and percentage terms.\n         *\n         * vTaskGetRunTimeStats() has a dependency on the sprintf() C library\n         * function that might bloat the code size, use a lot of stack, and\n         * provide different results on different platforms.  An alternative,\n         * tiny, third party, and limited functionality implementation of\n         * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in\n         * a file called printf-stdarg.c (note printf-stdarg.c does not provide\n         * a full snprintf() implementation!).\n         *\n         * It is recommended that production systems call uxTaskGetSystemState()\n         * directly to get access to raw stats data, rather than indirectly\n         * through a call to vTaskGetRunTimeStats().\n         */\n\n/* Make sure the write buffer does not contain a string. */\n*pcWriteBuffer = ( char ) 0x00;\n\n/* Take a snapshot of the number of tasks in case it changes while this\n        function is executing. */\nuxArraySize = uxCurrentNumberOfTasks;\n\n/* Allocate an array index for each task.  NOTE!  If\n        configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will\n        equate to NULL. */\npxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */\n\nif( pxTaskStatusArray != NULL )\n{\n/* Generate the (binary) data. */\nuxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &amp;ulTotalTime );\n\n/* For percentage calculations. */\nulTotalTime /= 100UL;\n\n/* Avoid divide by zero errors. */\nif( ulTotalTime &gt; 0UL )\n{\n/* Create a human readable table from the binary data. */\nfor( x = 0; x &lt; uxArraySize; x++ )\n{\n/* What percentage of the total run time has the task used?\n                    This will always be rounded down to the nearest integer.\n                    ulTotalRunTimeDiv100 has already been divided by 100. */\nulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;\n\n/* Write the task name to the string, padding with\n                    spaces so it can be printed in tabular form more\n                    easily. */\npcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );\n\nif( ulStatsAsPercentage &gt; 0UL )\n{\n#ifdef portLU_PRINTF_SPECIFIER_REQUIRED\n{\nsprintf( pcWriteBuffer, \"\\t%lu\\t\\t%lu%%\\r\\n\", pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );\n}\n#else\n{\n/* sizeof( int ) == sizeof( long ) so a smaller\n                            printf() library can be used. */\nsprintf( pcWriteBuffer, \"\\t%u\\t\\t%u%%\\r\\n\", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */\n}\n#endif\n}\nelse\n{\n/* If the percentage is zero here then the task has\n                        consumed less than 1% of the total run time. */\n#ifdef portLU_PRINTF_SPECIFIER_REQUIRED\n{\nsprintf( pcWriteBuffer, \"\\t%lu\\t\\t&lt;1%%\\r\\n\", pxTaskStatusArray[ x ].ulRunTimeCounter );\n}\n#else\n{\n/* sizeof( int ) == sizeof( long ) so a smaller\n                            printf() library can be used. */\nsprintf( pcWriteBuffer, \"\\t%u\\t\\t&lt;1%%\\r\\n\", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */\n}\n#endif\n}\n\npcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\n/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION\n            is 0 then vPortFree() will be #defined to nothing. */\nvPortFree( pxTaskStatusArray );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n\n#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) &amp;&amp; ( configUSE_STATS_FORMATTING_FUNCTIONS &gt; 0 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */\n/*-----------------------------------------------------------*/\n\nTickType_t uxTaskResetEventItemValue( void )\n{\nTickType_t uxReturn;\n\nuxReturn = listGET_LIST_ITEM_VALUE( &amp;( pxCurrentTCB-&gt;xEventListItem ) );\n\n/* Reset the event list item to its normal value - so it can be used with\n    queues and semaphores. */\nlistSET_LIST_ITEM_VALUE( &amp;( pxCurrentTCB-&gt;xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB-&gt;uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\n\nreturn uxReturn;\n}\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_MUTEXES == 1 )\n\nTaskHandle_t pvTaskIncrementMutexHeldCount( void )\n{\n/* If xSemaphoreCreateMutex() is called before any tasks have been created\n        then pxCurrentTCB will be NULL. */\nif( pxCurrentTCB != NULL )\n{\n( pxCurrentTCB-&gt;uxMutexesHeld )++;\n}\n\nreturn pxCurrentTCB;\n}\n\n#endif /* configUSE_MUTEXES */\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TASK_NOTIFICATIONS == 1 )\n\nuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )\n{\nuint32_t ulReturn;\n\ntaskENTER_CRITICAL();\n{\n/* Only block if the notification count is not already non-zero. */\nif( pxCurrentTCB-&gt;ulNotifiedValue == 0UL )\n{\n/* Mark this task as waiting for a notification. */\npxCurrentTCB-&gt;ucNotifyState = taskWAITING_NOTIFICATION;\n\nif( xTicksToWait &gt; ( TickType_t ) 0 )\n{\nprvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );\ntraceTASK_NOTIFY_TAKE_BLOCK();\n\n/* All ports are written to allow a yield in a critical\n                    section (some will yield immediately, others wait until the\n                    critical section exits) - but it is not something that\n                    application code should ever do. */\nportYIELD_WITHIN_API();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\ntaskEXIT_CRITICAL();\n\ntaskENTER_CRITICAL();\n{\ntraceTASK_NOTIFY_TAKE();\nulReturn = pxCurrentTCB-&gt;ulNotifiedValue;\n\nif( ulReturn != 0UL )\n{\nif( xClearCountOnExit != pdFALSE )\n{\npxCurrentTCB-&gt;ulNotifiedValue = 0UL;\n}\nelse\n{\npxCurrentTCB-&gt;ulNotifiedValue = ulReturn - ( uint32_t ) 1;\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\npxCurrentTCB-&gt;ucNotifyState = taskNOT_WAITING_NOTIFICATION;\n}\ntaskEXIT_CRITICAL();\n\nreturn ulReturn;\n}\n\n#endif /* configUSE_TASK_NOTIFICATIONS */\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TASK_NOTIFICATIONS == 1 )\n\nBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )\n{\nBaseType_t xReturn;\n\ntaskENTER_CRITICAL();\n{\n/* Only block if a notification is not already pending. */\nif( pxCurrentTCB-&gt;ucNotifyState != taskNOTIFICATION_RECEIVED )\n{\n/* Clear bits in the task's notification value as bits may get\n                set by the notifying task or interrupt.  This can be used to\n                clear the value to zero. */\npxCurrentTCB-&gt;ulNotifiedValue &amp;= ~ulBitsToClearOnEntry;\n\n/* Mark this task as waiting for a notification. */\npxCurrentTCB-&gt;ucNotifyState = taskWAITING_NOTIFICATION;\n\nif( xTicksToWait &gt; ( TickType_t ) 0 )\n{\nprvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );\ntraceTASK_NOTIFY_WAIT_BLOCK();\n\n/* All ports are written to allow a yield in a critical\n                    section (some will yield immediately, others wait until the\n                    critical section exits) - but it is not something that\n                    application code should ever do. */\nportYIELD_WITHIN_API();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\ntaskEXIT_CRITICAL();\n\ntaskENTER_CRITICAL();\n{\ntraceTASK_NOTIFY_WAIT();\n\nif( pulNotificationValue != NULL )\n{\n/* Output the current notification value, which may or may not\n                have changed. */\n*pulNotificationValue = pxCurrentTCB-&gt;ulNotifiedValue;\n}\n\n/* If ucNotifyValue is set then either the task never entered the\n            blocked state (because a notification was already pending) or the\n            task unblocked because of a notification.  Otherwise the task\n            unblocked because of a timeout. */\nif( pxCurrentTCB-&gt;ucNotifyState != taskNOTIFICATION_RECEIVED )\n{\n/* A notification was not received. */\nxReturn = pdFALSE;\n}\nelse\n{\n/* A notification was already pending or a notification was\n                received while the task was waiting. */\npxCurrentTCB-&gt;ulNotifiedValue &amp;= ~ulBitsToClearOnExit;\nxReturn = pdTRUE;\n}\n\npxCurrentTCB-&gt;ucNotifyState = taskNOT_WAITING_NOTIFICATION;\n}\ntaskEXIT_CRITICAL();\n\nreturn xReturn;\n}\n\n#endif /* configUSE_TASK_NOTIFICATIONS */\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TASK_NOTIFICATIONS == 1 )\n\nBaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )\n{\nTCB_t * pxTCB;\nBaseType_t xReturn = pdPASS;\nuint8_t ucOriginalNotifyState;\n\nconfigASSERT( xTaskToNotify );\npxTCB = xTaskToNotify;\n\ntaskENTER_CRITICAL();\n{\nif( pulPreviousNotificationValue != NULL )\n{\n*pulPreviousNotificationValue = pxTCB-&gt;ulNotifiedValue;\n}\n\nucOriginalNotifyState = pxTCB-&gt;ucNotifyState;\n\npxTCB-&gt;ucNotifyState = taskNOTIFICATION_RECEIVED;\n\nswitch( eAction )\n{\ncase eSetBits   :\npxTCB-&gt;ulNotifiedValue |= ulValue;\nbreak;\n\ncase eIncrement :\n( pxTCB-&gt;ulNotifiedValue )++;\nbreak;\n\ncase eSetValueWithOverwrite :\npxTCB-&gt;ulNotifiedValue = ulValue;\nbreak;\n\ncase eSetValueWithoutOverwrite :\nif( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )\n{\npxTCB-&gt;ulNotifiedValue = ulValue;\n}\nelse\n{\n/* The value could not be written to the task. */\nxReturn = pdFAIL;\n}\nbreak;\n\ncase eNoAction:\n/* The task is being notified without its notify value being\n                    updated. */\nbreak;\n\ndefault:\n/* Should not get here if all enums are handled.\n                    Artificially force an assert by testing a value the\n                    compiler can't assume is const. */\nconfigASSERT( pxTCB-&gt;ulNotifiedValue == ~0UL );\n\nbreak;\n}\n\ntraceTASK_NOTIFY();\n\n/* If the task is in the blocked state specifically to wait for a\n            notification then unblock it now. */\nif( ucOriginalNotifyState == taskWAITING_NOTIFICATION )\n{\n( void ) uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) );\nprvAddTaskToReadyList( pxTCB );\n\n/* The task should not have been on an event list. */\nconfigASSERT( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) == NULL );\n\n#if( configUSE_TICKLESS_IDLE != 0 )\n{\n/* If a task is blocked waiting for a notification then\n                    xNextTaskUnblockTime might be set to the blocked task's time\n                    out time.  If the task is unblocked for a reason other than\n                    a timeout xNextTaskUnblockTime is normally left unchanged,\n                    because it will automatically get reset to a new value when\n                    the tick count equals xNextTaskUnblockTime.  However if\n                    tickless idling is used it might be more important to enter\n                    sleep mode at the earliest possible time - so reset\n                    xNextTaskUnblockTime here to ensure it is updated at the\n                    earliest possible time. */\nprvResetNextTaskUnblockTime();\n}\n#endif\n\nif( pxTCB-&gt;uxPriority &gt; pxCurrentTCB-&gt;uxPriority )\n{\n/* The notified task has a priority above the currently\n                    executing task so a yield is required. */\ntaskYIELD_IF_USING_PREEMPTION();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\ntaskEXIT_CRITICAL();\n\nreturn xReturn;\n}\n\n#endif /* configUSE_TASK_NOTIFICATIONS */\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TASK_NOTIFICATIONS == 1 )\n\nBaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )\n{\nTCB_t * pxTCB;\nuint8_t ucOriginalNotifyState;\nBaseType_t xReturn = pdPASS;\nUBaseType_t uxSavedInterruptStatus;\n\nconfigASSERT( xTaskToNotify );\n\n/* RTOS ports that support interrupt nesting have the concept of a\n        maximum system call (or maximum API call) interrupt priority.\n        Interrupts that are above the maximum system call priority are keep\n        permanently enabled, even when the RTOS kernel is in a critical section,\n        but cannot make any calls to FreeRTOS API functions.  If configASSERT()\n        is defined in FreeRTOSConfig.h then\n        portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion\n        failure if a FreeRTOS API function is called from an interrupt that has\n        been assigned a priority above the configured maximum system call\n        priority.  Only FreeRTOS functions that end in FromISR can be called\n        from interrupts that have been assigned a priority at or (logically)\n        below the maximum system call interrupt priority.  FreeRTOS maintains a\n        separate interrupt safe API to ensure interrupt entry is as fast and as\n        simple as possible.  More information (albeit Cortex-M specific) is\n        provided on the following link:\n        http://www.freertos.org/RTOS-Cortex-M3-M4.html */\nportASSERT_IF_INTERRUPT_PRIORITY_INVALID();\n\npxTCB = xTaskToNotify;\n\nuxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();\n{\nif( pulPreviousNotificationValue != NULL )\n{\n*pulPreviousNotificationValue = pxTCB-&gt;ulNotifiedValue;\n}\n\nucOriginalNotifyState = pxTCB-&gt;ucNotifyState;\npxTCB-&gt;ucNotifyState = taskNOTIFICATION_RECEIVED;\n\nswitch( eAction )\n{\ncase eSetBits   :\npxTCB-&gt;ulNotifiedValue |= ulValue;\nbreak;\n\ncase eIncrement :\n( pxTCB-&gt;ulNotifiedValue )++;\nbreak;\n\ncase eSetValueWithOverwrite :\npxTCB-&gt;ulNotifiedValue = ulValue;\nbreak;\n\ncase eSetValueWithoutOverwrite :\nif( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )\n{\npxTCB-&gt;ulNotifiedValue = ulValue;\n}\nelse\n{\n/* The value could not be written to the task. */\nxReturn = pdFAIL;\n}\nbreak;\n\ncase eNoAction :\n/* The task is being notified without its notify value being\n                    updated. */\nbreak;\n\ndefault:\n/* Should not get here if all enums are handled.\n                    Artificially force an assert by testing a value the\n                    compiler can't assume is const. */\nconfigASSERT( pxTCB-&gt;ulNotifiedValue == ~0UL );\nbreak;\n}\n\ntraceTASK_NOTIFY_FROM_ISR();\n\n/* If the task is in the blocked state specifically to wait for a\n            notification then unblock it now. */\nif( ucOriginalNotifyState == taskWAITING_NOTIFICATION )\n{\n/* The task should not have been on an event list. */\nconfigASSERT( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) == NULL );\n\nif( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )\n{\n( void ) uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) );\nprvAddTaskToReadyList( pxTCB );\n}\nelse\n{\n/* The delayed and ready lists cannot be accessed, so hold\n                    this task pending until the scheduler is resumed. */\nvListInsertEnd( &amp;( xPendingReadyList ), &amp;( pxTCB-&gt;xEventListItem ) );\n}\n\nif( pxTCB-&gt;uxPriority &gt; pxCurrentTCB-&gt;uxPriority )\n{\n/* The notified task has a priority above the currently\n                    executing task so a yield is required. */\nif( pxHigherPriorityTaskWoken != NULL )\n{\n*pxHigherPriorityTaskWoken = pdTRUE;\n}\n\n/* Mark that a yield is pending in case the user is not\n                    using the \"xHigherPriorityTaskWoken\" parameter to an ISR\n                    safe FreeRTOS function. */\nxYieldPending = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n}\nportCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\n\nreturn xReturn;\n}\n\n#endif /* configUSE_TASK_NOTIFICATIONS */\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TASK_NOTIFICATIONS == 1 )\n\nvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )\n{\nTCB_t * pxTCB;\nuint8_t ucOriginalNotifyState;\nUBaseType_t uxSavedInterruptStatus;\n\nconfigASSERT( xTaskToNotify );\n\n/* RTOS ports that support interrupt nesting have the concept of a\n        maximum system call (or maximum API call) interrupt priority.\n        Interrupts that are above the maximum system call priority are keep\n        permanently enabled, even when the RTOS kernel is in a critical section,\n        but cannot make any calls to FreeRTOS API functions.  If configASSERT()\n        is defined in FreeRTOSConfig.h then\n        portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion\n        failure if a FreeRTOS API function is called from an interrupt that has\n        been assigned a priority above the configured maximum system call\n        priority.  Only FreeRTOS functions that end in FromISR can be called\n        from interrupts that have been assigned a priority at or (logically)\n        below the maximum system call interrupt priority.  FreeRTOS maintains a\n        separate interrupt safe API to ensure interrupt entry is as fast and as\n        simple as possible.  More information (albeit Cortex-M specific) is\n        provided on the following link:\n        http://www.freertos.org/RTOS-Cortex-M3-M4.html */\nportASSERT_IF_INTERRUPT_PRIORITY_INVALID();\n\npxTCB = xTaskToNotify;\n\nuxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();\n{\nucOriginalNotifyState = pxTCB-&gt;ucNotifyState;\npxTCB-&gt;ucNotifyState = taskNOTIFICATION_RECEIVED;\n\n/* 'Giving' is equivalent to incrementing a count in a counting\n            semaphore. */\n( pxTCB-&gt;ulNotifiedValue )++;\n\ntraceTASK_NOTIFY_GIVE_FROM_ISR();\n\n/* If the task is in the blocked state specifically to wait for a\n            notification then unblock it now. */\nif( ucOriginalNotifyState == taskWAITING_NOTIFICATION )\n{\n/* The task should not have been on an event list. */\nconfigASSERT( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) == NULL );\n\nif( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )\n{\n( void ) uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) );\nprvAddTaskToReadyList( pxTCB );\n}\nelse\n{\n/* The delayed and ready lists cannot be accessed, so hold\n                    this task pending until the scheduler is resumed. */\nvListInsertEnd( &amp;( xPendingReadyList ), &amp;( pxTCB-&gt;xEventListItem ) );\n}\n\nif( pxTCB-&gt;uxPriority &gt; pxCurrentTCB-&gt;uxPriority )\n{\n/* The notified task has a priority above the currently\n                    executing task so a yield is required. */\nif( pxHigherPriorityTaskWoken != NULL )\n{\n*pxHigherPriorityTaskWoken = pdTRUE;\n}\n\n/* Mark that a yield is pending in case the user is not\n                    using the \"xHigherPriorityTaskWoken\" parameter in an ISR\n                    safe FreeRTOS function. */\nxYieldPending = pdTRUE;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n}\nportCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\n}\n\n#endif /* configUSE_TASK_NOTIFICATIONS */\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TASK_NOTIFICATIONS == 1 )\n\nBaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )\n{\nTCB_t *pxTCB;\nBaseType_t xReturn;\n\n/* If null is passed in here then it is the calling task that is having\n        its notification state cleared. */\npxTCB = prvGetTCBFromHandle( xTask );\n\ntaskENTER_CRITICAL();\n{\nif( pxTCB-&gt;ucNotifyState == taskNOTIFICATION_RECEIVED )\n{\npxTCB-&gt;ucNotifyState = taskNOT_WAITING_NOTIFICATION;\nxReturn = pdPASS;\n}\nelse\n{\nxReturn = pdFAIL;\n}\n}\ntaskEXIT_CRITICAL();\n\nreturn xReturn;\n}\n\n#endif /* configUSE_TASK_NOTIFICATIONS */\n/*-----------------------------------------------------------*/\n\n#if( configUSE_TASK_NOTIFICATIONS == 1 )\n\nuint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear )\n{\nTCB_t *pxTCB;\nuint32_t ulReturn;\n\n/* If null is passed in here then it is the calling task that is having\n        its notification state cleared. */\npxTCB = prvGetTCBFromHandle( xTask );\n\ntaskENTER_CRITICAL();\n{\n/* Return the notification as it was before the bits were cleared,\n            then clear the bit mask. */\nulReturn = pxCurrentTCB-&gt;ulNotifiedValue;\npxTCB-&gt;ulNotifiedValue &amp;= ~ulBitsToClear;\n}\ntaskEXIT_CRITICAL();\n\nreturn ulReturn;\n}\n\n#endif /* configUSE_TASK_NOTIFICATIONS */\n/*-----------------------------------------------------------*/\n\n#if( ( configGENERATE_RUN_TIME_STATS == 1 ) &amp;&amp; ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) )\n\nuint32_t ulTaskGetIdleRunTimeCounter( void )\n{\nreturn xIdleTaskHandle-&gt;ulRunTimeCounter;\n}\n\n#endif\n/*-----------------------------------------------------------*/\n\nstatic void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )\n{\nTickType_t xTimeToWake;\nconst TickType_t xConstTickCount = xTickCount;\n\n#if( INCLUDE_xTaskAbortDelay == 1 )\n{\n/* About to enter a delayed list, so ensure the ucDelayAborted flag is\n        reset to pdFALSE so it can be detected as having been set to pdTRUE\n        when the task leaves the Blocked state. */\npxCurrentTCB-&gt;ucDelayAborted = pdFALSE;\n}\n#endif\n\n/* Remove the task from the ready list before adding it to the blocked list\n    as the same list item is used for both lists. */\nif( uxListRemove( &amp;( pxCurrentTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) 0 )\n{\n/* The current task must be in a ready list, so there is no need to\n        check, and the port reset macro can be called directly. */\nportRESET_READY_PRIORITY( pxCurrentTCB-&gt;uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB-&gt;uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\n#if ( INCLUDE_vTaskSuspend == 1 )\n{\nif( ( xTicksToWait == portMAX_DELAY ) &amp;&amp; ( xCanBlockIndefinitely != pdFALSE ) )\n{\n/* Add the task to the suspended task list instead of a delayed task\n            list to ensure it is not woken by a timing event.  It will block\n            indefinitely. */\nvListInsertEnd( &amp;xSuspendedTaskList, &amp;( pxCurrentTCB-&gt;xStateListItem ) );\n}\nelse\n{\n/* Calculate the time at which the task should be woken if the event\n            does not occur.  This may overflow but this doesn't matter, the\n            kernel will manage it correctly. */\nxTimeToWake = xConstTickCount + xTicksToWait;\n\n/* The list item will be inserted in wake time order. */\nlistSET_LIST_ITEM_VALUE( &amp;( pxCurrentTCB-&gt;xStateListItem ), xTimeToWake );\n\nif( xTimeToWake &lt; xConstTickCount )\n{\n/* Wake time has overflowed.  Place this item in the overflow\n                list. */\nvListInsert( pxOverflowDelayedTaskList, &amp;( pxCurrentTCB-&gt;xStateListItem ) );\n}\nelse\n{\n/* The wake time has not overflowed, so the current block list\n                is used. */\nvListInsert( pxDelayedTaskList, &amp;( pxCurrentTCB-&gt;xStateListItem ) );\n\n/* If the task entering the blocked state was placed at the\n                head of the list of blocked tasks then xNextTaskUnblockTime\n                needs to be updated too. */\nif( xTimeToWake &lt; xNextTaskUnblockTime )\n{\nxNextTaskUnblockTime = xTimeToWake;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n}\n}\n#else /* INCLUDE_vTaskSuspend */\n{\n/* Calculate the time at which the task should be woken if the event\n        does not occur.  This may overflow but this doesn't matter, the kernel\n        will manage it correctly. */\nxTimeToWake = xConstTickCount + xTicksToWait;\n\n/* The list item will be inserted in wake time order. */\nlistSET_LIST_ITEM_VALUE( &amp;( pxCurrentTCB-&gt;xStateListItem ), xTimeToWake );\n\nif( xTimeToWake &lt; xConstTickCount )\n{\n/* Wake time has overflowed.  Place this item in the overflow list. */\nvListInsert( pxOverflowDelayedTaskList, &amp;( pxCurrentTCB-&gt;xStateListItem ) );\n}\nelse\n{\n/* The wake time has not overflowed, so the current block list is used. */\nvListInsert( pxDelayedTaskList, &amp;( pxCurrentTCB-&gt;xStateListItem ) );\n\n/* If the task entering the blocked state was placed at the head of the\n            list of blocked tasks then xNextTaskUnblockTime needs to be updated\n            too. */\nif( xTimeToWake &lt; xNextTaskUnblockTime )\n{\nxNextTaskUnblockTime = xTimeToWake;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n\n/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */\n( void ) xCanBlockIndefinitely;\n}\n#endif /* INCLUDE_vTaskSuspend */\n}\n\n/* Code below here allows additional code to be inserted into this source file,\nespecially where access to file scope functions and data is needed (for example\nwhen performing module tests). */\n\n#ifdef FREERTOS_MODULE_TEST\n#include \"tasks_test_access_functions.h\"\n#endif\n\n\n#if( configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1 )\n\n#include \"freertos_tasks_c_additions.h\"\n\n#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT\nstatic void freertos_tasks_c_additions_init( void )\n{\nFREERTOS_TASKS_C_ADDITIONS_INIT();\n}\n#endif\n\n#endif\n</code></pre>"},{"location":"apiStm/timers_8c/","title":"File timers.c","text":"<p>FileList &gt; FreeRTOS &gt; src &gt; timers.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"task.h\"</code></li> <li><code>#include \"queue.h\"</code></li> <li><code>#include \"timers.h\"</code></li> </ul>"},{"location":"apiStm/timers_8c/#macros","title":"Macros","text":"Type Name define MPU_WRAPPERS_INCLUDED_FROM_API_FILE"},{"location":"apiStm/timers_8c/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/timers_8c/#define-mpu_wrappers_included_from_api_file","title":"define MPU_WRAPPERS_INCLUDED_FROM_API_FILE","text":"<pre><code>#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE \n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/FreeRTOS/src/timers.c</code></p>"},{"location":"apiStm/timers_8c_source/","title":"File timers.c","text":"<p>File List &gt; FreeRTOS &gt; src &gt; timers.c</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n/* Standard includes. */\n#include &lt;stdlib.h&gt;\n\n/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining\nall the API functions to use the MPU wrappers.  That should only be done when\ntask.h is included from an application file. */\n#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE\n\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n#include \"queue.h\"\n#include \"timers.h\"\n\n#if ( INCLUDE_xTimerPendFunctionCall == 1 ) &amp;&amp; ( configUSE_TIMERS == 0 )\n#error configUSE_TIMERS must be set to 1 to make the xTimerPendFunctionCall() function available.\n#endif\n\n/* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified\nbecause the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined\nfor the header files above, but not in this file, in order to generate the\ncorrect privileged Vs unprivileged linkage and placement. */\n#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e9021 !e961 !e750. */\n\n\n/* This entire source file will be skipped if the application is not configured\nto include software timer functionality.  This #if is closed at the very bottom\nof this file.  If you want to include software timer functionality then ensure\nconfigUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */\n#if ( configUSE_TIMERS == 1 )\n\n/* Misc definitions. */\n#define tmrNO_DELAY     ( TickType_t ) 0U\n\n/* The name assigned to the timer service task.  This can be overridden by\ndefining trmTIMER_SERVICE_TASK_NAME in FreeRTOSConfig.h. */\n#ifndef configTIMER_SERVICE_TASK_NAME\n#define configTIMER_SERVICE_TASK_NAME \"Tmr Svc\"\n#endif\n\n/* Bit definitions used in the ucStatus member of a timer structure. */\n#define tmrSTATUS_IS_ACTIVE                 ( ( uint8_t ) 0x01 )\n#define tmrSTATUS_IS_STATICALLY_ALLOCATED   ( ( uint8_t ) 0x02 )\n#define tmrSTATUS_IS_AUTORELOAD             ( ( uint8_t ) 0x04 )\n\n/* The definition of the timers themselves. */\ntypedef struct tmrTimerControl /* The old naming convention is used to prevent breaking kernel aware debuggers. */\n{\nconst char              *pcTimerName;       /*&lt;&lt; Text name.  This is not used by the kernel, it is included simply to make debugging easier. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\nListItem_t              xTimerListItem;     /*&lt;&lt; Standard linked list item as used by all kernel features for event management. */\nTickType_t              xTimerPeriodInTicks;/*&lt;&lt; How quickly and often the timer expires. */\nvoid                    *pvTimerID;         /*&lt;&lt; An ID to identify the timer.  This allows the timer to be identified when the same callback is used for multiple timers. */\nTimerCallbackFunction_t pxCallbackFunction; /*&lt;&lt; The function that will be called when the timer expires. */\n#if( configUSE_TRACE_FACILITY == 1 )\nUBaseType_t         uxTimerNumber;      /*&lt;&lt; An ID assigned by trace tools such as FreeRTOS+Trace */\n#endif\nuint8_t                 ucStatus;           /*&lt;&lt; Holds bits to say if the timer was statically allocated or not, and if it is active or not. */\n} xTIMER;\n\n/* The old xTIMER name is maintained above then typedefed to the new Timer_t\nname below to enable the use of older kernel aware debuggers. */\ntypedef xTIMER Timer_t;\n\n/* The definition of messages that can be sent and received on the timer queue.\nTwo types of message can be queued - messages that manipulate a software timer,\nand messages that request the execution of a non-timer related callback.  The\ntwo message types are defined in two separate structures, xTimerParametersType\nand xCallbackParametersType respectively. */\ntypedef struct tmrTimerParameters\n{\nTickType_t          xMessageValue;      /*&lt;&lt; An optional value used by a subset of commands, for example, when changing the period of a timer. */\nTimer_t *           pxTimer;            /*&lt;&lt; The timer to which the command will be applied. */\n} TimerParameter_t;\n\n\ntypedef struct tmrCallbackParameters\n{\nPendedFunction_t    pxCallbackFunction; /* &lt;&lt; The callback function to execute. */\nvoid *pvParameter1;                     /* &lt;&lt; The value that will be used as the callback functions first parameter. */\nuint32_t ulParameter2;                  /* &lt;&lt; The value that will be used as the callback functions second parameter. */\n} CallbackParameters_t;\n\n/* The structure that contains the two message types, along with an identifier\nthat is used to determine which message type is valid. */\ntypedef struct tmrTimerQueueMessage\n{\nBaseType_t          xMessageID;         /*&lt;&lt; The command being sent to the timer service task. */\nunion\n{\nTimerParameter_t xTimerParameters;\n\n/* Don't include xCallbackParameters if it is not going to be used as\n        it makes the structure (and therefore the timer queue) larger. */\n#if ( INCLUDE_xTimerPendFunctionCall == 1 )\nCallbackParameters_t xCallbackParameters;\n#endif /* INCLUDE_xTimerPendFunctionCall */\n} u;\n} DaemonTaskMessage_t;\n\n/*lint -save -e956 A manual analysis and inspection has been used to determine\nwhich static variables must be declared volatile. */\n\n/* The list in which active timers are stored.  Timers are referenced in expire\ntime order, with the nearest expiry time at the front of the list.  Only the\ntimer service task is allowed to access these lists.\nxActiveTimerList1 and xActiveTimerList2 could be at function scope but that\nbreaks some kernel aware debuggers, and debuggers that reply on removing the\nstatic qualifier. */\nPRIVILEGED_DATA static List_t xActiveTimerList1;\nPRIVILEGED_DATA static List_t xActiveTimerList2;\nPRIVILEGED_DATA static List_t *pxCurrentTimerList;\nPRIVILEGED_DATA static List_t *pxOverflowTimerList;\n\n/* A queue that is used to send commands to the timer service task. */\nPRIVILEGED_DATA static QueueHandle_t xTimerQueue = NULL;\nPRIVILEGED_DATA static TaskHandle_t xTimerTaskHandle = NULL;\n\n/*lint -restore */\n\n/*-----------------------------------------------------------*/\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n\n/* If static allocation is supported then the application must provide the\n    following callback function - which enables the application to optionally\n    provide the memory that will be used by the timer task as the task's stack\n    and TCB. */\nextern void vApplicationGetTimerTaskMemory( StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize );\n\n#endif\n\n/*\n * Initialise the infrastructure used by the timer service task if it has not\n * been initialised already.\n */\nstatic void prvCheckForValidListAndQueue( void ) PRIVILEGED_FUNCTION;\n\n/*\n * The timer service task (daemon).  Timer functionality is controlled by this\n * task.  Other tasks communicate with the timer service task using the\n * xTimerQueue queue.\n */\nstatic portTASK_FUNCTION_PROTO( prvTimerTask, pvParameters ) PRIVILEGED_FUNCTION;\n\n/*\n * Called by the timer service task to interpret and process a command it\n * received on the timer queue.\n */\nstatic void prvProcessReceivedCommands( void ) PRIVILEGED_FUNCTION;\n\n/*\n * Insert the timer into either xActiveTimerList1, or xActiveTimerList2,\n * depending on if the expire time causes a timer counter overflow.\n */\nstatic BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime ) PRIVILEGED_FUNCTION;\n\n/*\n * An active timer has reached its expire time.  Reload the timer if it is an\n * auto-reload timer, then call its callback.\n */\nstatic void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow ) PRIVILEGED_FUNCTION;\n\n/*\n * The tick count has overflowed.  Switch the timer lists after ensuring the\n * current timer list does not still reference some timers.\n */\nstatic void prvSwitchTimerLists( void ) PRIVILEGED_FUNCTION;\n\n/*\n * Obtain the current tick count, setting *pxTimerListsWereSwitched to pdTRUE\n * if a tick count overflow occurred since prvSampleTimeNow() was last called.\n */\nstatic TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched ) PRIVILEGED_FUNCTION;\n\n/*\n * If the timer list contains any active timers then return the expire time of\n * the timer that will expire first and set *pxListWasEmpty to false.  If the\n * timer list does not contain any timers then return 0 and set *pxListWasEmpty\n * to pdTRUE.\n */\nstatic TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty ) PRIVILEGED_FUNCTION;\n\n/*\n * If a timer has expired, process it.  Otherwise, block the timer service task\n * until either a timer does expire or a command is received.\n */\nstatic void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;\n\n/*\n * Called after a Timer_t structure has been allocated either statically or\n * dynamically to fill in the structure's members.\n */\nstatic void prvInitialiseNewTimer(  const char * const pcTimerName,         /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\nconst TickType_t xTimerPeriodInTicks,\nconst UBaseType_t uxAutoReload,\nvoid * const pvTimerID,\nTimerCallbackFunction_t pxCallbackFunction,\nTimer_t *pxNewTimer ) PRIVILEGED_FUNCTION;\n/*-----------------------------------------------------------*/\n\nBaseType_t xTimerCreateTimerTask( void )\n{\nBaseType_t xReturn = pdFAIL;\n\n/* This function is called when the scheduler is started if\n    configUSE_TIMERS is set to 1.  Check that the infrastructure used by the\n    timer service task has been created/initialised.  If timers have already\n    been created then the initialisation will already have been performed. */\nprvCheckForValidListAndQueue();\n\nif( xTimerQueue != NULL )\n{\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n{\nStaticTask_t *pxTimerTaskTCBBuffer = NULL;\nStackType_t *pxTimerTaskStackBuffer = NULL;\nuint32_t ulTimerTaskStackSize;\n\nvApplicationGetTimerTaskMemory( &amp;pxTimerTaskTCBBuffer, &amp;pxTimerTaskStackBuffer, &amp;ulTimerTaskStackSize );\nxTimerTaskHandle = xTaskCreateStatic(   prvTimerTask,\nconfigTIMER_SERVICE_TASK_NAME,\nulTimerTaskStackSize,\nNULL,\n( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,\npxTimerTaskStackBuffer,\npxTimerTaskTCBBuffer );\n\nif( xTimerTaskHandle != NULL )\n{\nxReturn = pdPASS;\n}\n}\n#else\n{\nxReturn = xTaskCreate(  prvTimerTask,\nconfigTIMER_SERVICE_TASK_NAME,\nconfigTIMER_TASK_STACK_DEPTH,\nNULL,\n( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,\n&amp;xTimerTaskHandle );\n}\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nconfigASSERT( xReturn );\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n\nTimerHandle_t xTimerCreate( const char * const pcTimerName,         /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\nconst TickType_t xTimerPeriodInTicks,\nconst UBaseType_t uxAutoReload,\nvoid * const pvTimerID,\nTimerCallbackFunction_t pxCallbackFunction )\n{\nTimer_t *pxNewTimer;\n\npxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */\n\nif( pxNewTimer != NULL )\n{\n/* Status is thus far zero as the timer is not created statically\n            and has not been started.  The auto-reload bit may get set in\n            prvInitialiseNewTimer. */\npxNewTimer-&gt;ucStatus = 0x00;\nprvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );\n}\n\nreturn pxNewTimer;\n}\n\n#endif /* configSUPPORT_DYNAMIC_ALLOCATION */\n/*-----------------------------------------------------------*/\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n\nTimerHandle_t xTimerCreateStatic(   const char * const pcTimerName,     /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\nconst TickType_t xTimerPeriodInTicks,\nconst UBaseType_t uxAutoReload,\nvoid * const pvTimerID,\nTimerCallbackFunction_t pxCallbackFunction,\nStaticTimer_t *pxTimerBuffer )\n{\nTimer_t *pxNewTimer;\n\n#if( configASSERT_DEFINED == 1 )\n{\n/* Sanity check that the size of the structure used to declare a\n            variable of type StaticTimer_t equals the size of the real timer\n            structure. */\nvolatile size_t xSize = sizeof( StaticTimer_t );\nconfigASSERT( xSize == sizeof( Timer_t ) );\n( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */\n}\n#endif /* configASSERT_DEFINED */\n\n/* A pointer to a StaticTimer_t structure MUST be provided, use it. */\nconfigASSERT( pxTimerBuffer );\npxNewTimer = ( Timer_t * ) pxTimerBuffer; /*lint !e740 !e9087 StaticTimer_t is a pointer to a Timer_t, so guaranteed to be aligned and sized correctly (checked by an assert()), so this is safe. */\n\nif( pxNewTimer != NULL )\n{\n/* Timers can be created statically or dynamically so note this\n            timer was created statically in case it is later deleted.  The\n            auto-reload bit may get set in prvInitialiseNewTimer(). */\npxNewTimer-&gt;ucStatus = tmrSTATUS_IS_STATICALLY_ALLOCATED;\n\nprvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );\n}\n\nreturn pxNewTimer;\n}\n\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n/*-----------------------------------------------------------*/\n\nstatic void prvInitialiseNewTimer(  const char * const pcTimerName,         /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\nconst TickType_t xTimerPeriodInTicks,\nconst UBaseType_t uxAutoReload,\nvoid * const pvTimerID,\nTimerCallbackFunction_t pxCallbackFunction,\nTimer_t *pxNewTimer )\n{\n/* 0 is not a valid value for xTimerPeriodInTicks. */\nconfigASSERT( ( xTimerPeriodInTicks &gt; 0 ) );\n\nif( pxNewTimer != NULL )\n{\n/* Ensure the infrastructure used by the timer service task has been\n        created/initialised. */\nprvCheckForValidListAndQueue();\n\n/* Initialise the timer structure members using the function\n        parameters. */\npxNewTimer-&gt;pcTimerName = pcTimerName;\npxNewTimer-&gt;xTimerPeriodInTicks = xTimerPeriodInTicks;\npxNewTimer-&gt;pvTimerID = pvTimerID;\npxNewTimer-&gt;pxCallbackFunction = pxCallbackFunction;\nvListInitialiseItem( &amp;( pxNewTimer-&gt;xTimerListItem ) );\nif( uxAutoReload != pdFALSE )\n{\npxNewTimer-&gt;ucStatus |= tmrSTATUS_IS_AUTORELOAD;\n}\ntraceTIMER_CREATE( pxNewTimer );\n}\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )\n{\nBaseType_t xReturn = pdFAIL;\nDaemonTaskMessage_t xMessage;\n\nconfigASSERT( xTimer );\n\n/* Send a message to the timer service task to perform a particular action\n    on a particular timer definition. */\nif( xTimerQueue != NULL )\n{\n/* Send a command to the timer service task to start the xTimer timer. */\nxMessage.xMessageID = xCommandID;\nxMessage.u.xTimerParameters.xMessageValue = xOptionalValue;\nxMessage.u.xTimerParameters.pxTimer = xTimer;\n\nif( xCommandID &lt; tmrFIRST_FROM_ISR_COMMAND )\n{\nif( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )\n{\nxReturn = xQueueSendToBack( xTimerQueue, &amp;xMessage, xTicksToWait );\n}\nelse\n{\nxReturn = xQueueSendToBack( xTimerQueue, &amp;xMessage, tmrNO_DELAY );\n}\n}\nelse\n{\nxReturn = xQueueSendToBackFromISR( xTimerQueue, &amp;xMessage, pxHigherPriorityTaskWoken );\n}\n\ntraceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nTaskHandle_t xTimerGetTimerDaemonTaskHandle( void )\n{\n/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been\n    started, then xTimerTaskHandle will be NULL. */\nconfigASSERT( ( xTimerTaskHandle != NULL ) );\nreturn xTimerTaskHandle;\n}\n/*-----------------------------------------------------------*/\n\nTickType_t xTimerGetPeriod( TimerHandle_t xTimer )\n{\nTimer_t *pxTimer = xTimer;\n\nconfigASSERT( xTimer );\nreturn pxTimer-&gt;xTimerPeriodInTicks;\n}\n/*-----------------------------------------------------------*/\n\nvoid vTimerSetReloadMode( TimerHandle_t xTimer, const UBaseType_t uxAutoReload )\n{\nTimer_t * pxTimer =  xTimer;\n\nconfigASSERT( xTimer );\ntaskENTER_CRITICAL();\n{\nif( uxAutoReload != pdFALSE )\n{\npxTimer-&gt;ucStatus |= tmrSTATUS_IS_AUTORELOAD;\n}\nelse\n{\npxTimer-&gt;ucStatus &amp;= ~tmrSTATUS_IS_AUTORELOAD;\n}\n}\ntaskEXIT_CRITICAL();\n}\n/*-----------------------------------------------------------*/\n\nUBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer )\n{\nTimer_t * pxTimer =  xTimer;\nUBaseType_t uxReturn;\n\nconfigASSERT( xTimer );\ntaskENTER_CRITICAL();\n{\nif( ( pxTimer-&gt;ucStatus &amp; tmrSTATUS_IS_AUTORELOAD ) == 0 )\n{\n/* Not an auto-reload timer. */\nuxReturn = ( UBaseType_t ) pdFALSE;\n}\nelse\n{\n/* Is an auto-reload timer. */\nuxReturn = ( UBaseType_t ) pdTRUE;\n}\n}\ntaskEXIT_CRITICAL();\n\nreturn uxReturn;\n}\n/*-----------------------------------------------------------*/\n\nTickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )\n{\nTimer_t * pxTimer =  xTimer;\nTickType_t xReturn;\n\nconfigASSERT( xTimer );\nxReturn = listGET_LIST_ITEM_VALUE( &amp;( pxTimer-&gt;xTimerListItem ) );\nreturn xReturn;\n}\n/*-----------------------------------------------------------*/\n\nconst char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n{\nTimer_t *pxTimer = xTimer;\n\nconfigASSERT( xTimer );\nreturn pxTimer-&gt;pcTimerName;\n}\n/*-----------------------------------------------------------*/\n\nstatic void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )\n{\nBaseType_t xResult;\nTimer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */\n\n/* Remove the timer from the list of active timers.  A check has already\n    been performed to ensure the list is not empty. */\n( void ) uxListRemove( &amp;( pxTimer-&gt;xTimerListItem ) );\ntraceTIMER_EXPIRED( pxTimer );\n\n/* If the timer is an auto-reload timer then calculate the next\n    expiry time and re-insert the timer in the list of active timers. */\nif( ( pxTimer-&gt;ucStatus &amp; tmrSTATUS_IS_AUTORELOAD ) != 0 )\n{\n/* The timer is inserted into a list using a time relative to anything\n        other than the current time.  It will therefore be inserted into the\n        correct list relative to the time this task thinks it is now. */\nif( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer-&gt;xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )\n{\n/* The timer expired before it was added to the active timer\n            list.  Reload it now.  */\nxResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );\nconfigASSERT( xResult );\n( void ) xResult;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\npxTimer-&gt;ucStatus &amp;= ~tmrSTATUS_IS_ACTIVE;\nmtCOVERAGE_TEST_MARKER();\n}\n\n/* Call the timer callback. */\npxTimer-&gt;pxCallbackFunction( ( TimerHandle_t ) pxTimer );\n}\n/*-----------------------------------------------------------*/\n\nstatic portTASK_FUNCTION( prvTimerTask, pvParameters )\n{\nTickType_t xNextExpireTime;\nBaseType_t xListWasEmpty;\n\n/* Just to avoid compiler warnings. */\n( void ) pvParameters;\n\n#if( configUSE_DAEMON_TASK_STARTUP_HOOK == 1 )\n{\nextern void vApplicationDaemonTaskStartupHook( void );\n\n/* Allow the application writer to execute some code in the context of\n        this task at the point the task starts executing.  This is useful if the\n        application includes initialisation code that would benefit from\n        executing after the scheduler has been started. */\nvApplicationDaemonTaskStartupHook();\n}\n#endif /* configUSE_DAEMON_TASK_STARTUP_HOOK */\n\nfor( ;; )\n{\n/* Query the timers list to see if it contains any timers, and if so,\n        obtain the time at which the next timer will expire. */\nxNextExpireTime = prvGetNextExpireTime( &amp;xListWasEmpty );\n\n/* If a timer has expired, process it.  Otherwise, block this task\n        until either a timer does expire, or a command is received. */\nprvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );\n\n/* Empty the command queue. */\nprvProcessReceivedCommands();\n}\n}\n/*-----------------------------------------------------------*/\n\nstatic void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )\n{\nTickType_t xTimeNow;\nBaseType_t xTimerListsWereSwitched;\n\nvTaskSuspendAll();\n{\n/* Obtain the time now to make an assessment as to whether the timer\n        has expired or not.  If obtaining the time causes the lists to switch\n        then don't process this timer as any timers that remained in the list\n        when the lists were switched will have been processed within the\n        prvSampleTimeNow() function. */\nxTimeNow = prvSampleTimeNow( &amp;xTimerListsWereSwitched );\nif( xTimerListsWereSwitched == pdFALSE )\n{\n/* The tick count has not overflowed, has the timer expired? */\nif( ( xListWasEmpty == pdFALSE ) &amp;&amp; ( xNextExpireTime &lt;= xTimeNow ) )\n{\n( void ) xTaskResumeAll();\nprvProcessExpiredTimer( xNextExpireTime, xTimeNow );\n}\nelse\n{\n/* The tick count has not overflowed, and the next expire\n                time has not been reached yet.  This task should therefore\n                block to wait for the next expire time or a command to be\n                received - whichever comes first.  The following line cannot\n                be reached unless xNextExpireTime &gt; xTimeNow, except in the\n                case when the current timer list is empty. */\nif( xListWasEmpty != pdFALSE )\n{\n/* The current timer list is empty - is the overflow list\n                    also empty? */\nxListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );\n}\n\nvQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );\n\nif( xTaskResumeAll() == pdFALSE )\n{\n/* Yield to wait for either a command to arrive, or the\n                    block time to expire.  If a command arrived between the\n                    critical section being exited and this yield then the yield\n                    will not cause the task to block. */\nportYIELD_WITHIN_API();\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n}\nelse\n{\n( void ) xTaskResumeAll();\n}\n}\n}\n/*-----------------------------------------------------------*/\n\nstatic TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )\n{\nTickType_t xNextExpireTime;\n\n/* Timers are listed in expiry time order, with the head of the list\n    referencing the task that will expire first.  Obtain the time at which\n    the timer with the nearest expiry time will expire.  If there are no\n    active timers then just set the next expire time to 0.  That will cause\n    this task to unblock when the tick count overflows, at which point the\n    timer lists will be switched and the next expiry time can be\n    re-assessed.  */\n*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );\nif( *pxListWasEmpty == pdFALSE )\n{\nxNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );\n}\nelse\n{\n/* Ensure the task unblocks when the tick count rolls over. */\nxNextExpireTime = ( TickType_t ) 0U;\n}\n\nreturn xNextExpireTime;\n}\n/*-----------------------------------------------------------*/\n\nstatic TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )\n{\nTickType_t xTimeNow;\nPRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */\n\nxTimeNow = xTaskGetTickCount();\n\nif( xTimeNow &lt; xLastTime )\n{\nprvSwitchTimerLists();\n*pxTimerListsWereSwitched = pdTRUE;\n}\nelse\n{\n*pxTimerListsWereSwitched = pdFALSE;\n}\n\nxLastTime = xTimeNow;\n\nreturn xTimeNow;\n}\n/*-----------------------------------------------------------*/\n\nstatic BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )\n{\nBaseType_t xProcessTimerNow = pdFALSE;\n\nlistSET_LIST_ITEM_VALUE( &amp;( pxTimer-&gt;xTimerListItem ), xNextExpiryTime );\nlistSET_LIST_ITEM_OWNER( &amp;( pxTimer-&gt;xTimerListItem ), pxTimer );\n\nif( xNextExpiryTime &lt;= xTimeNow )\n{\n/* Has the expiry time elapsed between the command to start/reset a\n        timer was issued, and the time the command was processed? */\nif( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) &gt;= pxTimer-&gt;xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\n{\n/* The time between a command being issued and the command being\n            processed actually exceeds the timers period.  */\nxProcessTimerNow = pdTRUE;\n}\nelse\n{\nvListInsert( pxOverflowTimerList, &amp;( pxTimer-&gt;xTimerListItem ) );\n}\n}\nelse\n{\nif( ( xTimeNow &lt; xCommandTime ) &amp;&amp; ( xNextExpiryTime &gt;= xCommandTime ) )\n{\n/* If, since the command was issued, the tick count has overflowed\n            but the expiry time has not, then the timer must have already passed\n            its expiry time and should be processed immediately. */\nxProcessTimerNow = pdTRUE;\n}\nelse\n{\nvListInsert( pxCurrentTimerList, &amp;( pxTimer-&gt;xTimerListItem ) );\n}\n}\n\nreturn xProcessTimerNow;\n}\n/*-----------------------------------------------------------*/\n\nstatic void prvProcessReceivedCommands( void )\n{\nDaemonTaskMessage_t xMessage;\nTimer_t *pxTimer;\nBaseType_t xTimerListsWereSwitched, xResult;\nTickType_t xTimeNow;\n\nwhile( xQueueReceive( xTimerQueue, &amp;xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */\n{\n#if ( INCLUDE_xTimerPendFunctionCall == 1 )\n{\n/* Negative commands are pended function calls rather than timer\n            commands. */\nif( xMessage.xMessageID &lt; ( BaseType_t ) 0 )\n{\nconst CallbackParameters_t * const pxCallback = &amp;( xMessage.u.xCallbackParameters );\n\n/* The timer uses the xCallbackParameters member to request a\n                callback be executed.  Check the callback is not NULL. */\nconfigASSERT( pxCallback );\n\n/* Call the function. */\npxCallback-&gt;pxCallbackFunction( pxCallback-&gt;pvParameter1, pxCallback-&gt;ulParameter2 );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n#endif /* INCLUDE_xTimerPendFunctionCall */\n\n/* Commands that are positive are timer commands rather than pended\n        function calls. */\nif( xMessage.xMessageID &gt;= ( BaseType_t ) 0 )\n{\n/* The messages uses the xTimerParameters member to work on a\n            software timer. */\npxTimer = xMessage.u.xTimerParameters.pxTimer;\n\nif( listIS_CONTAINED_WITHIN( NULL, &amp;( pxTimer-&gt;xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */\n{\n/* The timer is in a list, remove it. */\n( void ) uxListRemove( &amp;( pxTimer-&gt;xTimerListItem ) );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n\ntraceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.u.xTimerParameters.xMessageValue );\n\n/* In this case the xTimerListsWereSwitched parameter is not used, but\n            it must be present in the function call.  prvSampleTimeNow() must be\n            called after the message is received from xTimerQueue so there is no\n            possibility of a higher priority task adding a message to the message\n            queue with a time that is ahead of the timer daemon task (because it\n            pre-empted the timer daemon task after the xTimeNow value was set). */\nxTimeNow = prvSampleTimeNow( &amp;xTimerListsWereSwitched );\n\nswitch( xMessage.xMessageID )\n{\ncase tmrCOMMAND_START :\ncase tmrCOMMAND_START_FROM_ISR :\ncase tmrCOMMAND_RESET :\ncase tmrCOMMAND_RESET_FROM_ISR :\ncase tmrCOMMAND_START_DONT_TRACE :\n/* Start or restart a timer. */\npxTimer-&gt;ucStatus |= tmrSTATUS_IS_ACTIVE;\nif( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer-&gt;xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )\n{\n/* The timer expired before it was added to the active\n                        timer list.  Process it now. */\npxTimer-&gt;pxCallbackFunction( ( TimerHandle_t ) pxTimer );\ntraceTIMER_EXPIRED( pxTimer );\n\nif( ( pxTimer-&gt;ucStatus &amp; tmrSTATUS_IS_AUTORELOAD ) != 0 )\n{\nxResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer-&gt;xTimerPeriodInTicks, NULL, tmrNO_DELAY );\nconfigASSERT( xResult );\n( void ) xResult;\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\nbreak;\n\ncase tmrCOMMAND_STOP :\ncase tmrCOMMAND_STOP_FROM_ISR :\n/* The timer has already been removed from the active list. */\npxTimer-&gt;ucStatus &amp;= ~tmrSTATUS_IS_ACTIVE;\nbreak;\n\ncase tmrCOMMAND_CHANGE_PERIOD :\ncase tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :\npxTimer-&gt;ucStatus |= tmrSTATUS_IS_ACTIVE;\npxTimer-&gt;xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;\nconfigASSERT( ( pxTimer-&gt;xTimerPeriodInTicks &gt; 0 ) );\n\n/* The new period does not really have a reference, and can\n                    be longer or shorter than the old one.  The command time is\n                    therefore set to the current time, and as the period cannot\n                    be zero the next expiry time can only be in the future,\n                    meaning (unlike for the xTimerStart() case above) there is\n                    no fail case that needs to be handled here. */\n( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer-&gt;xTimerPeriodInTicks ), xTimeNow, xTimeNow );\nbreak;\n\ncase tmrCOMMAND_DELETE :\n#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n{\n/* The timer has already been removed from the active list,\n                        just free up the memory if the memory was dynamically\n                        allocated. */\nif( ( pxTimer-&gt;ucStatus &amp; tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )\n{\nvPortFree( pxTimer );\n}\nelse\n{\npxTimer-&gt;ucStatus &amp;= ~tmrSTATUS_IS_ACTIVE;\n}\n}\n#else\n{\n/* If dynamic allocation is not enabled, the memory\n                        could not have been dynamically allocated. So there is\n                        no need to free the memory - just mark the timer as\n                        \"not active\". */\npxTimer-&gt;ucStatus &amp;= ~tmrSTATUS_IS_ACTIVE;\n}\n#endif /* configSUPPORT_DYNAMIC_ALLOCATION */\nbreak;\n\ndefault :\n/* Don't expect to get here. */\nbreak;\n}\n}\n}\n}\n/*-----------------------------------------------------------*/\n\nstatic void prvSwitchTimerLists( void )\n{\nTickType_t xNextExpireTime, xReloadTime;\nList_t *pxTemp;\nTimer_t *pxTimer;\nBaseType_t xResult;\n\n/* The tick count has overflowed.  The timer lists must be switched.\n    If there are any timers still referenced from the current timer list\n    then they must have expired and should be processed before the lists\n    are switched. */\nwhile( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )\n{\nxNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );\n\n/* Remove the timer from the list. */\npxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */\n( void ) uxListRemove( &amp;( pxTimer-&gt;xTimerListItem ) );\ntraceTIMER_EXPIRED( pxTimer );\n\n/* Execute its callback, then send a command to restart the timer if\n        it is an auto-reload timer.  It cannot be restarted here as the lists\n        have not yet been switched. */\npxTimer-&gt;pxCallbackFunction( ( TimerHandle_t ) pxTimer );\n\nif( ( pxTimer-&gt;ucStatus &amp; tmrSTATUS_IS_AUTORELOAD ) != 0 )\n{\n/* Calculate the reload value, and if the reload value results in\n            the timer going into the same timer list then it has already expired\n            and the timer should be re-inserted into the current list so it is\n            processed again within this loop.  Otherwise a command should be sent\n            to restart the timer to ensure it is only inserted into a list after\n            the lists have been swapped. */\nxReloadTime = ( xNextExpireTime + pxTimer-&gt;xTimerPeriodInTicks );\nif( xReloadTime &gt; xNextExpireTime )\n{\nlistSET_LIST_ITEM_VALUE( &amp;( pxTimer-&gt;xTimerListItem ), xReloadTime );\nlistSET_LIST_ITEM_OWNER( &amp;( pxTimer-&gt;xTimerListItem ), pxTimer );\nvListInsert( pxCurrentTimerList, &amp;( pxTimer-&gt;xTimerListItem ) );\n}\nelse\n{\nxResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );\nconfigASSERT( xResult );\n( void ) xResult;\n}\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n\npxTemp = pxCurrentTimerList;\npxCurrentTimerList = pxOverflowTimerList;\npxOverflowTimerList = pxTemp;\n}\n/*-----------------------------------------------------------*/\n\nstatic void prvCheckForValidListAndQueue( void )\n{\n/* Check that the list from which active timers are referenced, and the\n    queue used to communicate with the timer service, have been\n    initialised. */\ntaskENTER_CRITICAL();\n{\nif( xTimerQueue == NULL )\n{\nvListInitialise( &amp;xActiveTimerList1 );\nvListInitialise( &amp;xActiveTimerList2 );\npxCurrentTimerList = &amp;xActiveTimerList1;\npxOverflowTimerList = &amp;xActiveTimerList2;\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n{\n/* The timer queue is allocated statically in case\n                configSUPPORT_DYNAMIC_ALLOCATION is 0. */\nstatic StaticQueue_t xStaticTimerQueue; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */\nstatic uint8_t ucStaticTimerQueueStorage[ ( size_t ) configTIMER_QUEUE_LENGTH * sizeof( DaemonTaskMessage_t ) ]; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */\n\nxTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &amp;( ucStaticTimerQueueStorage[ 0 ] ), &amp;xStaticTimerQueue );\n}\n#else\n{\nxTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );\n}\n#endif\n\n#if ( configQUEUE_REGISTRY_SIZE &gt; 0 )\n{\nif( xTimerQueue != NULL )\n{\nvQueueAddToRegistry( xTimerQueue, \"TmrQ\" );\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\n#endif /* configQUEUE_REGISTRY_SIZE */\n}\nelse\n{\nmtCOVERAGE_TEST_MARKER();\n}\n}\ntaskEXIT_CRITICAL();\n}\n/*-----------------------------------------------------------*/\n\nBaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )\n{\nBaseType_t xReturn;\nTimer_t *pxTimer = xTimer;\n\nconfigASSERT( xTimer );\n\n/* Is the timer in the list of active timers? */\ntaskENTER_CRITICAL();\n{\nif( ( pxTimer-&gt;ucStatus &amp; tmrSTATUS_IS_ACTIVE ) == 0 )\n{\nxReturn = pdFALSE;\n}\nelse\n{\nxReturn = pdTRUE;\n}\n}\ntaskEXIT_CRITICAL();\n\nreturn xReturn;\n} /*lint !e818 Can't be pointer to const due to the typedef. */\n/*-----------------------------------------------------------*/\n\nvoid *pvTimerGetTimerID( const TimerHandle_t xTimer )\n{\nTimer_t * const pxTimer = xTimer;\nvoid *pvReturn;\n\nconfigASSERT( xTimer );\n\ntaskENTER_CRITICAL();\n{\npvReturn = pxTimer-&gt;pvTimerID;\n}\ntaskEXIT_CRITICAL();\n\nreturn pvReturn;\n}\n/*-----------------------------------------------------------*/\n\nvoid vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )\n{\nTimer_t * const pxTimer = xTimer;\n\nconfigASSERT( xTimer );\n\ntaskENTER_CRITICAL();\n{\npxTimer-&gt;pvTimerID = pvNewID;\n}\ntaskEXIT_CRITICAL();\n}\n/*-----------------------------------------------------------*/\n\n#if( INCLUDE_xTimerPendFunctionCall == 1 )\n\nBaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )\n{\nDaemonTaskMessage_t xMessage;\nBaseType_t xReturn;\n\n/* Complete the message with the function parameters and post it to the\n        daemon task. */\nxMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;\nxMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;\nxMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;\nxMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;\n\nxReturn = xQueueSendFromISR( xTimerQueue, &amp;xMessage, pxHigherPriorityTaskWoken );\n\ntracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );\n\nreturn xReturn;\n}\n\n#endif /* INCLUDE_xTimerPendFunctionCall */\n/*-----------------------------------------------------------*/\n\n#if( INCLUDE_xTimerPendFunctionCall == 1 )\n\nBaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait )\n{\nDaemonTaskMessage_t xMessage;\nBaseType_t xReturn;\n\n/* This function can only be called after a timer has been created or\n        after the scheduler has been started because, until then, the timer\n        queue does not exist. */\nconfigASSERT( xTimerQueue );\n\n/* Complete the message with the function parameters and post it to the\n        daemon task. */\nxMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK;\nxMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;\nxMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;\nxMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;\n\nxReturn = xQueueSendToBack( xTimerQueue, &amp;xMessage, xTicksToWait );\n\ntracePEND_FUNC_CALL( xFunctionToPend, pvParameter1, ulParameter2, xReturn );\n\nreturn xReturn;\n}\n\n#endif /* INCLUDE_xTimerPendFunctionCall */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_TRACE_FACILITY == 1 )\n\nUBaseType_t uxTimerGetTimerNumber( TimerHandle_t xTimer )\n{\nreturn ( ( Timer_t * ) xTimer )-&gt;uxTimerNumber;\n}\n\n#endif /* configUSE_TRACE_FACILITY */\n/*-----------------------------------------------------------*/\n\n#if ( configUSE_TRACE_FACILITY == 1 )\n\nvoid vTimerSetTimerNumber( TimerHandle_t xTimer, UBaseType_t uxTimerNumber )\n{\n( ( Timer_t * ) xTimer )-&gt;uxTimerNumber = uxTimerNumber;\n}\n\n#endif /* configUSE_TRACE_FACILITY */\n/*-----------------------------------------------------------*/\n\n/* This entire source file will be skipped if the application is not configured\nto include software timer functionality.  If you want to include software timer\nfunctionality then ensure configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */\n#endif /* configUSE_TIMERS == 1 */\n</code></pre>"},{"location":"apiStm/dir_ba91ee832338db2cc6be09eb7edd6a06/","title":"Dir fw/rbcx-coprocessor/lib/libusb_stm32","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; lib &gt; libusb_stm32</p>"},{"location":"apiStm/dir_ba91ee832338db2cc6be09eb7edd6a06/#directories","title":"Directories","text":"Type Name dir include dir src <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/</code></p>"},{"location":"apiStm/dir_65452da8826453c25a2896bba09f0855/","title":"Dir fw/rbcx-coprocessor/lib/libusb_stm32/include","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; lib &gt; libusb_stm32 &gt; include</p>"},{"location":"apiStm/dir_65452da8826453c25a2896bba09f0855/#files","title":"Files","text":"Type Name file stm32.h file usb.h file usb_cdc.h file usb_std.h file usbd_core.h <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/</code></p>"},{"location":"apiStm/stm32_8h/","title":"File stm32.h","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; lib &gt; libusb_stm32 &gt; include &gt; stm32.h</p> <p>Go to the source code of this file.</p>"},{"location":"apiStm/stm32_8h/#macros","title":"Macros","text":"Type Name define _BCL (reg, bits) (reg) = ((reg) &amp; ~(bits)) define _BMD (reg, msk, val) (reg) = (((reg) &amp; ~(msk)) | (val)) define _BST (reg, bits) (reg) = ((reg) | (bits)) define _BV (bit) (0x01 &lt;&lt; (bit)) define _WBC (reg, bits) while(((reg) &amp; (bits)) != 0) define _WBS (reg, bits) while(((reg) &amp; (bits)) == 0) define _WVL (reg, msk, val) while(((reg) &amp; (msk)) != (val))"},{"location":"apiStm/stm32_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/stm32_8h/#define-_bcl","title":"define _BCL","text":"<pre><code>#define _BCL (\nreg,\nbits\n) (reg) = ((reg) &amp; ~(bits))\n</code></pre>"},{"location":"apiStm/stm32_8h/#define-_bmd","title":"define _BMD","text":"<pre><code>#define _BMD (\nreg,\nmsk,\nval\n) (reg) = (((reg) &amp; ~(msk)) | (val))\n</code></pre>"},{"location":"apiStm/stm32_8h/#define-_bst","title":"define _BST","text":"<pre><code>#define _BST (\nreg,\nbits\n) (reg) = ((reg) | (bits))\n</code></pre>"},{"location":"apiStm/stm32_8h/#define-_bv","title":"define _BV","text":"<pre><code>#define _BV (\nbit\n) (0x01 &lt;&lt; (bit))\n</code></pre>"},{"location":"apiStm/stm32_8h/#define-_wbc","title":"define _WBC","text":"<pre><code>#define _WBC (\nreg,\nbits\n) while(((reg) &amp; (bits)) != 0)\n</code></pre>"},{"location":"apiStm/stm32_8h/#define-_wbs","title":"define _WBS","text":"<pre><code>#define _WBS (\nreg,\nbits\n) while(((reg) &amp; (bits)) == 0)\n</code></pre>"},{"location":"apiStm/stm32_8h/#define-_wvl","title":"define _WVL","text":"<pre><code>#define _WVL (\nreg,\nmsk,\nval\n) while(((reg) &amp; (msk)) != (val))\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/stm32.h</code></p>"},{"location":"apiStm/stm32_8h_source/","title":"File stm32.h","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; lib &gt; libusb_stm32 &gt; include &gt; stm32.h</p> <p>Go to the documentation of this file. </p> <pre><code>#ifndef _STM32_H_\n#define _STM32_H_\n\n/* modify bitfield */\n#define _BMD(reg, msk, val)     (reg) = (((reg) &amp; ~(msk)) | (val))\n/* set bitfield */\n#define _BST(reg, bits)         (reg) = ((reg) | (bits))\n/* clear bitfield */\n#define _BCL(reg, bits)         (reg) = ((reg) &amp; ~(bits))\n/* wait until bitfield set */\n#define _WBS(reg, bits)         while(((reg) &amp; (bits)) == 0)\n/* wait until bitfield clear */\n#define _WBC(reg, bits)         while(((reg) &amp; (bits)) != 0)\n/* wait for bitfield value */\n#define _WVL(reg, msk, val)     while(((reg) &amp; (msk)) != (val))\n/* bit value */\n#define _BV(bit)                (0x01 &lt;&lt; (bit))\n\n#if defined(STM32F0)\n#include \"stm32f0xx.h\"\n#elif defined(STM32F1)\n#include \"stm32f1xx.h\"\n#elif defined(STM32F2)\n#include \"stm32f2xx.h\"\n#elif defined(STM32F3)\n#include \"stm32f3xx.h\"\n#elif defined(STM32F4)\n#include \"stm32f4xx.h\"\n#elif defined(STM32F7)\n#include \"stm32f7xx.h\"\n#elif defined(STM32H7)\n#include \"stm32h7xx.h\"\n#elif defined(STM32L0)\n#include \"stm32l0xx.h\"\n#elif defined(STM32L1)\n#include \"stm32l1xx.h\"\n#elif defined(STM32L4)\n#include \"stm32l4xx.h\"\n#elif defined(STM32G4)\n#include \"stm32g4xx.h\"\n#else\n#error \"STM32 family not defined\"\n#endif\n\n\n#endif // _STM32_H_\n</code></pre>"},{"location":"apiStm/usb_8h/","title":"File usb.h","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; lib &gt; libusb_stm32 &gt; include &gt; usb.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"usbd_core.h\"</code></li> <li><code>#include \"usb_std.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb.h</code></p>"},{"location":"apiStm/usb_8h_source/","title":"File usb.h","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; lib &gt; libusb_stm32 &gt; include &gt; usb.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* This file is the part of the Lightweight USB device Stack for STM32 microcontrollers\n *\n * Copyright \u00a92016 Dmitry Filimonchuk &lt;dmitrystu[at]gmail[dot]com&gt;\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *   http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _USB_H_\n#define _USB_H_\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n\n#include \"usbd_core.h\"\n#if !defined(__ASSEMBLER__)\n#include \"usb_std.h\"\n#endif\n\n#if defined(STM32L052xx) || defined(STM32L053xx) || \\\n    defined(STM32L062xx) || defined(STM32L063xx) || \\\n    defined(STM32L072xx) || defined(STM32L073xx) || \\\n    defined(STM32L082xx) || defined(STM32L083xx) || \\\n    defined(STM32F042x6) || defined(STM32F048xx) || \\\n    defined(STM32F070x6) || defined(STM32F070xB) || \\\n    defined(STM32F072xB) || defined(STM32F078xx)\n\n#define USBD_STM32L052\n\n#if !defined(__ASSEMBLER__)\nextern const struct usbd_driver usbd_devfs;\nextern const struct usbd_driver usbd_devfs_asm;\n#if defined(USBD_ASM_DRIVER)\n#define usbd_hw usbd_devfs_asm\n#else\n#define usbd_hw usbd_devfs\n#endif\n#endif\n\n#elif defined(STM32L432xx) || defined(STM32L433xx) || \\\n      defined(STM32L442xx) || defined(STM32L443xx) || \\\n      defined(STM32L452xx) || defined(STM32L462xx) || \\\n      defined(STM32G4)\n\n#define USBD_STM32L433\n\n#if !defined(__ASSEMBLER__)\nextern const struct usbd_driver usbd_devfs;\nextern const struct usbd_driver usbd_devfs_asm;\n#if defined(USBD_ASM_DRIVER)\n#define usbd_hw usbd_devfs_asm\n#else\n#define usbd_hw usbd_devfs\n#endif\n#endif\n\n#elif defined(STM32L1)\n\n#define USBD_STM32L100\n\n#if !defined(__ASSEMBLER__)\nextern const struct usbd_driver usbd_devfs;\nextern const struct usbd_driver usbd_devfs_asm;\n#if defined(USBD_ASM_DRIVER)\n#define usbd_hw usbd_devfs_asm\n#else\n#define usbd_hw usbd_devfs\n#endif\n#endif\n\n#elif defined(STM32L475xx) || defined(STM32L476xx)\n\n#define USBD_STM32L476\n\n#if !defined(__ASSEMBLER__)\nextern const struct usbd_driver usbd_otgfs;\n#define usbd_hw usbd_otgfs\n#endif\n\n#elif defined(STM32F405xx) || defined(STM32F415xx) || \\\n      defined(STM32F407xx) || defined(STM32F417xx) || \\\n      defined(STM32F427xx) || defined(STM32F437xx) || \\\n      defined(STM32F429xx) || defined(STM32F439xx)\n\n#define USBD_STM32F429FS\n#define USBD_STM32F429HS\n\n#if !defined(__ASSEMBLER__)\nextern const struct usbd_driver usbd_otgfs;\nextern const struct usbd_driver usbd_otghs;\n#if defined(USBD_PRIMARY_OTGHS)\n#define usbd_hw usbd_otghs\n#else\n#define usbd_hw usbd_otgfs\n#endif\n#endif  //__ASSEMBLER__\n\n#elif defined(STM32F411xE)\n\n#define USBD_STM32F429FS\nextern const struct usbd_driver usbd_otgfs;\n#define usbd_hw usbd_otgfs\n\n#elif defined(STM32F102x6) || defined(STM32F102xB) || \\\n      defined(STM32F103x6) || defined(STM32F103xB) || \\\n      defined(STM32F103xE) || defined(STM32F103xG) || \\\n      defined(STM32F302x8) || defined(STM32F302xC) || defined(STM32F302xE) || \\\n      defined(STM32F303xC) || defined(STM32F303xE) || \\\n      defined(STM32F373xC)\n\n#define USBD_STM32F103\n\n#if !defined(__ASSEMBLER__)\nextern const struct usbd_driver usbd_devfs;\nextern const struct usbd_driver usbd_devfs_asm;\n#if defined(USBD_ASM_DRIVER)\n#define usbd_hw usbd_devfs_asm\n#else\n#define usbd_hw usbd_devfs\n#endif\n#endif\n\n#elif defined(STM32F105xC) || defined(STM32F107xC)\n#define USBD_STM32F105\n\n#if !defined(__ASSEMBLER__)\nextern const struct usbd_driver usbd_otgfs;\n#define usbd_hw usbd_otgfs\n#endif\n\n#else\n#error Unsupported STM32 family\n#endif\n\n#if defined (__cplusplus)\n}\n#endif\n#endif //_USB_H_\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/","title":"File usb_cdc.h","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; lib &gt; libusb_stm32 &gt; include &gt; usb_cdc.h</p> <p>Go to the source code of this file.</p>"},{"location":"apiStm/usb__cdc_8h/#classes","title":"Classes","text":"Type Name struct usb_cdc_acm_desc Abstract Control Management Functional Descriptor. struct usb_cdc_call_mgmt_desc Call Management Functional Descriptor. struct usb_cdc_country_desc Country Selection Functional Descriptor. struct usb_cdc_header_desc Header Functional Descriptor. struct usb_cdc_line_coding Line Coding Structure. struct usb_cdc_notification Notification structure from CDC. struct usb_cdc_union_desc Union Functional Descriptor."},{"location":"apiStm/usb__cdc_8h/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t Data Data payload. uint8_t bCharFormat Stop bits. uint8_t bDataBits Data bits (5,6,7,8 or 16). uint8_t bDataInterface Interface number of Data Class interface optionally used for call management. uint8_t bDescriptorSubType Header functional descriptor subtype. uint8_t bDescriptorType CS_INTERFACE descriptor type. uint8_t bFunctionLength Size of this descriptor in bytes. uint8_t bMasterInterface0 The interface number of the CDC interface designated as the master or controlling interface for the union. uint8_t bNotificationType Notification type. uint8_t bParityType Parity. uint8_t bSlaveInterface0 Interface number of first slave or associated interface in the union. uint16_t bcdCDC USB CDC Specification release number in BCD. uint8_t bmCapabilities The call management capabilities that this configuration supports. uint8_t bmRequestType This bitmapped field identifies the characteristics of the specific request. uint32_t dwDTERate Data terminal rate, in bits per second. uint8_t iCountryCodeRelDate Index of a string giving the release date for the implemented ISO 3166 Country Codes. uint8_t wCountyCode0 Country code in hexadecimal format. uint16_t wIndex Interface. uint16_t wLength Data payload length in bytes. uint16_t wValue Notification value."},{"location":"apiStm/usb__cdc_8h/#public-functions","title":"Public Functions","text":"Type Name struct usb_cdc_header_desc __attribute__ ((packed))"},{"location":"apiStm/usb__cdc_8h/#macros","title":"Macros","text":"Type Name define USB_CDC_1_5_STOP_BITS  0x011.5 stop bits. define USB_CDC_1_STOP_BITS  0x001 stop bit. define USB_CDC_2_STOP_BITS  0x022 stop bits. define USB_CDC_CALL_MGMT_CAP_CALL_MGMT  0x01Device handles call management itself. define USB_CDC_CALL_MGMT_CAP_DATA_INTF  0x02Device can send/receive call management information over a Data Class interface. define USB_CDC_CAP_BRK  0x04Supports the request Send_Break. define USB_CDC_CAP_LINE  0x02Supports the request combination of Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State. define USB_CDC_CAP_NOTIFY  0x08Supports notification Network_Connection. define USB_CDC_CLEAR_COMM_FEATURE  0x04Controls the settings for a particular communication feature of a particular target, setting the selected feature to its default state. define USB_CDC_COMM_FEATURE  0x01Supports the request combination of Set_Comm_Feature, Clear_Comm_Feature, Get_Comm_Feature. define USB_CDC_EVEN_PARITY  0x02EVEN parity bit. define USB_CDC_GET_COMM_FEATURE  0x03Returns the current settings for the communication feature as selected. define USB_CDC_GET_ENCAPSULATED_RESP  0x01Used to request a response in the format of the supported control protocol of the Communication Class interface. define USB_CDC_GET_LINE_CODING  0x21Allows the host to find out the currently configured line coding. define USB_CDC_MARK_PARITY  0x03patity is MARK. define USB_CDC_NO_PARITY  0x00NO parity bit. define USB_CDC_NTF_NETWORK_CONNECTION  0x00Allows the device to notify the host about network connection status. define USB_CDC_NTF_RESPONSE_AVAILABLE  0x01Allows the device to notify the host that a response is available. define USB_CDC_NTF_SERIAL_STATE  0x20Sends asynchronous notification of UART status. define USB_CDC_NTF_SPEED_CHANGE  0x2AAllows the device to inform the host-networking driver that a change in either the uplink or the downlink bit rate of the connection has occurred. define USB_CDC_ODD_PARITY  0x01ODD parity bit. define USB_CDC_PROTO_CDCSPEC  0xFECDC specified. define USB_CDC_PROTO_HOST  0xFDHost based driver. define USB_CDC_PROTO_NONE  0x00No class specific protocol required. define USB_CDC_PROTO_NTB  0x01Network Transfer Block. define USB_CDC_PROTO_V25TER  0x01AT Commands: V.250 etc. define USB_CDC_SEND_BREAK  0x23Sends special carrier modulation that generates an RS-232 style break. define USB_CDC_SEND_ENCAPSULATED_CMD  0x00Used to issue a command in the format of the supported control protocol of the Communication Class interface. define USB_CDC_SET_COMM_FEATURE  0x02Controls the settings for a particular communication feature of a particular target. define USB_CDC_SET_CONTROL_LINE_STATE  0x22Generates RS-232/V.24 style control signals. define USB_CDC_SET_LINE_CODING  0x20Allows the host to specify typical asynchronous line-character formatting properties. define USB_CDC_SPACE_PARITY  0x04patity is SPACE. define USB_CDC_STATE_BREAK  0x0004State of break detection mechanism of the device. define USB_CDC_STATE_FRAMING  0x0010A framing error has occurred. define USB_CDC_STATE_OVERRUN  0x0040Received data has been discarded due to overrun in the device. define USB_CDC_STATE_PARITY  0x0020A parity error has occurred. define USB_CDC_STATE_RING  0x0008State of ring signal detection of the device. define USB_CDC_STATE_RX_CARRIER  0x0001State of receiver carrier detection mechanism. define USB_CDC_STATE_TX_CARRIER  0x0002State of transmission carrier. define USB_CDC_SUBCLASS_ACM  0x02Abstract Control Model. define USB_CLASS_CDC  0x02Communicational Device class. define USB_CLASS_CDC_DATA  0x0AData Interface class. define USB_DTYPE_CDC_ACM  0x02Abstract Control Management Functional Descriptor. define USB_DTYPE_CDC_CALL_MANAGEMENT  0x01Call Management Functional Descriptor. define USB_DTYPE_CDC_COUNTRY  0x07Country Selection Functional Descriptor. define USB_DTYPE_CDC_HEADER  0x00Header Functional Descriptor. define USB_DTYPE_CDC_UNION  0x06Union Functional Descriptor."},{"location":"apiStm/usb__cdc_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/usb__cdc_8h/#variable-data","title":"variable Data","text":"<pre><code>uint8_t Data[];\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#variable-bcharformat","title":"variable bCharFormat","text":"<pre><code>uint8_t bCharFormat;\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#variable-bdatabits","title":"variable bDataBits","text":"<pre><code>uint8_t bDataBits;\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#variable-bdatainterface","title":"variable bDataInterface","text":"<pre><code>uint8_t bDataInterface;\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#variable-bdescriptorsubtype","title":"variable bDescriptorSubType","text":"<p>Header functional descriptor subtype. <pre><code>uint8_t bDescriptorSubType;\n</code></pre></p> <p>Abstract Control Management functional descriptor subtype.</p> <p>Call Management functional descriptor subtype.</p> <p>Country Selection Functional Descriptor.</p> <p>Union Functional Descriptor. </p>"},{"location":"apiStm/usb__cdc_8h/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<p>CS_INTERFACE descriptor type. <pre><code>uint8_t bDescriptorType;\n</code></pre></p> <p>Debug descriptor type.</p> <p>String descriptor type.</p> <p>Endpoint descriptor.</p> <p>IAD descriptor.</p> <p>Interface descriptor.</p> <p>Configuration descriptor.</p> <p>Qualifier descriptor.</p> <p>USB_DTYPE_DEVICE Device descriptor. </p>"},{"location":"apiStm/usb__cdc_8h/#variable-bfunctionlength","title":"variable bFunctionLength","text":"<p>Size of this descriptor in bytes. <pre><code>uint8_t bFunctionLength;\n</code></pre></p> <p>Size of this functional descriptor, in bytes. </p>"},{"location":"apiStm/usb__cdc_8h/#variable-bmasterinterface0","title":"variable bMasterInterface0","text":"<pre><code>uint8_t bMasterInterface0;\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#variable-bnotificationtype","title":"variable bNotificationType","text":"<pre><code>uint8_t bNotificationType;\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#variable-bparitytype","title":"variable bParityType","text":"<pre><code>uint8_t bParityType;\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#variable-bslaveinterface0","title":"variable bSlaveInterface0","text":"<pre><code>uint8_t bSlaveInterface0;\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#variable-bcdcdc","title":"variable bcdCDC","text":"<pre><code>uint16_t bcdCDC;\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#variable-bmcapabilities","title":"variable bmCapabilities","text":"<p>The call management capabilities that this configuration supports. <pre><code>uint8_t bmCapabilities;\n</code></pre></p> <p>The capabilities that this configuration supports. </p>"},{"location":"apiStm/usb__cdc_8h/#variable-bmrequesttype","title":"variable bmRequestType","text":"<pre><code>uint8_t bmRequestType;\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#variable-dwdterate","title":"variable dwDTERate","text":"<pre><code>uint32_t dwDTERate;\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#variable-icountrycodereldate","title":"variable iCountryCodeRelDate","text":"<pre><code>uint8_t iCountryCodeRelDate;\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#variable-wcountycode0","title":"variable wCountyCode0","text":"<p>Country code in hexadecimal format. <pre><code>uint8_t wCountyCode0;\n</code></pre></p> <p>As defined in ISO 3166, release date as specified in iCountryCodeRelDate for the first supported country. </p>"},{"location":"apiStm/usb__cdc_8h/#variable-windex","title":"variable wIndex","text":"<pre><code>uint16_t wIndex;\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#variable-wlength","title":"variable wLength","text":"<pre><code>uint16_t wLength;\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#variable-wvalue","title":"variable wValue","text":"<pre><code>uint16_t wValue;\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/usb__cdc_8h/#function-__attribute__","title":"function __attribute__","text":"<pre><code>struct usb_cdc_header_desc __attribute__ (\n(packed)\n) </code></pre>"},{"location":"apiStm/usb__cdc_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_1_5_stop_bits","title":"define USB_CDC_1_5_STOP_BITS","text":"<pre><code>#define USB_CDC_1_5_STOP_BITS 0x01\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_1_stop_bits","title":"define USB_CDC_1_STOP_BITS","text":"<pre><code>#define USB_CDC_1_STOP_BITS 0x00\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_2_stop_bits","title":"define USB_CDC_2_STOP_BITS","text":"<pre><code>#define USB_CDC_2_STOP_BITS 0x02\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_call_mgmt_cap_call_mgmt","title":"define USB_CDC_CALL_MGMT_CAP_CALL_MGMT","text":"<pre><code>#define USB_CDC_CALL_MGMT_CAP_CALL_MGMT 0x01\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_call_mgmt_cap_data_intf","title":"define USB_CDC_CALL_MGMT_CAP_DATA_INTF","text":"<pre><code>#define USB_CDC_CALL_MGMT_CAP_DATA_INTF 0x02\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_cap_brk","title":"define USB_CDC_CAP_BRK","text":"<pre><code>#define USB_CDC_CAP_BRK 0x04\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_cap_line","title":"define USB_CDC_CAP_LINE","text":"<pre><code>#define USB_CDC_CAP_LINE 0x02\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_cap_notify","title":"define USB_CDC_CAP_NOTIFY","text":"<pre><code>#define USB_CDC_CAP_NOTIFY 0x08\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_clear_comm_feature","title":"define USB_CDC_CLEAR_COMM_FEATURE","text":"<pre><code>#define USB_CDC_CLEAR_COMM_FEATURE 0x04\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_comm_feature","title":"define USB_CDC_COMM_FEATURE","text":"<pre><code>#define USB_CDC_COMM_FEATURE 0x01\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_even_parity","title":"define USB_CDC_EVEN_PARITY","text":"<pre><code>#define USB_CDC_EVEN_PARITY 0x02\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_get_comm_feature","title":"define USB_CDC_GET_COMM_FEATURE","text":"<pre><code>#define USB_CDC_GET_COMM_FEATURE 0x03\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_get_encapsulated_resp","title":"define USB_CDC_GET_ENCAPSULATED_RESP","text":"<pre><code>#define USB_CDC_GET_ENCAPSULATED_RESP 0x01\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_get_line_coding","title":"define USB_CDC_GET_LINE_CODING","text":"<pre><code>#define USB_CDC_GET_LINE_CODING 0x21\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_mark_parity","title":"define USB_CDC_MARK_PARITY","text":"<pre><code>#define USB_CDC_MARK_PARITY 0x03\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_no_parity","title":"define USB_CDC_NO_PARITY","text":"<pre><code>#define USB_CDC_NO_PARITY 0x00\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_ntf_network_connection","title":"define USB_CDC_NTF_NETWORK_CONNECTION","text":"<pre><code>#define USB_CDC_NTF_NETWORK_CONNECTION 0x00\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_ntf_response_available","title":"define USB_CDC_NTF_RESPONSE_AVAILABLE","text":"<pre><code>#define USB_CDC_NTF_RESPONSE_AVAILABLE 0x01\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_ntf_serial_state","title":"define USB_CDC_NTF_SERIAL_STATE","text":"<pre><code>#define USB_CDC_NTF_SERIAL_STATE 0x20\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_ntf_speed_change","title":"define USB_CDC_NTF_SPEED_CHANGE","text":"<pre><code>#define USB_CDC_NTF_SPEED_CHANGE 0x2A\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_odd_parity","title":"define USB_CDC_ODD_PARITY","text":"<pre><code>#define USB_CDC_ODD_PARITY 0x01\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_proto_cdcspec","title":"define USB_CDC_PROTO_CDCSPEC","text":"<p>CDC specified. <pre><code>#define USB_CDC_PROTO_CDCSPEC 0xFE\n</code></pre></p> <p>The protocol(s) are described using a Protocol Unit Functional Descriptors on Communication Class Interface. </p>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_proto_host","title":"define USB_CDC_PROTO_HOST","text":"<p>Host based driver. <pre><code>#define USB_CDC_PROTO_HOST 0xFD\n</code></pre></p> <p>This protocol code should only be used in messages between host and device to identify the host driver portion of a protocol stack. </p>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_proto_none","title":"define USB_CDC_PROTO_NONE","text":"<pre><code>#define USB_CDC_PROTO_NONE 0x00\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_proto_ntb","title":"define USB_CDC_PROTO_NTB","text":"<pre><code>#define USB_CDC_PROTO_NTB 0x01\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_proto_v25ter","title":"define USB_CDC_PROTO_V25TER","text":"<pre><code>#define USB_CDC_PROTO_V25TER 0x01\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_send_break","title":"define USB_CDC_SEND_BREAK","text":"<pre><code>#define USB_CDC_SEND_BREAK 0x23\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_send_encapsulated_cmd","title":"define USB_CDC_SEND_ENCAPSULATED_CMD","text":"<pre><code>#define USB_CDC_SEND_ENCAPSULATED_CMD 0x00\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_set_comm_feature","title":"define USB_CDC_SET_COMM_FEATURE","text":"<pre><code>#define USB_CDC_SET_COMM_FEATURE 0x02\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_set_control_line_state","title":"define USB_CDC_SET_CONTROL_LINE_STATE","text":"<pre><code>#define USB_CDC_SET_CONTROL_LINE_STATE 0x22\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_set_line_coding","title":"define USB_CDC_SET_LINE_CODING","text":"<pre><code>#define USB_CDC_SET_LINE_CODING 0x20\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_space_parity","title":"define USB_CDC_SPACE_PARITY","text":"<pre><code>#define USB_CDC_SPACE_PARITY 0x04\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_state_break","title":"define USB_CDC_STATE_BREAK","text":"<pre><code>#define USB_CDC_STATE_BREAK 0x0004\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_state_framing","title":"define USB_CDC_STATE_FRAMING","text":"<pre><code>#define USB_CDC_STATE_FRAMING 0x0010\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_state_overrun","title":"define USB_CDC_STATE_OVERRUN","text":"<pre><code>#define USB_CDC_STATE_OVERRUN 0x0040\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_state_parity","title":"define USB_CDC_STATE_PARITY","text":"<pre><code>#define USB_CDC_STATE_PARITY 0x0020\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_state_ring","title":"define USB_CDC_STATE_RING","text":"<pre><code>#define USB_CDC_STATE_RING 0x0008\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_state_rx_carrier","title":"define USB_CDC_STATE_RX_CARRIER","text":"<p>State of receiver carrier detection mechanism. <pre><code>#define USB_CDC_STATE_RX_CARRIER 0x0001\n</code></pre></p> <p>This signal corresponds to V.24 signal 109 and RS-232 DCD. </p>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_state_tx_carrier","title":"define USB_CDC_STATE_TX_CARRIER","text":"<p>State of transmission carrier. <pre><code>#define USB_CDC_STATE_TX_CARRIER 0x0002\n</code></pre></p> <p>This signal corresponds to V.24 signal 106 and RS-232 DSR. </p>"},{"location":"apiStm/usb__cdc_8h/#define-usb_cdc_subclass_acm","title":"define USB_CDC_SUBCLASS_ACM","text":"<pre><code>#define USB_CDC_SUBCLASS_ACM 0x02\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_class_cdc","title":"define USB_CLASS_CDC","text":"<pre><code>#define USB_CLASS_CDC 0x02\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_class_cdc_data","title":"define USB_CLASS_CDC_DATA","text":"<pre><code>#define USB_CLASS_CDC_DATA 0x0A\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_dtype_cdc_acm","title":"define USB_DTYPE_CDC_ACM","text":"<pre><code>#define USB_DTYPE_CDC_ACM 0x02\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_dtype_cdc_call_management","title":"define USB_DTYPE_CDC_CALL_MANAGEMENT","text":"<pre><code>#define USB_DTYPE_CDC_CALL_MANAGEMENT 0x01\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_dtype_cdc_country","title":"define USB_DTYPE_CDC_COUNTRY","text":"<pre><code>#define USB_DTYPE_CDC_COUNTRY 0x07\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_dtype_cdc_header","title":"define USB_DTYPE_CDC_HEADER","text":"<pre><code>#define USB_DTYPE_CDC_HEADER 0x00\n</code></pre>"},{"location":"apiStm/usb__cdc_8h/#define-usb_dtype_cdc_union","title":"define USB_DTYPE_CDC_UNION","text":"<pre><code>#define USB_DTYPE_CDC_UNION 0x06\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_cdc.h</code></p>"},{"location":"apiStm/usb__cdc_8h_source/","title":"File usb_cdc.h","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; lib &gt; libusb_stm32 &gt; include &gt; usb_cdc.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* This file is the part of the Lightweight USB device Stack for STM32 microcontrollers\n *\n * Copyright \u00a92016 Dmitry Filimonchuk &lt;dmitrystu[at]gmail[dot]com&gt;\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *   http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _USB_CDC_H_\n#define _USB_CDC_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define USB_CLASS_CDC                   0x02    \n#define USB_CLASS_CDC_DATA              0x0A    \n#define USB_CDC_SUBCLASS_ACM            0x02    \n#define USB_CDC_PROTO_NONE              0x00    \n#define USB_CDC_PROTO_V25TER            0x01    \n#define USB_CDC_PROTO_NTB               0x01    \n#define USB_CDC_PROTO_HOST              0xFD    \n#define USB_CDC_PROTO_CDCSPEC           0xFE    \n#define USB_DTYPE_CDC_HEADER            0x00    \n#define USB_DTYPE_CDC_CALL_MANAGEMENT   0x01    \n#define USB_DTYPE_CDC_ACM               0x02    \n#define USB_DTYPE_CDC_UNION             0x06    \n#define USB_DTYPE_CDC_COUNTRY           0x07    \n#define USB_CDC_SEND_ENCAPSULATED_CMD   0x00    \n#define USB_CDC_GET_ENCAPSULATED_RESP   0x01    \n#define USB_CDC_SET_COMM_FEATURE        0x02    \n#define USB_CDC_GET_COMM_FEATURE        0x03    \n#define USB_CDC_CLEAR_COMM_FEATURE      0x04    \n#define USB_CDC_SET_LINE_CODING         0x20    \n#define USB_CDC_GET_LINE_CODING         0x21    \n#define USB_CDC_SET_CONTROL_LINE_STATE  0x22    \n#define USB_CDC_SEND_BREAK              0x23    \n#define USB_CDC_NTF_NETWORK_CONNECTION  0x00    \n#define USB_CDC_NTF_RESPONSE_AVAILABLE  0x01    \n#define USB_CDC_NTF_SERIAL_STATE        0x20    \n#define USB_CDC_NTF_SPEED_CHANGE        0x2A    \n#define USB_CDC_COMM_FEATURE            0x01    \n#define USB_CDC_CAP_LINE                0x02    \n#define USB_CDC_CAP_BRK                 0x04    \n#define USB_CDC_CAP_NOTIFY              0x08    \n#define USB_CDC_CALL_MGMT_CAP_CALL_MGMT 0x01    \n#define USB_CDC_CALL_MGMT_CAP_DATA_INTF 0x02    \n#define USB_CDC_1_STOP_BITS             0x00    \n#define USB_CDC_1_5_STOP_BITS           0x01    \n#define USB_CDC_2_STOP_BITS             0x02    \n#define USB_CDC_NO_PARITY               0x00    \n#define USB_CDC_ODD_PARITY              0x01    \n#define USB_CDC_EVEN_PARITY             0x02    \n#define USB_CDC_MARK_PARITY             0x03    \n#define USB_CDC_SPACE_PARITY            0x04    \n#define USB_CDC_STATE_RX_CARRIER        0x0001 \n#define USB_CDC_STATE_TX_CARRIER        0x0002 \n#define USB_CDC_STATE_BREAK             0x0004 \n#define USB_CDC_STATE_RING              0x0008 \n#define USB_CDC_STATE_FRAMING           0x0010 \n#define USB_CDC_STATE_PARITY            0x0020 \n#define USB_CDC_STATE_OVERRUN           0x0040 \nstruct usb_cdc_header_desc {\nuint8_t     bFunctionLength;    uint8_t     bDescriptorType;    uint8_t     bDescriptorSubType; uint16_t    bcdCDC;             } __attribute__ ((packed));\n\nstruct usb_cdc_union_desc {\nuint8_t     bFunctionLength;    uint8_t     bDescriptorType;    uint8_t     bDescriptorSubType; uint8_t     bMasterInterface0;  uint8_t     bSlaveInterface0;   /* ... and there could be other slave interfaces */\n} __attribute__ ((packed));\n\nstruct usb_cdc_country_desc {\nuint8_t     bFunctionLength;     uint8_t     bDescriptorType;     uint8_t     bDescriptorSubType;  uint8_t     iCountryCodeRelDate; uint8_t     wCountyCode0;        /* ... and there can be a lot of country codes */\n} __attribute__ ((packed));\n\nstruct usb_cdc_call_mgmt_desc {\nuint8_t     bFunctionLength;    uint8_t     bDescriptorType;    uint8_t     bDescriptorSubType; uint8_t     bmCapabilities;     uint8_t     bDataInterface;     } __attribute__ ((packed));\n\nstruct usb_cdc_acm_desc {\nuint8_t     bFunctionLength;    uint8_t     bDescriptorType;    uint8_t     bDescriptorSubType; uint8_t     bmCapabilities;     } __attribute__ ((packed));\n\nstruct usb_cdc_notification {\nuint8_t     bmRequestType;      uint8_t     bNotificationType;  uint16_t    wValue;             uint16_t    wIndex;             uint16_t    wLength;            uint8_t     Data[];             } __attribute__ ((packed));\n\nstruct usb_cdc_line_coding {\nuint32_t    dwDTERate;          uint8_t     bCharFormat;        uint8_t     bParityType;        uint8_t     bDataBits;          } __attribute__ ((packed));\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* _USB_CDC_H_ */\n</code></pre>"},{"location":"apiStm/usb__std_8h/","title":"File usb_std.h","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; lib &gt; libusb_stm32 &gt; include &gt; usb_std.h</p> <p>Go to the source code of this file.</p>"},{"location":"apiStm/usb__std_8h/#classes","title":"Classes","text":"Type Name struct usb_config_descriptor USB device configuration descriptor. struct usb_debug_descriptor USB debug descriptor. struct usb_device_descriptor Represents a USB device descriptor. struct usb_endpoint_descriptor USB endpoint descriptor. struct usb_header_descriptor common USB descriptor header struct usb_iad_descriptor USB interface association descriptor. struct usb_interface_descriptor USB interface descriptor. struct usb_qualifier_descriptor USB device qualifier descriptor. struct usb_string_descriptor USB string descriptor."},{"location":"apiStm/usb__std_8h/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bAlternateSetting Alternate setting for the interface number. uint8_t bConfigurationValue Configuration index of the current configuration. uint8_t bDebugInEndpoint Endpoint number of the Debug Data IN endpoint. uint8_t bDebugOutEndpoint Endpoint number of the Debug Data OUTendpoint. uint8_t bDescriptorType Type of the descriptor. uint8_t bDeviceClass USB device class. uint8_t bDeviceProtocol USB device protocol. uint8_t bDeviceSubClass USB device subclass. uint8_t bEndpointAddress Logical address of the endpoint within the device for the current configuration, including direction mask. uint8_t bFirstInterface Index of the first associated interface. uint8_t bFunctionClass Function class ID. uint8_t bFunctionProtocol Function protocol ID. uint8_t bFunctionSubClass Function subclass ID. uint8_t bInterfaceClass Interface class ID. uint8_t bInterfaceCount Total number of associated interfaces. uint8_t bInterfaceNumber Index of the interface in the current configuration. uint8_t bInterfaceProtocol Interface protocol ID. uint8_t bInterfaceSubClass Interface subclass ID. uint8_t bInterval Polling interval in milliseconds for the endpoint if it is an INTERRUPT or ISOCHRONOUS type. uint8_t bLength Size of the descriptor, in bytes. uint8_t bMaxPacketSize0 Size of the control endpoint's bank in bytes. uint8_t bMaxPower Maximum power consumption of the device. USB_CFG_POWER_MA() macro. uint8_t bNumConfigurations Total number of configurations supported by the device. uint8_t bNumEndpoints Total number of endpoints in the interface. uint8_t bNumInterfaces Total number of interfaces in the configuration. uint8_t bReserved Reserved for future use, must be 0. uint16_t bcdDevice Product release (version) number. uint16_t bcdUSB BCD of the supported USB specification. uint8_t bmAttributes Configuration attributes. uint8_t iConfiguration Index of a string descriptor describing the configuration. uint8_t iFunction Index of the string descriptor describing the interface association. uint8_t iInterface Index of the string descriptor describing the interface. uint8_t iManufacturer String index for the manufacturer's name. uint8_t iProduct String index for the product name/details. uint8_t iSerialNumber String index for the product serial number. uint16_t idProduct Unique product ID for the USB product. uint16_t idVendor Vendor ID for the USB product. uint16_t wMaxPacketSize Size of the endpoint bank, in bytes. This indicates the maximum packet size that the endpoint can receive at a time. uint16_t wString String data, as unicode characters or array of USB standard LANGID codes codes. uint16_t wTotalLength Size of the configuration descriptor header, and all sub descriptors inside the configuration."},{"location":"apiStm/usb__std_8h/#public-functions","title":"Public Functions","text":"Type Name struct usb_header_descriptor __attribute__ ((packed))  struct usb_string_descriptor __attribute__ ((packed, aligned(2)))"},{"location":"apiStm/usb__std_8h/#macros","title":"Macros","text":"Type Name define CAT (x, y) __CAT(x,y) define INTSERIALNO_DESCRIPTOR  0xFEString descriptor is an internal serial number provided by hardware driver. define NO_DESCRIPTOR  0x00String descriptor doesn't exists in the device. define USB_ARRAY_DESC (...)  define USB_CFG_ATTR_RESERVED  0x80 define USB_CFG_ATTR_SELFPOWERED  0x40 define USB_CFG_POWER_MA (mA) ((mA) &gt;&gt; 1)Macro to set \u043caximum power consumption field for the usb_config_descriptor . define USB_CLASS_APP_SPEC  0xFEApplication Specific class. define USB_CLASS_AUDIO  0x01Audio device class. define USB_CLASS_AV  0x10Audio/Video device class. define USB_CLASS_BILLBOARD  0x11Billboard device class. define USB_CLASS_CBRIDGE  0x12USB Type-C Bridge device class. define USB_CLASS_CONTENT_SEC  0x0DContent Security device class. define USB_CLASS_CSCID  0x0BSmart Card device class. define USB_CLASS_DIAGNOSTIC  0xDCDiagnostic device class. define USB_CLASS_HEALTHCARE  0x0FPersonal Healthcare device class. define USB_CLASS_HUB  0x09HUB device class. define USB_CLASS_IAD  0xEFClass defined on interface association level. define USB_CLASS_MASS_STORAGE  0x08Mass Storage device class. define USB_CLASS_MISC  0xEFMiscellanious device class. define USB_CLASS_PER_INTERFACE  0x00Class defined on interface level. define USB_CLASS_PHYSICAL  0x05Physical device class. define USB_CLASS_PRINTER  0x07Printer device class. define USB_CLASS_STILL_IMAGE  0x06Still Imaging device class. define USB_CLASS_VENDOR  0xFFVendor specific class. define USB_CLASS_VIDEO  0x0EVideo device class. define USB_CLASS_WIRELESS  0xE0Wireless controller class. define USB_DTYPE_CONFIGURATION  0x02Configuration descriptor. define USB_DTYPE_CS_ENDPOINT  0x25Class specific endpoint descriptor. define USB_DTYPE_CS_INTERFACE  0x24Class specific interface descriptor. define USB_DTYPE_DEBUG  0x0ADebug descriptor. define USB_DTYPE_DEVICE  0x01Device descriptor. define USB_DTYPE_ENDPOINT  0x05Endpoint descriptor. define USB_DTYPE_INTERFACE  0x04Interface descriptor. define USB_DTYPE_INTERFACEPOWER  0x08Interface power descriptor. define USB_DTYPE_INTERFASEASSOC  0x0BInterface association descriptor. define USB_DTYPE_OTG  0x09OTG descriptor. define USB_DTYPE_OTHER  0x07Descriptor is of other type. define USB_DTYPE_QUALIFIER  0x06Qualifier descriptor. define USB_DTYPE_STRING  0x03String descriptor. define USB_EPATTR_ADAPTIVE  0x08Adaptive endpoint. define USB_EPATTR_ASYNC  0x04Asynchronous endpoint. define USB_EPATTR_NO_SYNC  0x00No synchronization. define USB_EPATTR_SYNC  0x0CSynchronous endpoint. define USB_EPDIR_IN  0x00Host-to-device endpoint direction. define USB_EPDIR_OUT  0x80Device-to-host endpoint direction. define USB_EPTYPE_BULK  0x02Bbulk endpoint. define USB_EPTYPE_CONTROL  0x00Control endpoint. define USB_EPTYPE_INTERRUPT  0x03Interrupt endpoint. define USB_EPTYPE_ISOCHRONUS  0x01Isochronous endpoint. define USB_EPUSAGE_DATA  0x00Data endpoint. define USB_EPUSAGE_FEEDBACK  0x10Feedback endpoint. define USB_EPUSAGE_IMP_FEEDBACK  0x20Implicit feedback Data endpoint. define USB_FEAT_DEBUG_MODE  0x06 define USB_FEAT_ENDPOINT_HALT  0x00Halt endpoint. define USB_FEAT_REMOTE_WKUP  0x01 define USB_FEAT_TEST_MODE  0x02 define USB_LANGID_AFR  0x0436Afrikaans. define USB_LANGID_ARA_AE  0x3801Arabic (U.A.E.) define USB_LANGID_ARA_BH  0x3c01Arabic (Bahrain) define USB_LANGID_ARA_DZ  0x1401Arabic (Algeria) define USB_LANGID_ARA_EG  0x0c01Arabic (Egypt) define USB_LANGID_ARA_IQ  0x0801Arabic (Iraq) define USB_LANGID_ARA_JO  0x2c01Arabic (Jordan) define USB_LANGID_ARA_KW  0x3401Arabic (Kuwait) define USB_LANGID_ARA_LB  0x3001Arabic (Lebanon) define USB_LANGID_ARA_LY  0x1001Arabic (Libya) define USB_LANGID_ARA_MA  0x1801Arabic (Morocco) define USB_LANGID_ARA_OM  0x2001Arabic (Oman) define USB_LANGID_ARA_QA  0x4001Arabic (Qatar) define USB_LANGID_ARA_SA  0x0401Arabic (Saudi Arabia) define USB_LANGID_ARA_SY  0x2801Arabic (Syria) define USB_LANGID_ARA_TN  0x1c01Arabic (Tunisia) define USB_LANGID_ARA_YE  0x2401Arabic (Yemen) define USB_LANGID_ASM  0x044dAssamese. define USB_LANGID_AZE_CYR  0x082cAzeri (Cyrillic) define USB_LANGID_AZE_LAT  0x042cAzeri (Latin) define USB_LANGID_BEL  0x0423Belarussian. define USB_LANGID_BEN  0x0445Bengali. define USB_LANGID_BUL  0x0402Bulgarian. define USB_LANGID_CAT  0x0403Catalan. define USB_LANGID_CZE  0x0405Czech. define USB_LANGID_DAN  0x0406Danish. define USB_LANGID_DEU  0x0407German (Standard) define USB_LANGID_DEU_AT  0x0c07German (Austria) define USB_LANGID_DEU_LI  0x1407German (Liechtenstein) define USB_LANGID_DEU_LU  0x1007German (Luxembourg) define USB_LANGID_DEU_SZ  0x0807German (Switzerland) define USB_LANGID_ELL  0x0408Greek. define USB_LANGID_ENG_AU  0x0c09English (Australian) define USB_LANGID_ENG_BZ  0x2809English (Belize) define USB_LANGID_ENG_CA  0x1009English (Canadian) define USB_LANGID_ENG_CAR  0x2409English (Caribbean) define USB_LANGID_ENG_IE  0x1809English (Ireland) define USB_LANGID_ENG_JM  0x2009English (Jamaica) define USB_LANGID_ENG_NZ  0x1409English (New Zealand) define USB_LANGID_ENG_PH  0x3409English (Philippines) define USB_LANGID_ENG_TH  0x2c09English (Trinidad) define USB_LANGID_ENG_UK  0x0809English (United Kingdom) define USB_LANGID_ENG_US  0x0409English (United States) define USB_LANGID_ENG_ZA  0x1c09English (South Africa) define USB_LANGID_ENG_ZW  0x3009English (Zimbabwe) define USB_LANGID_EST  0x0425Estonian. define USB_LANGID_EUS  0x042dBasque. define USB_LANGID_FAO  0x0438Faeroese. define USB_LANGID_FAS  0x0429Farsi. define USB_LANGID_FIN  0x040bFinnish. define USB_LANGID_FRA  0x040cFrench (Standard) define USB_LANGID_FRA_BE  0x080cFrench (Belgian) define USB_LANGID_FRA_CA  0x0c0cFrench (Canadian) define USB_LANGID_FRA_LU  0x140cFrench (Luxembourg) define USB_LANGID_FRA_MC  0x180cFrench (Monaco) define USB_LANGID_FRA_SZ  0x100cFrench (Switzerland) define USB_LANGID_GUJ  0x0447Gujarati. define USB_LANGID_HEB  0x040dHebrew. define USB_LANGID_HIN  0x0439Hindi. define USB_LANGID_HRV  0x041aCroatian. define USB_LANGID_HUN  0x040eHungarian. define USB_LANGID_HYE  0x042bArmenian. define USB_LANGID_IND  0x0421Indonesian. define USB_LANGID_ISL  0x040fIcelandic. define USB_LANGID_ITA  0x0410Italian (Standard) define USB_LANGID_ITA_SZ  0x0810Italian (Switzerland) define USB_LANGID_JPN  0x0411Japanese. define USB_LANGID_KAN  0x044bKannada. define USB_LANGID_KAS  0x0860Kashmiri (India) define USB_LANGID_KAT  0x0437Georgian. define USB_LANGID_KAZ  0x043fKazakh. define USB_LANGID_KOK  0x0457Konkani. define USB_LANGID_KOR  0x0412Korean. define USB_LANGID_KOR_JOH  0x0812Korean (Johab) define USB_LANGID_LAV  0x0426Latvian. define USB_LANGID_LIT  0x0427Lithuanian. define USB_LANGID_LIT_CLS  0x0827Lithuanian (Classic) define USB_LANGID_MAL  0x044cMalayalam. define USB_LANGID_MAR  0x044eMarathi. define USB_LANGID_MKD  0x042fMacedonian. define USB_LANGID_MNI  0x0458Manipuri. define USB_LANGID_MSA  0x043eMalay (Malaysian) define USB_LANGID_MSA_BN  0x083eMalay (Brunei Darussalam) define USB_LANGID_MYA  0x0455Burmese. define USB_LANGID_NEP  0x0861Nepali (India) define USB_LANGID_NLD_BE  0x0813Dutch (Belgium) define USB_LANGID_NLD_NL  0x0413Dutch (Netherlands) define USB_LANGID_NNO  0x0814Norwegian (Nynorsk) define USB_LANGID_NOB  0x0414Norwegian (Bokmal) define USB_LANGID_NSO  0x0430Sutu, Sotho. define USB_LANGID_ORI  0x0448Oriya. define USB_LANGID_PAN  0x0446Punjabi. define USB_LANGID_POL  0x0415Polish. define USB_LANGID_POR  0x0816Portuguese (Standard) define USB_LANGID_POR_BR  0x0416Portuguese (Brazil) define USB_LANGID_RON  0x0418Romanian. define USB_LANGID_RUS  0x0419Russian. define USB_LANGID_SAN  0x044fSanskrit. define USB_LANGID_SLK  0x041bSlovak. define USB_LANGID_SLV  0x0424Slovenian. define USB_LANGID_SND  0x0459Sindhi. define USB_LANGID_SPA  0x040aSpanish (Traditional Sort) define USB_LANGID_SPA_AR  0x2c0aSpanish (Argentina) define USB_LANGID_SPA_BO  0x400aSpanish (Bolivia) define USB_LANGID_SPA_CL  0x340aSpanish (Chile) define USB_LANGID_SPA_CO  0x240aSpanish (Colombia) define USB_LANGID_SPA_CR  0x140aSpanish (Costa Rica) define USB_LANGID_SPA_DO  0x1c0aSpanish (Dominican Republic) define USB_LANGID_SPA_EC  0x300aSpanish (Ecuador) define USB_LANGID_SPA_GT  0x100aSpanish (Guatemala) define USB_LANGID_SPA_HN  0x480aSpanish (Honduras) define USB_LANGID_SPA_MDN  0x0c0aSpanish (Modern Sort) define USB_LANGID_SPA_MX  0x080aSpanish (Mexican) define USB_LANGID_SPA_NI  0x4c0aSpanish (Nicaragua) define USB_LANGID_SPA_PA  0x180aSpanish (Panama) define USB_LANGID_SPA_PE  0x280aSpanish (Peru) define USB_LANGID_SPA_PR  0x500aSpanish (Puerto Rico) define USB_LANGID_SPA_PY  0x3c0aSpanish (Paraguay) define USB_LANGID_SPA_SV  0x440aSpanish (El Salvador) define USB_LANGID_SPA_UY  0x380aSpanish (Uruguay) define USB_LANGID_SPA_VE  0x200aSpanish (Venezuela) define USB_LANGID_SQI  0x041cAlbanian. define USB_LANGID_SRB_CYR  0x0c1aSerbian (Cyrillic) define USB_LANGID_SRB_LAT  0x081aSerbian (Latin) define USB_LANGID_SWA  0x0441Swahili (Kenya) define USB_LANGID_SWE  0x041dSwedish. define USB_LANGID_SWE_FI  0x081dSwedish (Finland) define USB_LANGID_TAM  0x0449Tamil. define USB_LANGID_TAT  0x0444Tatar (Tatarstan) define USB_LANGID_TEL  0x044aTelugu. define USB_LANGID_THA  0x041eThai. define USB_LANGID_TUR  0x041fTurkish. define USB_LANGID_URD_IN  0x0820Urdu (India) define USB_LANGID_URD_PK  0x0420Urdu (Pakistan) define USB_LANGID_UZB_CYR  0x0843Uzbek (Cyrillic) define USB_LANGID_UZB_LAT  0x0443Uzbek (Latin) define USB_LANGID_VIE  0x042aVietnamese. define USB_LANGID_ZHO_CN  0x0804Chinese (PRC) define USB_LANGID_ZHO_HK  0x0c04Chinese (Hong Kong SAR, PRC) define USB_LANGID_ZHO_MO  0x1404Chinese (Macau SAR) define USB_LANGID_ZHO_SG  0x1004Chinese (Singapore) define USB_LANGID_ZHO_TW  0x0404Chinese (Taiwan) define USB_LANGIG_UKR  0x0422Ukrainian. define USB_PROTO_IAD  0x01Protocol defined on interface association level. define USB_PROTO_NONE  0x00No protocol defined. define USB_PROTO_VENDOR  0xFFVendor specific protocol. define USB_STD_CLEAR_FEATURE  0x01Used to clear or disable a specific feature. define USB_STD_GET_CONFIG  0x08Returns the current device configuration value. define USB_STD_GET_DESCRIPTOR  0x06Returns the specified descriptor if the descriptor exists. define USB_STD_GET_INTERFACE  0x0AReturns the selected alternate setting for the specified interface. define USB_STD_GET_STATUS  0x00Returns status for the specified recipient. define USB_STD_SET_ADDRESS  0x05Sets the device address for all future device accesses. define USB_STD_SET_CONFIG  0x09Sets the device configuration. define USB_STD_SET_DESCRIPTOR  0x07This request is optional and may be used to update existing descriptors or new descriptors may be added. define USB_STD_SET_FEATURE  0x03Used to set or enable a specific feature. define USB_STD_SET_INTERFACE  0x0BAllows the host to select an alternate setting for the specified interface. define USB_STD_SYNCH_FRAME  0x0CUsed to set and then report an endpoint's synchronization frame. define USB_STRING_DESC (s)  define USB_SUBCLASS_IAD  0x02Subclass defined on interface association level. define USB_SUBCLASS_NONE  0x00No subclass defined. define USB_SUBCLASS_VENDOR  0xFFVendor specific subclass. define USB_TEST_FORCE_ENABLE  0x05Test Force Enable. define USB_TEST_J  0x01Test J. define USB_TEST_K  0x02Test K. define USB_TEST_PACKET  0x04Test Pcaket. define USB_TEST_SE0_NAK  0x03Test SE0 NAK. define VERSION_BCD (maj, min, rev) (((maj &amp; 0xFF) &lt;&lt; 8) | ((min &amp; 0x0F) &lt;&lt; 4) | (rev &amp; 0x0F)) define __CAT (x, y) x ## y"},{"location":"apiStm/usb__std_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/usb__std_8h/#variable-balternatesetting","title":"variable bAlternateSetting","text":"<pre><code>uint8_t bAlternateSetting;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-bconfigurationvalue","title":"variable bConfigurationValue","text":"<pre><code>uint8_t bConfigurationValue;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-bdebuginendpoint","title":"variable bDebugInEndpoint","text":"<pre><code>uint8_t bDebugInEndpoint;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-bdebugoutendpoint","title":"variable bDebugOutEndpoint","text":"<pre><code>uint8_t bDebugOutEndpoint;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-bdescriptortype","title":"variable bDescriptorType","text":"<p>Type of the descriptor. <pre><code>uint8_t bDescriptorType;\n</code></pre></p> <p>Debug descriptor type.</p> <p>String descriptor type.</p> <p>Endpoint descriptor.</p> <p>IAD descriptor.</p> <p>Interface descriptor.</p> <p>Configuration descriptor.</p> <p>Qualifier descriptor.</p> <p>USB_DTYPE_DEVICE Device descriptor. </p>"},{"location":"apiStm/usb__std_8h/#variable-bdeviceclass","title":"variable bDeviceClass","text":"<pre><code>uint8_t bDeviceClass;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-bdeviceprotocol","title":"variable bDeviceProtocol","text":"<pre><code>uint8_t bDeviceProtocol;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-bdevicesubclass","title":"variable bDeviceSubClass","text":"<pre><code>uint8_t bDeviceSubClass;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-bendpointaddress","title":"variable bEndpointAddress","text":"<pre><code>uint8_t bEndpointAddress;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-bfirstinterface","title":"variable bFirstInterface","text":"<pre><code>uint8_t bFirstInterface;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-bfunctionclass","title":"variable bFunctionClass","text":"<pre><code>uint8_t bFunctionClass;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-bfunctionprotocol","title":"variable bFunctionProtocol","text":"<pre><code>uint8_t bFunctionProtocol;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-bfunctionsubclass","title":"variable bFunctionSubClass","text":"<pre><code>uint8_t bFunctionSubClass;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-binterfaceclass","title":"variable bInterfaceClass","text":"<pre><code>uint8_t bInterfaceClass;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-binterfacecount","title":"variable bInterfaceCount","text":"<pre><code>uint8_t bInterfaceCount;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-binterfacenumber","title":"variable bInterfaceNumber","text":"<pre><code>uint8_t bInterfaceNumber;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-binterfaceprotocol","title":"variable bInterfaceProtocol","text":"<pre><code>uint8_t bInterfaceProtocol;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-binterfacesubclass","title":"variable bInterfaceSubClass","text":"<pre><code>uint8_t bInterfaceSubClass;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-binterval","title":"variable bInterval","text":"<pre><code>uint8_t bInterval;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-blength","title":"variable bLength","text":"<pre><code>uint8_t bLength;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-bmaxpacketsize0","title":"variable bMaxPacketSize0","text":"<pre><code>uint8_t bMaxPacketSize0;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-bmaxpower","title":"variable bMaxPower","text":"<pre><code>uint8_t bMaxPower;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-bnumconfigurations","title":"variable bNumConfigurations","text":"<pre><code>uint8_t bNumConfigurations;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-bnumendpoints","title":"variable bNumEndpoints","text":"<pre><code>uint8_t bNumEndpoints;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-bnuminterfaces","title":"variable bNumInterfaces","text":"<pre><code>uint8_t bNumInterfaces;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-breserved","title":"variable bReserved","text":"<pre><code>uint8_t bReserved;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-bcddevice","title":"variable bcdDevice","text":"<pre><code>uint16_t bcdDevice;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-bcdusb","title":"variable bcdUSB","text":"<pre><code>uint16_t bcdUSB;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-bmattributes","title":"variable bmAttributes","text":"<p>Configuration attributes. <pre><code>uint8_t bmAttributes;\n</code></pre></p> <p>Endpoint attributes, USB_ENDPOINT_DEF.</p> <p>Comprised of a mask of <code>USB_CONFIG_ATTR_</code> masks. On all devices, this should include USB_CONFIG_ATTR_RESERVED at a minimum. </p>"},{"location":"apiStm/usb__std_8h/#variable-iconfiguration","title":"variable iConfiguration","text":"<pre><code>uint8_t iConfiguration;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-ifunction","title":"variable iFunction","text":"<pre><code>uint8_t iFunction;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-iinterface","title":"variable iInterface","text":"<pre><code>uint8_t iInterface;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-imanufacturer","title":"variable iManufacturer","text":"<pre><code>uint8_t iManufacturer;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-iproduct","title":"variable iProduct","text":"<pre><code>uint8_t iProduct;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-iserialnumber","title":"variable iSerialNumber","text":"<pre><code>uint8_t iSerialNumber;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-idproduct","title":"variable idProduct","text":"<pre><code>uint16_t idProduct;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-idvendor","title":"variable idVendor","text":"<pre><code>uint16_t idVendor;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-wmaxpacketsize","title":"variable wMaxPacketSize","text":"<pre><code>uint16_t wMaxPacketSize;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-wstring","title":"variable wString","text":"<pre><code>uint16_t wString[];\n</code></pre>"},{"location":"apiStm/usb__std_8h/#variable-wtotallength","title":"variable wTotalLength","text":"<pre><code>uint16_t wTotalLength;\n</code></pre>"},{"location":"apiStm/usb__std_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/usb__std_8h/#function-__attribute__","title":"function __attribute__","text":"<pre><code>struct usb_header_descriptor __attribute__ (\n(packed)\n) </code></pre>"},{"location":"apiStm/usb__std_8h/#function-__attribute___1","title":"function __attribute__","text":"<pre><code>struct usb_string_descriptor __attribute__ (\n(packed, aligned(2))\n) </code></pre>"},{"location":"apiStm/usb__std_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/usb__std_8h/#define-cat","title":"define CAT","text":"<pre><code>#define CAT (\nx,\ny\n) __CAT(x,y)\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-intserialno_descriptor","title":"define INTSERIALNO_DESCRIPTOR","text":"<pre><code>#define INTSERIALNO_DESCRIPTOR 0xFE\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-no_descriptor","title":"define NO_DESCRIPTOR","text":"<pre><code>#define NO_DESCRIPTOR 0x00\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_array_desc","title":"define USB_ARRAY_DESC","text":"<pre><code>#define USB_ARRAY_DESC (\n...\n) {.bLength = 2 + sizeof((uint16_t[]){__VA_ARGS__}),\\\n                                    .bDescriptorType = USB_DTYPE_STRING ,\\\n                                    .wString = {__VA_ARGS__}}\n</code></pre> <p>Macro to create usb_string_descriptor from array </p>"},{"location":"apiStm/usb__std_8h/#define-usb_cfg_attr_reserved","title":"define USB_CFG_ATTR_RESERVED","text":"<pre><code>#define USB_CFG_ATTR_RESERVED 0x80\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_cfg_attr_selfpowered","title":"define USB_CFG_ATTR_SELFPOWERED","text":"<pre><code>#define USB_CFG_ATTR_SELFPOWERED 0x40\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_cfg_power_ma","title":"define USB_CFG_POWER_MA","text":"<pre><code>#define USB_CFG_POWER_MA (\nmA\n) ((mA) &gt;&gt; 1)\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_class_app_spec","title":"define USB_CLASS_APP_SPEC","text":"<pre><code>#define USB_CLASS_APP_SPEC 0xFE\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_class_audio","title":"define USB_CLASS_AUDIO","text":"<pre><code>#define USB_CLASS_AUDIO 0x01\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_class_av","title":"define USB_CLASS_AV","text":"<pre><code>#define USB_CLASS_AV 0x10\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_class_billboard","title":"define USB_CLASS_BILLBOARD","text":"<pre><code>#define USB_CLASS_BILLBOARD 0x11\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_class_cbridge","title":"define USB_CLASS_CBRIDGE","text":"<pre><code>#define USB_CLASS_CBRIDGE 0x12\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_class_content_sec","title":"define USB_CLASS_CONTENT_SEC","text":"<pre><code>#define USB_CLASS_CONTENT_SEC 0x0D\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_class_cscid","title":"define USB_CLASS_CSCID","text":"<pre><code>#define USB_CLASS_CSCID 0x0B\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_class_diagnostic","title":"define USB_CLASS_DIAGNOSTIC","text":"<pre><code>#define USB_CLASS_DIAGNOSTIC 0xDC\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_class_healthcare","title":"define USB_CLASS_HEALTHCARE","text":"<pre><code>#define USB_CLASS_HEALTHCARE 0x0F\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_class_hub","title":"define USB_CLASS_HUB","text":"<pre><code>#define USB_CLASS_HUB 0x09\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_class_iad","title":"define USB_CLASS_IAD","text":"<pre><code>#define USB_CLASS_IAD 0xEF\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_class_mass_storage","title":"define USB_CLASS_MASS_STORAGE","text":"<pre><code>#define USB_CLASS_MASS_STORAGE 0x08\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_class_misc","title":"define USB_CLASS_MISC","text":"<pre><code>#define USB_CLASS_MISC 0xEF\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_class_per_interface","title":"define USB_CLASS_PER_INTERFACE","text":"<pre><code>#define USB_CLASS_PER_INTERFACE 0x00\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_class_physical","title":"define USB_CLASS_PHYSICAL","text":"<pre><code>#define USB_CLASS_PHYSICAL 0x05\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_class_printer","title":"define USB_CLASS_PRINTER","text":"<pre><code>#define USB_CLASS_PRINTER 0x07\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_class_still_image","title":"define USB_CLASS_STILL_IMAGE","text":"<pre><code>#define USB_CLASS_STILL_IMAGE 0x06\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_class_vendor","title":"define USB_CLASS_VENDOR","text":"<pre><code>#define USB_CLASS_VENDOR 0xFF\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_class_video","title":"define USB_CLASS_VIDEO","text":"<pre><code>#define USB_CLASS_VIDEO 0x0E\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_class_wireless","title":"define USB_CLASS_WIRELESS","text":"<pre><code>#define USB_CLASS_WIRELESS 0xE0\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_dtype_configuration","title":"define USB_DTYPE_CONFIGURATION","text":"<pre><code>#define USB_DTYPE_CONFIGURATION 0x02\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_dtype_cs_endpoint","title":"define USB_DTYPE_CS_ENDPOINT","text":"<pre><code>#define USB_DTYPE_CS_ENDPOINT 0x25\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_dtype_cs_interface","title":"define USB_DTYPE_CS_INTERFACE","text":"<pre><code>#define USB_DTYPE_CS_INTERFACE 0x24\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_dtype_debug","title":"define USB_DTYPE_DEBUG","text":"<pre><code>#define USB_DTYPE_DEBUG 0x0A\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_dtype_device","title":"define USB_DTYPE_DEVICE","text":"<pre><code>#define USB_DTYPE_DEVICE 0x01\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_dtype_endpoint","title":"define USB_DTYPE_ENDPOINT","text":"<pre><code>#define USB_DTYPE_ENDPOINT 0x05\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_dtype_interface","title":"define USB_DTYPE_INTERFACE","text":"<pre><code>#define USB_DTYPE_INTERFACE 0x04\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_dtype_interfacepower","title":"define USB_DTYPE_INTERFACEPOWER","text":"<pre><code>#define USB_DTYPE_INTERFACEPOWER 0x08\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_dtype_interfaseassoc","title":"define USB_DTYPE_INTERFASEASSOC","text":"<pre><code>#define USB_DTYPE_INTERFASEASSOC 0x0B\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_dtype_otg","title":"define USB_DTYPE_OTG","text":"<pre><code>#define USB_DTYPE_OTG 0x09\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_dtype_other","title":"define USB_DTYPE_OTHER","text":"<pre><code>#define USB_DTYPE_OTHER 0x07\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_dtype_qualifier","title":"define USB_DTYPE_QUALIFIER","text":"<pre><code>#define USB_DTYPE_QUALIFIER 0x06\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_dtype_string","title":"define USB_DTYPE_STRING","text":"<pre><code>#define USB_DTYPE_STRING 0x03\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_epattr_adaptive","title":"define USB_EPATTR_ADAPTIVE","text":"<pre><code>#define USB_EPATTR_ADAPTIVE 0x08\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_epattr_async","title":"define USB_EPATTR_ASYNC","text":"<pre><code>#define USB_EPATTR_ASYNC 0x04\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_epattr_no_sync","title":"define USB_EPATTR_NO_SYNC","text":"<pre><code>#define USB_EPATTR_NO_SYNC 0x00\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_epattr_sync","title":"define USB_EPATTR_SYNC","text":"<pre><code>#define USB_EPATTR_SYNC 0x0C\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_epdir_in","title":"define USB_EPDIR_IN","text":"<pre><code>#define USB_EPDIR_IN 0x00\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_epdir_out","title":"define USB_EPDIR_OUT","text":"<pre><code>#define USB_EPDIR_OUT 0x80\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_eptype_bulk","title":"define USB_EPTYPE_BULK","text":"<pre><code>#define USB_EPTYPE_BULK 0x02\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_eptype_control","title":"define USB_EPTYPE_CONTROL","text":"<pre><code>#define USB_EPTYPE_CONTROL 0x00\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_eptype_interrupt","title":"define USB_EPTYPE_INTERRUPT","text":"<pre><code>#define USB_EPTYPE_INTERRUPT 0x03\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_eptype_isochronus","title":"define USB_EPTYPE_ISOCHRONUS","text":"<pre><code>#define USB_EPTYPE_ISOCHRONUS 0x01\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_epusage_data","title":"define USB_EPUSAGE_DATA","text":"<pre><code>#define USB_EPUSAGE_DATA 0x00\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_epusage_feedback","title":"define USB_EPUSAGE_FEEDBACK","text":"<pre><code>#define USB_EPUSAGE_FEEDBACK 0x10\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_epusage_imp_feedback","title":"define USB_EPUSAGE_IMP_FEEDBACK","text":"<pre><code>#define USB_EPUSAGE_IMP_FEEDBACK 0x20\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_feat_debug_mode","title":"define USB_FEAT_DEBUG_MODE","text":"<pre><code>#define USB_FEAT_DEBUG_MODE 0x06\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_feat_endpoint_halt","title":"define USB_FEAT_ENDPOINT_HALT","text":"<pre><code>#define USB_FEAT_ENDPOINT_HALT 0x00\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_feat_remote_wkup","title":"define USB_FEAT_REMOTE_WKUP","text":"<pre><code>#define USB_FEAT_REMOTE_WKUP 0x01\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_feat_test_mode","title":"define USB_FEAT_TEST_MODE","text":"<pre><code>#define USB_FEAT_TEST_MODE 0x02\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_afr","title":"define USB_LANGID_AFR","text":"<pre><code>#define USB_LANGID_AFR 0x0436\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_ara_ae","title":"define USB_LANGID_ARA_AE","text":"<pre><code>#define USB_LANGID_ARA_AE 0x3801\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_ara_bh","title":"define USB_LANGID_ARA_BH","text":"<pre><code>#define USB_LANGID_ARA_BH 0x3c01\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_ara_dz","title":"define USB_LANGID_ARA_DZ","text":"<pre><code>#define USB_LANGID_ARA_DZ 0x1401\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_ara_eg","title":"define USB_LANGID_ARA_EG","text":"<pre><code>#define USB_LANGID_ARA_EG 0x0c01\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_ara_iq","title":"define USB_LANGID_ARA_IQ","text":"<pre><code>#define USB_LANGID_ARA_IQ 0x0801\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_ara_jo","title":"define USB_LANGID_ARA_JO","text":"<pre><code>#define USB_LANGID_ARA_JO 0x2c01\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_ara_kw","title":"define USB_LANGID_ARA_KW","text":"<pre><code>#define USB_LANGID_ARA_KW 0x3401\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_ara_lb","title":"define USB_LANGID_ARA_LB","text":"<pre><code>#define USB_LANGID_ARA_LB 0x3001\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_ara_ly","title":"define USB_LANGID_ARA_LY","text":"<pre><code>#define USB_LANGID_ARA_LY 0x1001\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_ara_ma","title":"define USB_LANGID_ARA_MA","text":"<pre><code>#define USB_LANGID_ARA_MA 0x1801\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_ara_om","title":"define USB_LANGID_ARA_OM","text":"<pre><code>#define USB_LANGID_ARA_OM 0x2001\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_ara_qa","title":"define USB_LANGID_ARA_QA","text":"<pre><code>#define USB_LANGID_ARA_QA 0x4001\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_ara_sa","title":"define USB_LANGID_ARA_SA","text":"<pre><code>#define USB_LANGID_ARA_SA 0x0401\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_ara_sy","title":"define USB_LANGID_ARA_SY","text":"<pre><code>#define USB_LANGID_ARA_SY 0x2801\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_ara_tn","title":"define USB_LANGID_ARA_TN","text":"<pre><code>#define USB_LANGID_ARA_TN 0x1c01\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_ara_ye","title":"define USB_LANGID_ARA_YE","text":"<pre><code>#define USB_LANGID_ARA_YE 0x2401\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_asm","title":"define USB_LANGID_ASM","text":"<pre><code>#define USB_LANGID_ASM 0x044d\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_aze_cyr","title":"define USB_LANGID_AZE_CYR","text":"<pre><code>#define USB_LANGID_AZE_CYR 0x082c\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_aze_lat","title":"define USB_LANGID_AZE_LAT","text":"<pre><code>#define USB_LANGID_AZE_LAT 0x042c\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_bel","title":"define USB_LANGID_BEL","text":"<pre><code>#define USB_LANGID_BEL 0x0423\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_ben","title":"define USB_LANGID_BEN","text":"<pre><code>#define USB_LANGID_BEN 0x0445\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_bul","title":"define USB_LANGID_BUL","text":"<pre><code>#define USB_LANGID_BUL 0x0402\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_cat","title":"define USB_LANGID_CAT","text":"<pre><code>#define USB_LANGID_CAT 0x0403\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_cze","title":"define USB_LANGID_CZE","text":"<pre><code>#define USB_LANGID_CZE 0x0405\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_dan","title":"define USB_LANGID_DAN","text":"<pre><code>#define USB_LANGID_DAN 0x0406\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_deu","title":"define USB_LANGID_DEU","text":"<pre><code>#define USB_LANGID_DEU 0x0407\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_deu_at","title":"define USB_LANGID_DEU_AT","text":"<pre><code>#define USB_LANGID_DEU_AT 0x0c07\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_deu_li","title":"define USB_LANGID_DEU_LI","text":"<pre><code>#define USB_LANGID_DEU_LI 0x1407\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_deu_lu","title":"define USB_LANGID_DEU_LU","text":"<pre><code>#define USB_LANGID_DEU_LU 0x1007\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_deu_sz","title":"define USB_LANGID_DEU_SZ","text":"<pre><code>#define USB_LANGID_DEU_SZ 0x0807\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_ell","title":"define USB_LANGID_ELL","text":"<pre><code>#define USB_LANGID_ELL 0x0408\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_eng_au","title":"define USB_LANGID_ENG_AU","text":"<pre><code>#define USB_LANGID_ENG_AU 0x0c09\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_eng_bz","title":"define USB_LANGID_ENG_BZ","text":"<pre><code>#define USB_LANGID_ENG_BZ 0x2809\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_eng_ca","title":"define USB_LANGID_ENG_CA","text":"<pre><code>#define USB_LANGID_ENG_CA 0x1009\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_eng_car","title":"define USB_LANGID_ENG_CAR","text":"<pre><code>#define USB_LANGID_ENG_CAR 0x2409\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_eng_ie","title":"define USB_LANGID_ENG_IE","text":"<pre><code>#define USB_LANGID_ENG_IE 0x1809\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_eng_jm","title":"define USB_LANGID_ENG_JM","text":"<pre><code>#define USB_LANGID_ENG_JM 0x2009\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_eng_nz","title":"define USB_LANGID_ENG_NZ","text":"<pre><code>#define USB_LANGID_ENG_NZ 0x1409\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_eng_ph","title":"define USB_LANGID_ENG_PH","text":"<pre><code>#define USB_LANGID_ENG_PH 0x3409\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_eng_th","title":"define USB_LANGID_ENG_TH","text":"<pre><code>#define USB_LANGID_ENG_TH 0x2c09\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_eng_uk","title":"define USB_LANGID_ENG_UK","text":"<pre><code>#define USB_LANGID_ENG_UK 0x0809\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_eng_us","title":"define USB_LANGID_ENG_US","text":"<pre><code>#define USB_LANGID_ENG_US 0x0409\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_eng_za","title":"define USB_LANGID_ENG_ZA","text":"<pre><code>#define USB_LANGID_ENG_ZA 0x1c09\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_eng_zw","title":"define USB_LANGID_ENG_ZW","text":"<pre><code>#define USB_LANGID_ENG_ZW 0x3009\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_est","title":"define USB_LANGID_EST","text":"<pre><code>#define USB_LANGID_EST 0x0425\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_eus","title":"define USB_LANGID_EUS","text":"<pre><code>#define USB_LANGID_EUS 0x042d\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_fao","title":"define USB_LANGID_FAO","text":"<pre><code>#define USB_LANGID_FAO 0x0438\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_fas","title":"define USB_LANGID_FAS","text":"<pre><code>#define USB_LANGID_FAS 0x0429\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_fin","title":"define USB_LANGID_FIN","text":"<pre><code>#define USB_LANGID_FIN 0x040b\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_fra","title":"define USB_LANGID_FRA","text":"<pre><code>#define USB_LANGID_FRA 0x040c\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_fra_be","title":"define USB_LANGID_FRA_BE","text":"<pre><code>#define USB_LANGID_FRA_BE 0x080c\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_fra_ca","title":"define USB_LANGID_FRA_CA","text":"<pre><code>#define USB_LANGID_FRA_CA 0x0c0c\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_fra_lu","title":"define USB_LANGID_FRA_LU","text":"<pre><code>#define USB_LANGID_FRA_LU 0x140c\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_fra_mc","title":"define USB_LANGID_FRA_MC","text":"<pre><code>#define USB_LANGID_FRA_MC 0x180c\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_fra_sz","title":"define USB_LANGID_FRA_SZ","text":"<pre><code>#define USB_LANGID_FRA_SZ 0x100c\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_guj","title":"define USB_LANGID_GUJ","text":"<pre><code>#define USB_LANGID_GUJ 0x0447\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_heb","title":"define USB_LANGID_HEB","text":"<pre><code>#define USB_LANGID_HEB 0x040d\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_hin","title":"define USB_LANGID_HIN","text":"<pre><code>#define USB_LANGID_HIN 0x0439\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_hrv","title":"define USB_LANGID_HRV","text":"<pre><code>#define USB_LANGID_HRV 0x041a\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_hun","title":"define USB_LANGID_HUN","text":"<pre><code>#define USB_LANGID_HUN 0x040e\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_hye","title":"define USB_LANGID_HYE","text":"<pre><code>#define USB_LANGID_HYE 0x042b\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_ind","title":"define USB_LANGID_IND","text":"<pre><code>#define USB_LANGID_IND 0x0421\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_isl","title":"define USB_LANGID_ISL","text":"<pre><code>#define USB_LANGID_ISL 0x040f\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_ita","title":"define USB_LANGID_ITA","text":"<pre><code>#define USB_LANGID_ITA 0x0410\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_ita_sz","title":"define USB_LANGID_ITA_SZ","text":"<pre><code>#define USB_LANGID_ITA_SZ 0x0810\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_jpn","title":"define USB_LANGID_JPN","text":"<pre><code>#define USB_LANGID_JPN 0x0411\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_kan","title":"define USB_LANGID_KAN","text":"<pre><code>#define USB_LANGID_KAN 0x044b\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_kas","title":"define USB_LANGID_KAS","text":"<pre><code>#define USB_LANGID_KAS 0x0860\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_kat","title":"define USB_LANGID_KAT","text":"<pre><code>#define USB_LANGID_KAT 0x0437\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_kaz","title":"define USB_LANGID_KAZ","text":"<pre><code>#define USB_LANGID_KAZ 0x043f\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_kok","title":"define USB_LANGID_KOK","text":"<pre><code>#define USB_LANGID_KOK 0x0457\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_kor","title":"define USB_LANGID_KOR","text":"<pre><code>#define USB_LANGID_KOR 0x0412\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_kor_joh","title":"define USB_LANGID_KOR_JOH","text":"<pre><code>#define USB_LANGID_KOR_JOH 0x0812\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_lav","title":"define USB_LANGID_LAV","text":"<pre><code>#define USB_LANGID_LAV 0x0426\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_lit","title":"define USB_LANGID_LIT","text":"<pre><code>#define USB_LANGID_LIT 0x0427\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_lit_cls","title":"define USB_LANGID_LIT_CLS","text":"<pre><code>#define USB_LANGID_LIT_CLS 0x0827\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_mal","title":"define USB_LANGID_MAL","text":"<pre><code>#define USB_LANGID_MAL 0x044c\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_mar","title":"define USB_LANGID_MAR","text":"<pre><code>#define USB_LANGID_MAR 0x044e\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_mkd","title":"define USB_LANGID_MKD","text":"<pre><code>#define USB_LANGID_MKD 0x042f\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_mni","title":"define USB_LANGID_MNI","text":"<pre><code>#define USB_LANGID_MNI 0x0458\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_msa","title":"define USB_LANGID_MSA","text":"<pre><code>#define USB_LANGID_MSA 0x043e\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_msa_bn","title":"define USB_LANGID_MSA_BN","text":"<pre><code>#define USB_LANGID_MSA_BN 0x083e\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_mya","title":"define USB_LANGID_MYA","text":"<pre><code>#define USB_LANGID_MYA 0x0455\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_nep","title":"define USB_LANGID_NEP","text":"<pre><code>#define USB_LANGID_NEP 0x0861\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_nld_be","title":"define USB_LANGID_NLD_BE","text":"<pre><code>#define USB_LANGID_NLD_BE 0x0813\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_nld_nl","title":"define USB_LANGID_NLD_NL","text":"<pre><code>#define USB_LANGID_NLD_NL 0x0413\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_nno","title":"define USB_LANGID_NNO","text":"<pre><code>#define USB_LANGID_NNO 0x0814\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_nob","title":"define USB_LANGID_NOB","text":"<pre><code>#define USB_LANGID_NOB 0x0414\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_nso","title":"define USB_LANGID_NSO","text":"<pre><code>#define USB_LANGID_NSO 0x0430\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_ori","title":"define USB_LANGID_ORI","text":"<pre><code>#define USB_LANGID_ORI 0x0448\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_pan","title":"define USB_LANGID_PAN","text":"<pre><code>#define USB_LANGID_PAN 0x0446\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_pol","title":"define USB_LANGID_POL","text":"<pre><code>#define USB_LANGID_POL 0x0415\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_por","title":"define USB_LANGID_POR","text":"<pre><code>#define USB_LANGID_POR 0x0816\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_por_br","title":"define USB_LANGID_POR_BR","text":"<pre><code>#define USB_LANGID_POR_BR 0x0416\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_ron","title":"define USB_LANGID_RON","text":"<pre><code>#define USB_LANGID_RON 0x0418\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_rus","title":"define USB_LANGID_RUS","text":"<pre><code>#define USB_LANGID_RUS 0x0419\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_san","title":"define USB_LANGID_SAN","text":"<pre><code>#define USB_LANGID_SAN 0x044f\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_slk","title":"define USB_LANGID_SLK","text":"<pre><code>#define USB_LANGID_SLK 0x041b\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_slv","title":"define USB_LANGID_SLV","text":"<pre><code>#define USB_LANGID_SLV 0x0424\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_snd","title":"define USB_LANGID_SND","text":"<pre><code>#define USB_LANGID_SND 0x0459\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_spa","title":"define USB_LANGID_SPA","text":"<pre><code>#define USB_LANGID_SPA 0x040a\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_spa_ar","title":"define USB_LANGID_SPA_AR","text":"<pre><code>#define USB_LANGID_SPA_AR 0x2c0a\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_spa_bo","title":"define USB_LANGID_SPA_BO","text":"<pre><code>#define USB_LANGID_SPA_BO 0x400a\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_spa_cl","title":"define USB_LANGID_SPA_CL","text":"<pre><code>#define USB_LANGID_SPA_CL 0x340a\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_spa_co","title":"define USB_LANGID_SPA_CO","text":"<pre><code>#define USB_LANGID_SPA_CO 0x240a\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_spa_cr","title":"define USB_LANGID_SPA_CR","text":"<pre><code>#define USB_LANGID_SPA_CR 0x140a\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_spa_do","title":"define USB_LANGID_SPA_DO","text":"<pre><code>#define USB_LANGID_SPA_DO 0x1c0a\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_spa_ec","title":"define USB_LANGID_SPA_EC","text":"<pre><code>#define USB_LANGID_SPA_EC 0x300a\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_spa_gt","title":"define USB_LANGID_SPA_GT","text":"<pre><code>#define USB_LANGID_SPA_GT 0x100a\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_spa_hn","title":"define USB_LANGID_SPA_HN","text":"<pre><code>#define USB_LANGID_SPA_HN 0x480a\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_spa_mdn","title":"define USB_LANGID_SPA_MDN","text":"<pre><code>#define USB_LANGID_SPA_MDN 0x0c0a\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_spa_mx","title":"define USB_LANGID_SPA_MX","text":"<pre><code>#define USB_LANGID_SPA_MX 0x080a\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_spa_ni","title":"define USB_LANGID_SPA_NI","text":"<pre><code>#define USB_LANGID_SPA_NI 0x4c0a\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_spa_pa","title":"define USB_LANGID_SPA_PA","text":"<pre><code>#define USB_LANGID_SPA_PA 0x180a\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_spa_pe","title":"define USB_LANGID_SPA_PE","text":"<pre><code>#define USB_LANGID_SPA_PE 0x280a\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_spa_pr","title":"define USB_LANGID_SPA_PR","text":"<pre><code>#define USB_LANGID_SPA_PR 0x500a\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_spa_py","title":"define USB_LANGID_SPA_PY","text":"<pre><code>#define USB_LANGID_SPA_PY 0x3c0a\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_spa_sv","title":"define USB_LANGID_SPA_SV","text":"<pre><code>#define USB_LANGID_SPA_SV 0x440a\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_spa_uy","title":"define USB_LANGID_SPA_UY","text":"<pre><code>#define USB_LANGID_SPA_UY 0x380a\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_spa_ve","title":"define USB_LANGID_SPA_VE","text":"<pre><code>#define USB_LANGID_SPA_VE 0x200a\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_sqi","title":"define USB_LANGID_SQI","text":"<pre><code>#define USB_LANGID_SQI 0x041c\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_srb_cyr","title":"define USB_LANGID_SRB_CYR","text":"<pre><code>#define USB_LANGID_SRB_CYR 0x0c1a\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_srb_lat","title":"define USB_LANGID_SRB_LAT","text":"<pre><code>#define USB_LANGID_SRB_LAT 0x081a\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_swa","title":"define USB_LANGID_SWA","text":"<pre><code>#define USB_LANGID_SWA 0x0441\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_swe","title":"define USB_LANGID_SWE","text":"<pre><code>#define USB_LANGID_SWE 0x041d\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_swe_fi","title":"define USB_LANGID_SWE_FI","text":"<pre><code>#define USB_LANGID_SWE_FI 0x081d\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_tam","title":"define USB_LANGID_TAM","text":"<pre><code>#define USB_LANGID_TAM 0x0449\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_tat","title":"define USB_LANGID_TAT","text":"<pre><code>#define USB_LANGID_TAT 0x0444\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_tel","title":"define USB_LANGID_TEL","text":"<pre><code>#define USB_LANGID_TEL 0x044a\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_tha","title":"define USB_LANGID_THA","text":"<pre><code>#define USB_LANGID_THA 0x041e\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_tur","title":"define USB_LANGID_TUR","text":"<pre><code>#define USB_LANGID_TUR 0x041f\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_urd_in","title":"define USB_LANGID_URD_IN","text":"<pre><code>#define USB_LANGID_URD_IN 0x0820\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_urd_pk","title":"define USB_LANGID_URD_PK","text":"<pre><code>#define USB_LANGID_URD_PK 0x0420\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_uzb_cyr","title":"define USB_LANGID_UZB_CYR","text":"<pre><code>#define USB_LANGID_UZB_CYR 0x0843\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_uzb_lat","title":"define USB_LANGID_UZB_LAT","text":"<pre><code>#define USB_LANGID_UZB_LAT 0x0443\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_vie","title":"define USB_LANGID_VIE","text":"<pre><code>#define USB_LANGID_VIE 0x042a\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_zho_cn","title":"define USB_LANGID_ZHO_CN","text":"<pre><code>#define USB_LANGID_ZHO_CN 0x0804\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_zho_hk","title":"define USB_LANGID_ZHO_HK","text":"<pre><code>#define USB_LANGID_ZHO_HK 0x0c04\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_zho_mo","title":"define USB_LANGID_ZHO_MO","text":"<pre><code>#define USB_LANGID_ZHO_MO 0x1404\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_zho_sg","title":"define USB_LANGID_ZHO_SG","text":"<pre><code>#define USB_LANGID_ZHO_SG 0x1004\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langid_zho_tw","title":"define USB_LANGID_ZHO_TW","text":"<pre><code>#define USB_LANGID_ZHO_TW 0x0404\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_langig_ukr","title":"define USB_LANGIG_UKR","text":"<pre><code>#define USB_LANGIG_UKR 0x0422\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_proto_iad","title":"define USB_PROTO_IAD","text":"<pre><code>#define USB_PROTO_IAD 0x01\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_proto_none","title":"define USB_PROTO_NONE","text":"<pre><code>#define USB_PROTO_NONE 0x00\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_proto_vendor","title":"define USB_PROTO_VENDOR","text":"<pre><code>#define USB_PROTO_VENDOR 0xFF\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_std_clear_feature","title":"define USB_STD_CLEAR_FEATURE","text":"<pre><code>#define USB_STD_CLEAR_FEATURE 0x01\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_std_get_config","title":"define USB_STD_GET_CONFIG","text":"<pre><code>#define USB_STD_GET_CONFIG 0x08\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_std_get_descriptor","title":"define USB_STD_GET_DESCRIPTOR","text":"<pre><code>#define USB_STD_GET_DESCRIPTOR 0x06\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_std_get_interface","title":"define USB_STD_GET_INTERFACE","text":"<pre><code>#define USB_STD_GET_INTERFACE 0x0A\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_std_get_status","title":"define USB_STD_GET_STATUS","text":"<pre><code>#define USB_STD_GET_STATUS 0x00\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_std_set_address","title":"define USB_STD_SET_ADDRESS","text":"<pre><code>#define USB_STD_SET_ADDRESS 0x05\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_std_set_config","title":"define USB_STD_SET_CONFIG","text":"<pre><code>#define USB_STD_SET_CONFIG 0x09\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_std_set_descriptor","title":"define USB_STD_SET_DESCRIPTOR","text":"<pre><code>#define USB_STD_SET_DESCRIPTOR 0x07\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_std_set_feature","title":"define USB_STD_SET_FEATURE","text":"<pre><code>#define USB_STD_SET_FEATURE 0x03\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_std_set_interface","title":"define USB_STD_SET_INTERFACE","text":"<pre><code>#define USB_STD_SET_INTERFACE 0x0B\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_std_synch_frame","title":"define USB_STD_SYNCH_FRAME","text":"<pre><code>#define USB_STD_SYNCH_FRAME 0x0C\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_string_desc","title":"define USB_STRING_DESC","text":"<pre><code>#define USB_STRING_DESC (\ns\n) {.bLength = sizeof(CAT(u,s)),\\\n                                    .bDescriptorType = USB_DTYPE_STRING ,\\\n                                    .wString = {CAT(u,s)}}\n</code></pre> <p>Macro to create usb_string_descriptor from string </p>"},{"location":"apiStm/usb__std_8h/#define-usb_subclass_iad","title":"define USB_SUBCLASS_IAD","text":"<pre><code>#define USB_SUBCLASS_IAD 0x02\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_subclass_none","title":"define USB_SUBCLASS_NONE","text":"<pre><code>#define USB_SUBCLASS_NONE 0x00\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_subclass_vendor","title":"define USB_SUBCLASS_VENDOR","text":"<pre><code>#define USB_SUBCLASS_VENDOR 0xFF\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_test_force_enable","title":"define USB_TEST_FORCE_ENABLE","text":"<pre><code>#define USB_TEST_FORCE_ENABLE 0x05\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_test_j","title":"define USB_TEST_J","text":"<pre><code>#define USB_TEST_J 0x01\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_test_k","title":"define USB_TEST_K","text":"<pre><code>#define USB_TEST_K 0x02\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_test_packet","title":"define USB_TEST_PACKET","text":"<pre><code>#define USB_TEST_PACKET 0x04\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-usb_test_se0_nak","title":"define USB_TEST_SE0_NAK","text":"<pre><code>#define USB_TEST_SE0_NAK 0x03\n</code></pre>"},{"location":"apiStm/usb__std_8h/#define-version_bcd","title":"define VERSION_BCD","text":"<pre><code>#define VERSION_BCD (\nmaj,\nmin,\nrev\n) (((maj &amp; 0xFF) &lt;&lt; 8) | ((min &amp; 0x0F) &lt;&lt; 4) | (rev &amp; 0x0F))\n</code></pre> <p>Macro to encode major/minor/version number into BCD code </p> <p>Parameters:</p> <ul> <li><code>maj</code> Major version </li> <li><code>min</code> Minor version </li> <li><code>rev</code> Revision </li> </ul>"},{"location":"apiStm/usb__std_8h/#define-__cat","title":"define __CAT","text":"<pre><code>#define __CAT (\nx,\ny\n) x ## y\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usb_std.h</code></p>"},{"location":"apiStm/usb__std_8h_source/","title":"File usb_std.h","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; lib &gt; libusb_stm32 &gt; include &gt; usb_std.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* This file is the part of the Lightweight USB device Stack for STM32 microcontrollers\n *\n * Copyright \u00a92016 Dmitry Filimonchuk &lt;dmitrystu[at]gmail[dot]com&gt;\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *   http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _USB_STD_H_\n#define _USB_STD_H_\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n\n#define __CAT(x,y) x ## y\n#define CAT(x,y) __CAT(x,y)\n\n#define VERSION_BCD(maj, min, rev)  (((maj &amp; 0xFF) &lt;&lt; 8) | ((min &amp; 0x0F) &lt;&lt; 4) | (rev &amp; 0x0F))\n\n#define USB_ARRAY_DESC(...)        {.bLength = 2 + sizeof((uint16_t[]){__VA_ARGS__}),\\\n                                    .bDescriptorType = USB_DTYPE_STRING,\\\n                                    .wString = {__VA_ARGS__}}\n#define USB_STRING_DESC(s)         {.bLength = sizeof(CAT(u,s)),\\\n                                    .bDescriptorType = USB_DTYPE_STRING,\\\n                                    .wString = {CAT(u,s)}}\n\n#define USB_CFG_POWER_MA(mA)        ((mA) &gt;&gt; 1)\n#define USB_CFG_ATTR_RESERVED       0x80\n#define USB_CFG_ATTR_SELFPOWERED    0x40\n#define USB_EPDIR_IN                0x00    \n#define USB_EPDIR_OUT               0x80    \n#define USB_EPTYPE_CONTROL          0x00    \n#define USB_EPTYPE_ISOCHRONUS       0x01    \n#define USB_EPTYPE_BULK             0x02    \n#define USB_EPTYPE_INTERRUPT        0x03    \n#define USB_EPATTR_NO_SYNC          0x00    \n#define USB_EPATTR_ASYNC            0x04    \n#define USB_EPATTR_ADAPTIVE         0x08    \n#define USB_EPATTR_SYNC             0x0C    \n#define USB_EPUSAGE_DATA            0x00    \n#define USB_EPUSAGE_FEEDBACK        0x10    \n#define USB_EPUSAGE_IMP_FEEDBACK    0x20    \n#define NO_DESCRIPTOR               0x00    \n#define INTSERIALNO_DESCRIPTOR      0xFE    \n#define USB_CLASS_PER_INTERFACE     0x00    \n#define USB_SUBCLASS_NONE           0x00    \n#define USB_PROTO_NONE              0x00    \n#define USB_CLASS_AUDIO             0x01    \n#define USB_CLASS_PHYSICAL          0x05    \n#define USB_CLASS_STILL_IMAGE       0x06    \n#define USB_CLASS_PRINTER           0x07    \n#define USB_CLASS_MASS_STORAGE      0x08    \n#define USB_CLASS_HUB               0x09    \n#define USB_CLASS_CSCID             0x0B    \n#define USB_CLASS_CONTENT_SEC       0x0D    \n#define USB_CLASS_VIDEO             0x0E    \n#define USB_CLASS_HEALTHCARE        0x0F    \n#define USB_CLASS_AV                0x10    \n#define USB_CLASS_BILLBOARD         0x11    \n#define USB_CLASS_CBRIDGE           0x12    \n#define USB_CLASS_DIAGNOSTIC        0xDC    \n#define USB_CLASS_WIRELESS          0xE0    \n#define USB_CLASS_MISC              0xEF    \n#define USB_CLASS_APP_SPEC          0xFE    \n#define USB_CLASS_VENDOR            0xFF    \n#define USB_SUBCLASS_VENDOR         0xFF    \n#define USB_PROTO_VENDOR            0xFF    \n#define USB_CLASS_IAD               0xEF    \n#define USB_SUBCLASS_IAD            0x02    \n#define USB_PROTO_IAD               0x01    \n#define USB_DTYPE_DEVICE            0x01    \n#define USB_DTYPE_CONFIGURATION     0x02    \n#define USB_DTYPE_STRING            0x03    \n#define USB_DTYPE_INTERFACE         0x04    \n#define USB_DTYPE_ENDPOINT          0x05    \n#define USB_DTYPE_QUALIFIER         0x06    \n#define USB_DTYPE_OTHER             0x07    \n#define USB_DTYPE_INTERFACEPOWER    0x08    \n#define USB_DTYPE_OTG               0x09    \n#define USB_DTYPE_DEBUG             0x0A    \n#define USB_DTYPE_INTERFASEASSOC    0x0B    \n#define USB_DTYPE_CS_INTERFACE      0x24    \n#define USB_DTYPE_CS_ENDPOINT       0x25    \n#define USB_STD_GET_STATUS          0x00    \n#define USB_STD_CLEAR_FEATURE       0x01    \n#define USB_STD_SET_FEATURE         0x03    \n#define USB_STD_SET_ADDRESS         0x05    \n#define USB_STD_GET_DESCRIPTOR      0x06    \n#define USB_STD_SET_DESCRIPTOR      0x07    \n#define USB_STD_GET_CONFIG          0x08    \n#define USB_STD_SET_CONFIG          0x09    \n#define USB_STD_GET_INTERFACE       0x0A    \n#define USB_STD_SET_INTERFACE       0x0B    \n#define USB_STD_SYNCH_FRAME         0x0C    \n#define USB_FEAT_ENDPOINT_HALT      0x00    \n#define USB_FEAT_REMOTE_WKUP        0x01\n#define USB_FEAT_TEST_MODE          0x02\n#define USB_FEAT_DEBUG_MODE         0x06\n#define USB_TEST_J                  0x01    \n#define USB_TEST_K                  0x02    \n#define USB_TEST_SE0_NAK            0x03    \n#define USB_TEST_PACKET             0x04    \n#define USB_TEST_FORCE_ENABLE       0x05    \n#define USB_LANGID_AFR              0x0436   \n#define USB_LANGID_SQI              0x041c   \n#define USB_LANGID_ARA_SA           0x0401   \n#define USB_LANGID_ARA_IQ           0x0801   \n#define USB_LANGID_ARA_EG           0x0c01   \n#define USB_LANGID_ARA_LY           0x1001   \n#define USB_LANGID_ARA_DZ           0x1401   \n#define USB_LANGID_ARA_MA           0x1801   \n#define USB_LANGID_ARA_TN           0x1c01   \n#define USB_LANGID_ARA_OM           0x2001   \n#define USB_LANGID_ARA_YE           0x2401   \n#define USB_LANGID_ARA_SY           0x2801   \n#define USB_LANGID_ARA_JO           0x2c01   \n#define USB_LANGID_ARA_LB           0x3001   \n#define USB_LANGID_ARA_KW           0x3401   \n#define USB_LANGID_ARA_AE           0x3801   \n#define USB_LANGID_ARA_BH           0x3c01   \n#define USB_LANGID_ARA_QA           0x4001   \n#define USB_LANGID_HYE              0x042b   \n#define USB_LANGID_ASM              0x044d   \n#define USB_LANGID_AZE_LAT          0x042c   \n#define USB_LANGID_AZE_CYR          0x082c   \n#define USB_LANGID_EUS              0x042d   \n#define USB_LANGID_BEL              0x0423   \n#define USB_LANGID_BEN              0x0445   \n#define USB_LANGID_BUL              0x0402   \n#define USB_LANGID_MYA              0x0455   \n#define USB_LANGID_CAT              0x0403   \n#define USB_LANGID_ZHO_TW           0x0404   \n#define USB_LANGID_ZHO_CN           0x0804   \n#define USB_LANGID_ZHO_HK           0x0c04   \n#define USB_LANGID_ZHO_SG           0x1004   \n#define USB_LANGID_ZHO_MO           0x1404   \n#define USB_LANGID_HRV              0x041a   \n#define USB_LANGID_CZE              0x0405   \n#define USB_LANGID_DAN              0x0406   \n#define USB_LANGID_NLD_NL           0x0413   \n#define USB_LANGID_NLD_BE           0x0813   \n#define USB_LANGID_ENG_US           0x0409   \n#define USB_LANGID_ENG_UK           0x0809   \n#define USB_LANGID_ENG_AU           0x0c09   \n#define USB_LANGID_ENG_CA           0x1009   \n#define USB_LANGID_ENG_NZ           0x1409   \n#define USB_LANGID_ENG_IE           0x1809   \n#define USB_LANGID_ENG_ZA           0x1c09   \n#define USB_LANGID_ENG_JM           0x2009   \n#define USB_LANGID_ENG_CAR          0x2409   \n#define USB_LANGID_ENG_BZ           0x2809   \n#define USB_LANGID_ENG_TH           0x2c09   \n#define USB_LANGID_ENG_ZW           0x3009   \n#define USB_LANGID_ENG_PH           0x3409   \n#define USB_LANGID_EST              0x0425   \n#define USB_LANGID_FAO              0x0438   \n#define USB_LANGID_FAS              0x0429   \n#define USB_LANGID_FIN              0x040b   \n#define USB_LANGID_FRA              0x040c   \n#define USB_LANGID_FRA_BE           0x080c   \n#define USB_LANGID_FRA_CA           0x0c0c   \n#define USB_LANGID_FRA_SZ           0x100c   \n#define USB_LANGID_FRA_LU           0x140c   \n#define USB_LANGID_FRA_MC           0x180c   \n#define USB_LANGID_KAT              0x0437   \n#define USB_LANGID_DEU              0x0407   \n#define USB_LANGID_DEU_SZ           0x0807   \n#define USB_LANGID_DEU_AT           0x0c07   \n#define USB_LANGID_DEU_LU           0x1007   \n#define USB_LANGID_DEU_LI           0x1407   \n#define USB_LANGID_ELL              0x0408   \n#define USB_LANGID_GUJ              0x0447   \n#define USB_LANGID_HEB              0x040d   \n#define USB_LANGID_HIN              0x0439   \n#define USB_LANGID_HUN              0x040e   \n#define USB_LANGID_ISL              0x040f   \n#define USB_LANGID_IND              0x0421   \n#define USB_LANGID_ITA              0x0410   \n#define USB_LANGID_ITA_SZ           0x0810   \n#define USB_LANGID_JPN              0x0411   \n#define USB_LANGID_KAN              0x044b   \n#define USB_LANGID_KAS              0x0860   \n#define USB_LANGID_KAZ              0x043f   \n#define USB_LANGID_KOK              0x0457   \n#define USB_LANGID_KOR              0x0412   \n#define USB_LANGID_KOR_JOH          0x0812   \n#define USB_LANGID_LAV              0x0426   \n#define USB_LANGID_LIT              0x0427   \n#define USB_LANGID_LIT_CLS          0x0827   \n#define USB_LANGID_MKD              0x042f   \n#define USB_LANGID_MSA              0x043e   \n#define USB_LANGID_MSA_BN           0x083e   \n#define USB_LANGID_MAL              0x044c   \n#define USB_LANGID_MNI              0x0458   \n#define USB_LANGID_MAR              0x044e   \n#define USB_LANGID_NEP              0x0861   \n#define USB_LANGID_NOB              0x0414   \n#define USB_LANGID_NNO              0x0814   \n#define USB_LANGID_ORI              0x0448   \n#define USB_LANGID_POL              0x0415   \n#define USB_LANGID_POR_BR           0x0416   \n#define USB_LANGID_POR              0x0816   \n#define USB_LANGID_PAN              0x0446   \n#define USB_LANGID_RON              0x0418   \n#define USB_LANGID_RUS              0x0419   \n#define USB_LANGID_SAN              0x044f   \n#define USB_LANGID_SRB_CYR          0x0c1a   \n#define USB_LANGID_SRB_LAT          0x081a   \n#define USB_LANGID_SND              0x0459   \n#define USB_LANGID_SLK              0x041b   \n#define USB_LANGID_SLV              0x0424   \n#define USB_LANGID_SPA              0x040a   \n#define USB_LANGID_SPA_MX           0x080a   \n#define USB_LANGID_SPA_MDN          0x0c0a   \n#define USB_LANGID_SPA_GT           0x100a   \n#define USB_LANGID_SPA_CR           0x140a   \n#define USB_LANGID_SPA_PA           0x180a   \n#define USB_LANGID_SPA_DO           0x1c0a   \n#define USB_LANGID_SPA_VE           0x200a   \n#define USB_LANGID_SPA_CO           0x240a   \n#define USB_LANGID_SPA_PE           0x280a   \n#define USB_LANGID_SPA_AR           0x2c0a   \n#define USB_LANGID_SPA_EC           0x300a   \n#define USB_LANGID_SPA_CL           0x340a   \n#define USB_LANGID_SPA_UY           0x380a   \n#define USB_LANGID_SPA_PY           0x3c0a   \n#define USB_LANGID_SPA_BO           0x400a   \n#define USB_LANGID_SPA_SV           0x440a   \n#define USB_LANGID_SPA_HN           0x480a   \n#define USB_LANGID_SPA_NI           0x4c0a   \n#define USB_LANGID_SPA_PR           0x500a   \n#define USB_LANGID_NSO              0x0430   \n#define USB_LANGID_SWA              0x0441   \n#define USB_LANGID_SWE              0x041d   \n#define USB_LANGID_SWE_FI           0x081d   \n#define USB_LANGID_TAM              0x0449   \n#define USB_LANGID_TAT              0x0444   \n#define USB_LANGID_TEL              0x044a   \n#define USB_LANGID_THA              0x041e   \n#define USB_LANGID_TUR              0x041f   \n#define USB_LANGIG_UKR              0x0422   \n#define USB_LANGID_URD_PK           0x0420   \n#define USB_LANGID_URD_IN           0x0820   \n#define USB_LANGID_UZB_LAT          0x0443   \n#define USB_LANGID_UZB_CYR          0x0843   \n#define USB_LANGID_VIE              0x042a   \nstruct usb_header_descriptor {\nuint8_t bLength;                uint8_t bDescriptorType;        } __attribute__((packed));\n\nstruct usb_device_descriptor {\nuint8_t  bLength;               uint8_t  bDescriptorType;       uint16_t bcdUSB;                uint8_t  bDeviceClass;          uint8_t  bDeviceSubClass;       uint8_t  bDeviceProtocol;       uint8_t  bMaxPacketSize0;       uint16_t idVendor;              uint16_t idProduct;             uint16_t bcdDevice;             uint8_t  iManufacturer;         uint8_t  iProduct;              uint8_t  iSerialNumber;         uint8_t  bNumConfigurations;    } __attribute__((packed));\n\nstruct usb_qualifier_descriptor {\nuint8_t  bLength;               uint8_t  bDescriptorType;       uint16_t bcdUSB;                uint8_t  bDeviceClass;          uint8_t  bDeviceSubClass;       uint8_t  bDeviceProtocol;       uint8_t  bMaxPacketSize0;       uint8_t  bNumConfigurations;    uint8_t  bReserved;             } __attribute__((packed));\n\nstruct usb_config_descriptor {\nuint8_t  bLength;               uint8_t  bDescriptorType;       uint16_t wTotalLength;          uint8_t  bNumInterfaces;        uint8_t  bConfigurationValue;   uint8_t  iConfiguration;        uint8_t  bmAttributes;          uint8_t  bMaxPower;             } __attribute__((packed));\n\nstruct usb_interface_descriptor {\nuint8_t bLength;                uint8_t bDescriptorType;        uint8_t bInterfaceNumber;       uint8_t bAlternateSetting;      uint8_t bNumEndpoints;          uint8_t bInterfaceClass;        uint8_t bInterfaceSubClass;     uint8_t bInterfaceProtocol;     uint8_t iInterface;             } __attribute__((packed));\n\nstruct usb_iad_descriptor {\nuint8_t bLength;                uint8_t bDescriptorType;        uint8_t bFirstInterface;        uint8_t bInterfaceCount;        uint8_t bFunctionClass;         uint8_t bFunctionSubClass;      uint8_t bFunctionProtocol;      uint8_t iFunction;              } __attribute__((packed));\n\nstruct usb_endpoint_descriptor {\nuint8_t  bLength;               uint8_t  bDescriptorType;       uint8_t  bEndpointAddress;      uint8_t  bmAttributes;          uint16_t wMaxPacketSize;        uint8_t  bInterval;             } __attribute__((packed));\n\nstruct usb_string_descriptor {\nuint8_t  bLength;               uint8_t  bDescriptorType;       uint16_t wString[];             } __attribute__((packed, aligned(2)));\n\nstruct usb_debug_descriptor {\nuint8_t  bLength;               uint8_t  bDescriptorType;       uint8_t  bDebugInEndpoint;      uint8_t  bDebugOutEndpoint;     } __attribute__((packed));\n\n#if defined (__cplusplus)\n}\n#endif\n#endif //_USB_STD_H_\n</code></pre>"},{"location":"apiStm/usbd__core_8h/","title":"File usbd_core.h","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; lib &gt; libusb_stm32 &gt; include &gt; usbd_core.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdbool.h&gt;</code></li> </ul>"},{"location":"apiStm/usbd__core_8h/#classes","title":"Classes","text":"Type Name struct _usbd_device Represents a USB device data. struct usbd_ctlreq Represents generic USB control request. struct usbd_driver Represents a hardware USB driver call table. struct usbd_status"},{"location":"apiStm/usbd__core_8h/#public-types","title":"Public Types","text":"Type Name enum _usbd_respond Reporting status results. typedef usbd_respond(* usbd_cfg_callback USB set configuration callback function. typedef usbd_respond(* usbd_ctl_callback USB control callback function. enum usbd_ctl_state USB device control endpoint machine state. typedef struct _usbd_device usbd_device typedef usbd_respond(* usbd_dsc_callback USB get descriptor callback function. typedef void(* usbd_evt_callback Generic USB device event callback for events and endpoints processing. typedef uint8_t(* usbd_hw_connect typedef void(* usbd_hw_enable Enables or disables USB hardware. typedef bool(* usbd_hw_ep_config Configures endpoint. typedef void(* usbd_hw_ep_deconfig De-configures, cleans and disables endpoint. typedef bool(* usbd_hw_ep_isstalled Checks endpoint for stalled state. typedef int32_t(* usbd_hw_ep_read Reads data from OUT or control endpoint. typedef void(* usbd_hw_ep_setstall typedef int32_t(* usbd_hw_ep_write Writes data to IN or control endpoint. typedef uint16_t(* usbd_hw_get_frameno Gets frame number from usb hardware. typedef uint16_t(* usbd_hw_get_serialno Makes a string descriptor contains unique serial number from hardware ID's. typedef uint32_t(* usbd_hw_getinfo Get USB device status and capabilities. typedef void(* usbd_hw_poll Polls USB hardware for the events. typedef void(* usbd_hw_setaddr Sets USB hardware address. enum usbd_machine_state USB device machine states. typedef enum _usbd_respond usbd_respond Reporting status results. typedef void(* usbd_rqc_callback USB control transfer completed callback function."},{"location":"apiStm/usbd__core_8h/#public-functions","title":"Public Functions","text":"Type Name void usbd_poll (usbd_device * dev) Polls USB for events."},{"location":"apiStm/usbd__core_8h/#public-static-functions","title":"Public Static Functions","text":"Type Name uint8_t usbd_connect (usbd_device * dev, bool connect) Connects or disconnects USB hardware to/from usb host. void usbd_enable (usbd_device * dev, bool enable) Enables or disables USB hardware. bool usbd_ep_config (usbd_device * dev, uint8_t ep, uint8_t eptype, uint16_t epsize) Configure endpoint. void usbd_ep_deconfig (usbd_device * dev, uint8_t ep) Deconfigure endpoint. int32_t usbd_ep_read (usbd_device * dev, uint8_t ep, void * buf, uint16_t blen) Read data from endpoint. void usbd_ep_stall (usbd_device * dev, uint8_t ep) Stall endpoint. void usbd_ep_unstall (usbd_device * dev, uint8_t ep) Unstall endpoint. int32_t usbd_ep_write (usbd_device * dev, uint8_t ep, void * buf, uint16_t blen) Write data to endpoint. uint32_t usbd_getinfo (usbd_device * dev) Retrieves status and capabilities. void usbd_init (usbd_device * dev, const struct usbd_driver * drv, const uint8_t ep0size, uint32_t * buffer, const uint16_t bsize) Initializes device structure. void usbd_reg_config (usbd_device * dev, usbd_cfg_callback callback) Register callback for SET_CONFIG control request. void usbd_reg_control (usbd_device * dev, usbd_ctl_callback callback) Register callback for all control requests. void usbd_reg_descr (usbd_device * dev, usbd_dsc_callback callback) Register callback for GET_DESCRIPTOR control request. void usbd_reg_endpoint (usbd_device * dev, uint8_t ep, usbd_evt_callback callback) Register endpoint callback. void usbd_reg_event (usbd_device * dev, uint8_t evt, usbd_evt_callback callback) Registers event callback."},{"location":"apiStm/usbd__core_8h/#macros","title":"Macros","text":"Type Name define USBD_HW_ADDRFST  (1 &lt;&lt; 0)Set address before STATUS_OUT. define USBD_HW_BC  (1 &lt;&lt; 1)Battery charging detection supported. define USBD_HW_ENABLED  (1 &lt;&lt; 3)USB device enabled. define USBD_HW_ENUMSPEED  (2 &lt;&lt; 4)USB device enumeration speed mask. define USBD_HW_SPEED_FS  (2 &lt;&lt; 4)Full speed. define USBD_HW_SPEED_HS  (3 &lt;&lt; 4)High speed. define USBD_HW_SPEED_LS  (1 &lt;&lt; 4)Low speed. define USBD_HW_SPEED_NC  (0 &lt;&lt; 4)Not connected. define USB_EPTYPE_DBLBUF  0x04Doublebuffered endpoint (bulk endpoint only). define USB_REQ_CLASS  (1 &lt;&lt; 5)Class specified request. define USB_REQ_DEVICE  (0 &lt;&lt; 0)Request to device. define USB_REQ_DEVTOHOST  (1 &lt;&lt; 7)Request direction is DEVICE to HOST. define USB_REQ_DIRECTION  (1 &lt;&lt; 7)Request direction mask. define USB_REQ_ENDPOINT  (2 &lt;&lt; 0)Request to endpoint. define USB_REQ_HOSTTODEV  (0 &lt;&lt; 7)Request direction is HOST to DEVICE. define USB_REQ_INTERFACE  (1 &lt;&lt; 0)Request to interface. define USB_REQ_OTHER  (3 &lt;&lt; 0)Other request. define USB_REQ_RECIPIENT  (3 &lt;&lt; 0)Request recipient mask. define USB_REQ_STANDARD  (0 &lt;&lt; 5)Standard request. define USB_REQ_TYPE  (3 &lt;&lt; 5)Request type mask. define USB_REQ_VENDOR  (2 &lt;&lt; 5)Vendor specified request. define USND_HW_HS  (1 &lt;&lt; 2)High speed supported. define usbd_evt_count  8 define usbd_evt_eprx  5Data packet received. define usbd_evt_epsetup  6Setup packet received. define usbd_evt_eptx  4Data packet transmitted. define usbd_evt_error  7Data error. define usbd_evt_reset  0Reset. define usbd_evt_sof  1Start of frame. define usbd_evt_susp  2Suspend. define usbd_evt_wkup  3Wakeup. define usbd_lane_cdp  3Lanes connected to charging downstream port. define usbd_lane_dcp  4Lanes connected to dedicated charging port. define usbd_lane_dsc  1Lanes disconnected. define usbd_lane_sdp  2Lanes connected to standard downstream port. define usbd_lane_unk  0Unknown or proprietary charger."},{"location":"apiStm/usbd__core_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/usbd__core_8h/#enum-_usbd_respond","title":"enum _usbd_respond","text":"<pre><code>enum _usbd_respond {\nusbd_fail,\nusbd_ack,\nusbd_nak\n};\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#typedef-usbd_cfg_callback","title":"typedef usbd_cfg_callback","text":"<p>USB set configuration callback function. <pre><code>typedef usbd_respond(* usbd_cfg_callback) (usbd_device *dev, uint8_t cfg);\n</code></pre></p> <p>called when SET_CONFIGURATION request issued </p> <p>Parameters:</p> <ul> <li><code>dev</code> pointer to USB device </li> <li><code>cfg</code> configuration number. </li> </ul> <p>Note:</p> <p>if config is 0 device endpoints should be de-configured </p> <p>Returns:</p> <p>TRUE if success </p>"},{"location":"apiStm/usbd__core_8h/#typedef-usbd_ctl_callback","title":"typedef usbd_ctl_callback","text":"<p>USB control callback function. <pre><code>typedef usbd_respond(* usbd_ctl_callback) (usbd_device *dev, usbd_ctlreq *req, usbd_rqc_callback *callback);\n</code></pre></p> <p>Uses for the control request processing. Some requests will be handled by core if callback don't process it (returns FALSE). If request was not processed STALL PID will be issued. * GET_CONFIGURATION * SET_CONFIGURATION (passes to usbd_cfg_callback) * GET_DESCRIPTOR (passes to usbd_dsc_callback) * GET_STATUS * SET_FEATURE, CLEAR_FEATURE (endpoints only) * SET_ADDRESS </p> <p>Parameters:</p> <ul> <li><code>dev</code> points to USB device </li> <li><code>req</code> points to usb control request </li> <li><code>*callback</code> USB control transfer completion callback, default is NULL (no callback) </li> </ul> <p>Returns:</p> <p>usbd_respond status. </p>"},{"location":"apiStm/usbd__core_8h/#enum-usbd_ctl_state","title":"enum usbd_ctl_state","text":"<pre><code>enum usbd_ctl_state {\nusbd_ctl_idle,\nusbd_ctl_rxdata,\nusbd_ctl_txdata,\nusbd_ctl_ztxdata,\nusbd_ctl_lastdata,\nusbd_ctl_statusin,\nusbd_ctl_statusout\n};\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#typedef-usbd_device","title":"typedef usbd_device","text":"<pre><code>typedef struct _usbd_device usbd_device;\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#typedef-usbd_dsc_callback","title":"typedef usbd_dsc_callback","text":"<p>USB get descriptor callback function. <pre><code>typedef usbd_respond(* usbd_dsc_callback) (usbd_ctlreq *req, void **address, uint16_t *dsize);\n</code></pre></p> <p>Called when GET_DESCRIPTOR request issued </p> <p>Parameters:</p> <ul> <li><code>req</code> pointer to usb control request structure </li> <li><code>address</code> pointer to the descriptor in memory. Points to req-&gt;data by default. You can use this buffer. </li> <li><code>dsize</code> descriptor size. maximum buffer size by default. </li> </ul> <p>Returns:</p> <p>usbd_ack if you passed the correct descriptor, usbd_fail otherwise. </p>"},{"location":"apiStm/usbd__core_8h/#typedef-usbd_evt_callback","title":"typedef usbd_evt_callback","text":"<p>Generic USB device event callback for events and endpoints processing. <pre><code>typedef void(* usbd_evt_callback) (usbd_device *dev, uint8_t event, uint8_t ep);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> pointer to USB device </li> <li><code>event</code> USB event </li> <li><code>ep</code> active endpoint number </li> </ul> <p>Note:</p> <p>endpoints with same indexes i.e. 0x01 and 0x81 shares same callback. </p>"},{"location":"apiStm/usbd__core_8h/#typedef-usbd_hw_connect","title":"typedef usbd_hw_connect","text":"<pre><code>typedef uint8_t(* usbd_hw_connect) (bool connect);\n</code></pre> <p>Connects or disconnects USB hardware to/from usb host </p> <p>Parameters:</p> <ul> <li><code>connect</code> Connects USB to host if TRUE, disconnects otherwise </li> </ul> <p>Returns:</p> <p>lanes connection status. </p>"},{"location":"apiStm/usbd__core_8h/#typedef-usbd_hw_enable","title":"typedef usbd_hw_enable","text":"<p>Enables or disables USB hardware. <pre><code>typedef void(* usbd_hw_enable) (bool enable);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>enable</code> Enables USB when TRUE disables otherwise. </li> </ul>"},{"location":"apiStm/usbd__core_8h/#typedef-usbd_hw_ep_config","title":"typedef usbd_hw_ep_config","text":"<p>Configures endpoint. <pre><code>typedef bool(* usbd_hw_ep_config) (uint8_t ep, uint8_t eptype, uint16_t epsize);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ep</code> endpoint address. Use USB_EPDIR_ macros to set endpoint direction </li> <li><code>eptype</code> endpoint type. Use USB_EPTYPE_* macros. </li> <li><code>epsize</code> endpoint size in bytes </li> </ul> <p>Returns:</p> <p>TRUE if success </p>"},{"location":"apiStm/usbd__core_8h/#typedef-usbd_hw_ep_deconfig","title":"typedef usbd_hw_ep_deconfig","text":"<p>De-configures, cleans and disables endpoint. <pre><code>typedef void(* usbd_hw_ep_deconfig) (uint8_t ep);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ep</code> endpoint index </li> </ul> <p>Note:</p> <p>if you have two one-direction single-buffered endpoints with same index (i.e. 0x02 and 0x82) both will be deconfigured. </p>"},{"location":"apiStm/usbd__core_8h/#typedef-usbd_hw_ep_isstalled","title":"typedef usbd_hw_ep_isstalled","text":"<p>Checks endpoint for stalled state. <pre><code>typedef bool(* usbd_hw_ep_isstalled) (uint8_t ep);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ep</code> endpoint address </li> </ul> <p>Returns:</p> <p>TRUE if endpoint is stalled </p>"},{"location":"apiStm/usbd__core_8h/#typedef-usbd_hw_ep_read","title":"typedef usbd_hw_ep_read","text":"<p>Reads data from OUT or control endpoint. <pre><code>typedef int32_t(* usbd_hw_ep_read) (uint8_t ep, void *buf, uint16_t blen);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ep</code> endpoint index, should belong to OUT or CONTROL endpoint. </li> <li><code>buf</code> pointer to read buffer </li> <li><code>blen</code> size of the read buffer in bytes </li> </ul> <p>Returns:</p> <p>size of the actually received data, -1 on error. </p>"},{"location":"apiStm/usbd__core_8h/#typedef-usbd_hw_ep_setstall","title":"typedef usbd_hw_ep_setstall","text":"<pre><code>typedef void(* usbd_hw_ep_setstall) (uint8_t ep, bool stall);\n</code></pre> <p>Stalls and unstalls endpoint </p> <p>Parameters:</p> <ul> <li><code>ep</code> endpoint address </li> <li><code>stall</code> endpoint will be stalled if TRUE and unstalled otherwise. </li> </ul> <p>Note:</p> <p>Has no effect on inactive endpoints. </p>"},{"location":"apiStm/usbd__core_8h/#typedef-usbd_hw_ep_write","title":"typedef usbd_hw_ep_write","text":"<p>Writes data to IN or control endpoint. <pre><code>typedef int32_t(* usbd_hw_ep_write) (uint8_t ep, void *buf, uint16_t blen);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ep</code> endpoint index, hould belong to IN or CONTROL endpoint </li> <li><code>buf</code> pointer to data buffer </li> <li><code>blen</code> size of data will be written </li> </ul> <p>Returns:</p> <p>number of written bytes </p>"},{"location":"apiStm/usbd__core_8h/#typedef-usbd_hw_get_frameno","title":"typedef usbd_hw_get_frameno","text":"<pre><code>typedef uint16_t(* usbd_hw_get_frameno) (void);\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#typedef-usbd_hw_get_serialno","title":"typedef usbd_hw_get_serialno","text":"<p>Makes a string descriptor contains unique serial number from hardware ID's. <pre><code>typedef uint16_t(* usbd_hw_get_serialno) (void *buffer);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buffer</code> pointer to buffer for the descriptor </li> </ul> <p>Returns:</p> <p>of the descriptor in bytes </p>"},{"location":"apiStm/usbd__core_8h/#typedef-usbd_hw_getinfo","title":"typedef usbd_hw_getinfo","text":"<p>Get USB device status and capabilities. <pre><code>typedef uint32_t(* usbd_hw_getinfo) (void);\n</code></pre></p> <p>Returns:</p> <p>Hardware status and capabilities USBD_HW_CAPS </p>"},{"location":"apiStm/usbd__core_8h/#typedef-usbd_hw_poll","title":"typedef usbd_hw_poll","text":"<p>Polls USB hardware for the events. <pre><code>typedef void(* usbd_hw_poll) (usbd_device *dev, usbd_evt_callback callback);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> pointer to usb device structure </li> <li><code>callback</code> callback to event processing subroutine </li> </ul>"},{"location":"apiStm/usbd__core_8h/#typedef-usbd_hw_setaddr","title":"typedef usbd_hw_setaddr","text":"<p>Sets USB hardware address. <pre><code>typedef void(* usbd_hw_setaddr) (uint8_t address);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>address</code> USB address </li> </ul>"},{"location":"apiStm/usbd__core_8h/#enum-usbd_machine_state","title":"enum usbd_machine_state","text":"<pre><code>enum usbd_machine_state {\nusbd_state_disabled,\nusbd_state_disconnected,\nusbd_state_default,\nusbd_state_addressed,\nusbd_state_configured\n};\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#typedef-usbd_respond","title":"typedef usbd_respond","text":"<pre><code>typedef enum _usbd_respond usbd_respond;\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#typedef-usbd_rqc_callback","title":"typedef usbd_rqc_callback","text":"<p>USB control transfer completed callback function. <pre><code>typedef void(* usbd_rqc_callback) (usbd_device *dev, usbd_ctlreq *req);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> pointer to USB device </li> <li><code>req</code> pointer to usb request structure </li> </ul> <p>Note:</p> <p>usbd_device-&gt;complete_callback will be set to NULL after this callback completion. </p>"},{"location":"apiStm/usbd__core_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/usbd__core_8h/#function-usbd_poll","title":"function usbd_poll","text":"<p>Polls USB for events. <pre><code>void usbd_poll (\nusbd_device * dev\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> Pointer to device structure </li> </ul> <p>Note:</p> <p>can be called as from main routine as from USB interrupt </p>"},{"location":"apiStm/usbd__core_8h/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"apiStm/usbd__core_8h/#function-usbd_connect","title":"function usbd_connect","text":"<p>Connects or disconnects USB hardware to/from usb host. <pre><code>static inline uint8_t usbd_connect (\nusbd_device * dev,\nbool connect\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> dev usb device _usbd_device </li> <li><code>connect</code> Connects USB to host if TRUE, disconnects otherwise </li> </ul> <p>Returns:</p> <p>lanes connection status. USB_LANES_STATUS </p>"},{"location":"apiStm/usbd__core_8h/#function-usbd_enable","title":"function usbd_enable","text":"<p>Enables or disables USB hardware. <pre><code>static inline void usbd_enable (\nusbd_device * dev,\nbool enable\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> dev usb device _usbd_device </li> <li><code>enable</code> Enables USB when TRUE disables otherwise </li> </ul>"},{"location":"apiStm/usbd__core_8h/#function-usbd_ep_config","title":"function usbd_ep_config","text":"<p>Configure endpoint. <pre><code>static inline bool usbd_ep_config (\nusbd_device * dev,\nuint8_t ep,\nuint8_t eptype,\nuint16_t epsize\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> dev usb device _usbd_device </li> <li><code>ep</code> endpoint address. Use USB_EPDIR_ macros to set endpoint direction </li> <li><code>eptype</code> endpoint type. Use USB_EPTYPE_* macros. </li> <li><code>epsize</code> endpoint size in bytes </li> </ul> <p>Returns:</p> <p>TRUE if success </p>"},{"location":"apiStm/usbd__core_8h/#function-usbd_ep_deconfig","title":"function usbd_ep_deconfig","text":"<p>Deconfigure endpoint. <pre><code>static inline void usbd_ep_deconfig (\nusbd_device * dev,\nuint8_t ep\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> dev usb device _usbd_device </li> <li><code>ep</code> endpoint index </li> </ul> <p>Note:</p> <p>if you have two one-direction single-buffered endpoints with same index (i.e. 0x02 and 0x82) both will be deconfigured. </p>"},{"location":"apiStm/usbd__core_8h/#function-usbd_ep_read","title":"function usbd_ep_read","text":"<p>Read data from endpoint. <pre><code>static inline int32_t usbd_ep_read (\nusbd_device * dev,\nuint8_t ep,\nvoid * buf,\nuint16_t blen\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> dev usb device _usbd_device </li> <li><code>ep</code> endpoint index, should belong to OUT or CONTROL endpoint. </li> <li><code>buf</code> pointer to read buffer </li> <li><code>blen</code> size of the read buffer in bytes </li> </ul> <p>Returns:</p> <p>size of the actually received data, -1 on error. </p>"},{"location":"apiStm/usbd__core_8h/#function-usbd_ep_stall","title":"function usbd_ep_stall","text":"<p>Stall endpoint. <pre><code>static inline void usbd_ep_stall (\nusbd_device * dev,\nuint8_t ep\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> dev usb device _usbd_device </li> <li><code>ep</code> endpoint address </li> </ul>"},{"location":"apiStm/usbd__core_8h/#function-usbd_ep_unstall","title":"function usbd_ep_unstall","text":"<p>Unstall endpoint. <pre><code>static inline void usbd_ep_unstall (\nusbd_device * dev,\nuint8_t ep\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> dev usb device _usbd_device </li> <li><code>ep</code> endpoint address </li> </ul>"},{"location":"apiStm/usbd__core_8h/#function-usbd_ep_write","title":"function usbd_ep_write","text":"<p>Write data to endpoint. <pre><code>static inline int32_t usbd_ep_write (\nusbd_device * dev,\nuint8_t ep,\nvoid * buf,\nuint16_t blen\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> dev usb device _usbd_device </li> <li><code>ep</code> endpoint index, hould belong to IN or CONTROL endpoint </li> <li><code>buf</code> pointer to data buffer </li> <li><code>blen</code> size of data will be written </li> </ul> <p>Returns:</p> <p>number of written bytes </p>"},{"location":"apiStm/usbd__core_8h/#function-usbd_getinfo","title":"function usbd_getinfo","text":"<p>Retrieves status and capabilities. <pre><code>static inline uint32_t usbd_getinfo (\nusbd_device * dev\n) </code></pre></p> <p>Returns:</p> <p>current HW status, enumeration speed and capabilities USBD_HW_CAPS </p>"},{"location":"apiStm/usbd__core_8h/#function-usbd_init","title":"function usbd_init","text":"<p>Initializes device structure. <pre><code>static inline void usbd_init (\nusbd_device * dev,\nconst struct usbd_driver * drv,\nconst uint8_t ep0size,\nuint32_t * buffer,\nconst uint16_t bsize\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> USB device that will be initialized </li> <li><code>drv</code> Pointer to hardware driver </li> <li><code>ep0size</code> Control endpoint 0 size </li> <li><code>buffer</code> Pointer to control request data buffer (32-bit aligned) </li> <li><code>bsize</code> Size of the data buffer </li> </ul>"},{"location":"apiStm/usbd__core_8h/#function-usbd_reg_config","title":"function usbd_reg_config","text":"<p>Register callback for SET_CONFIG control request. <pre><code>static inline void usbd_reg_config (\nusbd_device * dev,\nusbd_cfg_callback callback\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> dev usb device _usbd_device </li> <li><code>callback</code> pointer to user usbd_cfg_callback </li> </ul>"},{"location":"apiStm/usbd__core_8h/#function-usbd_reg_control","title":"function usbd_reg_control","text":"<p>Register callback for all control requests. <pre><code>static inline void usbd_reg_control (\nusbd_device * dev,\nusbd_ctl_callback callback\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> usb device _usbd_device </li> <li><code>callback</code> user control callback usbd_ctl_callback </li> </ul>"},{"location":"apiStm/usbd__core_8h/#function-usbd_reg_descr","title":"function usbd_reg_descr","text":"<p>Register callback for GET_DESCRIPTOR control request. <pre><code>static inline void usbd_reg_descr (\nusbd_device * dev,\nusbd_dsc_callback callback\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> dev usb device _usbd_device </li> <li><code>callback</code> pointer to user usbd_ctl_callback </li> </ul>"},{"location":"apiStm/usbd__core_8h/#function-usbd_reg_endpoint","title":"function usbd_reg_endpoint","text":"<p>Register endpoint callback. <pre><code>static inline void usbd_reg_endpoint (\nusbd_device * dev,\nuint8_t ep,\nusbd_evt_callback callback\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> dev usb device _usbd_device </li> <li><code>ep</code> endpoint index </li> <li><code>callback</code> pointer to user usbd_evt_callback callback for endpoint events </li> </ul>"},{"location":"apiStm/usbd__core_8h/#function-usbd_reg_event","title":"function usbd_reg_event","text":"<p>Registers event callback. <pre><code>static inline void usbd_reg_event (\nusbd_device * dev,\nuint8_t evt,\nusbd_evt_callback callback\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> dev usb device _usbd_device </li> <li><code>evt</code> device event wants to be registered </li> <li><code>callback</code> pointer to user usbd_evt_callback for this event </li> </ul>"},{"location":"apiStm/usbd__core_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/usbd__core_8h/#define-usbd_hw_addrfst","title":"define USBD_HW_ADDRFST","text":"<pre><code>#define USBD_HW_ADDRFST (1 &lt;&lt; 0)\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usbd_hw_bc","title":"define USBD_HW_BC","text":"<pre><code>#define USBD_HW_BC (1 &lt;&lt; 1)\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usbd_hw_enabled","title":"define USBD_HW_ENABLED","text":"<pre><code>#define USBD_HW_ENABLED (1 &lt;&lt; 3)\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usbd_hw_enumspeed","title":"define USBD_HW_ENUMSPEED","text":"<pre><code>#define USBD_HW_ENUMSPEED (2 &lt;&lt; 4)\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usbd_hw_speed_fs","title":"define USBD_HW_SPEED_FS","text":"<pre><code>#define USBD_HW_SPEED_FS (2 &lt;&lt; 4)\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usbd_hw_speed_hs","title":"define USBD_HW_SPEED_HS","text":"<pre><code>#define USBD_HW_SPEED_HS (3 &lt;&lt; 4)\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usbd_hw_speed_ls","title":"define USBD_HW_SPEED_LS","text":"<pre><code>#define USBD_HW_SPEED_LS (1 &lt;&lt; 4)\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usbd_hw_speed_nc","title":"define USBD_HW_SPEED_NC","text":"<pre><code>#define USBD_HW_SPEED_NC (0 &lt;&lt; 4)\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usb_eptype_dblbuf","title":"define USB_EPTYPE_DBLBUF","text":"<pre><code>#define USB_EPTYPE_DBLBUF 0x04\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usb_req_class","title":"define USB_REQ_CLASS","text":"<pre><code>#define USB_REQ_CLASS (1 &lt;&lt; 5)\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usb_req_device","title":"define USB_REQ_DEVICE","text":"<pre><code>#define USB_REQ_DEVICE (0 &lt;&lt; 0)\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usb_req_devtohost","title":"define USB_REQ_DEVTOHOST","text":"<pre><code>#define USB_REQ_DEVTOHOST (1 &lt;&lt; 7)\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usb_req_direction","title":"define USB_REQ_DIRECTION","text":"<pre><code>#define USB_REQ_DIRECTION (1 &lt;&lt; 7)\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usb_req_endpoint","title":"define USB_REQ_ENDPOINT","text":"<pre><code>#define USB_REQ_ENDPOINT (2 &lt;&lt; 0)\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usb_req_hosttodev","title":"define USB_REQ_HOSTTODEV","text":"<pre><code>#define USB_REQ_HOSTTODEV (0 &lt;&lt; 7)\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usb_req_interface","title":"define USB_REQ_INTERFACE","text":"<pre><code>#define USB_REQ_INTERFACE (1 &lt;&lt; 0)\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usb_req_other","title":"define USB_REQ_OTHER","text":"<pre><code>#define USB_REQ_OTHER (3 &lt;&lt; 0)\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usb_req_recipient","title":"define USB_REQ_RECIPIENT","text":"<pre><code>#define USB_REQ_RECIPIENT (3 &lt;&lt; 0)\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usb_req_standard","title":"define USB_REQ_STANDARD","text":"<pre><code>#define USB_REQ_STANDARD (0 &lt;&lt; 5)\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usb_req_type","title":"define USB_REQ_TYPE","text":"<pre><code>#define USB_REQ_TYPE (3 &lt;&lt; 5)\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usb_req_vendor","title":"define USB_REQ_VENDOR","text":"<pre><code>#define USB_REQ_VENDOR (2 &lt;&lt; 5)\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usnd_hw_hs","title":"define USND_HW_HS","text":"<pre><code>#define USND_HW_HS (1 &lt;&lt; 2)\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usbd_evt_count","title":"define usbd_evt_count","text":"<pre><code>#define usbd_evt_count 8\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usbd_evt_eprx","title":"define usbd_evt_eprx","text":"<pre><code>#define usbd_evt_eprx 5\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usbd_evt_epsetup","title":"define usbd_evt_epsetup","text":"<pre><code>#define usbd_evt_epsetup 6\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usbd_evt_eptx","title":"define usbd_evt_eptx","text":"<pre><code>#define usbd_evt_eptx 4\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usbd_evt_error","title":"define usbd_evt_error","text":"<pre><code>#define usbd_evt_error 7\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usbd_evt_reset","title":"define usbd_evt_reset","text":"<pre><code>#define usbd_evt_reset 0\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usbd_evt_sof","title":"define usbd_evt_sof","text":"<pre><code>#define usbd_evt_sof 1\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usbd_evt_susp","title":"define usbd_evt_susp","text":"<pre><code>#define usbd_evt_susp 2\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usbd_evt_wkup","title":"define usbd_evt_wkup","text":"<pre><code>#define usbd_evt_wkup 3\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usbd_lane_cdp","title":"define usbd_lane_cdp","text":"<pre><code>#define usbd_lane_cdp 3\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usbd_lane_dcp","title":"define usbd_lane_dcp","text":"<pre><code>#define usbd_lane_dcp 4\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usbd_lane_dsc","title":"define usbd_lane_dsc","text":"<pre><code>#define usbd_lane_dsc 1\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usbd_lane_sdp","title":"define usbd_lane_sdp","text":"<pre><code>#define usbd_lane_sdp 2\n</code></pre>"},{"location":"apiStm/usbd__core_8h/#define-usbd_lane_unk","title":"define usbd_lane_unk","text":"<pre><code>#define usbd_lane_unk 0\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/include/usbd_core.h</code></p>"},{"location":"apiStm/usbd__core_8h_source/","title":"File usbd_core.h","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; lib &gt; libusb_stm32 &gt; include &gt; usbd_core.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* This file is the part of the Lightweight USB device Stack for STM32 microcontrollers\n *\n * Copyright \u00a92016 Dmitry Filimonchuk &lt;dmitrystu[at]gmail[dot]com&gt;\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *   http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n.*/\n\n#ifndef _USBD_CORE_H_\n#define _USBD_CORE_H_\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n\n#if defined(__DOXYGEN__)\n#define USBD_SOF_DISABLED   \n#define USBD_VBUS_DETECT    \n#define USBD_DP_PORT        \n#define USBD_DP_PIN         \n#define USBD_SOF_OUT        \n#define USBD_PRIMARY_OTGHS  \n#define USBD_USE_EXT_ULPI   \n#endif\n\n#define usbd_evt_reset      0   \n#define usbd_evt_sof        1   \n#define usbd_evt_susp       2   \n#define usbd_evt_wkup       3   \n#define usbd_evt_eptx       4   \n#define usbd_evt_eprx       5   \n#define usbd_evt_epsetup    6   \n#define usbd_evt_error      7   \n#define usbd_evt_count      8\n#define usbd_lane_unk       0   \n#define usbd_lane_dsc       1   \n#define usbd_lane_sdp       2   \n#define usbd_lane_cdp       3   \n#define usbd_lane_dcp       4   \n#define USBD_HW_ADDRFST     (1 &lt;&lt; 0)    \n#define USBD_HW_BC          (1 &lt;&lt; 1)    \n#define USND_HW_HS          (1 &lt;&lt; 2)    \n#define USBD_HW_ENABLED     (1 &lt;&lt; 3)    \n#define USBD_HW_ENUMSPEED   (2 &lt;&lt; 4)    \n#define USBD_HW_SPEED_NC    (0 &lt;&lt; 4)    \n#define USBD_HW_SPEED_LS    (1 &lt;&lt; 4)    \n#define USBD_HW_SPEED_FS    (2 &lt;&lt; 4)    \n#define USBD_HW_SPEED_HS    (3 &lt;&lt; 4)    \n#define USB_EPTYPE_DBLBUF   0x04    \n#define USB_REQ_DIRECTION   (1 &lt;&lt; 7)    \n#define USB_REQ_HOSTTODEV   (0 &lt;&lt; 7)    \n#define USB_REQ_DEVTOHOST   (1 &lt;&lt; 7)    \n#define USB_REQ_TYPE        (3 &lt;&lt; 5)    \n#define USB_REQ_STANDARD    (0 &lt;&lt; 5)    \n#define USB_REQ_CLASS       (1 &lt;&lt; 5)    \n#define USB_REQ_VENDOR      (2 &lt;&lt; 5)    \n#define USB_REQ_RECIPIENT   (3 &lt;&lt; 0)    \n#define USB_REQ_DEVICE      (0 &lt;&lt; 0)    \n#define USB_REQ_INTERFACE   (1 &lt;&lt; 0)    \n#define USB_REQ_ENDPOINT    (2 &lt;&lt; 0)    \n#define USB_REQ_OTHER       (3 &lt;&lt; 0)    \n#if !defined(__ASSEMBLER__)\n#include &lt;stdbool.h&gt;\n\nenum usbd_machine_state {\nusbd_state_disabled,\nusbd_state_disconnected,\nusbd_state_default,         usbd_state_addressed,       usbd_state_configured,      };\n\nenum usbd_ctl_state {\nusbd_ctl_idle,              usbd_ctl_rxdata,            usbd_ctl_txdata,            usbd_ctl_ztxdata,           usbd_ctl_lastdata,          usbd_ctl_statusin,          usbd_ctl_statusout,         };\n\ntypedef enum _usbd_respond {\nusbd_fail,                  usbd_ack,                   usbd_nak,                   } usbd_respond;\n\ntypedef struct _usbd_device usbd_device;\n\ntypedef struct {\nuint8_t     bmRequestType;  uint8_t     bRequest;       uint16_t    wValue;         uint16_t    wIndex;         uint16_t    wLength;        uint8_t     data[];         } usbd_ctlreq;\n\ntypedef struct {\nvoid        *data_buf;      void        *data_ptr;      uint16_t    data_count;     uint16_t    data_maxsize;   uint8_t     ep0size;        uint8_t     device_cfg;     uint8_t     device_state;   uint8_t     control_state;  } usbd_status;\n\ntypedef void (*usbd_evt_callback)(usbd_device *dev, uint8_t event, uint8_t ep);\n\ntypedef void (*usbd_rqc_callback)(usbd_device *dev, usbd_ctlreq *req);\n\ntypedef usbd_respond (*usbd_ctl_callback)(usbd_device *dev, usbd_ctlreq *req, usbd_rqc_callback *callback);\n\ntypedef usbd_respond (*usbd_dsc_callback)(usbd_ctlreq *req, void **address, uint16_t *dsize);\n\ntypedef usbd_respond (*usbd_cfg_callback)(usbd_device *dev, uint8_t cfg);\n\ntypedef uint32_t (*usbd_hw_getinfo)(void);\n\ntypedef void (*usbd_hw_enable)(bool enable);\n\ntypedef uint8_t (*usbd_hw_connect)(bool connect);\n\ntypedef void (*usbd_hw_setaddr)(uint8_t address);\n\ntypedef bool (*usbd_hw_ep_config)(uint8_t ep, uint8_t eptype, uint16_t epsize);\n\ntypedef void (*usbd_hw_ep_deconfig)(uint8_t ep);\n\ntypedef int32_t (*usbd_hw_ep_read)(uint8_t ep, void *buf, uint16_t blen);\n\ntypedef int32_t (*usbd_hw_ep_write)(uint8_t ep, void *buf, uint16_t blen);\n\ntypedef void (*usbd_hw_ep_setstall)(uint8_t ep, bool stall);\n\ntypedef bool (*usbd_hw_ep_isstalled)(uint8_t ep);\n\ntypedef void (*usbd_hw_poll)(usbd_device *dev, usbd_evt_callback callback);\n\ntypedef uint16_t (*usbd_hw_get_frameno)(void);\n\n\ntypedef uint16_t (*usbd_hw_get_serialno)(void *buffer);\n\nstruct usbd_driver {\nusbd_hw_getinfo         getinfo;            usbd_hw_enable          enable;             usbd_hw_connect         connect;            usbd_hw_setaddr         setaddr;            usbd_hw_ep_config       ep_config;          usbd_hw_ep_deconfig     ep_deconfig;        usbd_hw_ep_read         ep_read;            usbd_hw_ep_write        ep_write;           usbd_hw_ep_setstall     ep_setstall;        usbd_hw_ep_isstalled    ep_isstalled;       usbd_hw_poll            poll;               usbd_hw_get_frameno     frame_no;           usbd_hw_get_serialno    get_serialno_desc;  };\n\nstruct _usbd_device {\nconst struct usbd_driver    *driver;                usbd_ctl_callback           control_callback;       usbd_rqc_callback           complete_callback;      usbd_cfg_callback           config_callback;        usbd_dsc_callback           descriptor_callback;    usbd_evt_callback           events[usbd_evt_count]; usbd_evt_callback           endpoint[8];            usbd_status                 status;                 };\n\ninline static void usbd_init(usbd_device *dev, const struct usbd_driver *drv,\nconst uint8_t ep0size, uint32_t *buffer, const uint16_t bsize) {\ndev-&gt;driver = drv;\ndev-&gt;status.ep0size = ep0size;\ndev-&gt;status.data_ptr = buffer;\ndev-&gt;status.data_buf = buffer;\ndev-&gt;status.data_maxsize = bsize - __builtin_offsetof(usbd_ctlreq, data);\n}\n\nvoid usbd_poll(usbd_device *dev);\n\ninline static void usbd_reg_control(usbd_device *dev, usbd_ctl_callback callback) {\ndev-&gt;control_callback = callback;\n}\n\ninline static void usbd_reg_config(usbd_device *dev, usbd_cfg_callback callback) {\ndev-&gt;config_callback = callback;\n}\n\ninline static void usbd_reg_descr(usbd_device *dev, usbd_dsc_callback callback) {\ndev-&gt;descriptor_callback = callback;\n}\n\ninline static bool usbd_ep_config(usbd_device *dev, uint8_t ep, uint8_t eptype, uint16_t epsize) {\nreturn dev-&gt;driver-&gt;ep_config(ep, eptype, epsize);\n}\n\ninline static void usbd_ep_deconfig(usbd_device *dev, uint8_t ep) {\ndev-&gt;driver-&gt;ep_deconfig(ep);\n}\n\ninline static void usbd_reg_endpoint(usbd_device *dev, uint8_t ep, usbd_evt_callback callback) {\ndev-&gt;endpoint[ep &amp; 0x07] = callback;\n}\n\ninline static void usbd_reg_event(usbd_device *dev, uint8_t evt, usbd_evt_callback callback) {\ndev-&gt;events[evt] = callback;\n}\n\ninline static int32_t usbd_ep_write(usbd_device *dev, uint8_t ep, void *buf, uint16_t blen) {\nreturn dev-&gt;driver-&gt;ep_write(ep, buf, blen);\n}\n\ninline static int32_t usbd_ep_read(usbd_device *dev, uint8_t ep, void *buf, uint16_t blen) {\nreturn dev-&gt;driver-&gt;ep_read(ep, buf, blen);\n}\n\ninline static void usbd_ep_stall(usbd_device *dev, uint8_t ep) {\ndev-&gt;driver-&gt;ep_setstall(ep, 1);\n}\n\ninline static void usbd_ep_unstall(usbd_device *dev, uint8_t ep) {\ndev-&gt;driver-&gt;ep_setstall(ep, 0);\n}\n\ninline static void usbd_enable(usbd_device *dev, bool enable) {\ndev-&gt;driver-&gt;enable(enable);\n}\n\ninline static uint8_t usbd_connect(usbd_device *dev, bool connect) {\nreturn dev-&gt;driver-&gt;connect(connect);\n}\n\ninline static uint32_t usbd_getinfo(usbd_device *dev) {\nreturn dev-&gt;driver-&gt;getinfo();\n}\n\n#endif //(__ASSEMBLER__)\n#if defined(__cplusplus)\n}\n#endif\n#endif //_USBD_STD_H_\n</code></pre>"},{"location":"apiStm/dir_147e75a9dc3d3a1e76c2365b44d9a832/","title":"Dir fw/rbcx-coprocessor/lib/libusb_stm32/src","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; lib &gt; libusb_stm32 &gt; src</p>"},{"location":"apiStm/dir_147e75a9dc3d3a1e76c2365b44d9a832/#files","title":"Files","text":"Type Name file usbd_core.c file usbd_stm32f103_devfs.c <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/src/</code></p>"},{"location":"apiStm/usbd__core_8c/","title":"File usbd_core.c","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; lib &gt; libusb_stm32 &gt; src &gt; usbd_core.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;stdbool.h&gt;</code></li> <li><code>#include \"usb.h\"</code></li> </ul>"},{"location":"apiStm/usbd__core_8c/#public-functions","title":"Public Functions","text":"Type Name __attribute__ ((externally_visible))"},{"location":"apiStm/usbd__core_8c/#public-static-functions","title":"Public Static Functions","text":"Type Name usbd_respond usbd_configure (usbd_device * dev, uint8_t config) SET_CONFIG request processing. void usbd_process_callback (usbd_device * dev) Control transfer completion callback processing. usbd_respond usbd_process_devrq (usbd_device * dev, usbd_ctlreq * req) Standard control request processing for device. void usbd_process_ep0 (usbd_device * dev, uint8_t event, uint8_t ep) Control endpoint 0 event processing callback. void usbd_process_eprx (usbd_device * dev, uint8_t ep) Control endpoint RX event processing. usbd_respond usbd_process_eptrq (usbd_device * dev, usbd_ctlreq * req) Standard control request processing for endpoint. void usbd_process_eptx (usbd_device * dev, uint8_t ep) Control endpoint TX event processing. void usbd_process_evt (usbd_device * dev, uint8_t evt, uint8_t ep) General event processing callback. usbd_respond usbd_process_intrq (usbd_device * dev, usbd_ctlreq * req) Standard control request processing for interface. usbd_respond usbd_process_request (usbd_device * dev, usbd_ctlreq * req) Processing control request. void usbd_process_reset (usbd_device * dev) Resets USB device state. void usbd_set_address (usbd_device * dev, usbd_ctlreq * req) Callback that sets USB device address. void usbd_stall_pid (usbd_device * dev, uint8_t ep) Control endpoint stall (STALL PID)"},{"location":"apiStm/usbd__core_8c/#macros","title":"Macros","text":"Type Name define _MIN (a, b) ((a) &lt; (b)) ? (a) : (b)"},{"location":"apiStm/usbd__core_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/usbd__core_8c/#function-__attribute__","title":"function __attribute__","text":"<pre><code>__attribute__ (\n(externally_visible)\n) </code></pre>"},{"location":"apiStm/usbd__core_8c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"apiStm/usbd__core_8c/#function-usbd_configure","title":"function usbd_configure","text":"<p>SET_CONFIG request processing. <pre><code>static usbd_respond usbd_configure (\nusbd_device * dev,\nuint8_t config\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> usbd_device </li> <li><code>config</code> config number from request </li> </ul> <p>Returns:</p> <p>usbd_ack if success </p>"},{"location":"apiStm/usbd__core_8c/#function-usbd_process_callback","title":"function usbd_process_callback","text":"<p>Control transfer completion callback processing. <pre><code>static void usbd_process_callback (\nusbd_device * dev\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> pointer to the usb device </li> </ul> <p>Returns:</p> <p>none </p>"},{"location":"apiStm/usbd__core_8c/#function-usbd_process_devrq","title":"function usbd_process_devrq","text":"<p>Standard control request processing for device. <pre><code>static usbd_respond usbd_process_devrq (\nusbd_device * dev,\nusbd_ctlreq * req\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> pointer to usb device </li> <li><code>req</code> pointer to control request </li> </ul> <p>Returns:</p> <p>TRUE if request is handled </p>"},{"location":"apiStm/usbd__core_8c/#function-usbd_process_ep0","title":"function usbd_process_ep0","text":"<p>Control endpoint 0 event processing callback. <pre><code>static void usbd_process_ep0 (\nusbd_device * dev,\nuint8_t event,\nuint8_t ep\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> usb device </li> <li><code>event</code> endpoint event </li> </ul>"},{"location":"apiStm/usbd__core_8c/#function-usbd_process_eprx","title":"function usbd_process_eprx","text":"<p>Control endpoint RX event processing. <pre><code>static void usbd_process_eprx (\nusbd_device * dev,\nuint8_t ep\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> pointer to usb device </li> <li><code>ep</code> endpoint number </li> </ul>"},{"location":"apiStm/usbd__core_8c/#function-usbd_process_eptrq","title":"function usbd_process_eptrq","text":"<p>Standard control request processing for endpoint. <pre><code>static usbd_respond usbd_process_eptrq (\nusbd_device * dev,\nusbd_ctlreq * req\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> pointer to usb device </li> <li><code>req</code> pointer to control request </li> </ul> <p>Returns:</p> <p>TRUE if request is handled </p>"},{"location":"apiStm/usbd__core_8c/#function-usbd_process_eptx","title":"function usbd_process_eptx","text":"<p>Control endpoint TX event processing. <pre><code>static void usbd_process_eptx (\nusbd_device * dev,\nuint8_t ep\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> pointer to usb device </li> <li><code>ep</code> endpoint number </li> </ul>"},{"location":"apiStm/usbd__core_8c/#function-usbd_process_evt","title":"function usbd_process_evt","text":"<p>General event processing callback. <pre><code>static void usbd_process_evt (\nusbd_device * dev,\nuint8_t evt,\nuint8_t ep\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> usb device </li> <li><code>evt</code> usb event </li> <li><code>ep</code> active endpoint </li> </ul>"},{"location":"apiStm/usbd__core_8c/#function-usbd_process_intrq","title":"function usbd_process_intrq","text":"<p>Standard control request processing for interface. <pre><code>static usbd_respond usbd_process_intrq (\nusbd_device * dev,\nusbd_ctlreq * req\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> pointer to usb device </li> <li><code>req</code> pointer to control request </li> </ul> <p>Returns:</p> <p>TRUE if request is handled </p>"},{"location":"apiStm/usbd__core_8c/#function-usbd_process_request","title":"function usbd_process_request","text":"<p>Processing control request. <pre><code>static usbd_respond usbd_process_request (\nusbd_device * dev,\nusbd_ctlreq * req\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> pointer to usb device </li> <li><code>req</code> pointer to usb control request </li> </ul> <p>Returns:</p> <p>TRUE if request is handled </p>"},{"location":"apiStm/usbd__core_8c/#function-usbd_process_reset","title":"function usbd_process_reset","text":"<p>Resets USB device state. <pre><code>static void usbd_process_reset (\nusbd_device * dev\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> pointer to usb device </li> </ul> <p>Returns:</p> <p>none </p>"},{"location":"apiStm/usbd__core_8c/#function-usbd_set_address","title":"function usbd_set_address","text":"<p>Callback that sets USB device address. <pre><code>static void usbd_set_address (\nusbd_device * dev,\nusbd_ctlreq * req\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> pointer to usb device </li> <li><code>req</code> pointer to usb control request data </li> </ul> <p>Returns:</p> <p>none </p>"},{"location":"apiStm/usbd__core_8c/#function-usbd_stall_pid","title":"function usbd_stall_pid","text":"<p>Control endpoint stall (STALL PID) <pre><code>static void usbd_stall_pid (\nusbd_device * dev,\nuint8_t ep\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> pointer to usb device </li> <li><code>ep</code> endpoint number </li> </ul>"},{"location":"apiStm/usbd__core_8c/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/usbd__core_8c/#define-_min","title":"define _MIN","text":"<pre><code>#define _MIN (\na,\nb\n) ((a) &lt; (b)) ? (a) : (b)\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/src/usbd_core.c</code></p>"},{"location":"apiStm/usbd__core_8c_source/","title":"File usbd_core.c","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; lib &gt; libusb_stm32 &gt; src &gt; usbd_core.c</p> <p>Go to the documentation of this file. </p> <pre><code>/* This file is the part of the Lightweight USB device Stack for STM32 microcontrollers\n *\n * Copyright \u00a92016 Dmitry Filimonchuk &lt;dmitrystu[at]gmail[dot]com&gt;\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *   http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include &lt;stdint.h&gt;\n#include &lt;stdbool.h&gt;\n#include \"usb.h\"\n\n#define _MIN(a, b) ((a) &lt; (b)) ? (a) : (b)\n\nstatic void usbd_process_ep0 (usbd_device *dev, uint8_t event, uint8_t ep);\n\nstatic void usbd_process_reset(usbd_device *dev) {\ndev-&gt;status.device_state = usbd_state_default;\ndev-&gt;status.control_state = usbd_ctl_idle;\ndev-&gt;status.device_cfg = 0;\ndev-&gt;driver-&gt;ep_config(0, USB_EPTYPE_CONTROL, dev-&gt;status.ep0size);\ndev-&gt;endpoint[0] = usbd_process_ep0;\ndev-&gt;driver-&gt;setaddr(0);\n}\n\nstatic void usbd_set_address (usbd_device *dev, usbd_ctlreq *req) {\ndev-&gt;driver-&gt;setaddr(req-&gt;wValue);\ndev-&gt;status.device_state = (req-&gt;wValue) ? usbd_state_addressed : usbd_state_default;\n}\n\nstatic void usbd_process_callback (usbd_device *dev) {\nif (dev-&gt;complete_callback) {\ndev-&gt;complete_callback(dev, dev-&gt;status.data_buf);\ndev-&gt;complete_callback = 0;\n}\n}\n\nstatic usbd_respond usbd_configure(usbd_device *dev, uint8_t config) {\nif (dev-&gt;config_callback) {\nif (dev-&gt;config_callback(dev, config) == usbd_ack) {\ndev-&gt;status.device_cfg = config;\ndev-&gt;status.device_state = (config) ? usbd_state_configured : usbd_state_addressed;\nreturn usbd_ack;\n}\n}\nreturn usbd_fail;\n}\n\n\nstatic usbd_respond usbd_process_devrq (usbd_device *dev, usbd_ctlreq *req) {\nswitch (req-&gt;bRequest) {\ncase USB_STD_CLEAR_FEATURE:\n/* not yet supported */\nbreak;\ncase USB_STD_GET_CONFIG:\nreq-&gt;data[0] = dev-&gt;status.device_cfg;\nreturn usbd_ack;\ncase USB_STD_GET_DESCRIPTOR:\nif (req-&gt;wValue == ((USB_DTYPE_STRING &lt;&lt; 8) | INTSERIALNO_DESCRIPTOR )) {\ndev-&gt;status.data_count = dev-&gt;driver-&gt;get_serialno_desc(req-&gt;data);\nreturn usbd_ack;\n} else {\nif (dev-&gt;descriptor_callback) {\nreturn dev-&gt;descriptor_callback(req, &amp;(dev-&gt;status.data_ptr), &amp;(dev-&gt;status.data_count));\n}\n}\nbreak;\ncase USB_STD_GET_STATUS:\nreq-&gt;data[0] = 0;\nreq-&gt;data[1] = 0;\nreturn usbd_ack;\ncase USB_STD_SET_ADDRESS:\nif (usbd_getinfo(dev) &amp; USBD_HW_ADDRFST) {\nusbd_set_address(dev, req);\n} else {\ndev-&gt;complete_callback = usbd_set_address;\n}\nreturn usbd_ack;\ncase USB_STD_SET_CONFIG:\nreturn usbd_configure(dev, req-&gt;wValue);\ncase USB_STD_SET_DESCRIPTOR:\n/* should be externally handled */\nbreak;\ncase USB_STD_SET_FEATURE:\n/* not yet supported */\nbreak;\ndefault:\nbreak;\n}\nreturn usbd_fail;\n}\n\nstatic usbd_respond usbd_process_intrq(usbd_device *dev, usbd_ctlreq *req) {\n(void)dev;\nswitch (req-&gt;bRequest) {\ncase USB_STD_GET_STATUS:\nreq-&gt;data[0] = 0;\nreq-&gt;data[1] = 0;\nreturn usbd_ack;\ndefault:\nbreak;\n}\nreturn usbd_fail;\n}\n\nstatic usbd_respond usbd_process_eptrq(usbd_device *dev, usbd_ctlreq *req) {\nswitch (req-&gt;bRequest) {\ncase USB_STD_SET_FEATURE:\ndev-&gt;driver-&gt;ep_setstall(req-&gt;wIndex, 1);\nreturn usbd_ack;\ncase USB_STD_CLEAR_FEATURE:\ndev-&gt;driver-&gt;ep_setstall(req-&gt;wIndex, 0);\nreturn usbd_ack;\ncase USB_STD_GET_STATUS:\nreq-&gt;data[0] = dev-&gt;driver-&gt;ep_isstalled(req-&gt;wIndex) ? 1 : 0;\nreq-&gt;data[1] = 0;\nreturn usbd_ack;\ndefault:\nbreak;\n}\nreturn usbd_fail;\n}\n\nstatic usbd_respond usbd_process_request(usbd_device *dev, usbd_ctlreq *req) {\n/* processing control request by callback */\nif (dev-&gt;control_callback) {\nusbd_respond r = dev-&gt;control_callback(dev, req, &amp;(dev-&gt;complete_callback));\nif (r != usbd_fail) return r;\n}\n/* continuing standard USB requests */\nswitch (req-&gt;bmRequestType &amp; (USB_REQ_TYPE | USB_REQ_RECIPIENT)) {\ncase USB_REQ_STANDARD | USB_REQ_DEVICE:\nreturn usbd_process_devrq(dev, req);\ncase USB_REQ_STANDARD | USB_REQ_INTERFACE:\nreturn usbd_process_intrq(dev, req);\ncase USB_REQ_STANDARD | USB_REQ_ENDPOINT:\nreturn usbd_process_eptrq(dev, req);\ndefault:\nbreak;\n}\nreturn usbd_fail;\n}\n\n\nstatic void usbd_stall_pid(usbd_device *dev, uint8_t ep) {\ndev-&gt;driver-&gt;ep_setstall(ep &amp; 0x7F, 1);\ndev-&gt;driver-&gt;ep_setstall(ep | 0x80, 1);\ndev-&gt;status.control_state = usbd_ctl_idle;\n}\n\n\nstatic void usbd_process_eptx(usbd_device *dev, uint8_t ep) {\nint32_t _t;\nswitch (dev-&gt;status.control_state) {\ncase usbd_ctl_ztxdata:\ncase usbd_ctl_txdata:\n_t = _MIN(dev-&gt;status.data_count, dev-&gt;status.ep0size);\ndev-&gt;driver-&gt;ep_write(ep, dev-&gt;status.data_ptr, _t);\ndev-&gt;status.data_ptr += _t;\ndev-&gt;status.data_count -= _t;\n/* if all data is not sent */\nif (0 != dev-&gt;status.data_count) break;\n/* if last packet has a EP0 size and host awaiting for the more data ZLP should be sent*/\n/* if ZLP required, control state will be unchanged, therefore next TX event sends ZLP */\nif ( usbd_ctl_txdata == dev-&gt;status.control_state || _t != dev-&gt;status.ep0size ) {\ndev-&gt;status.control_state = usbd_ctl_lastdata; /* no ZLP required */\n}\nbreak;\ncase usbd_ctl_lastdata:\ndev-&gt;status.control_state = usbd_ctl_statusout;\nbreak;\ncase usbd_ctl_statusin:\ndev-&gt;status.control_state = usbd_ctl_idle;\nreturn usbd_process_callback(dev);\ndefault:\n/* unexpected TX completion */\n/* just skipping it */\nbreak;\n}\n}\n\nstatic void usbd_process_eprx(usbd_device *dev, uint8_t ep) {\nuint16_t _t;\nusbd_ctlreq *const req = dev-&gt;status.data_buf;\nswitch (dev-&gt;status.control_state) {\ncase usbd_ctl_idle:\n/* read SETUP packet, send STALL_PID if incorrect packet length */\nif (0x08 !=  dev-&gt;driver-&gt;ep_read(ep, req, dev-&gt;status.data_maxsize)) {\nreturn usbd_stall_pid(dev, ep);\n}\ndev-&gt;status.data_ptr = req-&gt;data;\ndev-&gt;status.data_count = req-&gt;wLength;\n/* processing request with no payload data*/\nif ((req-&gt;bmRequestType &amp; USB_REQ_DEVTOHOST) || (0 == req-&gt;wLength)) break;\n/* checking available memory for DATA OUT stage */\nif (req-&gt;wLength &gt; dev-&gt;status.data_maxsize) {\nreturn usbd_stall_pid(dev, ep);\n}\n/* continue DATA OUT stage */\ndev-&gt;status.control_state = usbd_ctl_rxdata;\nreturn;\ncase usbd_ctl_rxdata:\n/*receive DATA OUT packet(s) */\n_t = dev-&gt;driver-&gt;ep_read(ep, dev-&gt;status.data_ptr, dev-&gt;status.data_count);\nif (dev-&gt;status.data_count &lt; _t) {\n/* if received packet is large than expected */\n/* Must be error. Let's drop this request */\nreturn usbd_stall_pid(dev, ep);\n} else if (dev-&gt;status.data_count != _t) {\n/* if all data payload was not received yet */\ndev-&gt;status.data_count -= _t;\ndev-&gt;status.data_ptr += _t;\nreturn;\n}\nbreak;\ncase usbd_ctl_statusout:\n/* fake reading STATUS OUT */\ndev-&gt;driver-&gt;ep_read(ep, 0, 0);\ndev-&gt;status.control_state = usbd_ctl_idle;\nreturn usbd_process_callback(dev);\ndefault:\n/* unexpected RX packet */\nreturn usbd_stall_pid(dev, ep);\n}\n/* usb request received. let's handle it */\ndev-&gt;status.data_ptr = req-&gt;data;\ndev-&gt;status.data_count = /*req-&gt;wLength;*/dev-&gt;status.data_maxsize;\nswitch (usbd_process_request(dev, req)) {\ncase usbd_ack:\nif (req-&gt;bmRequestType &amp; USB_REQ_DEVTOHOST) {\n/* return data from function */\nif (dev-&gt;status.data_count &gt;= req-&gt;wLength) {\ndev-&gt;status.data_count = req-&gt;wLength;\ndev-&gt;status.control_state = usbd_ctl_txdata;\n} else {\n/* DATA IN packet smaller than requested */\n/* ZLP maybe wanted */\ndev-&gt;status.control_state = usbd_ctl_ztxdata;\n}\nreturn usbd_process_eptx(dev, ep | 0x80);\n\n} else {\n/* confirming by ZLP in STATUS_IN stage */\ndev-&gt;driver-&gt;ep_write(ep | 0x80, 0, 0);\ndev-&gt;status.control_state = usbd_ctl_statusin;\n}\nbreak;\ncase usbd_nak:\ndev-&gt;status.control_state = usbd_ctl_statusin;\nbreak;\ndefault:\nreturn usbd_stall_pid(dev, ep);\n}\n}\n\nstatic void usbd_process_ep0 (usbd_device *dev, uint8_t event, uint8_t ep) {\nswitch (event) {\ncase usbd_evt_epsetup:\n/* force switch to setup state */\ndev-&gt;status.control_state = usbd_ctl_idle;\ndev-&gt;complete_callback = 0;\ncase usbd_evt_eprx:\nreturn usbd_process_eprx(dev, ep);\ncase usbd_evt_eptx:\nreturn usbd_process_eptx(dev, ep);\ndefault:\nbreak;\n}\n}\n\n\nstatic void usbd_process_evt(usbd_device *dev, uint8_t evt, uint8_t ep) {\nswitch (evt) {\ncase usbd_evt_reset:\nusbd_process_reset(dev);\nbreak;\ncase usbd_evt_eprx:\ncase usbd_evt_eptx:\ncase usbd_evt_epsetup:\nif (dev-&gt;endpoint[ep &amp; 0x07]) dev-&gt;endpoint[ep &amp; 0x07](dev, evt, ep);\nbreak;\ndefault:\nbreak;\n}\nif (dev-&gt;events[evt]) dev-&gt;events[evt](dev, evt, ep);\n}\n\n__attribute__((externally_visible)) void usbd_poll(usbd_device *dev) {\nreturn dev-&gt;driver-&gt;poll(dev, usbd_process_evt);\n}\n</code></pre>"},{"location":"apiStm/usbd__stm32f103__devfs_8c/","title":"File usbd_stm32f103_devfs.c","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; lib &gt; libusb_stm32 &gt; src &gt; usbd_stm32f103_devfs.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;stdbool.h&gt;</code></li> <li><code>#include \"stm32.h\"</code></li> <li><code>#include \"usb.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/lib/libusb_stm32/src/usbd_stm32f103_devfs.c</code></p>"},{"location":"apiStm/usbd__stm32f103__devfs_8c_source/","title":"File usbd_stm32f103_devfs.c","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; lib &gt; libusb_stm32 &gt; src &gt; usbd_stm32f103_devfs.c</p> <p>Go to the documentation of this file. </p> <pre><code>/* This file is the part of the Lightweight USB device Stack for STM32 microcontrollers\n *\n * Copyright \u00a92016 Dmitry Filimonchuk &lt;dmitrystu[at]gmail[dot]com&gt;\n * Copyright \u00a92017 Max Chan &lt;max[at]maxchan[dot]info&gt;\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *   http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include &lt;stdint.h&gt;\n#include &lt;stdbool.h&gt;\n#include \"stm32.h\"\n#include \"usb.h\"\n\n#if defined(USBD_STM32F103)\n\n#define USB_EP_SWBUF_TX     USB_EP_DTOG_RX\n#define USB_EP_SWBUF_RX     USB_EP_DTOG_TX\n\n#define EP_TOGGLE_SET(epr, bits, mask) *(epr) = (*(epr) ^ (bits)) &amp; (USB_EPREG_MASK | (mask))\n\n#define EP_TX_STALL(epr)    EP_TOGGLE_SET((epr), USB_EP_TX_STALL,                   USB_EPTX_STAT)\n#define EP_RX_STALL(epr)    EP_TOGGLE_SET((epr), USB_EP_RX_STALL,                   USB_EPRX_STAT)\n#define EP_TX_UNSTALL(epr)  EP_TOGGLE_SET((epr), USB_EP_TX_NAK,                     USB_EPTX_STAT | USB_EP_DTOG_TX)\n#define EP_RX_UNSTALL(epr)  EP_TOGGLE_SET((epr), USB_EP_RX_VALID,                   USB_EPRX_STAT | USB_EP_DTOG_RX)\n#define EP_DTX_UNSTALL(epr) EP_TOGGLE_SET((epr), USB_EP_TX_VALID,                   USB_EPTX_STAT | USB_EP_DTOG_TX | USB_EP_SWBUF_TX)\n#define EP_DRX_UNSTALL(epr) EP_TOGGLE_SET((epr), USB_EP_RX_VALID | USB_EP_SWBUF_RX, USB_EPRX_STAT | USB_EP_DTOG_RX | USB_EP_SWBUF_RX)\n#define EP_TX_VALID(epr)    EP_TOGGLE_SET((epr), USB_EP_TX_VALID,                   USB_EPTX_STAT)\n#define EP_RX_VALID(epr)    EP_TOGGLE_SET((epr), USB_EP_RX_VALID,                   USB_EPRX_STAT)\n\n#define STATUS_VAL(x)       (x)\n\ntypedef union _pma_table pma_table;\n\n#if defined(STM32F302x8) || defined(STM32F302xE) || defined(STM32F303xE)\n#if !defined(USB_PMASIZE)\n#warning PMA memory size is not defined. Use 768 bytes by default\n#define USB_PMASIZE 0x300\n#endif\n#define PMA_STEP    1\n\ntypedef struct {\nuint16_t    addr;\nuint16_t    cnt;\n} pma_rec;\n\ninline static pma_table *EPT(uint8_t ep) {\nreturn (pma_table*)((ep &amp; 0x07) * 8 + USB_PMAADDR);\n}\n\ninline static uint16_t *PMA(uint16_t addr) {\nreturn (uint16_t*)(USB_PMAADDR + addr);\n}\n\n#else\n#if !defined(USB_PMASIZE)\n#warning PMA memory size is not defined. Use 512 bytes by default\n#define USB_PMASIZE 0x200\n#endif\n#define PMA_STEP    2\n\ntypedef struct {\nuint16_t    addr;\nuint16_t    :16;\nuint16_t    cnt;\nuint16_t    :16;\n} pma_rec;\n\ninline static pma_table *EPT(uint8_t ep) {\nreturn (pma_table*)((ep &amp; 0x07) * 16 + USB_PMAADDR);\n}\n\ninline static uint16_t *PMA(uint16_t addr) {\nreturn (uint16_t*)(USB_PMAADDR + 2 * addr);\n}\n#endif\n\nunion _pma_table {\nstruct {\npma_rec     tx;\npma_rec     rx;\n};\nstruct {\npma_rec     tx0;\npma_rec     tx1;\n};\nstruct {\npma_rec     rx0;\npma_rec     rx1;\n};\n};\n\ninline static void set_gpiox() {\n#if defined(STM32F1) &amp;&amp; defined(USBD_DP_PORT)\nif (USBD_DP_PORT == GPIOA) {RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPAEN; return;}\nif (USBD_DP_PORT == GPIOB) {RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPBEN; return;}\nif (USBD_DP_PORT == GPIOC) {RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPCEN; return;}\nif (USBD_DP_PORT == GPIOD) {RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPDEN; return;}\n#if defined(GPIOE)\nif (USBD_DP_PORT == GPIOE) {RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPEEN; return;}\n#endif\n#if defined(GPIOF)\nif (USBD_DP_PORT == GPIOF) {RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPFEN; return;}\n#endif\n#elif defined(STM32F3) &amp;&amp; defined(USBD_DP_PORT)\nif (USBD_DP_PORT == GPIOA) {RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN; return;}\nif (USBD_DP_PORT == GPIOB) {RCC-&gt;AHBENR |= RCC_AHBENR_GPIOBEN; return;}\nif (USBD_DP_PORT == GPIOC) {RCC-&gt;AHBENR |= RCC_AHBENR_GPIOCEN; return;}\nif (USBD_DP_PORT == GPIOD) {RCC-&gt;AHBENR |= RCC_AHBENR_GPIODEN; return;}\n#if defined(GPIOE)\nif (USBD_DP_PORT == GPIOE) {RCC-&gt;AHBENR |= RCC_AHBENR_GPIOEEN; return;}\n#endif\n#if defined(GPIOF)\nif (USBD_DP_PORT == GPIOF) {RCC-&gt;AHBENR |= RCC_AHBENR_GPIOFEN; return;}\n#endif\n#if defined(GPIOG)\nif (USBD_DP_PORT == GPIOG) {RCC-&gt;AHBENR |= RCC_AHBENR_GPIOGEN; return;}\n#endif\n#if defined(GPIOH)\nif (USBD_DP_PORT == GPIOH) {RCC-&gt;AHBENR |= RCC_AHBENR_GPIOHEN; return;}\n#endif\n#endif\nreturn;\n}\n\ninline static volatile uint16_t *EPR(uint8_t ep) {\nreturn (uint16_t*)((ep &amp; 0x07) * 4 + USB_BASE);\n}\n\nstatic uint16_t get_next_pma(uint16_t sz) {\nunsigned _result = USB_PMASIZE;\nfor (int i = 0; i &lt; 8; i++) {\npma_table *tbl = EPT(i);\nif ((tbl-&gt;tx.addr) &amp;&amp; (tbl-&gt;tx.addr &lt; _result)) _result = tbl-&gt;tx.addr;\nif ((tbl-&gt;rx.addr) &amp;&amp; (tbl-&gt;rx.addr &lt; _result)) _result = tbl-&gt;rx.addr;\n}\nreturn (_result &lt; (0x020 + sz)) ? 0 : (_result - sz);\n}\n\nuint32_t getinfo(void) {\nif (!(RCC-&gt;APB1ENR &amp; RCC_APB1ENR_USBEN)) return STATUS_VAL(0);\n#if defined(USBD_DP_PORT) &amp;&amp; defined(USBD_DP_PIN)\nif (USBD_DP_PORT-&gt;IDR &amp; _BV(USBD_DP_PIN)) return STATUS_VAL(USBD_HW_ENABLED | USBD_HW_SPEED_FS);\nreturn STATUS_VAL(USBD_HW_ENABLED);\n#else\nreturn STATUS_VAL(USBD_HW_ENABLED | USBD_HW_SPEED_FS);\n#endif\n}\n\nvoid ep_setstall(uint8_t ep, bool stall) {\nvolatile uint16_t *reg = EPR(ep);\n/* ISOCHRONOUS endpoint can't be stalled or unstalled */\nif (USB_EP_ISOCHRONOUS == (*reg &amp; USB_EP_T_FIELD)) return;\n/* If it's an IN endpoint */\nif (ep &amp; 0x80) {\n/* DISABLED endpoint can't be stalled or unstalled */\nif (USB_EP_TX_DIS == (*reg &amp; USB_EPTX_STAT)) return;\nif (stall) {\nEP_TX_STALL(reg);\n} else {\n/* if it's a doublebuffered endpoint */\nif ((USB_EP_KIND | USB_EP_BULK) == (*reg &amp; (USB_EP_T_FIELD | USB_EP_KIND))) {\n/* set endpoint to VALID and clear DTOG_TX &amp; SWBUF_TX */\nEP_DTX_UNSTALL(reg);\n} else {\n/* set endpoint to NAKED and clear DTOG_TX */\nEP_TX_UNSTALL(reg);\n}\n}\n} else {\nif (USB_EP_RX_DIS == (*reg &amp; USB_EPRX_STAT)) return;\nif (stall) {\nEP_RX_STALL(reg);\n} else {\n/* if it's a doublebuffered endpoint */\nif ((USB_EP_KIND | USB_EP_BULK) == (*reg &amp; (USB_EP_T_FIELD | USB_EP_KIND))) {\n/* set endpoint to VALID, clear DTOG_RX, set SWBUF_RX */\nEP_DRX_UNSTALL(reg);\n} else {\n/* set endpoint to VALID and clear DTOG_RX */\nEP_RX_UNSTALL(reg);\n}\n}\n}\n}\n\nbool ep_isstalled(uint8_t ep) {\nif (ep &amp; 0x80) {\nreturn (USB_EP_TX_STALL == (USB_EPTX_STAT &amp; *EPR(ep)));\n} else {\nreturn (USB_EP_RX_STALL == (USB_EPRX_STAT &amp; *EPR(ep)));\n}\n}\n\nuint8_t connect(bool connect) {\n#if defined(USBD_DP_PORT) &amp;&amp; defined(USBD_DP_PIN) &amp;&amp; defined(STM32F3)\nuint32_t _t = USBD_DP_PORT-&gt;MODER &amp; ~(0x03 &lt;&lt; (2 * USBD_DP_PIN));\nif (connect) {\n_t |= (0x01 &lt;&lt; (2 * USBD_DP_PIN));\nUSBD_DP_PORT-&gt;BSRR = (0x0001 &lt;&lt; USBD_DP_PIN);\n}\nUSBD_DP_PORT-&gt;MODER = _t;\n#elif defined(USBD_DP_PORT) &amp;&amp; defined(USBD_DP_PIN) &amp;&amp; defined(STM32F1)\n#if (USBD_DP_PIN &lt; 8)\nuint32_t _t = USBD_DP_PORT-&gt;CRL &amp; ~(0x0F &lt;&lt; (4 * USBD_DP_PIN));\nif (connect) {\n_t |= (0x02 &lt;&lt; (4 * USBD_DP_PIN));\nUSBD_DP_PORT-&gt;BSRR = (0x0001 &lt;&lt; USBD_DP_PIN);\n} else {\n_t |= (0x04 &lt;&lt; (4 * USBD_DP_PIN));\n}\nUSBD_DP_PORT-&gt;CRL = _t;\n#else\nuint32_t _t = USBD_DP_PORT-&gt;CRH &amp; ~(0x0F &lt;&lt; (4 * (USBD_DP_PIN - 8)));\nif (connect) {\n_t |= (0x02 &lt;&lt; (4 * (USBD_DP_PIN - 8)));\nUSBD_DP_PORT-&gt;BSRR = (0x0001 &lt;&lt; USBD_DP_PIN);\n} else {\n_t |= (0x04 &lt;&lt; (4 * (USBD_DP_PIN - 8)));\n}\nUSBD_DP_PORT-&gt;CRH = _t;\n#endif\n#endif\nreturn usbd_lane_unk;\n}\n\nvoid enable(bool enable) {\nif (enable) {\nset_gpiox();\nRCC-&gt;APB1ENR  |= RCC_APB1ENR_USBEN;\nRCC-&gt;APB1RSTR |= RCC_APB1RSTR_USBRST;\nRCC-&gt;APB1RSTR &amp;= ~RCC_APB1RSTR_USBRST;\nUSB-&gt;CNTR = USB_CNTR_CTRM | USB_CNTR_RESETM | USB_CNTR_ERRM |\n#if !defined(USBD_SOF_DISABLED)\nUSB_CNTR_SOFM |\n#endif\nUSB_CNTR_SUSPM | USB_CNTR_WKUPM;\n} else if (RCC-&gt;APB1ENR &amp; RCC_APB1ENR_USBEN) {\nRCC-&gt;APB1RSTR |= RCC_APB1RSTR_USBRST;\nRCC-&gt;APB1ENR &amp;= ~RCC_APB1ENR_USBEN;\n/* disconnecting DP if configured */\nconnect(0);\n}\n}\n\nvoid setaddr (uint8_t addr) {\nUSB-&gt;DADDR = USB_DADDR_EF | addr;\n}\n\nbool ep_config(uint8_t ep, uint8_t eptype, uint16_t epsize) {\nvolatile uint16_t *reg = EPR(ep);\npma_table *tbl = EPT(ep);\n/* epsize should be 16-bit aligned */\nif (epsize &amp; 0x01) epsize++;\n\nswitch (eptype) {\ncase USB_EPTYPE_CONTROL:\n*reg = USB_EP_CONTROL | (ep &amp; 0x07);\nbreak;\ncase USB_EPTYPE_ISOCHRONUS:\n*reg = USB_EP_ISOCHRONOUS | (ep &amp; 0x07);\nbreak;\ncase USB_EPTYPE_BULK:\n*reg = USB_EP_BULK | (ep &amp; 0x07);\nbreak;\ncase USB_EPTYPE_BULK | USB_EPTYPE_DBLBUF:\n*reg = USB_EP_BULK | USB_EP_KIND | (ep &amp; 0x07);\nbreak;\ndefault:\n*reg = USB_EP_INTERRUPT | (ep &amp; 0x07);\nbreak;\n}\n/* if it TX or CONTROL endpoint */\nif ((ep &amp; 0x80) || (eptype == USB_EPTYPE_CONTROL)) {\nuint16_t _pma;\n_pma = get_next_pma(epsize);\nif (_pma == 0) return false;\ntbl-&gt;tx.addr = _pma;\ntbl-&gt;tx.cnt  = 0;\nif ((eptype == USB_EPTYPE_ISOCHRONUS) ||\n(eptype == (USB_EPTYPE_BULK | USB_EPTYPE_DBLBUF))) {\n_pma = get_next_pma(epsize);\nif (_pma == 0) return false;\ntbl-&gt;tx1.addr = _pma;\ntbl-&gt;tx1.cnt  = 0;\nEP_DTX_UNSTALL(reg);\n} else {\nEP_TX_UNSTALL(reg);\n}\n}\nif (!(ep &amp; 0x80)) {\nuint16_t _rxcnt;\nuint16_t _pma;\nif (epsize &gt; 62) {\nif (epsize &amp; 0x1F) {\nepsize &amp;= ~0x1F;\nepsize += 0x20;\n}\n_rxcnt = 0x8000 - 0x20 + (epsize &lt;&lt; 5);\n} else {\n_rxcnt = epsize &lt;&lt; 9;\n}\n_pma = get_next_pma(epsize);\nif (_pma == 0) return false;\ntbl-&gt;rx.addr = _pma;\ntbl-&gt;rx.cnt  = _rxcnt;\nif ((eptype == USB_EPTYPE_ISOCHRONUS) ||\n(eptype == (USB_EPTYPE_BULK | USB_EPTYPE_DBLBUF))) {\n_pma = get_next_pma(epsize);\nif (_pma == 0) return false;\ntbl-&gt;rx0.addr = _pma;\ntbl-&gt;rx0.cnt  = _rxcnt;\nEP_DRX_UNSTALL(reg);\n} else {\nEP_RX_UNSTALL(reg);\n}\n}\nreturn true;\n}\n\nvoid ep_deconfig(uint8_t ep) {\npma_table *ept = EPT(ep);\n*EPR(ep) &amp;= ~USB_EPREG_MASK;\nept-&gt;rx.addr = 0;\nept-&gt;rx.cnt  = 0;\nept-&gt;tx.addr = 0;\nept-&gt;tx.cnt  = 0;\n}\n\nstatic uint16_t pma_read (uint8_t *buf, uint16_t blen, pma_rec *rx) {\nuint16_t *pma = PMA(rx-&gt;addr);\nuint16_t rxcnt = rx-&gt;cnt &amp; 0x03FF;\nrx-&gt;cnt &amp;= ~0x3FF;\nif (blen &gt; rxcnt) {\nblen = rxcnt;\n}\nrxcnt = blen;\nwhile (blen) {\nuint16_t _t = *pma;\n*buf++ = _t &amp; 0xFF;\nif (--blen) {\n*buf++ = _t &gt;&gt; 8;\npma += PMA_STEP;\nblen--;\n} else break;\n}\nreturn rxcnt;\n}\n\nint32_t ep_read(uint8_t ep, void *buf, uint16_t blen) {\npma_table *tbl = EPT(ep);\nvolatile uint16_t *reg = EPR(ep);\nswitch (*reg &amp; (USB_EPRX_STAT | USB_EP_T_FIELD | USB_EP_KIND)) {\n/* doublebuffered bulk endpoint */\ncase (USB_EP_RX_VALID | USB_EP_BULK | USB_EP_KIND):\n/* switching SWBUF if EP is NAKED */\nswitch (*reg &amp; (USB_EP_DTOG_RX | USB_EP_SWBUF_RX)) {\ncase 0:\ncase (USB_EP_DTOG_RX | USB_EP_SWBUF_RX):\n*reg = (*reg &amp; USB_EPREG_MASK) | USB_EP_SWBUF_RX;\nbreak;\ndefault:\nbreak;\n}\nif (*reg &amp; USB_EP_SWBUF_RX) {\nreturn pma_read(buf, blen, &amp;(tbl-&gt;rx1));\n} else {\nreturn pma_read(buf, blen, &amp;(tbl-&gt;rx0));\n}\n/* isochronous endpoint */\ncase (USB_EP_RX_VALID | USB_EP_ISOCHRONOUS):\nif (*reg &amp; USB_EP_DTOG_RX) {\nreturn pma_read(buf, blen, &amp;(tbl-&gt;rx1));\n} else {\nreturn pma_read(buf, blen, &amp;(tbl-&gt;rx0));\n}\n/* regular endpoint */\ncase (USB_EP_RX_NAK | USB_EP_BULK):\ncase (USB_EP_RX_NAK | USB_EP_CONTROL):\ncase (USB_EP_RX_NAK | USB_EP_INTERRUPT):\n{\nint32_t res = pma_read(buf, blen, &amp;(tbl-&gt;rx));\n/* setting endpoint to VALID state */\nEP_RX_VALID(reg);\nreturn res;\n}\n/* invalid or not ready */\ndefault:\nreturn -1;\n}\n}\n\nstatic void pma_write(const uint8_t *buf, uint16_t blen, pma_rec *tx) {\nuint16_t *pma = PMA(tx-&gt;addr);\ntx-&gt;cnt = blen;\nwhile (blen &gt; 1) {\n*pma = buf[1] &lt;&lt; 8 | buf[0];\npma += PMA_STEP;\nbuf += 2;\nblen -= 2;\n}\nif (blen) *pma = *buf;\n}\n\nint32_t ep_write(uint8_t ep, void *buf, uint16_t blen) {\npma_table *tbl = EPT(ep);\nvolatile uint16_t *reg = EPR(ep);\nswitch (*reg &amp; (USB_EPTX_STAT | USB_EP_T_FIELD | USB_EP_KIND)) {\n/* doublebuffered bulk endpoint */\ncase (USB_EP_TX_NAK   | USB_EP_BULK | USB_EP_KIND):\nif (*reg &amp; USB_EP_SWBUF_TX) {\npma_write(buf, blen, &amp;(tbl-&gt;tx1));\n} else {\npma_write(buf, blen, &amp;(tbl-&gt;tx0));\n}\n*reg = (*reg &amp; USB_EPREG_MASK) | USB_EP_SWBUF_TX;\nbreak;\n/* isochronous endpoint */\ncase (USB_EP_TX_VALID | USB_EP_ISOCHRONOUS):\nif (!(*reg &amp; USB_EP_DTOG_TX)) {\npma_write(buf, blen, &amp;(tbl-&gt;tx1));\n} else {\npma_write(buf, blen, &amp;(tbl-&gt;tx0));\n}\nbreak;\n/* regular endpoint */\ncase (USB_EP_TX_NAK | USB_EP_BULK):\ncase (USB_EP_TX_NAK | USB_EP_CONTROL):\ncase (USB_EP_TX_NAK | USB_EP_INTERRUPT):\npma_write(buf, blen, &amp;(tbl-&gt;tx));\nEP_TX_VALID(reg);\nbreak;\n/* invalid or not ready */\ndefault:\nreturn -1;\n}\nreturn blen;\n}\n\nuint16_t get_frame (void) {\nreturn USB-&gt;FNR &amp; USB_FNR_FN;\n}\n\nvoid evt_poll(usbd_device *dev, usbd_evt_callback callback) {\nuint8_t _ev, _ep;\nuint16_t _istr = USB-&gt;ISTR;\n_ep = _istr &amp; USB_ISTR_EP_ID;\n\nif (_istr &amp; USB_ISTR_CTR) {\nvolatile uint16_t *reg = EPR(_ep);\nif (*reg &amp; USB_EP_CTR_TX) {\n*reg &amp;= (USB_EPREG_MASK ^ USB_EP_CTR_TX);\n_ep |= 0x80;\n_ev = usbd_evt_eptx;\n} else {\n*reg &amp;= (USB_EPREG_MASK ^ USB_EP_CTR_RX);\n_ev = (*reg &amp; USB_EP_SETUP) ? usbd_evt_epsetup : usbd_evt_eprx;\n}\n} else if (_istr &amp; USB_ISTR_RESET) {\nUSB-&gt;ISTR &amp;= ~USB_ISTR_RESET;\nUSB-&gt;BTABLE = 0;\nfor (int i = 0; i &lt; 8; i++) {\nep_deconfig(i);\n}\n_ev = usbd_evt_reset;\n#if !defined(USBD_SOF_DISABLED)\n} else if (_istr &amp; USB_ISTR_SOF) {\n_ev = usbd_evt_sof;\nUSB-&gt;ISTR &amp;= ~USB_ISTR_SOF;\n#endif\n} else if (_istr &amp; USB_ISTR_WKUP) {\n_ev = usbd_evt_wkup;\nUSB-&gt;CNTR &amp;= ~USB_CNTR_FSUSP;\nUSB-&gt;ISTR &amp;= ~USB_ISTR_WKUP;\n} else if (_istr &amp; USB_ISTR_SUSP) {\n_ev = usbd_evt_susp;\nUSB-&gt;CNTR |= USB_CNTR_FSUSP;\nUSB-&gt;ISTR &amp;= ~USB_ISTR_SUSP;\n} else if (_istr &amp; USB_ISTR_ERR) {\nUSB-&gt;ISTR &amp;= ~USB_ISTR_ERR;\n_ev = usbd_evt_error;\n} else {\nreturn;\n}\ncallback(dev, _ev, _ep);\n}\n\nstatic uint32_t fnv1a32_turn (uint32_t fnv, uint32_t data ) {\nfor (int i = 0; i &lt; 4 ; i++) {\nfnv ^= (data &amp; 0xFF);\nfnv *= 16777619;\ndata &gt;&gt;= 8;\n}\nreturn fnv;\n}\n\nuint16_t get_serialno_desc(void *buffer) {\nstruct  usb_string_descriptor *dsc = buffer;\nuint16_t *str = dsc-&gt;wString;\nuint32_t fnv = 2166136261;\nfnv = fnv1a32_turn(fnv, *(uint32_t*)(UID_BASE + 0x00));\nfnv = fnv1a32_turn(fnv, *(uint32_t*)(UID_BASE + 0x04));\nfnv = fnv1a32_turn(fnv, *(uint32_t*)(UID_BASE + 0x08));\nfor (int i = 28; i &gt;= 0; i -= 4 ) {\nuint16_t c = (fnv &gt;&gt; i) &amp; 0x0F;\nc += (c &lt; 10) ? '0' : ('A' - 10);\n*str++ = c;\n}\ndsc-&gt;bDescriptorType = USB_DTYPE_STRING;\ndsc-&gt;bLength = 18;\nreturn 18;\n}\n\n__attribute__((externally_visible)) const struct usbd_driver usbd_devfs = {\ngetinfo,\nenable,\nconnect,\nsetaddr,\nep_config,\nep_deconfig,\nep_read,\nep_write,\nep_setstall,\nep_isstalled,\nevt_poll,\nget_frame,\nget_serialno_desc,\n};\n\n#endif //USBD_STM32F103\n</code></pre>"},{"location":"apiStm/dir_c468682377394ccf5865b8c9e718897d/","title":"Dir fw/rbcx-coprocessor/src","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; src</p>"},{"location":"apiStm/dir_c468682377394ccf5865b8c9e718897d/#files","title":"Files","text":"Type Name file Bsp.cpp file ButtonController.cpp file CdcUartTunnel.cpp file ControlLink.cpp file DebugLink.cpp file Dispatcher.cpp file Esp32Manager.cpp file FreeRTOSCallbacks.cpp file I2cController.cpp file MotorController.cpp file MpuController.cpp file OledController.cpp file OledController_fonts.cpp file Power.cpp file SmartServoController.cpp file StupidServoController.cpp file UltrasoundController.cpp file UsbCdcDescriptors.c file UsbCdcLink.cpp file main.cpp"},{"location":"apiStm/dir_c468682377394ccf5865b8c9e718897d/#directories","title":"Directories","text":"Type Name dir utils <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/</code></p>"},{"location":"apiStm/Bsp_8cpp/","title":"File Bsp.cpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; src &gt; Bsp.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"BuzzerController.hpp\"</code></li> <li><code>#include \"ControlLink.hpp\"</code></li> <li><code>#include \"Dispatcher.hpp\"</code></li> <li><code>#include \"Esp32Manager.hpp\"</code></li> <li><code>#include \"I2cController.hpp\"</code></li> <li><code>#include \"MotorController.hpp\"</code></li> <li><code>#include \"MpuController.hpp\"</code></li> <li><code>#include \"StupidServoController.hpp\"</code></li> <li><code>#include \"UltrasoundController.hpp\"</code></li> <li><code>#include \"utils/Debug.hpp\"</code></li> <li><code>#include \"utils/TaskWrapper.hpp\"</code></li> </ul>"},{"location":"apiStm/Bsp_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name TaskWrapper&lt; 1024 &gt; softResetTask"},{"location":"apiStm/Bsp_8cpp/#public-functions","title":"Public Functions","text":"Type Name void EXTI4_IRQHandler (void)  void EXTI9_5_IRQHandler (void)  void softReset ()  void softResetInit ()"},{"location":"apiStm/Bsp_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"apiStm/Bsp_8cpp/#variable-softresettask","title":"variable softResetTask","text":"<pre><code>TaskWrapper&lt;1024&gt; softResetTask;\n</code></pre>"},{"location":"apiStm/Bsp_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/Bsp_8cpp/#function-exti4_irqhandler","title":"function EXTI4_IRQHandler","text":"<pre><code>void EXTI4_IRQHandler (\nvoid\n) </code></pre>"},{"location":"apiStm/Bsp_8cpp/#function-exti9_5_irqhandler","title":"function EXTI9_5_IRQHandler","text":"<pre><code>void EXTI9_5_IRQHandler (\nvoid\n) </code></pre>"},{"location":"apiStm/Bsp_8cpp/#function-softreset","title":"function softReset","text":"<pre><code>void softReset () </code></pre>"},{"location":"apiStm/Bsp_8cpp/#function-softresetinit","title":"function softResetInit","text":"<pre><code>void softResetInit () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/Bsp.cpp</code></p>"},{"location":"apiStm/Bsp_8cpp_source/","title":"File Bsp.cpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; src &gt; Bsp.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"Bsp.hpp\"\n#include \"BuzzerController.hpp\"\n#include \"ControlLink.hpp\"\n#include \"Dispatcher.hpp\"\n#include \"Esp32Manager.hpp\"\n#include \"I2cController.hpp\"\n#include \"MotorController.hpp\"\n#include \"MpuController.hpp\"\n#include \"StupidServoController.hpp\"\n#include \"UltrasoundController.hpp\"\n#include \"utils/Debug.hpp\"\n#include \"utils/TaskWrapper.hpp\"\n\nstatic TaskWrapper&lt;1024&gt; softResetTask;\n\nextern \"C\" void EXTI4_IRQHandler(void) {\n// This EXTI vector only serves ESP_EN.\nsEsp32Manager.onEnRisingInIrq();\n__HAL_GPIO_EXTI_CLEAR_IT(espEnPin.second);\n}\n\nextern \"C\" void EXTI9_5_IRQHandler(void) {\n// This EXTI vector only serves the ultrasound ECHO\n// of which only one is listening at a time.\n// We want minimum jitter so avoid the stupid HAL callback scheme.\n\nultrasoundOnEchoEdge();\n__HAL_GPIO_EXTI_CLEAR_IT(uts1EchoPin.second | uts2EchoPin.second\n| uts3EchoPin.second | uts4EchoPin.second);\n}\n\nvoid softResetInit() {\nsoftResetTask.start(\"softrst\", softResetTaskPrio, []() {\nwhile (true) {\nif (xTaskNotifyWait(0, 0, nullptr, portMAX_DELAY) != pdTRUE)\ncontinue;\n\nDEBUG(\"Soft resetting peripherials to default state.\\n\");\n\nsetLeds(0);\nbuzzerSetState(false);\ndispatcherReset();\ncontrolLinkReset();\nstupidServoReset();\nultrasoundReset();\nmotorReset();\ni2cReset();\nmpuReset();\n}\n});\n}\n\nvoid softReset() {\nif (isInInterrupt()) {\nBaseType_t woken = pdFALSE;\nxTaskNotifyFromISR(softResetTask.handle(), 0, eNoAction, &amp;woken);\nportYIELD_FROM_ISR(woken);\n} else {\nxTaskNotify(softResetTask.handle(), 0, eNoAction);\n}\n}\n</code></pre>"},{"location":"apiStm/ButtonController_8cpp/","title":"File ButtonController.cpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; src &gt; ButtonController.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"task.h\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"DebugLink.hpp\"</code></li> <li><code>#include \"Dispatcher.hpp\"</code></li> <li><code>#include \"Power.hpp\"</code></li> <li><code>#include \"utils/Debug.hpp\"</code></li> </ul>"},{"location":"apiStm/ButtonController_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name uint32_t buttonState   = = 0 bool debugStateChanges   = = false uint32_t powerOffAt   = = 0"},{"location":"apiStm/ButtonController_8cpp/#public-functions","title":"Public Functions","text":"Type Name void buttonControllerPoll ()  void buttonControllerSetDebug (bool debug)"},{"location":"apiStm/ButtonController_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"apiStm/ButtonController_8cpp/#variable-buttonstate","title":"variable buttonState","text":"<pre><code>uint32_t buttonState;\n</code></pre>"},{"location":"apiStm/ButtonController_8cpp/#variable-debugstatechanges","title":"variable debugStateChanges","text":"<pre><code>bool debugStateChanges;\n</code></pre>"},{"location":"apiStm/ButtonController_8cpp/#variable-poweroffat","title":"variable powerOffAt","text":"<pre><code>uint32_t powerOffAt;\n</code></pre>"},{"location":"apiStm/ButtonController_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/ButtonController_8cpp/#function-buttoncontrollerpoll","title":"function buttonControllerPoll","text":"<pre><code>void buttonControllerPoll () </code></pre>"},{"location":"apiStm/ButtonController_8cpp/#function-buttoncontrollersetdebug","title":"function buttonControllerSetDebug","text":"<pre><code>void buttonControllerSetDebug (\nbool debug\n) </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/ButtonController.cpp</code></p>"},{"location":"apiStm/ButtonController_8cpp_source/","title":"File ButtonController.cpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; src &gt; ButtonController.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;stdint.h&gt;\n\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n\n#include \"Bsp.hpp\"\n#include \"DebugLink.hpp\"\n#include \"Dispatcher.hpp\"\n#include \"Power.hpp\"\n#include \"utils/Debug.hpp\"\n\nstatic uint32_t buttonState = 0;\nstatic uint32_t powerOffAt = 0;\n\nstatic bool debugStateChanges = false;\n\nvoid buttonControllerSetDebug(bool debug) { debugStateChanges = debug; }\n\nvoid buttonControllerPoll() {\nif (powerOffAt != 0 &amp;&amp; xTaskGetTickCount() &gt;= powerOffAt) {\npowerShutDown();\npowerOffAt = 0;\n}\n\nconst uint32_t newButtonState = getButtons();\nif (buttonState == newButtonState)\nreturn;\n\nif (debugStateChanges) {\nDEBUG(\"button state change: 0x%04lx -&gt; 0x%04lx\\n\", buttonState,\nnewButtonState);\n}\n\nauto status = CoprocStat();\nstatus.which_payload = CoprocStat_buttonsStat_tag;\nstatus.payload.buttonsStat.buttonsPressed\n= CoprocStat_ButtonsEnum(newButtonState);\n\ndispatcherEnqueueStatus(status);\nbuttonState = newButtonState;\n\nif ((newButtonState &amp; CoprocStat_ButtonsEnum_BOFF) != 0) {\npowerOffAt = xTaskGetTickCount() + pdMS_TO_TICKS(2000);\n} else {\npowerOffAt = 0;\n}\n\nif ((newButtonState &amp; CoprocStat_ButtonsEnum_BON) != 0) {\npinWrite(powerPin, 1);\n}\n}\n</code></pre>"},{"location":"apiStm/CdcUartTunnel_8cpp/","title":"File CdcUartTunnel.cpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; src &gt; CdcUartTunnel.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"stm32f1xx_hal.h\"</code></li> <li><code>#include \"stm32f1xx_hal_dma.h\"</code></li> <li><code>#include \"stm32f1xx_ll_rcc.h\"</code></li> <li><code>#include \"stm32f1xx_ll_usart.h\"</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"CdcUartTunnel.hpp\"</code></li> <li><code>#include \"UsbCdcLink.h\"</code></li> <li><code>#include \"utils/BasePriorityRaiser.hpp\"</code></li> <li><code>#include \"utils/ByteFifo.hpp\"</code></li> <li><code>#include \"utils/HalDma.hpp\"</code></li> </ul>"},{"location":"apiStm/CdcUartTunnel_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name DMA_HandleTypeDef dmaRxHandle DMA_HandleTypeDef dmaTxHandle ByteFifo&lt; 512 &gt; rxFifo std::array&lt; uint8_t, CDC_DATA_SZ &gt; txBuf BasePriorityRaiser&lt; usbLpIRQnPrio &gt; usbIrqPrioRaise"},{"location":"apiStm/CdcUartTunnel_8cpp/#public-functions","title":"Public Functions","text":"Type Name bool tunnelOnSetLineCodingInIrq (const usb_cdc_line_coding &amp; old, const usb_cdc_line_coding &amp; current)  void tunnelPoll ()  void tunnelUartInit ()"},{"location":"apiStm/CdcUartTunnel_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void tunnelDownstreamHandler ()  void tunnelUartRxPoll ()  void tunnelUartTx (uint8_t * data, size_t len)  bool tunnelUartTxReady ()  void tunnelUpstreamHandler ()"},{"location":"apiStm/CdcUartTunnel_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"apiStm/CdcUartTunnel_8cpp/#variable-dmarxhandle","title":"variable dmaRxHandle","text":"<pre><code>DMA_HandleTypeDef dmaRxHandle;\n</code></pre> <p>Implements passthrough between the \"tunnel\" UART and USB CDC. \"Tunnel\" UART leads to ESP32 main UART. </p>"},{"location":"apiStm/CdcUartTunnel_8cpp/#variable-dmatxhandle","title":"variable dmaTxHandle","text":"<pre><code>DMA_HandleTypeDef dmaTxHandle;\n</code></pre>"},{"location":"apiStm/CdcUartTunnel_8cpp/#variable-rxfifo","title":"variable rxFifo","text":"<pre><code>ByteFifo&lt;512&gt; rxFifo;\n</code></pre>"},{"location":"apiStm/CdcUartTunnel_8cpp/#variable-txbuf","title":"variable txBuf","text":"<pre><code>std::array&lt;uint8_t, CDC_DATA_SZ&gt; txBuf;\n</code></pre>"},{"location":"apiStm/CdcUartTunnel_8cpp/#variable-usbirqprioraise","title":"variable usbIrqPrioRaise","text":"<pre><code>BasePriorityRaiser&lt;usbLpIRQnPrio&gt; usbIrqPrioRaise;\n</code></pre>"},{"location":"apiStm/CdcUartTunnel_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/CdcUartTunnel_8cpp/#function-tunnelonsetlinecodinginirq","title":"function tunnelOnSetLineCodingInIrq","text":"<pre><code>bool tunnelOnSetLineCodingInIrq (\nconst usb_cdc_line_coding &amp; old,\nconst usb_cdc_line_coding &amp; current\n) </code></pre>"},{"location":"apiStm/CdcUartTunnel_8cpp/#function-tunnelpoll","title":"function tunnelPoll","text":"<pre><code>void tunnelPoll () </code></pre>"},{"location":"apiStm/CdcUartTunnel_8cpp/#function-tunneluartinit","title":"function tunnelUartInit","text":"<pre><code>void tunnelUartInit () </code></pre>"},{"location":"apiStm/CdcUartTunnel_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"apiStm/CdcUartTunnel_8cpp/#function-tunneldownstreamhandler","title":"function tunnelDownstreamHandler","text":"<pre><code>static void tunnelDownstreamHandler () </code></pre>"},{"location":"apiStm/CdcUartTunnel_8cpp/#function-tunneluartrxpoll","title":"function tunnelUartRxPoll","text":"<pre><code>static void tunnelUartRxPoll () </code></pre>"},{"location":"apiStm/CdcUartTunnel_8cpp/#function-tunneluarttx","title":"function tunnelUartTx","text":"<pre><code>static void tunnelUartTx (\nuint8_t * data,\nsize_t len\n) </code></pre>"},{"location":"apiStm/CdcUartTunnel_8cpp/#function-tunneluarttxready","title":"function tunnelUartTxReady","text":"<pre><code>static bool tunnelUartTxReady () </code></pre>"},{"location":"apiStm/CdcUartTunnel_8cpp/#function-tunnelupstreamhandler","title":"function tunnelUpstreamHandler","text":"<pre><code>static void tunnelUpstreamHandler () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/CdcUartTunnel.cpp</code></p>"},{"location":"apiStm/CdcUartTunnel_8cpp_source/","title":"File CdcUartTunnel.cpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; src &gt; CdcUartTunnel.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"stm32f1xx_hal.h\"\n#include \"stm32f1xx_hal_dma.h\"\n#include \"stm32f1xx_ll_rcc.h\"\n#include \"stm32f1xx_ll_usart.h\"\n\n#include \"FreeRTOS.h\"\n\n#include \"Bsp.hpp\"\n#include \"CdcUartTunnel.hpp\"\n#include \"UsbCdcLink.h\"\n#include \"utils/BasePriorityRaiser.hpp\"\n#include \"utils/ByteFifo.hpp\"\n#include \"utils/HalDma.hpp\"\n\nstatic DMA_HandleTypeDef dmaRxHandle;\nstatic DMA_HandleTypeDef dmaTxHandle;\nstatic ByteFifo&lt;512&gt; rxFifo;\nstatic std::array&lt;uint8_t, CDC_DATA_SZ&gt; txBuf;\nstatic BasePriorityRaiser&lt;usbLpIRQnPrio&gt; usbIrqPrioRaise;\n\nvoid tunnelUartInit() {\nLL_USART_InitTypeDef init;\nLL_USART_StructInit(&amp;init);\ninit.BaudRate = 115200;\ninit.DataWidth = LL_USART_DATAWIDTH_8B;\ninit.HardwareFlowControl = LL_USART_HWCONTROL_NONE;\ninit.Parity = LL_USART_PARITY_NONE;\ninit.StopBits = LL_USART_STOPBITS_1;\ninit.TransferDirection = LL_USART_DIRECTION_TX_RX;\nLL_USART_Init(tunnelUart, &amp;init);\nLL_USART_Enable(tunnelUart);\n\n// UART RX runs indefinitely in circular mode\ndmaRxHandle.Instance = tunnelUartRxDmaChannel;\ndmaRxHandle.Init.Direction = DMA_PERIPH_TO_MEMORY;\ndmaRxHandle.Init.Mode = DMA_CIRCULAR;\ndmaRxHandle.Init.MemInc = DMA_MINC_ENABLE;\ndmaRxHandle.Init.PeriphInc = DMA_PINC_DISABLE;\ndmaRxHandle.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;\ndmaRxHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;\ndmaRxHandle.Init.Priority = DMA_PRIORITY_MEDIUM;\nHAL_DMA_Init(&amp;dmaRxHandle);\nHAL_DMA_Start(&amp;dmaRxHandle, uintptr_t(&amp;(tunnelUart-&gt;DR)),\nuintptr_t(rxFifo.data()), rxFifo.size());\nLL_USART_EnableDMAReq_RX(tunnelUart);\n\n// UART TX burst is started ad hoc each time\ndmaTxHandle.Instance = tunnelUartTxDmaChannel;\ndmaTxHandle.Init.Direction = DMA_MEMORY_TO_PERIPH;\ndmaTxHandle.Init.Mode = DMA_NORMAL;\ndmaTxHandle.Init.MemInc = DMA_MINC_ENABLE;\ndmaTxHandle.Init.PeriphInc = DMA_PINC_DISABLE;\ndmaTxHandle.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;\ndmaTxHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;\ndmaTxHandle.Init.Priority = DMA_PRIORITY_MEDIUM;\nHAL_DMA_Init(&amp;dmaTxHandle);\nLL_USART_EnableDMAReq_TX(tunnelUart);\n\npinInit(\ntunnelUartTxPin, GPIO_MODE_AF_PP, GPIO_PULLUP, GPIO_SPEED_FREQ_HIGH);\npinInit(\ntunnelUartRxPin, GPIO_MODE_AF_INPUT, GPIO_PULLUP, GPIO_SPEED_FREQ_HIGH);\n}\n\nstatic void tunnelUartRxPoll() {\nint rxHead = rxFifo.size() - __HAL_DMA_GET_COUNTER(&amp;dmaRxHandle);\nrxFifo.setHead(rxHead);\n}\n\nstatic void tunnelUartTx(uint8_t* data, size_t len) {\nHAL_DMA_Start(\n&amp;dmaTxHandle, uintptr_t(data), uintptr_t(&amp;tunnelUart-&gt;DR), len);\n}\n\nstatic bool tunnelUartTxReady() {\nHAL_DMA_PollForTransfer_Really(&amp;dmaTxHandle, HAL_DMA_FULL_TRANSFER, 0);\nreturn dmaTxHandle.State == HAL_DMA_STATE_READY;\n}\n\nstatic void tunnelDownstreamHandler() {\nif (tunnelUartTxReady()) {\nusbIrqPrioRaise.lock();\nconst int transferred = usbd_ep_read(\n&amp;udev, CDC_TUNNEL_RXD_EP, txBuf.data(), txBuf.size());\nusbIrqPrioRaise.unlock();\n\nif (transferred &gt; 0) {\ntunnelUartTx(txBuf.data(), transferred);\n}\n}\n}\n\nstatic void tunnelUpstreamHandler() {\ntunnelUartRxPoll();\nauto readable = rxFifo.readableSpan();\nif (readable.second &gt; 0) {\nusbIrqPrioRaise.lock();\nconst int transferred = usbd_ep_write(&amp;udev, CDC_TUNNEL_TXD_EP,\nreadable.first, std::min(readable.second, size_t(CDC_DATA_SZ)));\nusbIrqPrioRaise.unlock();\n\nif (transferred &gt; 0) {\nrxFifo.notifyRead(transferred);\n}\n}\n}\n\nvoid tunnelPoll() {\ntunnelUpstreamHandler();\ntunnelDownstreamHandler();\n}\n\nbool tunnelOnSetLineCodingInIrq(\nconst usb_cdc_line_coding&amp; old, const usb_cdc_line_coding&amp; current) {\nif (old.dwDTERate != current.dwDTERate) {\n// From inside of LL_USART_Init, wtf is this not exported as some function?\n// https://github.com/STMicroelectronics/STM32CubeF1/blob/master/Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_usart.c\nif (current.dwDTERate &gt; 4500000U) {\nreturn false;\n}\n\nuint32_t periphclk = LL_RCC_PERIPH_FREQUENCY_NO;\nLL_RCC_ClocksTypeDef rcc_clocks;\nLL_RCC_GetSystemClocksFreq(&amp;rcc_clocks);\nif (tunnelUart == USART1) {\nperiphclk = rcc_clocks.PCLK2_Frequency;\n} else if (tunnelUart == USART2) {\nperiphclk = rcc_clocks.PCLK1_Frequency;\n} else if (tunnelUart == USART3) {\nperiphclk = rcc_clocks.PCLK1_Frequency;\n} else if (tunnelUart == UART4) {\nperiphclk = rcc_clocks.PCLK1_Frequency;\n} else if (tunnelUart == UART5) {\nperiphclk = rcc_clocks.PCLK1_Frequency;\n} else {\nabort();\n}\nLL_USART_SetBaudRate(tunnelUart, periphclk, current.dwDTERate);\n}\n\nif (current.bDataBits != 8) {\nreturn false;\n}\n\nif (old.bCharFormat != current.bCharFormat) {\nswitch (current.bCharFormat) {\ncase USB_CDC_1_STOP_BITS:\nLL_USART_SetStopBitsLength(tunnelUart, LL_USART_STOPBITS_1);\nbreak;\ncase USB_CDC_1_5_STOP_BITS:\nLL_USART_SetStopBitsLength(tunnelUart, LL_USART_STOPBITS_1_5);\nbreak;\ncase USB_CDC_2_STOP_BITS:\nLL_USART_SetStopBitsLength(tunnelUart, LL_USART_STOPBITS_2);\nbreak;\ndefault:\nreturn false;\n}\n}\n\nif (old.bParityType != current.bParityType) {\nswitch (current.bParityType) {\ncase USB_CDC_NO_PARITY:\nLL_USART_SetParity(tunnelUart, LL_USART_PARITY_NONE);\nbreak;\ncase USB_CDC_ODD_PARITY:\nLL_USART_SetParity(tunnelUart, LL_USART_PARITY_ODD);\nbreak;\ncase USB_CDC_EVEN_PARITY:\nLL_USART_SetParity(tunnelUart, LL_USART_PARITY_EVEN);\nbreak;\ndefault:\nreturn false;\n}\n}\nreturn true;\n}\n</code></pre>"},{"location":"apiStm/ControlLink_8cpp/","title":"File ControlLink.cpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; src &gt; ControlLink.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include \"stm32f1xx_hal.h\"</code></li> <li><code>#include \"stm32f1xx_hal_dma.h\"</code></li> <li><code>#include \"stm32f1xx_ll_usart.h\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"Esp32Manager.hpp\"</code></li> <li><code>#include \"coproc_codec.h\"</code></li> <li><code>#include \"coproc_link_parser.h\"</code></li> <li><code>#include \"rbcx.pb.h\"</code></li> <li><code>#include \"utils/ByteFifo.hpp\"</code></li> <li><code>#include \"utils/MessageBufferWrapper.hpp\"</code></li> </ul>"},{"location":"apiStm/ControlLink_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name rb::CoprocCodec codec DMA_HandleTypeDef dmaRxHandle DMA_HandleTypeDef dmaTxHandle ByteFifo&lt; 512 &gt; rxFifo std::array&lt; uint8_t, codec.MaxFrameSize &gt; txDmaBuf std::array&lt; uint8_t, codec.MaxFrameSize &gt; txEncodeBuf MessageBufferWrapper&lt; 512 &gt; txMessageBuf"},{"location":"apiStm/ControlLink_8cpp/#public-functions","title":"Public Functions","text":"Type Name void CONTROLUART_TX_DMA_HANDLER ()  void controlLinkReset ()  bool controlLinkRx (CoprocReq &amp; incoming)  void controlLinkTx (const CoprocStat &amp; outgoing)  void controlUartInit ()"},{"location":"apiStm/ControlLink_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void controlLinkUpdateRxFifo ()  rb::CoprocLinkParser&lt; CoprocReq, &amp;CoprocReq_msg &gt; parser (codec)"},{"location":"apiStm/ControlLink_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"apiStm/ControlLink_8cpp/#variable-codec","title":"variable codec","text":"<pre><code>rb::CoprocCodec codec;\n</code></pre>"},{"location":"apiStm/ControlLink_8cpp/#variable-dmarxhandle","title":"variable dmaRxHandle","text":"<pre><code>DMA_HandleTypeDef dmaRxHandle;\n</code></pre> <p>Implements control frame exchange. Frame byte layout: [0x00 LEN_BYTE COBS_DATA...] COBS is used to avoid having zero bytes present on UART except as packet beginnings. https://en.wikipedia.org/wiki/Consistent_Overhead_Byte_Stuffing </p>"},{"location":"apiStm/ControlLink_8cpp/#variable-dmatxhandle","title":"variable dmaTxHandle","text":"<pre><code>DMA_HandleTypeDef dmaTxHandle;\n</code></pre>"},{"location":"apiStm/ControlLink_8cpp/#variable-rxfifo","title":"variable rxFifo","text":"<pre><code>ByteFifo&lt;512&gt; rxFifo;\n</code></pre>"},{"location":"apiStm/ControlLink_8cpp/#variable-txdmabuf","title":"variable txDmaBuf","text":"<pre><code>std::array&lt;uint8_t, codec.MaxFrameSize&gt; txDmaBuf;\n</code></pre>"},{"location":"apiStm/ControlLink_8cpp/#variable-txencodebuf","title":"variable txEncodeBuf","text":"<pre><code>std::array&lt;uint8_t, codec.MaxFrameSize&gt; txEncodeBuf;\n</code></pre>"},{"location":"apiStm/ControlLink_8cpp/#variable-txmessagebuf","title":"variable txMessageBuf","text":"<pre><code>MessageBufferWrapper&lt;512&gt; txMessageBuf;\n</code></pre>"},{"location":"apiStm/ControlLink_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/ControlLink_8cpp/#function-controluart_tx_dma_handler","title":"function CONTROLUART_TX_DMA_HANDLER","text":"<pre><code>void CONTROLUART_TX_DMA_HANDLER () </code></pre>"},{"location":"apiStm/ControlLink_8cpp/#function-controllinkreset","title":"function controlLinkReset","text":"<pre><code>void controlLinkReset () </code></pre>"},{"location":"apiStm/ControlLink_8cpp/#function-controllinkrx","title":"function controlLinkRx","text":"<pre><code>bool controlLinkRx (\nCoprocReq &amp; incoming\n) </code></pre>"},{"location":"apiStm/ControlLink_8cpp/#function-controllinktx","title":"function controlLinkTx","text":"<pre><code>void controlLinkTx (\nconst CoprocStat &amp; outgoing\n) </code></pre>"},{"location":"apiStm/ControlLink_8cpp/#function-controluartinit","title":"function controlUartInit","text":"<pre><code>void controlUartInit () </code></pre>"},{"location":"apiStm/ControlLink_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"apiStm/ControlLink_8cpp/#function-controllinkupdaterxfifo","title":"function controlLinkUpdateRxFifo","text":"<pre><code>static void controlLinkUpdateRxFifo () </code></pre>"},{"location":"apiStm/ControlLink_8cpp/#function-parser","title":"function parser","text":"<pre><code>static rb::CoprocLinkParser&lt; CoprocReq, &amp;CoprocReq_msg &gt; parser (\ncodec\n) </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/ControlLink.cpp</code></p>"},{"location":"apiStm/ControlLink_8cpp_source/","title":"File ControlLink.cpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; src &gt; ControlLink.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;array&gt;\n\n#include \"stm32f1xx_hal.h\"\n#include \"stm32f1xx_hal_dma.h\"\n#include \"stm32f1xx_ll_usart.h\"\n\n#include \"Bsp.hpp\"\n#include \"Esp32Manager.hpp\"\n#include \"coproc_codec.h\"\n#include \"coproc_link_parser.h\"\n#include \"rbcx.pb.h\"\n#include \"utils/ByteFifo.hpp\"\n#include \"utils/MessageBufferWrapper.hpp\"\n\nstatic DMA_HandleTypeDef dmaRxHandle;\nstatic DMA_HandleTypeDef dmaTxHandle;\nstatic rb::CoprocCodec codec;\nstatic rb::CoprocLinkParser&lt;CoprocReq, &amp;CoprocReq_msg&gt; parser(codec);\nstatic ByteFifo&lt;512&gt; rxFifo;\n\n// Encode TX frame in txEncodeBuf, push to txMessageBuf, move to txDmaBuf and send via DMA.\nstatic std::array&lt;uint8_t, codec.MaxFrameSize&gt; txEncodeBuf;\nstatic std::array&lt;uint8_t, codec.MaxFrameSize&gt; txDmaBuf;\n\nstatic MessageBufferWrapper&lt;512&gt; txMessageBuf;\n\nvoid controlUartInit() {\ntxMessageBuf.create();\n\nLL_USART_InitTypeDef init;\nLL_USART_StructInit(&amp;init);\ninit.BaudRate = 921600;\ninit.DataWidth = LL_USART_DATAWIDTH_8B;\ninit.HardwareFlowControl = LL_USART_HWCONTROL_NONE;\ninit.Parity = LL_USART_PARITY_NONE;\ninit.StopBits = LL_USART_STOPBITS_1;\ninit.TransferDirection = LL_USART_DIRECTION_TX_RX;\nLL_USART_Init(controlUart, &amp;init);\nLL_USART_Enable(controlUart);\n\n// UART RX runs indefinitely in circular mode\ndmaRxHandle.Instance = controlUartRxDmaChannel;\ndmaRxHandle.Init.Direction = DMA_PERIPH_TO_MEMORY;\ndmaRxHandle.Init.Mode = DMA_CIRCULAR;\ndmaRxHandle.Init.MemInc = DMA_MINC_ENABLE;\ndmaRxHandle.Init.PeriphInc = DMA_PINC_DISABLE;\ndmaRxHandle.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;\ndmaRxHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;\ndmaRxHandle.Init.Priority = DMA_PRIORITY_MEDIUM;\nHAL_DMA_Init(&amp;dmaRxHandle);\nHAL_DMA_Start(&amp;dmaRxHandle, uintptr_t(&amp;(controlUart-&gt;DR)),\nuintptr_t(rxFifo.data()), rxFifo.size());\nLL_USART_EnableDMAReq_RX(controlUart);\n\n// UART TX burst is started ad hoc each time\ndmaTxHandle.Instance = controlUartTxDmaChannel;\ndmaTxHandle.Init.Direction = DMA_MEMORY_TO_PERIPH;\ndmaTxHandle.Init.Mode = DMA_NORMAL;\ndmaTxHandle.Init.MemInc = DMA_MINC_ENABLE;\ndmaTxHandle.Init.PeriphInc = DMA_PINC_DISABLE;\ndmaTxHandle.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;\ndmaTxHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;\ndmaTxHandle.Init.Priority = DMA_PRIORITY_MEDIUM;\nHAL_DMA_Init(&amp;dmaTxHandle);\nHAL_NVIC_SetPriority(controlUartTxDmaIRQn, controlUartTxDmaIRQnPrio, 0);\nHAL_NVIC_EnableIRQ(controlUartTxDmaIRQn);\nLL_USART_EnableDMAReq_TX(controlUart);\n}\n\nstatic void controlLinkUpdateRxFifo() {\nint rxHead = rxFifo.size() - __HAL_DMA_GET_COUNTER(&amp;dmaRxHandle);\nrxFifo.setHead(rxHead);\n}\n\nbool controlLinkRx(CoprocReq&amp; incoming) {\ncontrolLinkUpdateRxFifo();\nwhile (rxFifo.hasData()) {\nif (parser.add(rxFifo.pop())) {\nincoming = parser.lastMessage();\nreturn true;\n}\n}\nreturn false;\n}\n\nvoid controlLinkTx(const CoprocStat&amp; outgoing) {\nauto encodedSize = codec.encodeWithHeader(\n&amp;CoprocStat_msg, &amp;outgoing, txEncodeBuf.data(), txEncodeBuf.size());\n\nif (encodedSize == 0)\nabort();\n\nif (!txMessageBuf.push_back(txEncodeBuf.data(), encodedSize, 0)) {\nDEBUG(\"txMessageBuf overflow\\n\");\nabort();\n}\n\nHAL_NVIC_SetPendingIRQ(controlUartTxDmaIRQn);\n}\n\nvoid controlLinkReset() {\ncontrolLinkUpdateRxFifo();\nrxFifo.clear();\nwhile (!txMessageBuf.reset())\nvTaskDelay(0);\n}\n\nextern \"C\" void CONTROLUART_TX_DMA_HANDLER() {\nHAL_DMA_IRQHandler(&amp;dmaTxHandle);\nif (dmaTxHandle.State == HAL_DMA_STATE_READY) {\nBaseType_t pxHigherPriorityTaskWoken = pdFALSE;\n\nconst auto len = txMessageBuf.pop_front(\ntxDmaBuf.data(), txDmaBuf.size(), 0, &amp;pxHigherPriorityTaskWoken);\nif (len &gt; 0) {\nHAL_DMA_Start_IT(&amp;dmaTxHandle, uintptr_t(txDmaBuf.data()),\nuintptr_t(&amp;controlUart-&gt;DR), len);\n}\nportYIELD_FROM_ISR(pxHigherPriorityTaskWoken);\n}\n}\n</code></pre>"},{"location":"apiStm/DebugLink_8cpp/","title":"File DebugLink.cpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; src &gt; DebugLink.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;string.h&gt;</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"stream_buffer.h\"</code></li> <li><code>#include \"task.h\"</code></li> <li><code>#include \"stm32f1xx_hal.h\"</code></li> <li><code>#include \"stm32f1xx_hal_dma.h\"</code></li> <li><code>#include \"stm32f1xx_ll_usart.h\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"ButtonController.hpp\"</code></li> <li><code>#include \"BuzzerController.hpp\"</code></li> <li><code>#include \"Dispatcher.hpp\"</code></li> <li><code>#include \"I2cController.hpp\"</code></li> <li><code>#include \"Mpu6050.hpp\"</code></li> <li><code>#include \"OledController.hpp\"</code></li> <li><code>#include \"MpuController.hpp\"</code></li> <li><code>#include \"Power.hpp\"</code></li> <li><code>#include \"UsbCdcLink.h\"</code></li> <li><code>#include \"coproc_codec.h\"</code></li> <li><code>#include \"coproc_link_parser.h\"</code></li> <li><code>#include \"rbcx.pb.h\"</code></li> <li><code>#include \"utils/BasePriorityRaiser.hpp\"</code></li> <li><code>#include \"utils/ByteFifo.hpp\"</code></li> <li><code>#include \"utils/Debug.hpp\"</code></li> <li><code>#include \"utils/MessageBufferWrapper.hpp\"</code></li> <li><code>#include \"utils/MutexWrapper.hpp\"</code></li> <li><code>#include \"utils/QueueWrapper.hpp\"</code></li> <li><code>#include \"utils/StreamBufferWrapper.hpp\"</code></li> <li><code>#include \"utils/TickTimer.hpp\"</code></li> </ul>"},{"location":"apiStm/DebugLink_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr size_t MaxLineLength   = = 128 DMA_HandleTypeDef dmaRxHandle DMA_HandleTypeDef dmaTxHandle MessageBufferWrapper&lt; MaxLineLength+4 &gt; rxLineBuffer std::array&lt; uint8_t, 256 &gt; txDmaBuf StreamBufferWrapper&lt; txDmaBuf.size() *4 &gt; txUartStreamBuf ByteFifo&lt; MaxLineLength &gt; uartRxFifo std::array&lt; uint8_t, CDC_DATA_SZ &gt; usbFrameBuf BasePriorityRaiser&lt; usbLpIRQnPrio &gt; usbIrqPrioRaise ByteFifo&lt; MaxLineLength &gt; usbRxFifo ByteFifo&lt; MaxLineLength *4 &gt; usbTxFifo"},{"location":"apiStm/DebugLink_8cpp/#public-functions","title":"Public Functions","text":"Type Name void DEBUGUART_HANDLER (void)  void DEBUGUART_TX_DMA_HANDLER ()  int _write (int fd, char * data, int len)  void debugLinkPoll ()  ssize_t debugLinkTx (const uint8_t * data, size_t len)  void debugUartInit ()"},{"location":"apiStm/DebugLink_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void debugDownstreamHandler ()  void debugLinkHandleCommand (const char * cmd)  void debugUpstreamHandler ()  BaseType_t processRxBuf (ByteFifo&lt; Size &gt; &amp; fifo)"},{"location":"apiStm/DebugLink_8cpp/#macros","title":"Macros","text":"Type Name define COMMAND (name, ...)"},{"location":"apiStm/DebugLink_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"apiStm/DebugLink_8cpp/#variable-maxlinelength","title":"variable MaxLineLength","text":"<pre><code>constexpr size_t MaxLineLength;\n</code></pre>"},{"location":"apiStm/DebugLink_8cpp/#variable-dmarxhandle","title":"variable dmaRxHandle","text":"<pre><code>DMA_HandleTypeDef dmaRxHandle;\n</code></pre>"},{"location":"apiStm/DebugLink_8cpp/#variable-dmatxhandle","title":"variable dmaTxHandle","text":"<pre><code>DMA_HandleTypeDef dmaTxHandle;\n</code></pre>"},{"location":"apiStm/DebugLink_8cpp/#variable-rxlinebuffer","title":"variable rxLineBuffer","text":"<pre><code>MessageBufferWrapper&lt;MaxLineLength + 4&gt; rxLineBuffer;\n</code></pre>"},{"location":"apiStm/DebugLink_8cpp/#variable-txdmabuf","title":"variable txDmaBuf","text":"<pre><code>std::array&lt;uint8_t, 256&gt; txDmaBuf;\n</code></pre>"},{"location":"apiStm/DebugLink_8cpp/#variable-txuartstreambuf","title":"variable txUartStreamBuf","text":"<pre><code>StreamBufferWrapper&lt;txDmaBuf.size() * 4&gt; txUartStreamBuf;\n</code></pre>"},{"location":"apiStm/DebugLink_8cpp/#variable-uartrxfifo","title":"variable uartRxFifo","text":"<pre><code>ByteFifo&lt;MaxLineLength&gt; uartRxFifo;\n</code></pre>"},{"location":"apiStm/DebugLink_8cpp/#variable-usbframebuf","title":"variable usbFrameBuf","text":"<pre><code>std::array&lt;uint8_t, CDC_DATA_SZ&gt; usbFrameBuf;\n</code></pre>"},{"location":"apiStm/DebugLink_8cpp/#variable-usbirqprioraise","title":"variable usbIrqPrioRaise","text":"<pre><code>BasePriorityRaiser&lt;usbLpIRQnPrio&gt; usbIrqPrioRaise;\n</code></pre>"},{"location":"apiStm/DebugLink_8cpp/#variable-usbrxfifo","title":"variable usbRxFifo","text":"<pre><code>ByteFifo&lt;MaxLineLength&gt; usbRxFifo;\n</code></pre>"},{"location":"apiStm/DebugLink_8cpp/#variable-usbtxfifo","title":"variable usbTxFifo","text":"<pre><code>ByteFifo&lt;MaxLineLength * 4&gt; usbTxFifo;\n</code></pre>"},{"location":"apiStm/DebugLink_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/DebugLink_8cpp/#function-debuguart_handler","title":"function DEBUGUART_HANDLER","text":"<pre><code>void DEBUGUART_HANDLER (\nvoid\n) </code></pre>"},{"location":"apiStm/DebugLink_8cpp/#function-debuguart_tx_dma_handler","title":"function DEBUGUART_TX_DMA_HANDLER","text":"<pre><code>void DEBUGUART_TX_DMA_HANDLER () </code></pre>"},{"location":"apiStm/DebugLink_8cpp/#function-_write","title":"function _write","text":"<pre><code>int _write (\nint fd,\nchar * data,\nint len\n) </code></pre>"},{"location":"apiStm/DebugLink_8cpp/#function-debuglinkpoll","title":"function debugLinkPoll","text":"<pre><code>void debugLinkPoll () </code></pre>"},{"location":"apiStm/DebugLink_8cpp/#function-debuglinktx","title":"function debugLinkTx","text":"<pre><code>ssize_t debugLinkTx (\nconst uint8_t * data,\nsize_t len\n) </code></pre>"},{"location":"apiStm/DebugLink_8cpp/#function-debuguartinit","title":"function debugUartInit","text":"<pre><code>void debugUartInit () </code></pre>"},{"location":"apiStm/DebugLink_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"apiStm/DebugLink_8cpp/#function-debugdownstreamhandler","title":"function debugDownstreamHandler","text":"<pre><code>static void debugDownstreamHandler () </code></pre>"},{"location":"apiStm/DebugLink_8cpp/#function-debuglinkhandlecommand","title":"function debugLinkHandleCommand","text":"<pre><code>static void debugLinkHandleCommand (\nconst char * cmd\n) </code></pre>"},{"location":"apiStm/DebugLink_8cpp/#function-debugupstreamhandler","title":"function debugUpstreamHandler","text":"<pre><code>static void debugUpstreamHandler () </code></pre>"},{"location":"apiStm/DebugLink_8cpp/#function-processrxbuf","title":"function processRxBuf","text":"<pre><code>template&lt;int Size&gt;\nstatic BaseType_t processRxBuf (\nByteFifo &lt; Size &gt; &amp; fifo\n) </code></pre>"},{"location":"apiStm/DebugLink_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/DebugLink_8cpp/#define-command","title":"define COMMAND","text":"<pre><code>#define COMMAND (\nname,\n...\n) if (strncmp(cmd, name \" \", sizeof(name)) == 0) {                           \\\n        cmd += sizeof(name);                                                   \\\n        __VA_ARGS__                                                            \\\n    }\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/DebugLink.cpp</code></p>"},{"location":"apiStm/DebugLink_8cpp_source/","title":"File DebugLink.cpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; src &gt; DebugLink.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;array&gt;\n#include &lt;string.h&gt;\n\n#include \"FreeRTOS.h\"\n#include \"stream_buffer.h\"\n#include \"task.h\"\n\n#include \"stm32f1xx_hal.h\"\n#include \"stm32f1xx_hal_dma.h\"\n#include \"stm32f1xx_ll_usart.h\"\n\n#include \"Bsp.hpp\"\n#include \"ButtonController.hpp\"\n#include \"BuzzerController.hpp\"\n#include \"Dispatcher.hpp\"\n#include \"I2cController.hpp\"\n#include \"Mpu6050.hpp\"\n#include \"OledController.hpp\"\n#include \"MpuController.hpp\"\n#include \"Power.hpp\"\n#include \"UsbCdcLink.h\"\n#include \"coproc_codec.h\"\n#include \"coproc_link_parser.h\"\n#include \"rbcx.pb.h\"\n#include \"utils/BasePriorityRaiser.hpp\"\n#include \"utils/ByteFifo.hpp\"\n#include \"utils/Debug.hpp\"\n#include \"utils/MessageBufferWrapper.hpp\"\n#include \"utils/MutexWrapper.hpp\"\n#include \"utils/QueueWrapper.hpp\"\n#include \"utils/StreamBufferWrapper.hpp\"\n#include \"utils/TickTimer.hpp\"\n\n#include \"rbcx.pb.h\"\n\nstatic DMA_HandleTypeDef dmaTxHandle;\nstatic DMA_HandleTypeDef dmaRxHandle;\n\nstatic constexpr size_t MaxLineLength = 128;\n\nstatic std::array&lt;uint8_t, 256&gt; txDmaBuf;\nstatic StreamBufferWrapper&lt;txDmaBuf.size() * 4&gt; txUartStreamBuf;\n\nstatic ByteFifo&lt;MaxLineLength&gt; uartRxFifo;\nstatic MessageBufferWrapper&lt;MaxLineLength + 4&gt; rxLineBuffer;\n\nstatic std::array&lt;uint8_t, CDC_DATA_SZ&gt; usbFrameBuf;\nstatic ByteFifo&lt;MaxLineLength&gt; usbRxFifo;\nstatic ByteFifo&lt;MaxLineLength * 4&gt; usbTxFifo;\nstatic BasePriorityRaiser&lt;usbLpIRQnPrio&gt; usbIrqPrioRaise;\n\nvoid debugUartInit() {\ntxUartStreamBuf.create();\nrxLineBuffer.create();\n\nLL_USART_InitTypeDef init;\nLL_USART_StructInit(&amp;init);\ninit.BaudRate = 115200;\ninit.DataWidth = LL_USART_DATAWIDTH_8B;\ninit.HardwareFlowControl = LL_USART_HWCONTROL_NONE;\ninit.Parity = LL_USART_PARITY_NONE;\ninit.StopBits = LL_USART_STOPBITS_1;\ninit.TransferDirection = LL_USART_DIRECTION_TX_RX;\nif (LL_USART_Init(debugUart, &amp;init) != SUCCESS)\nabort();\nLL_USART_Enable(debugUart);\n\n// UART RX runs indefinitely in circular mode\ndmaRxHandle.Instance = debugUartRxDmaChannel;\ndmaRxHandle.Init.Direction = DMA_PERIPH_TO_MEMORY;\ndmaRxHandle.Init.Mode = DMA_CIRCULAR;\ndmaRxHandle.Init.MemInc = DMA_MINC_ENABLE;\ndmaRxHandle.Init.PeriphInc = DMA_PINC_DISABLE;\ndmaRxHandle.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;\ndmaRxHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;\ndmaRxHandle.Init.Priority = DMA_PRIORITY_MEDIUM;\nHAL_DMA_Init(&amp;dmaRxHandle);\nHAL_DMA_Start(&amp;dmaRxHandle, uintptr_t(&amp;(debugUart-&gt;DR)),\nuintptr_t(uartRxFifo.data()), uartRxFifo.size());\nLL_USART_EnableDMAReq_RX(debugUart);\n\nHAL_NVIC_SetPriority(debugUartIRQn, debugUartIrqPrio, 0);\nHAL_NVIC_EnableIRQ(debugUartIRQn);\nLL_USART_EnableIT_IDLE(debugUart);\n\n// UART TX burst is started ad hoc each time\ndmaTxHandle.Instance = debugUartTxDmaChannel;\ndmaTxHandle.Init.Direction = DMA_MEMORY_TO_PERIPH;\ndmaTxHandle.Init.Mode = DMA_NORMAL;\ndmaTxHandle.Init.MemInc = DMA_MINC_ENABLE;\ndmaTxHandle.Init.PeriphInc = DMA_PINC_DISABLE;\ndmaTxHandle.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;\ndmaTxHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;\ndmaTxHandle.Init.Priority = DMA_PRIORITY_MEDIUM;\nif (HAL_DMA_Init(&amp;dmaTxHandle) != HAL_OK)\nabort();\nHAL_NVIC_SetPriority(debugUartTxDmaIRQn, debugUartTxDmaIrqPrio, 0);\nHAL_NVIC_EnableIRQ(debugUartTxDmaIRQn);\nLL_USART_EnableDMAReq_TX(debugUart);\n\npinInit(debugUartTxPin, GPIO_MODE_AF_PP, GPIO_PULLUP, GPIO_SPEED_FREQ_HIGH);\npinInit(\ndebugUartRxPin, GPIO_MODE_AF_INPUT, GPIO_PULLUP, GPIO_SPEED_FREQ_HIGH);\n}\n\nssize_t debugLinkTx(const uint8_t* data, size_t len) {\nif ((size_t)len &gt; sizeof(txDmaBuf))\nreturn -1;\n\nsize_t res = 0;\n\nif (isInInterrupt()) {\nBaseType_t woken = pdFALSE;\nconst auto status = taskENTER_CRITICAL_FROM_ISR();\nres = txUartStreamBuf.write((uint8_t*)data, len, 0, &amp;woken);\nusbTxFifo.writeSpan((uint8_t*)data, len);\ntaskEXIT_CRITICAL_FROM_ISR(status);\nportYIELD_FROM_ISR(woken);\n} else {\nwhile (txUartStreamBuf.freeSpace() &lt; len)\nvTaskDelay(0);\ntaskENTER_CRITICAL();\nres = txUartStreamBuf.write((uint8_t*)data, len, 0);\nusbTxFifo.writeSpan((uint8_t*)data, len);\ntaskEXIT_CRITICAL();\n}\n\nif (res == 0)\nreturn -1;\n\nHAL_NVIC_SetPendingIRQ(debugUartTxDmaIRQn);\nreturn res;\n}\n\nextern \"C\" int _write(int fd, char* data, int len) {\nreturn debugLinkTx((uint8_t*)data, len);\n}\n\ntemplate &lt;int Size&gt; static BaseType_t processRxBuf(ByteFifo&lt;Size&gt;&amp; fifo) {\nconst auto fifoAvailable = std::min(MaxLineLength, fifo.available());\n\nchar buf[MaxLineLength];\nfifo.peekSpan((uint8_t*)buf, fifoAvailable);\n\nBaseType_t pxHigherPriorityTaskWoken = pdFALSE;\n\nsize_t remaining = fifoAvailable;\nchar* start = buf;\nwhile (remaining != 0) {\nchar* end = (char*)memchr(start, '\\n', remaining);\nif (!end)\nbreak;\n\n*end = '\\0';\n++end;\n\nconst size_t len = end - start;\n\nif (!rxLineBuffer.push_back(\n(uint8_t*)start, len, 0, &amp;pxHigherPriorityTaskWoken)) {\nprintf(\"Not enough space in line buffer, try sending commands \"\n\"slower.\\n\");\n}\n\nremaining -= len;\nfifo.notifyRead(len);\nstart = end;\n}\nreturn pxHigherPriorityTaskWoken;\n}\n\nextern \"C\" void DEBUGUART_HANDLER(void) {\nint rxHead = uartRxFifo.size() - __HAL_DMA_GET_COUNTER(&amp;dmaRxHandle);\nuartRxFifo.setHead(rxHead);\nLL_USART_ClearFlag_IDLE(debugUart);\nportYIELD_FROM_ISR(processRxBuf(uartRxFifo));\n}\n\nextern \"C\" void DEBUGUART_TX_DMA_HANDLER() {\nHAL_DMA_IRQHandler(&amp;dmaTxHandle);\n\nif (dmaTxHandle.State == HAL_DMA_STATE_READY) {\nBaseType_t pxHigherPriorityTaskWoken = pdFALSE;\nconst auto len = txUartStreamBuf.read(\ntxDmaBuf.data(), txDmaBuf.size(), 0, &amp;pxHigherPriorityTaskWoken);\n\nif (len &gt; 0) {\nHAL_DMA_Start_IT(&amp;dmaTxHandle, uint32_t(txDmaBuf.data()),\nuint32_t(&amp;debugUart-&gt;DR), len);\n}\n\nportYIELD_FROM_ISR(pxHigherPriorityTaskWoken);\n}\n}\n\n#define COMMAND(name, ...)                                                     \\\n    if (strncmp(cmd, name \" \", sizeof(name)) == 0) {                           \\\n        cmd += sizeof(name);                                                   \\\n        __VA_ARGS__                                                            \\\n    }\n\nstatic void debugLinkHandleCommand(const char* cmd) {\nCOMMAND(\"diag\", {\nprintTaskInfo();\nreturn;\n});\n\nCOMMAND(\"power\", {\nCOMMAND(\"calibrate\", {\nCoprocReq req = {\n.which_payload = CoprocReq_calibratePower_tag,\n};\n\nif (sscanf(cmd, \"%lu %lu %lu %lu\",\n&amp;req.payload.calibratePower.vccMv,\n&amp;req.payload.calibratePower.battMidMv,\n&amp;req.payload.calibratePower.vRef33Mv,\n&amp;req.payload.calibratePower.temperatureC)\n!= 4) {\nprintf(\"Invalid parameters!\\n\");\nreturn;\n}\n\ndispatcherEnqueueRequest(req);\nreturn;\n});\n\nCOMMAND(\"info\", {\nprintf(\"Power info: VCC %d mV bMid: %dmV VRef: %d mv Temperature \"\n\"%d C\\n\",\npowerBatteryMv(), powerBatteryMidMv(), powerVrefMv(),\npowerTemperatureC());\nreturn;\n});\n});\n\nCOMMAND(\"motors\", {\nCOMMAND(\"pid\", {\nCoprocReq req = {\n.which_payload = CoprocReq_motorReq_tag,\n};\nreq.payload.motorReq.which_motorCmd\n= CoprocReq_MotorReq_setVelocityRegCoefs_tag;\nauto&amp; c = req.payload.motorReq.motorCmd.setVelocityRegCoefs;\nif (sscanf(cmd, \"%lu %lu %lu\", &amp;c.p, &amp;c.i, &amp;c.d) != 3) {\nprintf(\"Invalid parameters!\\n\");\nreturn;\n}\n\nfor (int m : { 0, 1, 2, 3 }) {\nreq.payload.motorReq.motorIndex = m;\ndispatcherEnqueueRequest(req);\n}\nreturn;\n});\n\nCOMMAND(\"power\", {\nCoprocReq req = {\n.which_payload = CoprocReq_motorReq_tag,\n};\nreq.payload.motorReq.which_motorCmd\n= CoprocReq_MotorReq_setPower_tag;\nauto&amp; c = req.payload.motorReq;\nif (sscanf(cmd, \"%lu %ld\", &amp;c.motorIndex, &amp;c.motorCmd.setPower)\n!= 2) {\nprintf(\"Invalid parameters!\\n\");\nreturn;\n}\n\ndispatcherEnqueueRequest(req);\nreturn;\n});\n\nCOMMAND(\"velocity\", {\nCoprocReq req = {\n.which_payload = CoprocReq_motorReq_tag,\n};\nreq.payload.motorReq.which_motorCmd\n= CoprocReq_MotorReq_setVelocity_tag;\nauto&amp; c = req.payload.motorReq;\nif (sscanf(cmd, \"%lu %ld\", &amp;c.motorIndex, &amp;c.motorCmd.setVelocity)\n!= 2) {\nprintf(\"Invalid parameters!\\n\");\nreturn;\n}\n\ndispatcherEnqueueRequest(req);\nreturn;\n});\n\nCOMMAND(\"position\", {\nCoprocReq req = {\n.which_payload = CoprocReq_motorReq_tag,\n};\nauto&amp; c = req.payload.motorReq;\nc.which_motorCmd = CoprocReq_MotorReq_setPosition_tag;\nif (sscanf(cmd, \"%lu %ld %ld\", &amp;c.motorIndex,\n&amp;c.motorCmd.setPosition.targetPosition,\n&amp;c.motorCmd.setPosition.runningVelocity)\n!= 3) {\nprintf(\"Invalid parameters!\\n\");\nreturn;\n}\n\ndispatcherEnqueueRequest(req);\nreturn;\n});\n});\n\nCOMMAND(\"leds\", {\nCOMMAND(\"set\", {\nuint32_t val = 0;\nif (sscanf(cmd, \"%lu\", &amp;val) != 1) {\nprintf(\"Invalid parameters!\\n\");\nreturn;\n}\nsetLeds(val);\nreturn;\n});\n});\n\nCOMMAND(\"buzzer\", {\nbuzzerSetState(!pinRead(buzzerPin));\nreturn;\n});\n\nCOMMAND(\"buttons\", {\nCOMMAND(\"debug\", {\nbuttonControllerSetDebug(true);\nreturn;\n});\n});\n\nCOMMAND(\"oled\", {\nCOMMAND(\"test\", {\nprintf(\"Oled test: %d\\n\", oledTestConnection());\nreturn;\n});\n\nCOMMAND(\"fill\", {\nCOMMAND(\"white\", {               oledFill(White);\noledUpdateScreen();\nprintf(\"OLED fill white\\n\");\nreturn;\n});\nCOMMAND(\"black\", {\noledFill(Black);\noledUpdateScreen();\nprintf(\"OLED fill black\\n\");\nreturn;\n});\n});\nCOMMAND(\"write\", {\noledSetCursor(0, 0);\noledWriteString(\"AHOJ\", Font_11x18, White);\noledUpdateScreen();\nprintf(\"OLED write\\n\");\nreturn;\n});\nCOMMAND(\"init\", {\nCoprocReq_OledInit req;\nreq.width = 128;\nreq.height = 64;\nreq.rotate = true;\nreq.inverseColor = false;\noledInit(req);\nprintf(\"OLED init\\n\");\nreturn;\n});\n});\n\nCOMMAND(\"mpu\", {\nCOMMAND(\"init\", {\nmpuInitialize();\nprintf(\"MPU init\\n\");\nreturn;\n});\nCOMMAND(\"test\", {\nprintf(\"MPU test: %d\\n\", mpu_testConnection());\nreturn;\n});\nCOMMAND(\"temp\", {\nprintf(\"MPU temp: %d\\n\", mpu_getTemperature());\nreturn;\n});\nCOMMAND(\"acc\", {\nint16_t x, y, z;\n// int32_t x, y, z;\nmpu_getAcceleration(&amp;x, &amp;y, &amp;z);\nprintf(\"MPU acc: x:%d, y:%d, z:%d\\n\", x, y, z);\nreturn;\n});\nCOMMAND(\"gyro\", {\nint16_t x, y, z;\n// int32_t x, y, z;\nmpu_getRotation(&amp;x, &amp;y, &amp;z);\nprintf(\"MPU gyro: x:%d, y:%d, z:%d\\n\", x, y, z);\nreturn;\n});\n});\n\nCOMMAND(\"i2c\", {\nCOMMAND(\"transmit\", {\nunsigned DevAddress;\nuint8_t pData[10];\nunsigned Size;\nif (sscanf(cmd, \"%u %u %u\", &amp;DevAddress, &amp;pData[0], &amp;Size) != 3) {\nprintf(\"Invalid parameters!\\n\");\nreturn;\n}\nprintf(\"I2C tran %d\\n\",\nI2Cdev_Master_Transmit(DevAddress, pData, Size, 0));\nreturn;\n});\n\nCOMMAND(\"receive\", {\nunsigned DevAddress;\nuint8_t pData[10];\nunsigned Size;\nif (sscanf(cmd, \"%u %u\", &amp;DevAddress, &amp;Size) != 2) {\nprintf(\"Invalid parameters!\\n\");\nreturn;\n}\nprintf(\"I2C rec %d; ret: %d\\n\",\nI2Cdev_Master_Receive(DevAddress, pData, Size, 0), pData[0]);\nreturn;\n});\n\nCOMMAND(\"ping\", {\nunsigned DevAddress;\nunsigned Trials;\nif (sscanf(cmd, \"%u %u\", &amp;DevAddress, &amp;Trials) != 2) {\nprintf(\"Invalid parameters!\\n\");\nreturn;\n}\nprintf(\"I2C ping %d\\n\",\nI2Cdev_IsDeviceReady(DevAddress, Trials) == HAL_OK);\nreturn;\n});\n\nCOMMAND(\"scan\", {\nprintf(\"I2C scanner %d\\n\", I2Cdev_scan());\nreturn;\n});\n});\n\nprintf(\"Invalid command.\\n\");\n}\n\nstatic void debugDownstreamHandler() {\nusbIrqPrioRaise.lock();\nconst int transferred = usbd_ep_read(\n&amp;udev, CDC_DEBUG_RXD_EP, usbFrameBuf.data(), usbFrameBuf.size());\nusbIrqPrioRaise.unlock();\n\nif (transferred &gt; 0) {\nusbRxFifo.writeSpan(usbFrameBuf.data(), transferred);\nprocessRxBuf(usbRxFifo);\n}\n}\n\nstatic void debugUpstreamHandler() {\nportDISABLE_INTERRUPTS();\nconst auto chunk = std::min(usbTxFifo.available(), usbFrameBuf.size());\nif (chunk != 0) {\nusbTxFifo.peekSpan(usbFrameBuf.data(), chunk);\nint transferred\n= usbd_ep_write(&amp;udev, CDC_DEBUG_TXD_EP, usbFrameBuf.data(), chunk);\nif (transferred &gt; 0) {\nusbTxFifo.notifyRead(transferred);\n}\n}\nportENABLE_INTERRUPTS();\n}\n\nvoid debugLinkPoll() {\nchar buf[MaxLineLength];\nif (rxLineBuffer.pop_front((uint8_t*)buf, MaxLineLength, 0)) {\ndebugLinkHandleCommand(buf);\n}\n\nif (cdcLinkIsDebugEpEnabled()) {\ndebugDownstreamHandler();\ndebugUpstreamHandler();\n}\n}\n</code></pre>"},{"location":"apiStm/Dispatcher_8cpp/","title":"File Dispatcher.cpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; src &gt; Dispatcher.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"Dispatcher.hpp\"</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"utils/Debug.hpp\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"BuzzerController.hpp\"</code></li> <li><code>#include \"ControlLink.hpp\"</code></li> <li><code>#include \"Esp32Manager.hpp\"</code></li> <li><code>#include \"I2cController.hpp\"</code></li> <li><code>#include \"MotorController.hpp\"</code></li> <li><code>#include \"Power.hpp\"</code></li> <li><code>#include \"SmartServoController.hpp\"</code></li> <li><code>#include \"StupidServoController.hpp\"</code></li> <li><code>#include \"UltrasoundController.hpp\"</code></li> <li><code>#include \"queue.h\"</code></li> <li><code>#include \"rbcx.pb.h\"</code></li> <li><code>#include \"utils/QueueWrapper.hpp\"</code></li> </ul>"},{"location":"apiStm/Dispatcher_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name QueueWrapper&lt; CoprocReq, 8 &gt; requestQueue QueueWrapper&lt; CoprocStat, 64 &gt; statusQueue"},{"location":"apiStm/Dispatcher_8cpp/#public-functions","title":"Public Functions","text":"Type Name bool dispatcherEnqueueRequest (const CoprocReq &amp; request)  bool dispatcherEnqueueStatus (const CoprocStat &amp; status)  void dispatcherInit ()  void dispatcherPoll ()  void dispatcherReset ()"},{"location":"apiStm/Dispatcher_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void dispatcherProcessReq (const CoprocReq &amp; request)  void sendButtonsStat ()  void sendVersionStat ()"},{"location":"apiStm/Dispatcher_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"apiStm/Dispatcher_8cpp/#variable-requestqueue","title":"variable requestQueue","text":"<pre><code>QueueWrapper&lt;CoprocReq, 8&gt; requestQueue;\n</code></pre>"},{"location":"apiStm/Dispatcher_8cpp/#variable-statusqueue","title":"variable statusQueue","text":"<pre><code>QueueWrapper&lt;CoprocStat, 64&gt; statusQueue;\n</code></pre>"},{"location":"apiStm/Dispatcher_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/Dispatcher_8cpp/#function-dispatcherenqueuerequest","title":"function dispatcherEnqueueRequest","text":"<pre><code>bool dispatcherEnqueueRequest (\nconst CoprocReq &amp; request\n) </code></pre>"},{"location":"apiStm/Dispatcher_8cpp/#function-dispatcherenqueuestatus","title":"function dispatcherEnqueueStatus","text":"<pre><code>bool dispatcherEnqueueStatus (\nconst CoprocStat &amp; status\n) </code></pre>"},{"location":"apiStm/Dispatcher_8cpp/#function-dispatcherinit","title":"function dispatcherInit","text":"<pre><code>void dispatcherInit () </code></pre>"},{"location":"apiStm/Dispatcher_8cpp/#function-dispatcherpoll","title":"function dispatcherPoll","text":"<pre><code>void dispatcherPoll () </code></pre>"},{"location":"apiStm/Dispatcher_8cpp/#function-dispatcherreset","title":"function dispatcherReset","text":"<pre><code>void dispatcherReset () </code></pre>"},{"location":"apiStm/Dispatcher_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"apiStm/Dispatcher_8cpp/#function-dispatcherprocessreq","title":"function dispatcherProcessReq","text":"<pre><code>static void dispatcherProcessReq (\nconst CoprocReq &amp; request\n) </code></pre>"},{"location":"apiStm/Dispatcher_8cpp/#function-sendbuttonsstat","title":"function sendButtonsStat","text":"<pre><code>static void sendButtonsStat () </code></pre>"},{"location":"apiStm/Dispatcher_8cpp/#function-sendversionstat","title":"function sendVersionStat","text":"<pre><code>static void sendVersionStat () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/Dispatcher.cpp</code></p>"},{"location":"apiStm/Dispatcher_8cpp_source/","title":"File Dispatcher.cpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; src &gt; Dispatcher.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"Dispatcher.hpp\"\n#include \"FreeRTOS.h\"\n#include \"utils/Debug.hpp\"\n\n#include \"Bsp.hpp\"\n#include \"BuzzerController.hpp\"\n#include \"ControlLink.hpp\"\n#include \"Esp32Manager.hpp\"\n#include \"I2cController.hpp\"\n#include \"MotorController.hpp\"\n#include \"Power.hpp\"\n#include \"SmartServoController.hpp\"\n#include \"StupidServoController.hpp\"\n#include \"UltrasoundController.hpp\"\n#include \"queue.h\"\n#include \"rbcx.pb.h\"\n#include \"utils/QueueWrapper.hpp\"\n\nstatic QueueWrapper&lt;CoprocStat, 64&gt; statusQueue;\nstatic QueueWrapper&lt;CoprocReq, 8&gt; requestQueue;\n\nvoid dispatcherInit() {\nstatusQueue.create();\nrequestQueue.create();\n}\n\nbool dispatcherEnqueueStatus(const CoprocStat&amp; status) {\nBaseType_t pxHigherPriorityTaskWoken = pdFALSE;\nauto ok = statusQueue.push_back(status, 0, &amp;pxHigherPriorityTaskWoken);\nif (!ok) {\nDEBUG(\"Status queue overflow\\n\");\n}\nportYIELD_FROM_ISR(pxHigherPriorityTaskWoken);\nreturn ok;\n}\n\nbool dispatcherEnqueueRequest(const CoprocReq&amp; request) {\nBaseType_t pxHigherPriorityTaskWoken = pdFALSE;\nauto ok = requestQueue.push_back(request, 0, &amp;pxHigherPriorityTaskWoken);\nif (!ok) {\nDEBUG(\"Request queue overflow\\n\");\n}\nportYIELD_FROM_ISR(pxHigherPriorityTaskWoken);\nreturn ok;\n}\n\nstatic void sendButtonsStat() {\nCoprocStat status = {\n.which_payload = CoprocStat_buttonsStat_tag,\n};\nstatus.payload.buttonsStat.buttonsPressed\n= CoprocStat_ButtonsEnum(getButtons());\ncontrolLinkTx(status);\n}\n\nstatic void sendVersionStat() {\nCoprocStat status = {\n.which_payload = CoprocStat_versionStat_tag,\n};\n\nauto&amp; v = status.payload.versionStat;\n\nstatic_assert(sizeof(v.revision) == 8);\nstatic_assert(sizeof(RBCX_VER_REVISION) == 9); // + NULL byte\nmemcpy(v.revision, RBCX_VER_REVISION, 8);\n\nv.dirty = RBCX_VER_DIRTY;\nv.number = RBCX_VER_NUMBER;\ncontrolLinkTx(status);\n}\n\nstatic void dispatcherProcessReq(const CoprocReq&amp; request) {\nswitch (request.which_payload) {\ncase CoprocReq_setLeds_tag: {\nsetLeds(request.payload.setLeds.ledsOn);\nconst CoprocStat status = {\n.which_payload = CoprocStat_ledsStat_tag,\n};\ncontrolLinkTx(status);\nbreak;\n}\ncase CoprocReq_getButtons_tag:\nsendButtonsStat();\nbreak;\ncase CoprocReq_setStupidServo_tag:\nstupidServoDispatch(request.payload.setStupidServo);\nbreak;\ncase CoprocReq_ultrasoundReq_tag:\nultrasoundDispatch(request.payload.ultrasoundReq);\nbreak;\ncase CoprocReq_buzzerReq_tag:\nbuzzerSetState(request.payload.buzzerReq.on);\nbuzzerSetState(request.payload.buzzerReq.on);\nbreak;\ncase CoprocReq_versionReq_tag:\nsendVersionStat();\nbreak;\ncase CoprocReq_calibratePower_tag: {\nconst auto&amp; c = request.payload.calibratePower;\npowerCalibrate(c.vccMv, c.battMidMv, c.vRef33Mv, c.temperatureC);\nbreak;\n}\ncase CoprocReq_shutdownPower_tag:\npowerShutDown();\nbreak;\ncase CoprocReq_motorReq_tag:\nmotorDispatch(request.payload.motorReq);\nbreak;\ncase CoprocReq_i2cReq_tag:\ni2cDispatch(request.payload.i2cReq);\nbreak;\ncase CoprocReq_espWatchdogSettings_tag:\nsEsp32Manager.handleSettings(request.payload.espWatchdogSettings);\nbreak;\ncase CoprocReq_coprocStartupMessage_tag: {\nconst auto&amp; m = request.payload.coprocStartupMessage;\nif (m.getButtons) {\nsendButtonsStat();\n}\nif (m.getVersion) {\nsendVersionStat();\n}\nif (m.getRtc) {\n// TODO RTC not yet implemented\n}\nif (m.has_espWatchdogSettings) {\nsEsp32Manager.handleSettings(m.espWatchdogSettings);\n}\nbreak;\n}\ncase CoprocReq_smartServoReq_tag:\nsmartServoSendRequest(request.payload.smartServoReq);\nbreak;\n}\n}\n\nvoid dispatcherPoll() {\nCoprocReq request;\nCoprocStat status;\n\nif (controlLinkRx(request)) {\nsEsp32Manager.resetWatchdog();\ndispatcherProcessReq(request);\n}\n\nif (requestQueue.pop_front(request, 0)) {\ndispatcherProcessReq(request);\n}\n\nif (statusQueue.pop_front(status, 0)) {\ncontrolLinkTx(status);\n}\n}\n\nvoid dispatcherReset() {\nrequestQueue.reset();\nstatusQueue.reset();\n}\n</code></pre>"},{"location":"apiStm/Esp32Manager_8cpp/","title":"File Esp32Manager.cpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; src &gt; Esp32Manager.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"stm32f1xx_hal.h\"</code></li> <li><code>#include \"stm32f1xx_hal_gpio.h\"</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"task.h\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"utils/Debug.hpp\"</code></li> <li><code>#include \"Esp32Manager.hpp\"</code></li> </ul>"},{"location":"apiStm/Esp32Manager_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name Esp32Manager sEsp32Manager"},{"location":"apiStm/Esp32Manager_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr uint32_t Esp32WatchdogTimeoutMs   = = 150"},{"location":"apiStm/Esp32Manager_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/Esp32Manager_8cpp/#variable-sesp32manager","title":"variable sEsp32Manager","text":"<pre><code>Esp32Manager sEsp32Manager;\n</code></pre>"},{"location":"apiStm/Esp32Manager_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"apiStm/Esp32Manager_8cpp/#variable-esp32watchdogtimeoutms","title":"variable Esp32WatchdogTimeoutMs","text":"<pre><code>constexpr uint32_t Esp32WatchdogTimeoutMs;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/Esp32Manager.cpp</code></p>"},{"location":"apiStm/Esp32Manager_8cpp_source/","title":"File Esp32Manager.cpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; src &gt; Esp32Manager.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"stm32f1xx_hal.h\"\n#include \"stm32f1xx_hal_gpio.h\"\n\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n\n#include \"Bsp.hpp\"\n#include \"utils/Debug.hpp\"\n\n#include \"Esp32Manager.hpp\"\n\n// https://github.com/espressif/esptool/blob/4a1e87d290e9ba2870b4d092baf7b9ae15e4095d/esptool.py#L469\n\n// Bootloader\n// [   1441314][src/UsbCdcLink.c:205]: CONTROL_LINE_STATE DTR 0 RTS 1 &lt;-- 0\n// [   1441414][src/UsbCdcLink.c:205]: CONTROL_LINE_STATE DTR 1 RTS 1 &lt;-- 1\n// [   1441415][src/UsbCdcLink.c:205]: CONTROL_LINE_STATE DTR 1 RTS 0 &lt;-- 2\n// [   1441465][src/UsbCdcLink.c:205]: CONTROL_LINE_STATE DTR 0 RTS 0\n\n// Reboot\n//                                    (don't care)          DTR 0       &lt;-- 0\n// [    444506][src/UsbCdcLink.cpp:205]: CONTROL_LINE_STATE DTR 0 RTS 1 &lt;-- 1\n// [    444607][src/UsbCdcLink.cpp:205]: CONTROL_LINE_STATE DTR 0 RTS 0 &lt;-- 2\n\nstatic constexpr uint32_t Esp32WatchdogTimeoutMs = 150;\n\nEsp32Manager sEsp32Manager;\n\nEsp32Manager::Esp32Manager()\n: m_enPinHolders {}\n, m_queuedReset(RstNormal)\n, m_previousEnEdge(false)\n, m_inBootloader(false)\n, m_watchdogInhibit(true) {}\n\nEsp32Manager::~Esp32Manager() {}\n\nvoid Esp32Manager::init() {\npinInit(espEnPin, GPIO_MODE_INPUT, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW);\nm_previousEnEdge = pinRead(espEnPin);\n}\n\nvoid Esp32Manager::poll() {\nif (m_queuedReset != RstNone) {\nholdReset(EnSwReset);\nreleaseReset(EnSwReset, m_queuedReset == RstBootloader);\nm_queuedReset = RstNone;\n}\n\nif (m_unstrapTimer.poll()) {\nunstrapPins();\n}\n\nif (m_checkBreakTimer.poll()) {\nif (m_lastRts &amp;&amp; !m_lastDtr) {\nholdReset(EnSerialBreaks);\n} else {\nreleaseReset(EnSerialBreaks, m_lastDtr &amp;&amp; !m_lastRts);\n}\n}\n\nif (!m_watchdogInhibit &amp;&amp; m_watchdogTimer.poll() &amp;&amp; !m_inBootloader\n&amp;&amp; m_previousEnEdge &amp;&amp; m_enPinHolders == 0) {\nDEBUG(\"Esp32 watchdog timed out, resetting.\\n\");\nqueueReset();\n}\n}\n\nvoid Esp32Manager::holdReset(EnHolderType typ) {\nif (m_enPinHolders == 0) {\npinInit(espEnPin, GPIO_MODE_OUTPUT_OD, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW,\ntrue);\npinWrite(espEnPin, 0);\nsoftReset();\n}\nm_enPinHolders |= (1 &lt;&lt; typ);\n}\n\nvoid Esp32Manager::releaseReset(EnHolderType typ, bool strapForBootloader) {\nconst uint32_t mask = (1 &lt;&lt; typ);\nif (m_enPinHolders == mask) {\nstrapPins(strapForBootloader);\npinInit(espEnPin, GPIO_MODE_IT_RISING_FALLING, GPIO_NOPULL,\nGPIO_SPEED_FREQ_LOW, true);\nm_unstrapTimer.restart(2);\n}\nm_enPinHolders &amp;= ~mask;\n}\n\nvoid Esp32Manager::queueReset(bool bootloader) {\nm_queuedReset = !bootloader ? RstNormal : RstBootloader;\n}\n\nvoid Esp32Manager::strapPins(bool bootloader) {\n//DEBUG(\"Straping pins, bootloader: %d\\n\", bootloader);\npinInit(esp0Pin, GPIO_MODE_OUTPUT_OD, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW);\npinInit(esp12Pin, GPIO_MODE_OUTPUT_PP, GPIO_NOPULL,\nGPIO_SPEED_FREQ_LOW); // TODO: set pin 12 to OD on RBCX v1.1, v1.0 has HW bug\npinInit(esp15Pin, GPIO_MODE_OUTPUT_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW);\n\npinWrite(esp12Pin, 0); // 3.3v flash\npinWrite(esp15Pin, 1); // Do not silence bootloader messages\n\nif (!bootloader) {\npinWrite(esp0Pin, 1); // normal\n} else {\npinWrite(esp0Pin, 0); // bootloader\n\npinInit(esp2Pin, GPIO_MODE_OUTPUT_OD, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW);\npinWrite(esp2Pin, 0); // bootloader confirm\n}\n\nm_inBootloader = bootloader;\n\nif (bootloader) {\nm_watchdogTimer.stop();\n} else {\nm_watchdogTimer.restart(Esp32WatchdogTimeoutMs * 5);\n}\n}\n\nvoid Esp32Manager::unstrapPins() { reinitEspStrappingPins(); }\n\nvoid Esp32Manager::onEnRisingInIrq() {\nconst bool currentEdge = pinRead(espEnPin);\nif (currentEdge &amp;&amp; !m_previousEnEdge &amp;&amp; m_enPinHolders == 0) {\nqueueReset(m_lastDtr &amp;&amp; !m_lastRts);\n} else if (!currentEdge &amp;&amp; m_previousEnEdge) {\nsoftReset();\n}\nm_previousEnEdge = currentEdge;\n}\n\nvoid Esp32Manager::onSerialBreakInIrq(bool dtr, bool rts) {\nm_lastDtr = dtr;\nm_lastRts = rts;\nm_checkBreakTimer.restart(25);\n}\n\nvoid Esp32Manager::resetWatchdog() {\nm_watchdogTimer.restart(Esp32WatchdogTimeoutMs);\n}\n\nvoid Esp32Manager::setWatchdogInhibit(bool inhibit) {\nif (CoreDebug-&gt;DHCSR &amp; CoreDebug_DHCSR_C_DEBUGEN_Msk) {\nDEBUG(\"Watchdog is always inhibited with debugger attached, ignoring \"\n\"setWatchdogInhibit\\n\");\nm_watchdogInhibit = true;\n} else {\nm_watchdogInhibit = inhibit;\n}\n}\n\nvoid Esp32Manager::handleSettings(\nconst CoprocReq_EspWatchdogSettings&amp; settings) {\nsetWatchdogInhibit(settings.disable);\n}\n</code></pre>"},{"location":"apiStm/FreeRTOSCallbacks_8cpp/","title":"File FreeRTOSCallbacks.cpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; src &gt; FreeRTOSCallbacks.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"stm32f1xx_hal.h\"</code></li> <li><code>#include \"stm32f1xx_ll_utils.h\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"task.h\"</code></li> </ul>"},{"location":"apiStm/FreeRTOSCallbacks_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name StackType_t idleTaskStack StaticTask_t idleTaskStruct"},{"location":"apiStm/FreeRTOSCallbacks_8cpp/#public-functions","title":"Public Functions","text":"Type Name void _exit ()  void vApplicationGetIdleTaskMemory (StaticTask_t ** ppxIdleTaskTCBBuffer, StackType_t ** ppxIdleTaskStackBuffer, uint32_t * pulIdleTaskStackSize)  void vApplicationStackOverflowHook (TaskHandle_t xTask, signed char * pcTaskName)  void vApplicationTickHook ()"},{"location":"apiStm/FreeRTOSCallbacks_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"apiStm/FreeRTOSCallbacks_8cpp/#variable-idletaskstack","title":"variable idleTaskStack","text":"<pre><code>StackType_t idleTaskStack[configMINIMAL_STACK_SIZE];\n</code></pre>"},{"location":"apiStm/FreeRTOSCallbacks_8cpp/#variable-idletaskstruct","title":"variable idleTaskStruct","text":"<pre><code>StaticTask_t idleTaskStruct;\n</code></pre>"},{"location":"apiStm/FreeRTOSCallbacks_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/FreeRTOSCallbacks_8cpp/#function-_exit","title":"function _exit","text":"<pre><code>void _exit () </code></pre>"},{"location":"apiStm/FreeRTOSCallbacks_8cpp/#function-vapplicationgetidletaskmemory","title":"function vApplicationGetIdleTaskMemory","text":"<pre><code>void vApplicationGetIdleTaskMemory (\nStaticTask_t ** ppxIdleTaskTCBBuffer,\nStackType_t ** ppxIdleTaskStackBuffer,\nuint32_t * pulIdleTaskStackSize\n) </code></pre>"},{"location":"apiStm/FreeRTOSCallbacks_8cpp/#function-vapplicationstackoverflowhook","title":"function vApplicationStackOverflowHook","text":"<pre><code>void vApplicationStackOverflowHook (\nTaskHandle_t xTask,\nsigned char * pcTaskName\n) </code></pre>"},{"location":"apiStm/FreeRTOSCallbacks_8cpp/#function-vapplicationtickhook","title":"function vApplicationTickHook","text":"<pre><code>void vApplicationTickHook () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/FreeRTOSCallbacks.cpp</code></p>"},{"location":"apiStm/FreeRTOSCallbacks_8cpp_source/","title":"File FreeRTOSCallbacks.cpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; src &gt; FreeRTOSCallbacks.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"stm32f1xx_hal.h\"\n#include \"stm32f1xx_ll_utils.h\"\n\n#include \"Bsp.hpp\"\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n\nstatic StaticTask_t idleTaskStruct;\nstatic StackType_t idleTaskStack[configMINIMAL_STACK_SIZE];\n\n// While timeouts in LL functions rely on having milliseconds in SYSTICK,\n// timeouts in HAL functions require incrementing the uwTick variable:\nextern \"C\" void vApplicationTickHook() { HAL_IncTick(); }\n\nextern \"C\" void vApplicationGetIdleTaskMemory(\nStaticTask_t** ppxIdleTaskTCBBuffer, StackType_t** ppxIdleTaskStackBuffer,\nuint32_t* pulIdleTaskStackSize) {\n*ppxIdleTaskTCBBuffer = &amp;idleTaskStruct;\n*ppxIdleTaskStackBuffer = idleTaskStack;\n*pulIdleTaskStackSize = sizeof(idleTaskStack) / sizeof(StackType_t);\n}\n\n#if configUSE_TIMERS\nstatic StaticTask_t timerTaskStruct;\nstatic StackType_t timerTaskStack[configTIMER_TASK_STACK_DEPTH];\n\nextern \"C\" void vApplicationGetTimerTaskMemory(\nStaticTask_t** ppxIdleTaskTCBBuffer, StackType_t** ppxIdleTaskStackBuffer,\nuint32_t* pulIdleTaskStackSize) {\n*ppxIdleTaskTCBBuffer = &amp;timerTaskStruct;\n*ppxIdleTaskStackBuffer = timerTaskStack;\n*pulIdleTaskStackSize = sizeof(timerTaskStack) / sizeof(StackType_t);\n}\n#endif\n\nextern \"C\" void vApplicationStackOverflowHook(\nTaskHandle_t xTask, signed char* pcTaskName) {\nprintf(\"Stack overflow!\\n\");\nprintf(\"Task: %s\\n\", pcTaskName);\n\nabort();\n}\n\nextern \"C\" void _exit() {\nsoftReset();\n\nLL_mDelay(10);\nputs(\"\\n\\n !!! PROGRAM EXITED, HALTING !!!\\n\\n\");\nLL_mDelay(10);\n\n__disable_irq();\n\nuint32_t on = 0xFFFFFFF;\nwhile (true) {\nsetLeds(on);\non = ~on;\n\n// Triggers when STLink is connected, there doesn't seem to be a way\n// to check if a debugging session is in progress :/\nif (CoreDebug-&gt;DHCSR &amp; CoreDebug_DHCSR_C_DEBUGEN_Msk) {\n__BKPT();\n}\n\nLL_mDelay(200);\n}\n}\n</code></pre>"},{"location":"apiStm/I2cController_8cpp/","title":"File I2cController.cpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; src &gt; I2cController.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"I2cController.hpp\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"MpuController.hpp\"</code></li> <li><code>#include \"OledController.hpp\"</code></li> <li><code>#include \"utils/Debug.hpp\"</code></li> <li><code>#include \"utils/MutexWrapper.hpp\"</code></li> <li><code>#include \"utils/QueueWrapper.hpp\"</code></li> <li><code>#include \"utils/TaskWrapper.hpp\"</code></li> <li><code>#include \"timers.h\"</code></li> <li><code>#include &lt;mutex&gt;</code></li> </ul>"},{"location":"apiStm/I2cController_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name I2C_HandleTypeDef I2Cdev_hi2c uint16_t I2Cdev_readTimeout   = = I2CDEV_DEFAULT_READ_TIMEOUT EventGroupHandle_t i2cEventGroup TaskHandle_t i2cTaskHandle"},{"location":"apiStm/I2cController_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name xTaskHandle i2cCallingTask StaticEventGroup_t i2cEventBuffer MutexWrapper i2cMutex QueueWrapper&lt; CoprocReq_I2cReq, 16 &gt; i2cQueue TaskWrapper&lt; 1024 &gt; i2cTask"},{"location":"apiStm/I2cController_8cpp/#public-functions","title":"Public Functions","text":"Type Name __weak void HAL_I2C_ErrorCallback (I2C_HandleTypeDef * hi2c)  __weak void HAL_I2C_MasterRxCpltCallback (I2C_HandleTypeDef * hi2c)  __weak void HAL_I2C_MasterTxCpltCallback (I2C_HandleTypeDef * hi2c)  __weak void HAL_I2C_MemRxCpltCallback (I2C_HandleTypeDef * hi2c)  __weak void HAL_I2C_MemTxCpltCallback (I2C_HandleTypeDef * hi2c)  void I2C1_ER_IRQHandler ()  void I2C1_EV_IRQHandler ()  uint8_t I2Cdev_IsDeviceReady (uint16_t DevAddress, uint32_t Trials, uint32_t Timeout)  uint8_t I2Cdev_Master_Receive (uint16_t DevAddress, uint8_t * pData, uint16_t Size, uint32_t Timeout)  uint8_t I2Cdev_Master_Transmit (uint16_t DevAddress, uint8_t * pData, uint16_t Size, uint32_t Timeout)  uint8_t I2Cdev_Mem_Read (uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t * pData, uint16_t Size, uint32_t Timeout)  uint8_t I2Cdev_Mem_Write (uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t * pData, uint16_t Size, uint32_t Timeout)  uint8_t I2Cdev_init ()  uint8_t I2Cdev_readBit (uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t * data, uint16_t timeout)  uint8_t I2Cdev_readBitW (uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint16_t * data, uint16_t timeout)  uint8_t I2Cdev_readBits (uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t * data, uint16_t timeout)  uint8_t I2Cdev_readBitsW (uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint16_t * data, uint16_t timeout)  uint8_t I2Cdev_readByte (uint8_t devAddr, uint8_t regAddr, uint8_t * data, uint16_t timeout)  uint8_t I2Cdev_readBytes (uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t * data, uint16_t timeout)  uint8_t I2Cdev_readWord (uint8_t devAddr, uint8_t regAddr, uint16_t * data, uint16_t timeout)  uint8_t I2Cdev_readWords (uint8_t devAddr, uint8_t regAddr, uint8_t length, uint16_t * data, uint16_t timeout)  uint8_t I2Cdev_scan ()  uint16_t I2Cdev_writeBit (uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data)  uint16_t I2Cdev_writeBitW (uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint16_t data)  uint16_t I2Cdev_writeBits (uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data)  uint16_t I2Cdev_writeBitsW (uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint16_t data)  uint16_t I2Cdev_writeByte (uint8_t devAddr, uint8_t regAddr, uint8_t data)  uint16_t I2Cdev_writeBytes (uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t * pData)  uint16_t I2Cdev_writeWord (uint8_t devAddr, uint8_t regAddr, uint16_t data)  uint16_t I2Cdev_writeWords (uint8_t devAddr, uint8_t regAddr, uint8_t length, uint16_t * data)  void i2cDispatch (const CoprocReq_I2cReq &amp; req)  void i2cNotify ()  void i2cReset ()  uint8_t i2cWait (HAL_StatusTypeDef beginStatus, uint32_t tout)  uint8_t i2cWrap (F fun, uint32_t Timeout)"},{"location":"apiStm/I2cController_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/I2cController_8cpp/#variable-i2cdev_hi2c","title":"variable I2Cdev_hi2c","text":"<pre><code>I2C_HandleTypeDef I2Cdev_hi2c;\n</code></pre>"},{"location":"apiStm/I2cController_8cpp/#variable-i2cdev_readtimeout","title":"variable I2Cdev_readTimeout","text":"<pre><code>uint16_t I2Cdev_readTimeout;\n</code></pre> <p>Default timeout value for read operations. Set this to 0 to disable timeout detection. </p>"},{"location":"apiStm/I2cController_8cpp/#variable-i2ceventgroup","title":"variable i2cEventGroup","text":"<pre><code>EventGroupHandle_t i2cEventGroup;\n</code></pre>"},{"location":"apiStm/I2cController_8cpp/#variable-i2ctaskhandle","title":"variable i2cTaskHandle","text":"<pre><code>TaskHandle_t i2cTaskHandle;\n</code></pre>"},{"location":"apiStm/I2cController_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"apiStm/I2cController_8cpp/#variable-i2ccallingtask","title":"variable i2cCallingTask","text":"<pre><code>xTaskHandle i2cCallingTask;\n</code></pre>"},{"location":"apiStm/I2cController_8cpp/#variable-i2ceventbuffer","title":"variable i2cEventBuffer","text":"<pre><code>StaticEventGroup_t i2cEventBuffer;\n</code></pre>"},{"location":"apiStm/I2cController_8cpp/#variable-i2cmutex","title":"variable i2cMutex","text":"<pre><code>MutexWrapper i2cMutex;\n</code></pre>"},{"location":"apiStm/I2cController_8cpp/#variable-i2cqueue","title":"variable i2cQueue","text":"<pre><code>QueueWrapper&lt;CoprocReq_I2cReq, 16&gt; i2cQueue;\n</code></pre>"},{"location":"apiStm/I2cController_8cpp/#variable-i2ctask","title":"variable i2cTask","text":"<pre><code>TaskWrapper&lt;1024&gt; i2cTask;\n</code></pre>"},{"location":"apiStm/I2cController_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/I2cController_8cpp/#function-hal_i2c_errorcallback","title":"function HAL_I2C_ErrorCallback","text":"<pre><code>__weak void HAL_I2C_ErrorCallback (\nI2C_HandleTypeDef * hi2c\n) </code></pre>"},{"location":"apiStm/I2cController_8cpp/#function-hal_i2c_masterrxcpltcallback","title":"function HAL_I2C_MasterRxCpltCallback","text":"<pre><code>__weak void HAL_I2C_MasterRxCpltCallback (\nI2C_HandleTypeDef * hi2c\n) </code></pre>"},{"location":"apiStm/I2cController_8cpp/#function-hal_i2c_mastertxcpltcallback","title":"function HAL_I2C_MasterTxCpltCallback","text":"<pre><code>__weak void HAL_I2C_MasterTxCpltCallback (\nI2C_HandleTypeDef * hi2c\n) </code></pre>"},{"location":"apiStm/I2cController_8cpp/#function-hal_i2c_memrxcpltcallback","title":"function HAL_I2C_MemRxCpltCallback","text":"<pre><code>__weak void HAL_I2C_MemRxCpltCallback (\nI2C_HandleTypeDef * hi2c\n) </code></pre>"},{"location":"apiStm/I2cController_8cpp/#function-hal_i2c_memtxcpltcallback","title":"function HAL_I2C_MemTxCpltCallback","text":"<pre><code>__weak void HAL_I2C_MemTxCpltCallback (\nI2C_HandleTypeDef * hi2c\n) </code></pre>"},{"location":"apiStm/I2cController_8cpp/#function-i2c1_er_irqhandler","title":"function I2C1_ER_IRQHandler","text":"<pre><code>void I2C1_ER_IRQHandler () </code></pre>"},{"location":"apiStm/I2cController_8cpp/#function-i2c1_ev_irqhandler","title":"function I2C1_EV_IRQHandler","text":"<pre><code>void I2C1_EV_IRQHandler () </code></pre>"},{"location":"apiStm/I2cController_8cpp/#function-i2cdev_isdeviceready","title":"function I2Cdev_IsDeviceReady","text":"<pre><code>uint8_t I2Cdev_IsDeviceReady (\nuint16_t DevAddress,\nuint32_t Trials,\nuint32_t Timeout\n) </code></pre>"},{"location":"apiStm/I2cController_8cpp/#function-i2cdev_master_receive","title":"function I2Cdev_Master_Receive","text":"<pre><code>uint8_t I2Cdev_Master_Receive (\nuint16_t DevAddress,\nuint8_t * pData,\nuint16_t Size,\nuint32_t Timeout\n) </code></pre>"},{"location":"apiStm/I2cController_8cpp/#function-i2cdev_master_transmit","title":"function I2Cdev_Master_Transmit","text":"<pre><code>uint8_t I2Cdev_Master_Transmit (\nuint16_t DevAddress,\nuint8_t * pData,\nuint16_t Size,\nuint32_t Timeout\n) </code></pre>"},{"location":"apiStm/I2cController_8cpp/#function-i2cdev_mem_read","title":"function I2Cdev_Mem_Read","text":"<pre><code>uint8_t I2Cdev_Mem_Read (\nuint16_t DevAddress,\nuint16_t MemAddress,\nuint16_t MemAddSize,\nuint8_t * pData,\nuint16_t Size,\nuint32_t Timeout\n) </code></pre>"},{"location":"apiStm/I2cController_8cpp/#function-i2cdev_mem_write","title":"function I2Cdev_Mem_Write","text":"<pre><code>uint8_t I2Cdev_Mem_Write (\nuint16_t DevAddress,\nuint16_t MemAddress,\nuint16_t MemAddSize,\nuint8_t * pData,\nuint16_t Size,\nuint32_t Timeout\n) </code></pre>"},{"location":"apiStm/I2cController_8cpp/#function-i2cdev_init","title":"function I2Cdev_init","text":"<pre><code>uint8_t I2Cdev_init () </code></pre>"},{"location":"apiStm/I2cController_8cpp/#function-i2cdev_readbit","title":"function I2Cdev_readBit","text":"<pre><code>uint8_t I2Cdev_readBit (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitNum,\nuint8_t * data,\nuint16_t timeout\n) </code></pre> <p>Read a single bit from an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to read from </li> <li><code>bitNum</code> Bit position to read (0-7) </li> <li><code>data</code> Container for single bit value </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Status of read operation (true = success) </p>"},{"location":"apiStm/I2cController_8cpp/#function-i2cdev_readbitw","title":"function I2Cdev_readBitW","text":"<pre><code>uint8_t I2Cdev_readBitW (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitNum,\nuint16_t * data,\nuint16_t timeout\n) </code></pre> <p>Read a single bit from a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to read from </li> <li><code>bitNum</code> Bit position to read (0-15) </li> <li><code>data</code> Container for single bit value </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Status of read operation (true = success) </p>"},{"location":"apiStm/I2cController_8cpp/#function-i2cdev_readbits","title":"function I2Cdev_readBits","text":"<pre><code>uint8_t I2Cdev_readBits (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitStart,\nuint8_t length,\nuint8_t * data,\nuint16_t timeout\n) </code></pre> <p>Read multiple bits from an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to read from </li> <li><code>bitStart</code> First bit position to read (0-7) </li> <li><code>length</code> Number of bits to read (not more than 8) </li> <li><code>data</code> Container for right-aligned value (i.e. '101' read from any bitStart position will equal 0x05) </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Status of read operation (true = success) </p>"},{"location":"apiStm/I2cController_8cpp/#function-i2cdev_readbitsw","title":"function I2Cdev_readBitsW","text":"<pre><code>uint8_t I2Cdev_readBitsW (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitStart,\nuint8_t length,\nuint16_t * data,\nuint16_t timeout\n) </code></pre> <p>Read multiple bits from a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to read from </li> <li><code>bitStart</code> First bit position to read (0-15) </li> <li><code>length</code> Number of bits to read (not more than 16) </li> <li><code>data</code> Container for right-aligned value (i.e. '101' read from any bitStart position will equal 0x05) </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Status of read operation (1 = success, 0 = failure, -1 = timeout) </p>"},{"location":"apiStm/I2cController_8cpp/#function-i2cdev_readbyte","title":"function I2Cdev_readByte","text":"<pre><code>uint8_t I2Cdev_readByte (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t * data,\nuint16_t timeout\n) </code></pre> <p>Read single byte from an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to read from </li> <li><code>data</code> Container for byte value read from device </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Status of read operation (true = success) </p>"},{"location":"apiStm/I2cController_8cpp/#function-i2cdev_readbytes","title":"function I2Cdev_readBytes","text":"<pre><code>uint8_t I2Cdev_readBytes (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t length,\nuint8_t * data,\nuint16_t timeout\n) </code></pre> <p>Read multiple bytes from an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> First register regAddr to read from </li> <li><code>length</code> Number of bytes to read </li> <li><code>data</code> Buffer to store read data in </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Number of bytes read (-1 indicates failure) </p>"},{"location":"apiStm/I2cController_8cpp/#function-i2cdev_readword","title":"function I2Cdev_readWord","text":"<pre><code>uint8_t I2Cdev_readWord (\nuint8_t devAddr,\nuint8_t regAddr,\nuint16_t * data,\nuint16_t timeout\n) </code></pre> <p>Read single word from a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to read from </li> <li><code>data</code> Container for word value read from device </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Status of read operation (true = success) </p>"},{"location":"apiStm/I2cController_8cpp/#function-i2cdev_readwords","title":"function I2Cdev_readWords","text":"<pre><code>uint8_t I2Cdev_readWords (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t length,\nuint16_t * data,\nuint16_t timeout\n) </code></pre> <p>Read multiple words from a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> First register regAddr to read from </li> <li><code>length</code> Number of words to read </li> <li><code>data</code> Buffer to store read data in </li> <li><code>timeout</code> Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev_readTimeout) </li> </ul> <p>Returns:</p> <p>Number of words read (-1 indicates failure) </p>"},{"location":"apiStm/I2cController_8cpp/#function-i2cdev_scan","title":"function I2Cdev_scan","text":"<pre><code>uint8_t I2Cdev_scan () </code></pre>"},{"location":"apiStm/I2cController_8cpp/#function-i2cdev_writebit","title":"function I2Cdev_writeBit","text":"<pre><code>uint16_t I2Cdev_writeBit (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitNum,\nuint8_t data\n) </code></pre> <p>write a single bit in an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to write to </li> <li><code>bitNum</code> Bit position to write (0-7) </li> <li><code>value</code> New bit value to write </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"apiStm/I2cController_8cpp/#function-i2cdev_writebitw","title":"function I2Cdev_writeBitW","text":"<pre><code>uint16_t I2Cdev_writeBitW (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitNum,\nuint16_t data\n) </code></pre> <p>write a single bit in a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to write to </li> <li><code>bitNum</code> Bit position to write (0-15) </li> <li><code>value</code> New bit value to write </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"apiStm/I2cController_8cpp/#function-i2cdev_writebits","title":"function I2Cdev_writeBits","text":"<pre><code>uint16_t I2Cdev_writeBits (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitStart,\nuint8_t length,\nuint8_t data\n) </code></pre> <p>Write multiple bits in an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to write to </li> <li><code>bitStart</code> First bit position to write (0-7) </li> <li><code>length</code> Number of bits to write (not more than 8) </li> <li><code>data</code> Right-aligned value to write </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"apiStm/I2cController_8cpp/#function-i2cdev_writebitsw","title":"function I2Cdev_writeBitsW","text":"<pre><code>uint16_t I2Cdev_writeBitsW (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t bitStart,\nuint8_t length,\nuint16_t data\n) </code></pre> <p>Write multiple bits in a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register regAddr to write to </li> <li><code>bitStart</code> First bit position to write (0-15) </li> <li><code>length</code> Number of bits to write (not more than 16) </li> <li><code>data</code> Right-aligned value to write </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"apiStm/I2cController_8cpp/#function-i2cdev_writebyte","title":"function I2Cdev_writeByte","text":"<pre><code>uint16_t I2Cdev_writeByte (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t data\n) </code></pre> <p>Write single byte to an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register address to write to </li> <li><code>data</code> New byte value to write </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"apiStm/I2cController_8cpp/#function-i2cdev_writebytes","title":"function I2Cdev_writeBytes","text":"<pre><code>uint16_t I2Cdev_writeBytes (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t length,\nuint8_t * pData\n) </code></pre> <p>Write multiple bytes to an 8-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> First register address to write to </li> <li><code>length</code> Number of bytes to write </li> <li><code>data</code> Buffer to copy new data from </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"apiStm/I2cController_8cpp/#function-i2cdev_writeword","title":"function I2Cdev_writeWord","text":"<pre><code>uint16_t I2Cdev_writeWord (\nuint8_t devAddr,\nuint8_t regAddr,\nuint16_t data\n) </code></pre> <p>Write single word to a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> Register address to write to </li> <li><code>data</code> New word value to write </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"apiStm/I2cController_8cpp/#function-i2cdev_writewords","title":"function I2Cdev_writeWords","text":"<pre><code>uint16_t I2Cdev_writeWords (\nuint8_t devAddr,\nuint8_t regAddr,\nuint8_t length,\nuint16_t * data\n) </code></pre> <p>Write multiple words to a 16-bit device register. </p> <p>Parameters:</p> <ul> <li><code>devAddr</code> I2C slave device address </li> <li><code>regAddr</code> First register address to write to </li> <li><code>length</code> Number of words to write </li> <li><code>data</code> Buffer to copy new data from </li> </ul> <p>Returns:</p> <p>Status of operation (true = success) </p>"},{"location":"apiStm/I2cController_8cpp/#function-i2cdispatch","title":"function i2cDispatch","text":"<pre><code>void i2cDispatch (\nconst CoprocReq_I2cReq &amp; req\n) </code></pre>"},{"location":"apiStm/I2cController_8cpp/#function-i2cnotify","title":"function i2cNotify","text":"<pre><code>void i2cNotify () </code></pre>"},{"location":"apiStm/I2cController_8cpp/#function-i2creset","title":"function i2cReset","text":"<pre><code>void i2cReset () </code></pre>"},{"location":"apiStm/I2cController_8cpp/#function-i2cwait","title":"function i2cWait","text":"<pre><code>uint8_t i2cWait (\nHAL_StatusTypeDef beginStatus,\nuint32_t tout\n) </code></pre>"},{"location":"apiStm/I2cController_8cpp/#function-i2cwrap","title":"function i2cWrap","text":"<pre><code>template&lt;typename F typename F&gt;\nuint8_t i2cWrap (\nF fun,\nuint32_t Timeout\n) </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/I2cController.cpp</code></p>"},{"location":"apiStm/I2cController_8cpp_source/","title":"File I2cController.cpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; src &gt; I2cController.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>// I2Cdev library collection - Main I2C device class header file\n// Abstracts bit and byte I2C R/W functions into a convenient class\n// 6/9/2012 by Jeff Rowberg &lt;jeff@rowberg.net&gt;\n// 6/6/2015 by Andrey Voloshin &lt;voloshin@think.in.ua&gt;\n//\n// Changelog:\n//      2015-06-06 - ported to STM32 HAL library from Arduino code\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2013 Jeff Rowberg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n#include \"I2cController.hpp\"\n#include \"Bsp.hpp\"\n#include \"MpuController.hpp\"\n#include \"OledController.hpp\"\n#include \"utils/Debug.hpp\"\n\n#include \"utils/MutexWrapper.hpp\"\n#include \"utils/QueueWrapper.hpp\"\n#include \"utils/TaskWrapper.hpp\"\n#include \"timers.h\"\n\n// #include \"event_groups.h\"\n#include &lt;mutex&gt;\n\nstatic TaskWrapper&lt;1024&gt; i2cTask;\nTaskHandle_t i2cTaskHandle;\n\nstatic QueueWrapper&lt;CoprocReq_I2cReq, 16&gt; i2cQueue;\nstatic xTaskHandle i2cCallingTask;\nstatic MutexWrapper i2cMutex;\n\nEventGroupHandle_t i2cEventGroup;\nstatic StaticEventGroup_t i2cEventBuffer;\n\n// Hold pointer to inited HAL I2C device\nI2C_HandleTypeDef I2Cdev_hi2c;\n\nvoid i2cDispatch(const CoprocReq_I2cReq&amp; req) {\nif (i2cQueue.push_back(req, 0)) {\nxEventGroupSetBits(i2cEventGroup, I2C_MESSAGE);\n} else {\nDEBUG(\"I2c queue overflow\\n\");\n}\n}\n\nuint16_t I2Cdev_readTimeout = I2CDEV_DEFAULT_READ_TIMEOUT;\n\nuint8_t I2Cdev_init() {\nI2Cdev_hi2c.Instance = I2C1;\nI2Cdev_hi2c.Init.ClockSpeed = 400000;\nI2Cdev_hi2c.Init.DutyCycle = I2C_DUTYCYCLE_2;\nI2Cdev_hi2c.Init.OwnAddress1 = 0;\nI2Cdev_hi2c.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;\nI2Cdev_hi2c.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;\nI2Cdev_hi2c.Init.OwnAddress2 = 0;\nI2Cdev_hi2c.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;\nI2Cdev_hi2c.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;\nauto init = HAL_I2C_Init(&amp;I2Cdev_hi2c);\n\nif (init == HAL_OK) {\ni2cQueue.create();\ni2cMutex.create();\ni2cEventGroup = xEventGroupCreateStatic(&amp;i2cEventBuffer);\n\ni2cTask.start(\"i2c\", i2cPrio, []() {\nwhile (true) {\nCoprocReq_I2cReq req;\n\nEventBits_t eventsBit = I2C_NONE;\neventsBit = xEventGroupWaitBits(\ni2cEventGroup, 0xFF, pdTRUE, 0, portMAX_DELAY);\n\nif (eventsBit &amp; I2C_MPU_TICK) {\nmpuTick();\n// DEBUG(\"SEND MPU\\n\");\n}\n\nwhile (i2cQueue.pop_front(req, 0)) {\nswitch (req.which_payload) {\ncase CoprocReq_I2cReq_oledReq_tag:\noledDispatch(req.payload.oledReq);\nbreak;\ncase CoprocReq_I2cReq_mpuReq_tag:\nmpuDispatch(req.payload.mpuReq);\n// DEBUGLN(\"MPU Req %d\", req.payload.mpuReq.which_mpuCmd);\nbreak;\n}\n}\n// vTaskDelay(pdMS_TO_TICKS(10));\n}\n});\ni2cTaskHandle = i2cTask.handle();\n} else {\nDEBUG(\"Error I2c Init\\n\");\n}\n}\n\nvoid i2cNotify() {\nBaseType_t woken = 0;\nxTaskNotifyFromISR(i2cCallingTask, 0, eNoAction, &amp;woken);\nportYIELD_FROM_ISR(woken);\n}\n\nextern \"C\" void I2C1_EV_IRQHandler() { HAL_I2C_EV_IRQHandler(&amp;I2Cdev_hi2c); }\nextern \"C\" void I2C1_ER_IRQHandler() { HAL_I2C_ER_IRQHandler(&amp;I2Cdev_hi2c); }\n\nextern \"C\" __weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef* hi2c) {\ni2cNotify();\n}\n\nextern \"C\" __weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef* hi2c) {\ni2cNotify();\n}\n\nextern \"C\" __weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef* hi2c) {\ni2cNotify();\n}\n\nextern \"C\" __weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef* hi2c) {\ni2cNotify();\n}\n\nextern \"C\" __weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef* hi2c) {\ni2cNotify();\n}\n\nuint8_t i2cWait(HAL_StatusTypeDef beginStatus, uint32_t tout) {}\n\ntemplate &lt;typename F&gt; uint8_t i2cWrap(F fun, uint32_t Timeout) {\nuint16_t tout = Timeout &gt; 0 ? Timeout : I2CDEV_DEFAULT_READ_TIMEOUT;\nstd::scoped_lock lock(i2cMutex);\ni2cCallingTask = xTaskGetCurrentTaskHandle();\nauto beginStatus = fun();\n\nif (beginStatus == HAL_OK) {\nauto ok = xTaskNotifyWait(0, ~0, nullptr, pdMS_TO_TICKS(tout));\n\nif (!ok) {\nDEBUG(\"I2C timeout\\n\");\nHAL_I2C_Master_Abort_IT(&amp;I2Cdev_hi2c, 0);\n}\nreturn ok;\n} else {\nHAL_I2C_Master_Abort_IT(&amp;I2Cdev_hi2c, 0);\nreturn 0;\n}\n}\n\nvoid i2cReset() { i2cQueue.reset();        }\n\n/* Rewrited original functions */\nuint8_t I2Cdev_Master_Transmit(\nuint16_t DevAddress, uint8_t* pData, uint16_t Size, uint32_t Timeout) {\nreturn i2cWrap(\n[=]() {\nauto beginStatus = HAL_I2C_Master_Transmit_IT(\n&amp;I2Cdev_hi2c, DevAddress &lt;&lt; 1, pData, Size);\n\nif (beginStatus != HAL_OK) {\nDEBUG(\"I2C ERR - Tx %d bytes, ret: %d\\n\", Size, beginStatus);\n}\nreturn beginStatus;\n},\nTimeout);\n}\n\nuint8_t I2Cdev_Master_Receive(\nuint16_t DevAddress, uint8_t* pData, uint16_t Size, uint32_t Timeout) {\nreturn i2cWrap(\n[=]() {\nauto beginStatus = HAL_I2C_Master_Receive_IT(\n&amp;I2Cdev_hi2c, DevAddress &lt;&lt; 1, pData, Size);\n\nif (beginStatus != HAL_OK) {\nDEBUG(\"I2C ERR - Rx %d bytes, ret: %d\\n\", Size, beginStatus);\n}\nreturn beginStatus;\n},\nTimeout);\n}\n\nuint8_t I2Cdev_Mem_Write(uint16_t DevAddress, uint16_t MemAddress,\nuint16_t MemAddSize, uint8_t* pData, uint16_t Size, uint32_t Timeout) {\nreturn i2cWrap(\n[=]() {\nauto beginStatus = HAL_I2C_Mem_Write_IT(&amp;I2Cdev_hi2c,\nDevAddress &lt;&lt; 1, MemAddress, MemAddSize, pData, Size);\n\nif (beginStatus != HAL_OK) {\nDEBUG(\"I2C ERR - Mem write %d bytes, ret: %d\\n\", Size, beginStatus);\n}\nreturn beginStatus;\n},\nTimeout);\n}\n\nuint8_t I2Cdev_Mem_Read(uint16_t DevAddress, uint16_t MemAddress,\nuint16_t MemAddSize, uint8_t* pData, uint16_t Size, uint32_t Timeout) {\nreturn i2cWrap(\n[=]() {\nauto beginStatus = HAL_I2C_Mem_Read_IT(&amp;I2Cdev_hi2c,\nDevAddress &lt;&lt; 1, MemAddress, MemAddSize, pData, Size);\n\nif (beginStatus != HAL_OK) {\nDEBUG(\"I2C ERR - Mem read %d bytes, ret: %d\\n\", Size, beginStatus);\n}\nreturn beginStatus;\n},\nTimeout);\n}\n\nuint8_t I2Cdev_IsDeviceReady(\nuint16_t DevAddress, uint32_t Trials, uint32_t Timeout) {\nuint16_t tout = Timeout &gt; 0 ? Timeout : I2CDEV_DEFAULT_READ_TIMEOUT;\nreturn HAL_I2C_IsDeviceReady(&amp;I2Cdev_hi2c, DevAddress &lt;&lt; 1, Trials, tout)\n== HAL_OK;\n}\n/* Rewrited original functions */\n\nuint8_t I2Cdev_scan() {\nuint8_t counter = 0;\nfor (int range = 1; range &lt;= 254; range++) {\nif (I2Cdev_IsDeviceReady(range) != 0) {\nDEBUG(\"I2Cdev_scan[%d] ready: %#04x (%d)\\n\", counter, range, range);\ncounter++;\n}\n}\nreturn counter;\n}\n\nuint8_t I2Cdev_readBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum,\nuint8_t* data, uint16_t timeout) {\nuint8_t b;\nuint8_t count = I2Cdev_readByte(devAddr, regAddr, &amp;b, timeout);\n*data = b &amp; (1 &lt;&lt; bitNum);\nreturn count;\n}\n\nuint8_t I2Cdev_readBitW(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum,\nuint16_t* data, uint16_t timeout) {\nuint16_t b;\nuint8_t count = I2Cdev_readWord(devAddr, regAddr, &amp;b, timeout);\n*data = b &amp; (1 &lt;&lt; bitNum);\nreturn count;\n}\n\nuint8_t I2Cdev_readBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart,\nuint8_t length, uint8_t* data, uint16_t timeout) {\n// 01101001 read byte\n// 76543210 bit numbers\n//    xxx   args: bitStart=4, length=3\n//    010   masked\n//   -&gt; 010 shifted\nuint8_t count, b;\nif ((count = I2Cdev_readByte(devAddr, regAddr, &amp;b, timeout)) != 0) {\nuint8_t mask = ((1 &lt;&lt; length) - 1) &lt;&lt; (bitStart - length + 1);\nb &amp;= mask;\nb &gt;&gt;= (bitStart - length + 1);\n*data = b;\n}\nreturn count;\n}\n\nuint8_t I2Cdev_readBitsW(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart,\nuint8_t length, uint16_t* data, uint16_t timeout) {\n// 1101011001101001 read byte\n// fedcba9876543210 bit numbers\n//    xxx           args: bitStart=12, length=3\n//    010           masked\n//           -&gt; 010 shifted\nuint8_t count;\nuint16_t w;\nif ((count = I2Cdev_readWord(devAddr, regAddr, &amp;w, timeout)) != 0) {\nuint16_t mask = ((1 &lt;&lt; length) - 1) &lt;&lt; (bitStart - length + 1);\nw &amp;= mask;\nw &gt;&gt;= (bitStart - length + 1);\n*data = w;\n}\nreturn count;\n}\n\nuint8_t I2Cdev_readByte(\nuint8_t devAddr, uint8_t regAddr, uint8_t* data, uint16_t timeout) {\nreturn I2Cdev_readBytes(devAddr, regAddr, 1, data, timeout);\n}\n\nuint8_t I2Cdev_readWord(\nuint8_t devAddr, uint8_t regAddr, uint16_t* data, uint16_t timeout) {\nreturn I2Cdev_readWords(devAddr, regAddr, 1, data, timeout);\n}\n\nuint8_t I2Cdev_readBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length,\nuint8_t* data, uint16_t timeout) {\nuint16_t tout = timeout &gt; 0 ? timeout : I2CDEV_DEFAULT_READ_TIMEOUT;\nI2Cdev_Master_Transmit(devAddr, &amp;regAddr, 1, tout);\nuint8_t ret = I2Cdev_Master_Receive(devAddr, data, length, tout);\nif (ret != 0) {\nreturn length;\n}\nreturn -1;\n}\n\n// uint8_t I2Cdev_readBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t *data, uint16_t timeout)\n// {\n//     uint16_t tout = timeout &gt; 0 ? timeout : I2CDEV_DEFAULT_READ_TIMEOUT;\n\n//     HAL_I2C_Master_Transmit(&amp;I2Cdev_hi2c, devAddr &lt;&lt; 1, &amp;regAddr, 1, tout);\n//     if (HAL_I2C_Master_Receive(&amp;I2Cdev_hi2c, devAddr &lt;&lt; 1, data, length, tout) == HAL_OK) {\n//         DEBUG(\"I2Cdev_readBytes %d\\n\", length);\n//         return length;\n//     }\n//     return -1;\n// }\n\nuint8_t I2Cdev_readWords(uint8_t devAddr, uint8_t regAddr, uint8_t length,\nuint16_t* data, uint16_t timeout) {\nuint16_t tout = timeout &gt; 0 ? timeout : I2CDEV_DEFAULT_READ_TIMEOUT;\n\nI2Cdev_Master_Transmit(devAddr, &amp;regAddr, 1, tout);\nif (I2Cdev_Master_Receive(devAddr, (uint8_t*)data, length * 2, tout) != 0)\nreturn length;\nelse\nreturn -1;\n}\n\n// uint8_t I2Cdev_readWords(uint8_t devAddr, uint8_t regAddr, uint8_t length,\n//     uint16_t* data, uint16_t timeout) {\n//     uint16_t tout = timeout &gt; 0 ? timeout : I2CDEV_DEFAULT_READ_TIMEOUT;\n\n//     HAL_I2C_Master_Transmit(&amp;I2Cdev_hi2c, devAddr &lt;&lt; 1, &amp;regAddr, 1, tout);\n//     if (HAL_I2C_Master_Receive(\n//             &amp;I2Cdev_hi2c, devAddr &lt;&lt; 1, (uint8_t*)data, length * 2, tout)\n//         == HAL_OK)\n//         return length;\n//     else\n//         return -1;\n// }\n\nuint16_t I2Cdev_writeBit(\nuint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data) {\nuint8_t b;\nI2Cdev_readByte(devAddr, regAddr, &amp;b, I2Cdev_readTimeout);\nb = (data != 0) ? (b | (1 &lt;&lt; bitNum)) : (b &amp; ~(1 &lt;&lt; bitNum));\nreturn I2Cdev_writeByte(devAddr, regAddr, b);\n}\n\nuint16_t I2Cdev_writeBitW(\nuint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint16_t data) {\nuint16_t w;\nI2Cdev_readWord(devAddr, regAddr, &amp;w, 100);\nw = (data != 0) ? (w | (1 &lt;&lt; bitNum)) : (w &amp; ~(1 &lt;&lt; bitNum));\nreturn I2Cdev_writeWord(devAddr, regAddr, w);\n}\n\nuint16_t I2Cdev_writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart,\nuint8_t length, uint8_t data) {\n//      010 value to write\n// 76543210 bit numbers\n//    xxx   args: bitStart=4, length=3\n// 00011100 mask byte\n// 10101111 original value (sample)\n// 10100011 original &amp; ~mask\n// 10101011 masked | value\nuint8_t b;\nif (I2Cdev_readByte(devAddr, regAddr, &amp;b, 100) != 0) {\nuint8_t mask = ((1 &lt;&lt; length) - 1) &lt;&lt; (bitStart - length + 1);\ndata &lt;&lt;= (bitStart - length + 1); // shift data into correct position\ndata &amp;= mask; // zero all non-important bits in data\nb &amp;= ~(mask); // zero all important bits in existing byte\nb |= data; // combine data with existing byte\nreturn I2Cdev_writeByte(devAddr, regAddr, b);\n} else {\nreturn 0;\n}\n}\n\nuint16_t I2Cdev_writeBitsW(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart,\nuint8_t length, uint16_t data) {\n//              010 value to write\n// fedcba9876543210 bit numbers\n//    xxx           args: bitStart=12, length=3\n// 0001110000000000 mask word\n// 1010111110010110 original value (sample)\n// 1010001110010110 original &amp; ~mask\n// 1010101110010110 masked | value\nuint16_t w;\nif (I2Cdev_readWord(devAddr, regAddr, &amp;w, 100) != 0) {\nuint16_t mask = ((1 &lt;&lt; length) - 1) &lt;&lt; (bitStart - length + 1);\ndata &lt;&lt;= (bitStart - length + 1); // shift data into correct position\ndata &amp;= mask; // zero all non-important bits in data\nw &amp;= ~(mask); // zero all important bits in existing word\nw |= data; // combine data with existing word\nreturn I2Cdev_writeWord(devAddr, regAddr, w);\n} else {\nreturn 0;\n}\n}\n\nuint16_t I2Cdev_writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data) {\nreturn I2Cdev_writeBytes(devAddr, regAddr, 1, &amp;data);\n}\n\nuint16_t I2Cdev_writeWord(uint8_t devAddr, uint8_t regAddr, uint16_t data) {\nreturn I2Cdev_writeWords(devAddr, regAddr, 1, &amp;data);\n}\n\nuint16_t I2Cdev_writeBytes(\nuint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t* pData) {\n// Creating array to store regAddr + data in one buffer\nuint8_t buffer[length + 1];\nbuffer[0] = regAddr;\n\n// copy array\nmemcpy(buffer + 1, pData, sizeof(uint8_t) * length);\n\nauto ok = I2Cdev_Master_Transmit(devAddr, buffer, length + 1, 1000);\nreturn ok;\n}\n\nuint16_t I2Cdev_writeWords(\nuint8_t devAddr, uint8_t regAddr, uint8_t length, uint16_t* data) {\n// Creating array to store regAddr + data in one buffer\nuint8_t buffer[length + 1];\nbuffer[0] = regAddr;\n\n// copy array\nmemcpy(buffer + 1, data, sizeof(uint16_t) * length);\nauto ok = I2Cdev_Master_Transmit(\ndevAddr, buffer, sizeof(uint8_t) + sizeof(uint16_t) * length, 1000);\nreturn ok;\n}\n</code></pre>"},{"location":"apiStm/MotorController_8cpp/","title":"File MotorController.cpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; src &gt; MotorController.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"MotorController.hpp\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"ControlLink.hpp\"</code></li> <li><code>#include \"Dispatcher.hpp\"</code></li> <li><code>#include \"Motor.hpp\"</code></li> <li><code>#include \"utils/Debug.hpp\"</code></li> <li><code>#include \"utils/MutexWrapper.hpp\"</code></li> <li><code>#include \"utils/TaskWrapper.hpp\"</code></li> <li><code>#include \"stm32f1xx_ll_tim.h\"</code></li> <li><code>#include &lt;cstdlib&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"apiStm/MotorController_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr uint32_t encoderFilter   = = LL_TIM_IC_FILTER_FDIV32_N8 constexpr uint16_t maxPwm   = = 2000 std::array&lt; Motor, 4 &gt; motor MutexWrapper motorMut TaskWrapper&lt; 1024 &gt; motorTask"},{"location":"apiStm/MotorController_8cpp/#public-functions","title":"Public Functions","text":"Type Name void motorDispatch (const CoprocReq_MotorReq &amp; request)  void motorInit ()  void motorReset ()"},{"location":"apiStm/MotorController_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void setMotorPower (uint8_t motorIndex, int32_t power, bool brake)  void setPwmValue (TIM_TypeDef * timer, uint8_t motorIndex, uint16_t value)  void taskFunc ()"},{"location":"apiStm/MotorController_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"apiStm/MotorController_8cpp/#variable-encoderfilter","title":"variable encoderFilter","text":"<pre><code>constexpr uint32_t encoderFilter;\n</code></pre>"},{"location":"apiStm/MotorController_8cpp/#variable-maxpwm","title":"variable maxPwm","text":"<pre><code>constexpr uint16_t maxPwm;\n</code></pre>"},{"location":"apiStm/MotorController_8cpp/#variable-motor","title":"variable motor","text":"<pre><code>std::array&lt;Motor, 4&gt; motor;\n</code></pre>"},{"location":"apiStm/MotorController_8cpp/#variable-motormut","title":"variable motorMut","text":"<pre><code>MutexWrapper motorMut;\n</code></pre>"},{"location":"apiStm/MotorController_8cpp/#variable-motortask","title":"variable motorTask","text":"<pre><code>TaskWrapper&lt;1024&gt; motorTask;\n</code></pre>"},{"location":"apiStm/MotorController_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/MotorController_8cpp/#function-motordispatch","title":"function motorDispatch","text":"<pre><code>void motorDispatch (\nconst CoprocReq_MotorReq &amp; request\n) </code></pre>"},{"location":"apiStm/MotorController_8cpp/#function-motorinit","title":"function motorInit","text":"<pre><code>void motorInit () </code></pre>"},{"location":"apiStm/MotorController_8cpp/#function-motorreset","title":"function motorReset","text":"<pre><code>void motorReset () </code></pre>"},{"location":"apiStm/MotorController_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"apiStm/MotorController_8cpp/#function-setmotorpower","title":"function setMotorPower","text":"<pre><code>static void setMotorPower (\nuint8_t motorIndex,\nint32_t power,\nbool brake\n) </code></pre>"},{"location":"apiStm/MotorController_8cpp/#function-setpwmvalue","title":"function setPwmValue","text":"<pre><code>static void setPwmValue (\nTIM_TypeDef * timer,\nuint8_t motorIndex,\nuint16_t value\n) </code></pre>"},{"location":"apiStm/MotorController_8cpp/#function-taskfunc","title":"function taskFunc","text":"<pre><code>static void taskFunc () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/MotorController.cpp</code></p>"},{"location":"apiStm/MotorController_8cpp_source/","title":"File MotorController.cpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; src &gt; MotorController.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"MotorController.hpp\"\n#include \"Bsp.hpp\"\n#include \"ControlLink.hpp\"\n#include \"Dispatcher.hpp\"\n#include \"Motor.hpp\"\n#include \"utils/Debug.hpp\"\n#include \"utils/MutexWrapper.hpp\"\n#include \"utils/TaskWrapper.hpp\"\n\n#include \"stm32f1xx_ll_tim.h\"\n#include &lt;cstdlib&gt;\n#include &lt;mutex&gt;\n#include &lt;stdint.h&gt;\n\nstatic void setPwmValue(TIM_TypeDef* timer, uint8_t motorIndex, uint16_t value);\nstatic void setMotorPower(uint8_t motorIndex, int32_t power, bool brake);\n\n// Debounce ENC signals at ~3.5us (72MHz fDTS)\nstatic constexpr uint32_t encoderFilter = LL_TIM_IC_FILTER_FDIV32_N8;\nstatic constexpr uint16_t maxPwm = 2000;\nstatic std::array&lt;Motor, 4&gt; motor;\nstatic MutexWrapper motorMut;\nstatic TaskWrapper&lt;1024&gt; motorTask;\nstatic void taskFunc();\n\nvoid motorInit() {\nLL_TIM_InitTypeDef pwmInit;\nLL_TIM_StructInit(&amp;pwmInit);\n\npwmInit.Prescaler = 0;\n// this sets interrupts flag when counter reachs TOP:\npwmInit.CounterMode = LL_TIM_COUNTERMODE_CENTER_DOWN;\npwmInit.Autoreload = maxPwm;\npwmInit.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;\npwmInit.RepetitionCounter = 0;\n\nLL_TIM_OC_InitTypeDef ocInit;\nLL_TIM_OC_StructInit(&amp;ocInit);\nocInit.OCMode = LL_TIM_OCMODE_PWM2;\nocInit.OCState = LL_TIM_OCSTATE_ENABLE;\n\nocInit.OCNState = LL_TIM_OCSTATE_ENABLE;\nocInit.CompareValue = 0;\nocInit.OCPolarity = LL_TIM_OCPOLARITY_HIGH;\nocInit.OCNPolarity = LL_TIM_OCPOLARITY_HIGH;\nocInit.OCIdleState = LL_TIM_OCIDLESTATE_HIGH;\nocInit.OCNIdleState = LL_TIM_OCIDLESTATE_HIGH;\n\nLL_TIM_Init(pwmTimer, &amp;pwmInit);\nfor (uint16_t channel = LL_TIM_CHANNEL_CH1; channel != 0; channel &lt;&lt;= 4) {\nLL_TIM_OC_Init(pwmTimer, channel, &amp;ocInit);\nLL_TIM_OC_EnablePreload(pwmTimer, channel);\n}\n\nLL_TIM_SetOffStates(pwmTimer, LL_TIM_OSSI_DISABLE, LL_TIM_OSSR_ENABLE);\nLL_TIM_GenerateEvent_UPDATE(pwmTimer);\nLL_TIM_EnableAllOutputs(pwmTimer);\nLL_TIM_EnableCounter(pwmTimer);\n\nfor (int motorIndex : { 0, 1, 2, 3 }) {\nsetMotorPower(motorIndex, 0, false);\n}\n\nLL_TIM_ENCODER_InitTypeDef encInit;\nencInit.EncoderMode = LL_TIM_ENCODERMODE_X4_TI12;\nencInit.IC1Polarity = LL_TIM_IC_POLARITY_RISING;\nencInit.IC1ActiveInput = LL_TIM_ACTIVEINPUT_DIRECTTI;\nencInit.IC1Prescaler = LL_TIM_ICPSC_DIV1;\nencInit.IC1Filter = encoderFilter;\nencInit.IC2Polarity = LL_TIM_IC_POLARITY_RISING;\nencInit.IC2ActiveInput = LL_TIM_ACTIVEINPUT_DIRECTTI;\nencInit.IC2Prescaler = LL_TIM_ICPSC_DIV1;\nencInit.IC2Filter = encoderFilter;\nfor (auto timer : encoderTimer) {\nLL_TIM_ENCODER_Init(timer, &amp;encInit);\nLL_TIM_EnableCounter(timer);\n}\n\nmotorMut.create();\nmotorTask.start(\"motors\", motorTaskPrio, taskFunc);\n}\n\nstatic void taskFunc() {\nwhile (true) {\nauto now = xTaskGetTickCount();\n{\nstd::scoped_lock lock(motorMut);\n\nfor (int m : { 0, 1, 2, 3 }) {\nuint16_t encTicks = LL_TIM_GetCounter(encoderTimer[m]);\nauto&amp; targetMotor = motor[m];\nauto modeBefore = targetMotor.mode();\nauto action = targetMotor.poll(encTicks);\nauto modeAfter = targetMotor.mode();\nsetMotorPower(m, action, modeAfter == MotorMode_BRAKE);\n\nif (modeBefore == MotorMode_POSITION\n&amp;&amp; modeAfter == MotorMode_POSITION_IDLE) {\nCoprocStat stat = {\n.which_payload = CoprocStat_motorStat_tag,\n};\ntargetMotor.reportStat(stat.payload.motorStat);\nstat.payload.motorStat.motorIndex = m;\ndispatcherEnqueueStatus(stat);\n}\n}\n}\nvTaskDelayUntil(&amp;now, pdMS_TO_TICKS(1000 / motorLoopFreq));\n}\n}\n\nvoid motorDispatch(const CoprocReq_MotorReq&amp; request) {\nif (request.motorIndex &gt; 3) {\nreturn;\n}\n\nauto&amp; targetMotor = motor[request.motorIndex];\nstd::scoped_lock lock(motorMut);\n\nswitch (request.which_motorCmd) {\ncase CoprocReq_MotorReq_getState_tag: {\nCoprocStat stat = {\n.which_payload = CoprocStat_motorStat_tag,\n};\ntargetMotor.reportStat(stat.payload.motorStat);\nstat.payload.motorStat.motorIndex = request.motorIndex;\ncontrolLinkTx(stat);\n} break;\ncase CoprocReq_MotorReq_setPower_tag:\ntargetMotor.setTargetPower(request.motorCmd.setPower);\nbreak;\ncase CoprocReq_MotorReq_setBrake_tag:\ntargetMotor.setTargetBrakingPower(request.motorCmd.setBrake);\nbreak;\ncase CoprocReq_MotorReq_setVelocity_tag: {\nauto ticksPerSec = request.motorCmd.setVelocity;\nif (ticksPerSec &gt; INT16_MAX || ticksPerSec &lt; INT16_MIN) {\nDEBUG(\"Motor %d target velocity out of range &lt;-32768; 32767&gt; \"\n\"(%d).\\n\",\nint(request.motorIndex), int(ticksPerSec));\nreturn;\n}\ntargetMotor.setTargetVelocity(ticksPerSec);\n} break;\ncase CoprocReq_MotorReq_homePosition_tag:\ntargetMotor.homePosition(request.motorCmd.homePosition);\nbreak;\ncase CoprocReq_MotorReq_setPosition_tag:\ntargetMotor.setTargetPosition(request.motorCmd.setPosition, false);\nbreak;\ncase CoprocReq_MotorReq_addPosition_tag:\ntargetMotor.setTargetPosition(request.motorCmd.addPosition, true);\nbreak;\ncase CoprocReq_MotorReq_setVelocityRegCoefs_tag:\ntargetMotor.setVelocityPid(request.motorCmd.setVelocityRegCoefs);\nbreak;\ncase CoprocReq_MotorReq_setPositionRegCoefs_tag:\ntargetMotor.setPositionPid(request.motorCmd.setPositionRegCoefs);\nbreak;\ncase CoprocReq_MotorReq_setConfig_tag:\ntargetMotor.setConfig(request.motorCmd.setConfig);\nbreak;\n}\n}\n\nvoid motorReset() {\nstd::scoped_lock lock(motorMut);\n\nfor (int idx : { 0, 1, 2, 3 }) {\nmotor[idx].reset();\nsetMotorPower(idx, 0, false);\n}\n}\n\nstatic void setPwmValue(\nTIM_TypeDef* timer, uint8_t motorIndex, uint16_t value) {\nreinterpret_cast&lt;__IO uint16_t*&gt;(&amp;timer-&gt;CCR1)[motorIndex &lt;&lt; 1] = value;\n}\n\nstatic void setMotorPower(uint8_t motorIndex, int32_t power, bool brake) {\nif (power &gt; SHRT_MAX || power &lt; SHRT_MIN) {\nDEBUG(\"Motor %d power out of range &lt;-32768; 32767&gt; (%d).\\n\",\nint(motorIndex), int(power));\nreturn;\n}\n\nuint16_t pwm = uint32_t(abs(power) * maxPwm) / 32768;\nsetPwmValue(pwmTimer, motorIndex, pwm);\nif (pwm == 0 || brake) {\nswitch (motorIndex) {\ncase 3:\nIN4PORT-&gt;BRR = IN4AMASK | IN4BMASK; // set LOW on IN4A and IN4B\npwmTimer-&gt;CCER |= TIM_CCER_CC4P; // invert channel 4\nbreak;\ndefault:\n// set PWM on both channels and invert positive channel\npwmTimer-&gt;CCER\n= (pwmTimer-&gt;CCER &amp; ~(TIM_CCER_CC1NP &lt;&lt; (motorIndex &lt;&lt; 2)))\n| (TIM_CCER_CC1E &lt;&lt; (motorIndex &lt;&lt; 2))\n| (TIM_CCER_CC1NE &lt;&lt; (motorIndex &lt;&lt; 2))\n| (TIM_CCER_CC1P &lt;&lt; (motorIndex &lt;&lt; 2));\nbreak;\n}\n} else {\nswitch (motorIndex) {\ncase 3:\nIN4PORT-&gt;BSRR = power &lt; 0\n? IN4AMASK | (IN4BMASK &lt;&lt; 16) // pinWrite(in4aPin, power &lt; 0);\n: IN4BMASK | (IN4AMASK &lt;&lt; 16); // pinWrite(in4bPin, power &gt; 0);\npwmTimer-&gt;CCER &amp;= ~TIM_CCER_CC4P; // make channel 4 non-inverted\nbreak;\ndefault:\nif (power &gt; 0) {\n// set HIGH on positive channel and inverted PWM on negative channel\npwmTimer-&gt;CCER\n= (pwmTimer-&gt;CCER\n&amp; ~((TIM_CCER_CC1P &lt;&lt; (motorIndex &lt;&lt; 2))\n| (TIM_CCER_CC1NE &lt;&lt; (motorIndex &lt;&lt; 2))))\n| (TIM_CCER_CC1NP &lt;&lt; (motorIndex &lt;&lt; 2))\n| (TIM_CCER_CC1E &lt;&lt; (motorIndex &lt;&lt; 2));\n} else {\n// set HIGH on negative channel and inverted PWM on positive channel\npwmTimer-&gt;CCER\n= (pwmTimer-&gt;CCER\n&amp; ~((TIM_CCER_CC1E &lt;&lt; (motorIndex &lt;&lt; 2))\n| (TIM_CCER_CC1NP &lt;&lt; (motorIndex &lt;&lt; 2))))\n| (TIM_CCER_CC1NE &lt;&lt; (motorIndex &lt;&lt; 2))\n| (TIM_CCER_CC1P &lt;&lt; (motorIndex &lt;&lt; 2));\n}\nbreak;\n}\n}\n}\n</code></pre>"},{"location":"apiStm/MpuController_8cpp/","title":"File MpuController.cpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; src &gt; MpuController.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"MpuController.hpp\"</code></li> <li><code>#include \"Dispatcher.hpp\"</code></li> <li><code>#include \"utils/TickTimer.hpp\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"utils/QueueWrapper.hpp\"</code></li> <li><code>#include \"utils/TaskWrapper.hpp\"</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"timers.h\"</code></li> <li><code>#include \"event_groups.h\"</code></li> </ul>"},{"location":"apiStm/MpuController_8cpp/#classes","title":"Classes","text":"Type Name struct MpuMotion32 struct MpuMotion6 struct MpuVector struct MpuVector32"},{"location":"apiStm/MpuController_8cpp/#public-types","title":"Public Types","text":"Type Name typedef struct MpuMotion32 MpuMotion32 typedef struct MpuMotion6 MpuMotion6 typedef struct MpuVector MpuVector typedef struct MpuVector32 MpuVector32"},{"location":"apiStm/MpuController_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name uint16_t compressCoef   = = 4 mpu_t mpu6050 uint32_t mpuAggrCounter   = = 0 MpuMotion32 mpuAggrData constexpr uint32_t mpuTickPeriodMs   = = 10 StaticTimer_t mpuTimerBuffer TimerHandle_t mpuTimerHandle"},{"location":"apiStm/MpuController_8cpp/#public-functions","title":"Public Functions","text":"Type Name void mpuCreate ()  void mpuDispatch (const CoprocReq_MpuReq &amp; req)  void mpuInitialize ()  void mpuReset ()  void mpuTick ()  bool mpu_getAccelFIFOEnabled ()  bool mpu_getAccelXSelfTest ()  bool mpu_getAccelYSelfTest ()  bool mpu_getAccelZSelfTest ()  void mpu_getAcceleration (int16_t * x, int16_t * y, int16_t * z)  int16_t mpu_getAccelerationX ()  int16_t mpu_getAccelerationY ()  int16_t mpu_getAccelerationZ ()  uint8_t mpu_getAccelerometerPowerOnDelay ()  uint8_t mpu_getAuxVDDIOLevel ()  bool mpu_getClockOutputEnabled ()  uint8_t mpu_getClockSource ()  uint8_t mpu_getDHPFMode ()  uint8_t mpu_getDLPFMode ()  uint8_t mpu_getExternalFrameSync ()  uint8_t mpu_getExternalSensorByte (int position)  uint32_t mpu_getExternalSensorDWord (int position)  uint16_t mpu_getExternalSensorWord (int position)  bool mpu_getExternalShadowDelayEnabled ()  bool mpu_getFIFOEnabled ()  bool mpu_getFSyncInterruptEnabled ()  bool mpu_getFSyncInterruptLevel ()  uint8_t mpu_getFreefallDetectionCounterDecrement ()  uint8_t mpu_getFreefallDetectionDuration ()  uint8_t mpu_getFreefallDetectionThreshold ()  uint8_t mpu_getFullScaleAccelRange ()  uint8_t mpu_getFullScaleGyroRange ()  bool mpu_getI2CBypassEnabled ()  bool mpu_getI2CMasterModeEnabled ()  bool mpu_getIntDataReadyEnabled ()  bool mpu_getIntDataReadyStatus ()  uint8_t mpu_getIntEnabled ()  bool mpu_getIntFIFOBufferOverflowEnabled ()  bool mpu_getIntFIFOBufferOverflowStatus ()  bool mpu_getIntFreefallEnabled ()  bool mpu_getIntFreefallStatus ()  bool mpu_getIntI2CMasterEnabled ()  bool mpu_getIntI2CMasterStatus ()  bool mpu_getIntMotionEnabled ()  bool mpu_getIntMotionStatus ()  uint8_t mpu_getIntStatus ()  bool mpu_getIntZeroMotionEnabled ()  bool mpu_getIntZeroMotionStatus ()  bool mpu_getInterruptDrive ()  bool mpu_getInterruptLatch ()  bool mpu_getInterruptLatchClear ()  bool mpu_getInterruptMode ()  bool mpu_getLostArbitration ()  uint8_t mpu_getMasterClockSpeed ()  void mpu_getMotion6 (int16_t * ax, int16_t * ay, int16_t * az, int16_t * gx, int16_t * gy, int16_t * gz)  void mpu_getMotion9 (int16_t * ax, int16_t * ay, int16_t * az, int16_t * gx, int16_t * gy, int16_t * gz, int16_t * mx, int16_t * my, int16_t * mz)  uint8_t mpu_getMotionDetectionCounterDecrement ()  uint8_t mpu_getMotionDetectionDuration ()  uint8_t mpu_getMotionDetectionThreshold ()  bool mpu_getMultiMasterEnabled ()  bool mpu_getPassthroughStatus ()  uint8_t mpu_getRate ()  void mpu_getRotation (int16_t * x, int16_t * y, int16_t * z)  int16_t mpu_getRotationX ()  int16_t mpu_getRotationY ()  int16_t mpu_getRotationZ ()  uint8_t mpu_getSlate4InputByte ()  bool mpu_getSlave0FIFOEnabled ()  bool mpu_getSlave0Nack ()  bool mpu_getSlave1FIFOEnabled ()  bool mpu_getSlave1Nack ()  bool mpu_getSlave2FIFOEnabled ()  bool mpu_getSlave2Nack ()  bool mpu_getSlave3FIFOEnabled ()  bool mpu_getSlave3Nack ()  uint8_t mpu_getSlave4Address ()  bool mpu_getSlave4Enabled ()  bool mpu_getSlave4InterruptEnabled ()  bool mpu_getSlave4IsDone ()  uint8_t mpu_getSlave4MasterDelay ()  bool mpu_getSlave4Nack ()  uint8_t mpu_getSlave4Register ()  bool mpu_getSlave4WriteMode ()  uint8_t mpu_getSlaveAddress (uint8_t num)  uint8_t mpu_getSlaveDataLength (uint8_t num)  bool mpu_getSlaveDelayEnabled (uint8_t num)  bool mpu_getSlaveEnabled (uint8_t num)  bool mpu_getSlaveReadWriteTransitionEnabled ()  uint8_t mpu_getSlaveRegister (uint8_t num)  bool mpu_getSlaveWordByteSwap (uint8_t num)  bool mpu_getSlaveWordGroupOffset (uint8_t num)  bool mpu_getSlaveWriteMode (uint8_t num)  bool mpu_getSleepEnabled ()  bool mpu_getTempFIFOEnabled ()  bool mpu_getTempSensorEnabled ()  int16_t mpu_getTemperature ()  bool mpu_getWaitForExternalSensorEnabled ()  bool mpu_getWakeCycleEnabled ()  bool mpu_getXGyroFIFOEnabled ()  bool mpu_getXNegMotionDetected ()  bool mpu_getXPosMotionDetected ()  bool mpu_getYGyroFIFOEnabled ()  bool mpu_getYNegMotionDetected ()  bool mpu_getYPosMotionDetected ()  bool mpu_getZGyroFIFOEnabled ()  bool mpu_getZNegMotionDetected ()  bool mpu_getZPosMotionDetected ()  bool mpu_getZeroMotionDetected ()  uint8_t mpu_getZeroMotionDetectionDuration ()  uint8_t mpu_getZeroMotionDetectionThreshold ()  void mpu_reset ()  void mpu_resetAccelerometerPath ()  void mpu_resetFIFO ()  void mpu_resetGyroscopePath ()  void mpu_resetI2CMaster ()  void mpu_resetSensors ()  void mpu_resetTemperaturePath ()  void mpu_setAccelFIFOEnabled (bool enabled)  void mpu_setAccelXSelfTest (bool enabled)  void mpu_setAccelYSelfTest (bool enabled)  void mpu_setAccelZSelfTest (bool enabled)  void mpu_setAccelerometerPowerOnDelay (uint8_t delay)  void mpu_setAuxVDDIOLevel (uint8_t level)  void mpu_setClockOutputEnabled (bool enabled)  void mpu_setClockSource (uint8_t source)  void mpu_setDHPFMode (uint8_t bandwidth)  void mpu_setDLPFMode (uint8_t mode)  void mpu_setExternalFrameSync (uint8_t sync)  void mpu_setExternalShadowDelayEnabled (bool enabled)  void mpu_setFIFOEnabled (bool enabled)  void mpu_setFSyncInterruptEnabled (bool enabled)  void mpu_setFSyncInterruptLevel (bool level)  void mpu_setFreefallDetectionCounterDecrement (uint8_t decrement)  void mpu_setFreefallDetectionDuration (uint8_t duration)  void mpu_setFreefallDetectionThreshold (uint8_t threshold)  void mpu_setFullScaleAccelRange (uint8_t range)  void mpu_setFullScaleGyroRange (uint8_t range)  void mpu_setI2CBypassEnabled (bool enabled)  void mpu_setI2CMasterModeEnabled (bool enabled)  void mpu_setIntDataReadyEnabled (bool enabled)  void mpu_setIntEnabled (uint8_t enabled)  void mpu_setIntFIFOBufferOverflowEnabled (bool enabled)  void mpu_setIntFreefallEnabled (bool enabled)  void mpu_setIntI2CMasterEnabled (bool enabled)  void mpu_setIntMotionEnabled (bool enabled)  void mpu_setIntZeroMotionEnabled (bool enabled)  void mpu_setInterruptDrive (bool drive)  void mpu_setInterruptLatch (bool latch)  void mpu_setInterruptLatchClear (bool clear)  void mpu_setInterruptMode (bool mode)  void mpu_setMasterClockSpeed (uint8_t speed)  void mpu_setMotionDetectionCounterDecrement (uint8_t decrement)  void mpu_setMotionDetectionDuration (uint8_t duration)  void mpu_setMotionDetectionThreshold (uint8_t threshold)  void mpu_setMultiMasterEnabled (bool enabled)  void mpu_setRate (uint8_t rate)  void mpu_setSlave0FIFOEnabled (bool enabled)  void mpu_setSlave1FIFOEnabled (bool enabled)  void mpu_setSlave2FIFOEnabled (bool enabled)  void mpu_setSlave3FIFOEnabled (bool enabled)  void mpu_setSlave4Address (uint8_t address)  void mpu_setSlave4Enabled (bool enabled)  void mpu_setSlave4InterruptEnabled (bool enabled)  void mpu_setSlave4MasterDelay (uint8_t delay)  void mpu_setSlave4OutputByte (uint8_t data)  void mpu_setSlave4Register (uint8_t reg)  void mpu_setSlave4WriteMode (bool mode)  void mpu_setSlaveAddress (uint8_t num, uint8_t address)  void mpu_setSlaveDataLength (uint8_t num, uint8_t length)  void mpu_setSlaveDelayEnabled (uint8_t num, bool enabled)  void mpu_setSlaveEnabled (uint8_t num, bool enabled)  void mpu_setSlaveOutputByte (uint8_t num, uint8_t data)  void mpu_setSlaveReadWriteTransitionEnabled (bool enabled)  void mpu_setSlaveRegister (uint8_t num, uint8_t reg)  void mpu_setSlaveWordByteSwap (uint8_t num, bool enabled)  void mpu_setSlaveWordGroupOffset (uint8_t num, bool enabled)  void mpu_setSlaveWriteMode (uint8_t num, bool mode)  void mpu_setSleepEnabled (bool enabled)  void mpu_setTempFIFOEnabled (bool enabled)  void mpu_setTempSensorEnabled (bool enabled)  void mpu_setWaitForExternalSensorEnabled (bool enabled)  void mpu_setWakeCycleEnabled (bool enabled)  void mpu_setXGyroFIFOEnabled (bool enabled)  void mpu_setYGyroFIFOEnabled (bool enabled)  void mpu_setZGyroFIFOEnabled (bool enabled)  void mpu_setZeroMotionDetectionDuration (uint8_t duration)  void mpu_setZeroMotionDetectionThreshold (uint8_t threshold)  void mpu_switchSPIEnabled (bool enabled)  bool mpu_testConnection ()"},{"location":"apiStm/MpuController_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void mpuRead (MpuMotion6 &amp; data)  void mpuSend (const MpuMotion32 &amp; data)  void mpuTickCallback (TimerHandle_t tim)"},{"location":"apiStm/MpuController_8cpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/MpuController_8cpp/#typedef-mpumotion32","title":"typedef MpuMotion32","text":"<pre><code>typedef struct MpuMotion32 MpuMotion32;\n</code></pre>"},{"location":"apiStm/MpuController_8cpp/#typedef-mpumotion6","title":"typedef MpuMotion6","text":"<pre><code>typedef struct MpuMotion6 MpuMotion6;\n</code></pre>"},{"location":"apiStm/MpuController_8cpp/#typedef-mpuvector","title":"typedef MpuVector","text":"<pre><code>typedef struct MpuVector MpuVector;\n</code></pre>"},{"location":"apiStm/MpuController_8cpp/#typedef-mpuvector32","title":"typedef MpuVector32","text":"<pre><code>typedef struct MpuVector32 MpuVector32;\n</code></pre>"},{"location":"apiStm/MpuController_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"apiStm/MpuController_8cpp/#variable-compresscoef","title":"variable compressCoef","text":"<pre><code>uint16_t compressCoef;\n</code></pre>"},{"location":"apiStm/MpuController_8cpp/#variable-mpu6050","title":"variable mpu6050","text":"<pre><code>mpu_t mpu6050;\n</code></pre>"},{"location":"apiStm/MpuController_8cpp/#variable-mpuaggrcounter","title":"variable mpuAggrCounter","text":"<pre><code>uint32_t mpuAggrCounter;\n</code></pre>"},{"location":"apiStm/MpuController_8cpp/#variable-mpuaggrdata","title":"variable mpuAggrData","text":"<pre><code>MpuMotion32 mpuAggrData;\n</code></pre>"},{"location":"apiStm/MpuController_8cpp/#variable-mputickperiodms","title":"variable mpuTickPeriodMs","text":"<pre><code>constexpr uint32_t mpuTickPeriodMs;\n</code></pre>"},{"location":"apiStm/MpuController_8cpp/#variable-mputimerbuffer","title":"variable mpuTimerBuffer","text":"<pre><code>StaticTimer_t mpuTimerBuffer;\n</code></pre>"},{"location":"apiStm/MpuController_8cpp/#variable-mputimerhandle","title":"variable mpuTimerHandle","text":"<pre><code>TimerHandle_t mpuTimerHandle;\n</code></pre>"},{"location":"apiStm/MpuController_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/MpuController_8cpp/#function-mpucreate","title":"function mpuCreate","text":"<pre><code>void mpuCreate () </code></pre>"},{"location":"apiStm/MpuController_8cpp/#function-mpudispatch","title":"function mpuDispatch","text":"<pre><code>void mpuDispatch (\nconst CoprocReq_MpuReq &amp; req\n) </code></pre>"},{"location":"apiStm/MpuController_8cpp/#function-mpuinitialize","title":"function mpuInitialize","text":"<pre><code>void mpuInitialize () </code></pre> <p>Power on and prepare for general usage. This will activate the device and take it out of sleep mode (which must be done after start-up). This function also sets both the accelerometer and the gyroscope to their most sensitive settings, namely +/- 2g and +/- 250 degrees/sec, and sets the clock source to use the X Gyro for reference, which is slightly better than the default internal clock source. </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpureset","title":"function mpuReset","text":"<pre><code>void mpuReset () </code></pre>"},{"location":"apiStm/MpuController_8cpp/#function-mputick","title":"function mpuTick","text":"<pre><code>void mpuTick () </code></pre>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getaccelfifoenabled","title":"function mpu_getAccelFIFOEnabled","text":"<pre><code>bool mpu_getAccelFIFOEnabled () </code></pre> <p>Get accelerometer FIFO enabled value. When set to 1, this bit enables ACCEL_XOUT_H, ACCEL_XOUT_L, ACCEL_YOUT_H, ACCEL_YOUT_L, ACCEL_ZOUT_H, and ACCEL_ZOUT_L (Registers 59 to 64) to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current accelerometer FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getaccelxselftest","title":"function mpu_getAccelXSelfTest","text":"<pre><code>bool mpu_getAccelXSelfTest () </code></pre> <p>Get self-test enabled setting for accelerometer X axis. </p> <p>Returns:</p> <p>Self-test enabled value </p> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getaccelyselftest","title":"function mpu_getAccelYSelfTest","text":"<pre><code>bool mpu_getAccelYSelfTest () </code></pre> <p>Get self-test enabled value for accelerometer Y axis. </p> <p>Returns:</p> <p>Self-test enabled value </p> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getaccelzselftest","title":"function mpu_getAccelZSelfTest","text":"<pre><code>bool mpu_getAccelZSelfTest () </code></pre> <p>Get self-test enabled value for accelerometer Z axis. </p> <p>Returns:</p> <p>Self-test enabled value </p> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getacceleration","title":"function mpu_getAcceleration","text":"<pre><code>void mpu_getAcceleration (\nint16_t * x,\nint16_t * y,\nint16_t * z\n) </code></pre> <p>Get 3-axis accelerometer readings. These registers store the most recent accelerometer measurements. Accelerometer measurements are written to these registers at the Sample Rate as defined in Register 25.</p> <p>The accelerometer measurement registers, along with the temperature measurement registers, gyroscope measurement registers, and external sensor data registers, are composed of two sets of registers: an internal register set and a user-facing read register set.</p> <p>The data within the accelerometer sensors' internal register set is always updated at the Sample Rate. Meanwhile, the user-facing read register set duplicates the internal register set's data values whenever the serial interface is idle. This guarantees that a burst read of sensor registers will read measurements from the same sampling instant. Note that if burst reads are not used, the user is responsible for ensuring a set of single byte reads correspond to a single sampling instant by checking the Data Ready interrupt.</p> <p>Each 16-bit accelerometer measurement has a full scale defined in ACCEL_FS (Register 28). For each full scale setting, the accelerometers' sensitivity per LSB in ACCEL_xOUT is shown in the table below:</p> <p>Parameters:</p> <ul> <li><code>x</code> 16-bit signed integer container for X-axis acceleration </li> <li><code>y</code> 16-bit signed integer container for Y-axis acceleration </li> <li><code>z</code> 16-bit signed integer container for Z-axis acceleration </li> </ul> <p>See also: mpu_RA_GYRO_XOUT_H </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getaccelerationx","title":"function mpu_getAccelerationX","text":"<pre><code>int16_t mpu_getAccelerationX () </code></pre> <p>Get X-axis accelerometer reading. </p> <p>Returns:</p> <p>X-axis acceleration measurement in 16-bit 2's complement format </p> <p>See also: getMotion6() </p> <p>See also: mpu_RA_ACCEL_XOUT_H </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getaccelerationy","title":"function mpu_getAccelerationY","text":"<pre><code>int16_t mpu_getAccelerationY () </code></pre> <p>Get Y-axis accelerometer reading. </p> <p>Returns:</p> <p>Y-axis acceleration measurement in 16-bit 2's complement format </p> <p>See also: getMotion6() </p> <p>See also: mpu_RA_ACCEL_YOUT_H </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getaccelerationz","title":"function mpu_getAccelerationZ","text":"<pre><code>int16_t mpu_getAccelerationZ () </code></pre> <p>Get Z-axis accelerometer reading. </p> <p>Returns:</p> <p>Z-axis acceleration measurement in 16-bit 2's complement format </p> <p>See also: getMotion6() </p> <p>See also: mpu_RA_ACCEL_ZOUT_H </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getaccelerometerpowerondelay","title":"function mpu_getAccelerometerPowerOnDelay","text":"<pre><code>uint8_t mpu_getAccelerometerPowerOnDelay () </code></pre> <p>Get accelerometer power-on delay. The accelerometer data path provides samples to the sensor registers, Motion detection, Zero Motion detection, and Free Fall detection modules. The signal path contains filters which must be flushed on wake-up with new samples before the detection modules begin operations. The default wake-up delay, of 4ms can be lengthened by up to 3ms. This additional delay is specified in ACCEL_ON_DELAY in units of 1 LSB = 1 ms. The user may select any value above zero unless instructed otherwise by InvenSense. Please refer to Section 8 of the MPU-6000/MPU-6050 Product Specification document for further information regarding the detection modules. </p> <p>Returns:</p> <p>Current accelerometer power-on delay </p> <p>See also: mpu_RA_MOT_DETECT_CTRL </p> <p>See also: mpu_DETECT_ACCEL_ON_DELAY_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getauxvddiolevel","title":"function mpu_getAuxVDDIOLevel","text":"<pre><code>uint8_t mpu_getAuxVDDIOLevel () </code></pre> <p>Get the auxiliary I2C supply voltage level. When set to 1, the auxiliary I2C bus high logic level is VDD. When cleared to 0, the auxiliary I2C bus high logic level is VLOGIC. This does not apply to the MPU-6000, which does not have a VLOGIC pin. </p> <p>Returns:</p> <p>I2C supply voltage level (0=VLOGIC, 1=VDD) </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getclockoutputenabled","title":"function mpu_getClockOutputEnabled","text":"<pre><code>bool mpu_getClockOutputEnabled () </code></pre> <p>Get reference clock output enabled status. When this bit is equal to 1, a reference clock output is provided at the CLKOUT pin. When this bit is equal to 0, the clock output is disabled. For further information regarding CLKOUT, please refer to the MPU-60X0 Product Specification document. </p> <p>Returns:</p> <p>Current reference clock output enabled status </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_CLKOUT_EN_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getclocksource","title":"function mpu_getClockSource","text":"<pre><code>uint8_t mpu_getClockSource () </code></pre> <p>Get clock source setting. </p> <p>Returns:</p> <p>Current clock source setting </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_CLKSEL_BIT </p> <p>See also: mpu_PWR1_CLKSEL_LENGTH </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getdhpfmode","title":"function mpu_getDHPFMode","text":"<pre><code>uint8_t mpu_getDHPFMode () </code></pre> <p>Get the high-pass filter configuration. The DHPF is a filter module in the path leading to motion detectors (Free Fall, Motion threshold, and Zero Motion). The high pass filter output is not available to the data registers (see Figure in Section 8 of the MPU-6000/ MPU-6050 Product Specification document).</p> <p>The high pass filter has three modes:</p> <p>Returns:</p> <p>Current high-pass filter configuration </p> <p>See also: mpu_DHPF_RESET </p> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getdlpfmode","title":"function mpu_getDLPFMode","text":"<pre><code>uint8_t mpu_getDLPFMode () </code></pre> <p>Get digital low-pass filter configuration. The DLPF_CFG parameter sets the digital low pass filter configuration. It also determines the internal sampling rate used by the device as shown in the table below.</p> <p>Note: The accelerometer output rate is 1kHz. This means that for a Sample Rate greater than 1kHz, the same accelerometer sample may be output to the FIFO, DMP, and sensor registers more than once.</p> <p>Returns:</p> <p>DLFP configuration </p> <p>See also: mpu_RA_CONFIG </p> <p>See also: mpu_CFG_DLPF_CFG_BIT </p> <p>See also: mpu_CFG_DLPF_CFG_LENGTH </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getexternalframesync","title":"function mpu_getExternalFrameSync","text":"<pre><code>uint8_t mpu_getExternalFrameSync () </code></pre> <p>Get external FSYNC configuration. Configures the external Frame Synchronization (FSYNC) pin sampling. An external signal connected to the FSYNC pin can be sampled by configuring EXT_SYNC_SET. Signal changes to the FSYNC pin are latched so that short strobes may be captured. The latched FSYNC signal will be sampled at the Sampling Rate, as defined in register 25. After sampling, the latch will reset to the current FSYNC signal state.</p> <p>The sampled value will be reported in place of the least significant bit in a sensor data register determined by the value of EXT_SYNC_SET according to the following table.</p> <p>Returns:</p> <p>FSYNC configuration value </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getexternalsensorbyte","title":"function mpu_getExternalSensorByte","text":"<pre><code>uint8_t mpu_getExternalSensorByte (\nint position\n) </code></pre> <p>Read single byte from external sensor data register. These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53).</p> <p>External sensor data is written to these registers at the Sample Rate as defined in Register 25. This access rate can be reduced by using the Slave Delay Enable registers (Register 103).</p> <p>External sensor data registers, along with the gyroscope measurement registers, accelerometer measurement registers, and temperature measurement registers, are composed of two sets of registers: an internal register set and a user-facing read register set.</p> <p>The data within the external sensors' internal register set is always updated at the Sample Rate (or the reduced access rate) whenever the serial interface is idle. This guarantees that a burst read of sensor registers will read measurements from the same sampling instant. Note that if burst reads are not used, the user is responsible for ensuring a set of single byte reads correspond to a single sampling instant by checking the Data Ready interrupt.</p> <p>Data is placed in these external sensor data registers according to I2C_SLV0_CTRL, I2C_SLV1_CTRL, I2C_SLV2_CTRL, and I2C_SLV3_CTRL (Registers 39, 42, 45, and 48). When more than zero bytes are read (I2C_SLVx_LEN &gt; 0) from an enabled slave (I2C_SLVx_EN = 1), the slave is read at the Sample Rate (as defined in Register 25) or delayed rate (if specified in Register 52 and 103). During each Sample cycle, slave reads are performed in order of Slave number. If all slaves are enabled with more than zero bytes to be read, the order will be Slave 0, followed by Slave 1, Slave 2, and Slave 3.</p> <p>Each enabled slave will have EXT_SENS_DATA registers associated with it by number of bytes read (I2C_SLVx_LEN) in order of slave number, starting from EXT_SENS_DATA_00. Note that this means enabling or disabling a slave may change the higher numbered slaves' associated registers. Furthermore, if fewer total bytes are being read from the external sensors as a result of such a change, then the data remaining in the registers which no longer have an associated slave device (i.e. high numbered registers) will remain in these previously allocated registers unless reset.</p> <p>If the sum of the read lengths of all SLVx transactions exceed the number of available EXT_SENS_DATA registers, the excess bytes will be dropped. There are 24 EXT_SENS_DATA registers and hence the total read lengths between all the slaves cannot be greater than 24 or some bytes will be lost.</p> <p>Note: Slave 4's behavior is distinct from that of Slaves 0-3. For further information regarding the characteristics of Slave 4, please refer to Registers 49 to 53.</p> <p>EXAMPLE: Suppose that Slave 0 is enabled with 4 bytes to be read (I2C_SLV0_EN = 1 and I2C_SLV0_LEN = 4) while Slave 1 is enabled with 2 bytes to be read so that I2C_SLV1_EN = 1 and I2C_SLV1_LEN = 2. In such a situation, EXT_SENS_DATA _00 through _03 will be associated with Slave 0, while EXT_SENS_DATA _04 and 05 will be associated with Slave 1. If Slave 2 is enabled as well, registers starting from EXT_SENS_DATA_06 will be allocated to Slave 2.</p> <p>If Slave 2 is disabled while Slave 3 is enabled in this same situation, then registers starting from EXT_SENS_DATA_06 will be allocated to Slave 3 instead.</p> <p>REGISTER ALLOCATION FOR DYNAMIC DISABLE VS. NORMAL DISABLE: If a slave is disabled at any time, the space initially allocated to the slave in the EXT_SENS_DATA register, will remain associated with that slave. This is to avoid dynamic adjustment of the register allocation.</p> <p>The allocation of the EXT_SENS_DATA registers is recomputed only when (1) all slaves are disabled, or (2) the I2C_MST_RST bit is set (Register 106).</p> <p>This above is also true if one of the slaves gets NACKed and stops functioning.</p> <p>Parameters:</p> <ul> <li><code>position</code> Starting position (0-23) </li> </ul> <p>Returns:</p> <p>Byte read from register </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getexternalsensordword","title":"function mpu_getExternalSensorDWord","text":"<pre><code>uint32_t mpu_getExternalSensorDWord (\nint position\n) </code></pre> <p>Read double word (4 bytes) from external sensor data registers. </p> <p>Parameters:</p> <ul> <li><code>position</code> Starting position (0-20) </li> </ul> <p>Returns:</p> <p>Double word read from registers </p> <p>See also: getExternalSensorByte() </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getexternalsensorword","title":"function mpu_getExternalSensorWord","text":"<pre><code>uint16_t mpu_getExternalSensorWord (\nint position\n) </code></pre> <p>Read word (2 bytes) from external sensor data registers. </p> <p>Parameters:</p> <ul> <li><code>position</code> Starting position (0-21) </li> </ul> <p>Returns:</p> <p>Word read from register </p> <p>See also: getExternalSensorByte() </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getexternalshadowdelayenabled","title":"function mpu_getExternalShadowDelayEnabled","text":"<pre><code>bool mpu_getExternalShadowDelayEnabled () </code></pre> <p>Get external data shadow delay enabled status. This register is used to specify the timing of external sensor data shadowing. When DELAY_ES_SHADOW is set to 1, shadowing of external sensor data is delayed until all data has been received. </p> <p>Returns:</p> <p>Current external data shadow delay enabled status. </p> <p>See also: mpu_RA_I2C_MST_DELAY_CTRL </p> <p>See also: mpu_DELAYCTRL_DELAY_ES_SHADOW_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getfifoenabled","title":"function mpu_getFIFOEnabled","text":"<pre><code>bool mpu_getFIFOEnabled () </code></pre> <p>Get FIFO enabled status. When this bit is set to 0, the FIFO mpu6050.buffer is disabled. The FIFO mpu6050.buffer cannot be written to or read from while disabled. The FIFO mpu6050.buffer's state does not change unless the MPU-60X0 is power cycled. </p> <p>Returns:</p> <p>Current FIFO enabled status </p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_FIFO_EN_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getfsyncinterruptenabled","title":"function mpu_getFSyncInterruptEnabled","text":"<pre><code>bool mpu_getFSyncInterruptEnabled () </code></pre> <p>Get FSYNC pin interrupt enabled setting. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled setting </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_FSYNC_INT_EN_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getfsyncinterruptlevel","title":"function mpu_getFSyncInterruptLevel","text":"<pre><code>bool mpu_getFSyncInterruptLevel () </code></pre> <p>Get FSYNC interrupt logic level mode. </p> <p>Returns:</p> <p>Current FSYNC interrupt mode (0=active-high, 1=active-low) </p> <p>See also: getFSyncInterruptMode() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_FSYNC_INT_LEVEL_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getfreefalldetectioncounterdecrement","title":"function mpu_getFreefallDetectionCounterDecrement","text":"<pre><code>uint8_t mpu_getFreefallDetectionCounterDecrement () </code></pre> <p>Get Free Fall detection counter decrement configuration. Detection is registered by the Free Fall detection module after accelerometer measurements meet their respective threshold conditions over a specified number of samples. When the threshold conditions are met, the corresponding detection counter increments by 1. The user may control the rate at which the detection counter decrements when the threshold condition is not met by configuring FF_COUNT. The decrement rate can be set according to the following table:</p> <p>When FF_COUNT is configured to 0 (reset), any non-qualifying sample will reset the counter to 0. For further information on Free Fall detection, please refer to Registers 29 to 32.</p> <p>Returns:</p> <p>Current decrement configuration </p> <p>See also: mpu_RA_MOT_DETECT_CTRL </p> <p>See also: mpu_DETECT_FF_COUNT_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getfreefalldetectionduration","title":"function mpu_getFreefallDetectionDuration","text":"<pre><code>uint8_t mpu_getFreefallDetectionDuration () </code></pre> <p>Get free-fall event duration threshold. This register configures the duration counter threshold for Free Fall event detection. The duration counter ticks at 1kHz, therefore FF_DUR has a unit of 1 LSB = 1 ms.</p> <p>The Free Fall duration counter increments while the absolute value of the accelerometer measurements are each less than the detection threshold (Register 29). The Free Fall interrupt is triggered when the Free Fall duration counter reaches the time specified in this register.</p> <p>For more details on the Free Fall detection interrupt, see Section 8.2 of the MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and 58 of this document.</p> <p>Returns:</p> <p>Current free-fall duration threshold value (LSB = 1ms) </p> <p>See also: mpu_RA_FF_DUR </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getfreefalldetectionthreshold","title":"function mpu_getFreefallDetectionThreshold","text":"<pre><code>uint8_t mpu_getFreefallDetectionThreshold () </code></pre> <p>Get free-fall event acceleration threshold. This register configures the detection threshold for Free Fall event detection. The unit of FF_THR is 1LSB = 2mg. Free Fall is detected when the absolute value of the accelerometer measurements for the three axes are each less than the detection threshold. This condition increments the Free Fall duration counter (Register 30). The Free Fall interrupt is triggered when the Free Fall duration counter reaches the time specified in FF_DUR.</p> <p>For more details on the Free Fall detection interrupt, see Section 8.2 of the MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and 58 of this document.</p> <p>Returns:</p> <p>Current free-fall acceleration threshold value (LSB = 2mg) </p> <p>See also: mpu_RA_FF_THR </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getfullscaleaccelrange","title":"function mpu_getFullScaleAccelRange","text":"<pre><code>uint8_t mpu_getFullScaleAccelRange () </code></pre> <p>Get full-scale accelerometer range. The FS_SEL parameter allows setting the full-scale range of the accelerometer sensors, as described in the table below.</p> <p>Returns:</p> <p>Current full-scale accelerometer range setting </p> <p>See also: mpu_ACCEL_FS_2 </p> <p>See also: mpu_RA_ACCEL_CONFIG </p> <p>See also: mpu_ACONFIG_AFS_SEL_BIT </p> <p>See also: mpu_ACONFIG_AFS_SEL_LENGTH </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getfullscalegyrorange","title":"function mpu_getFullScaleGyroRange","text":"<pre><code>uint8_t mpu_getFullScaleGyroRange () </code></pre> <p>Get full-scale gyroscope range. The FS_SEL parameter allows setting the full-scale range of the gyro sensors, as described in the table below.</p> <p>Returns:</p> <p>Current full-scale gyroscope range setting </p> <p>See also: mpu_GYRO_FS_250 </p> <p>See also: mpu_RA_GYRO_CONFIG </p> <p>See also: mpu_GCONFIG_FS_SEL_BIT </p> <p>See also: mpu_GCONFIG_FS_SEL_LENGTH </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_geti2cbypassenabled","title":"function mpu_getI2CBypassEnabled","text":"<pre><code>bool mpu_getI2CBypassEnabled () </code></pre> <p>Get I2C bypass enabled status. When this bit is equal to 1 and I2C_MST_EN (Register 106 bit[5]) is equal to 0, the host application processor will be able to directly access the auxiliary I2C bus of the MPU-60X0. When this bit is equal to 0, the host application processor will not be able to directly access the auxiliary I2C bus of the MPU-60X0 regardless of the state of I2C_MST_EN (Register 106 bit[5]). </p> <p>Returns:</p> <p>Current I2C bypass enabled status </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_I2C_BYPASS_EN_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_geti2cmastermodeenabled","title":"function mpu_getI2CMasterModeEnabled","text":"<pre><code>bool mpu_getI2CMasterModeEnabled () </code></pre> <p>Get I2C Master Mode enabled status. When this mode is enabled, the MPU-60X0 acts as the I2C Master to the external sensor slave devices on the auxiliary I2C bus. When this bit is cleared to 0, the auxiliary I2C bus lines (AUX_DA and AUX_CL) are logically driven by the primary I2C bus (SDA and SCL). This is a precondition to enabling Bypass Mode. For further information regarding Bypass Mode, please refer to Register 55. </p> <p>Returns:</p> <p>Current I2C Master Mode enabled status </p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_I2C_MST_EN_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getintdatareadyenabled","title":"function mpu_getIntDataReadyEnabled","text":"<pre><code>bool mpu_getIntDataReadyEnabled () </code></pre> <p>Get Data Ready interrupt enabled setting. This event occurs each time a write operation to all of the sensor registers has been completed. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_DATA_RDY_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getintdatareadystatus","title":"function mpu_getIntDataReadyStatus","text":"<pre><code>bool mpu_getIntDataReadyStatus () </code></pre> <p>Get Data Ready interrupt status. This bit automatically sets to 1 when a Data Ready interrupt has been generated. The bit clears to 0 after the register has been read. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p> <p>See also: mpu_INTERRUPT_DATA_RDY_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getintenabled","title":"function mpu_getIntEnabled","text":"<pre><code>uint8_t mpu_getIntEnabled () </code></pre> <p>Get full interrupt enabled status. Full register byte for all interrupts, for quick reading. Each bit will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_FF_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getintfifobufferoverflowenabled","title":"function mpu_getIntFIFOBufferOverflowEnabled","text":"<pre><code>bool mpu_getIntFIFOBufferOverflowEnabled () </code></pre> <p>Get FIFO Buffer Overflow interrupt enabled status. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_FIFO_OFLOW_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getintfifobufferoverflowstatus","title":"function mpu_getIntFIFOBufferOverflowStatus","text":"<pre><code>bool mpu_getIntFIFOBufferOverflowStatus () </code></pre> <p>Get FIFO Buffer Overflow interrupt status. This bit automatically sets to 1 when a Free Fall interrupt has been generated. The bit clears to 0 after the register has been read. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p> <p>See also: mpu_INTERRUPT_FIFO_OFLOW_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getintfreefallenabled","title":"function mpu_getIntFreefallEnabled","text":"<pre><code>bool mpu_getIntFreefallEnabled () </code></pre> <p>Get Free Fall interrupt enabled status. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_FF_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getintfreefallstatus","title":"function mpu_getIntFreefallStatus","text":"<pre><code>bool mpu_getIntFreefallStatus () </code></pre> <p>Get Free Fall interrupt status. This bit automatically sets to 1 when a Free Fall interrupt has been generated. The bit clears to 0 after the register has been read. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p> <p>See also: mpu_INTERRUPT_FF_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getinti2cmasterenabled","title":"function mpu_getIntI2CMasterEnabled","text":"<pre><code>bool mpu_getIntI2CMasterEnabled () </code></pre> <p>Get I2C Master interrupt enabled status. This enables any of the I2C Master interrupt sources to generate an interrupt. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_I2C_MST_INT_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getinti2cmasterstatus","title":"function mpu_getIntI2CMasterStatus","text":"<pre><code>bool mpu_getIntI2CMasterStatus () </code></pre> <p>Get I2C Master interrupt status. This bit automatically sets to 1 when an I2C Master interrupt has been generated. For a list of I2C Master interrupts, please refer to Register 54. The bit clears to 0 after the register has been read. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p> <p>See also: mpu_INTERRUPT_I2C_MST_INT_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getintmotionenabled","title":"function mpu_getIntMotionEnabled","text":"<pre><code>bool mpu_getIntMotionEnabled () </code></pre> <p>Get Motion Detection interrupt enabled status. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_MOT_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getintmotionstatus","title":"function mpu_getIntMotionStatus","text":"<pre><code>bool mpu_getIntMotionStatus () </code></pre> <p>Get Motion Detection interrupt status. This bit automatically sets to 1 when a Motion Detection interrupt has been generated. The bit clears to 0 after the register has been read. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p> <p>See also: mpu_INTERRUPT_MOT_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getintstatus","title":"function mpu_getIntStatus","text":"<pre><code>uint8_t mpu_getIntStatus () </code></pre> <p>Get full set of interrupt status bits. These bits clear to 0 after the register has been read. Very useful for getting multiple INT statuses, since each single bit read clears all of them because it has to read the whole byte. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getintzeromotionenabled","title":"function mpu_getIntZeroMotionEnabled","text":"<pre><code>bool mpu_getIntZeroMotionEnabled () </code></pre> <p>Get Zero Motion Detection interrupt enabled status. Will be set 0 for disabled, 1 for enabled. </p> <p>Returns:</p> <p>Current interrupt enabled status </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_ZMOT_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getintzeromotionstatus","title":"function mpu_getIntZeroMotionStatus","text":"<pre><code>bool mpu_getIntZeroMotionStatus () </code></pre> <p>Get Zero Motion Detection interrupt status. This bit automatically sets to 1 when a Zero Motion Detection interrupt has been generated. The bit clears to 0 after the register has been read. </p> <p>Returns:</p> <p>Current interrupt status </p> <p>See also: mpu_RA_INT_STATUS </p> <p>See also: mpu_INTERRUPT_ZMOT_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getinterruptdrive","title":"function mpu_getInterruptDrive","text":"<pre><code>bool mpu_getInterruptDrive () </code></pre> <p>Get interrupt drive mode. Will be set 0 for push-pull, 1 for open-drain. </p> <p>Returns:</p> <p>Current interrupt drive mode (0=push-pull, 1=open-drain) </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_INT_OPEN_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getinterruptlatch","title":"function mpu_getInterruptLatch","text":"<pre><code>bool mpu_getInterruptLatch () </code></pre> <p>Get interrupt latch mode. Will be set 0 for 50us-pulse, 1 for latch-until-int-cleared. </p> <p>Returns:</p> <p>Current latch mode (0=50us-pulse, 1=latch-until-int-cleared) </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_LATCH_INT_EN_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getinterruptlatchclear","title":"function mpu_getInterruptLatchClear","text":"<pre><code>bool mpu_getInterruptLatchClear () </code></pre> <p>Get interrupt latch clear mode. Will be set 0 for status-read-only, 1 for any-register-read. </p> <p>Returns:</p> <p>Current latch clear mode (0=status-read-only, 1=any-register-read) </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_INT_RD_CLEAR_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getinterruptmode","title":"function mpu_getInterruptMode","text":"<pre><code>bool mpu_getInterruptMode () </code></pre> <p>Get interrupt logic level mode. Will be set 0 for active-high, 1 for active-low. </p> <p>Returns:</p> <p>Current interrupt mode (0=active-high, 1=active-low) </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_INT_LEVEL_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getlostarbitration","title":"function mpu_getLostArbitration","text":"<pre><code>bool mpu_getLostArbitration () </code></pre> <p>Get master arbitration lost status. This bit automatically sets to 1 when the I2C Master has lost arbitration of the auxiliary I2C bus (an error condition). This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted. </p> <p>Returns:</p> <p>Master arbitration lost status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getmasterclockspeed","title":"function mpu_getMasterClockSpeed","text":"<pre><code>uint8_t mpu_getMasterClockSpeed () </code></pre> <p>Get I2C master clock speed. I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the MPU-60X0 internal 8MHz clock. It sets the I2C master clock speed according to the following table:</p> <p>Returns:</p> <p>Current I2C master clock speed </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getmotion6","title":"function mpu_getMotion6","text":"<pre><code>void mpu_getMotion6 (\nint16_t * ax,\nint16_t * ay,\nint16_t * az,\nint16_t * gx,\nint16_t * gy,\nint16_t * gz\n) </code></pre> <p>Get raw 6-axis motion sensor readings (accel/gyro). Retrieves all currently available motion sensor values. </p> <p>Parameters:</p> <ul> <li><code>ax</code> 16-bit signed integer container for accelerometer X-axis value </li> <li><code>ay</code> 16-bit signed integer container for accelerometer Y-axis value </li> <li><code>az</code> 16-bit signed integer container for accelerometer Z-axis value </li> <li><code>gx</code> 16-bit signed integer container for gyroscope X-axis value </li> <li><code>gy</code> 16-bit signed integer container for gyroscope Y-axis value </li> <li><code>gz</code> 16-bit signed integer container for gyroscope Z-axis value </li> </ul> <p>See also: getAcceleration() </p> <p>See also: getRotation() </p> <p>See also: mpu_RA_ACCEL_XOUT_H </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getmotion9","title":"function mpu_getMotion9","text":"<pre><code>void mpu_getMotion9 (\nint16_t * ax,\nint16_t * ay,\nint16_t * az,\nint16_t * gx,\nint16_t * gy,\nint16_t * gz,\nint16_t * mx,\nint16_t * my,\nint16_t * mz\n) </code></pre> <p>Get raw 9-axis motion sensor readings (accel/gyro/compass). FUNCTION NOT FULLY IMPLEMENTED YET. </p> <p>Parameters:</p> <ul> <li><code>ax</code> 16-bit signed integer container for accelerometer X-axis value </li> <li><code>ay</code> 16-bit signed integer container for accelerometer Y-axis value </li> <li><code>az</code> 16-bit signed integer container for accelerometer Z-axis value </li> <li><code>gx</code> 16-bit signed integer container for gyroscope X-axis value </li> <li><code>gy</code> 16-bit signed integer container for gyroscope Y-axis value </li> <li><code>gz</code> 16-bit signed integer container for gyroscope Z-axis value </li> <li><code>mx</code> 16-bit signed integer container for magnetometer X-axis value </li> <li><code>my</code> 16-bit signed integer container for magnetometer Y-axis value </li> <li><code>mz</code> 16-bit signed integer container for magnetometer Z-axis value </li> </ul> <p>See also: getMotion6() </p> <p>See also: getAcceleration() </p> <p>See also: getRotation() </p> <p>See also: mpu_RA_ACCEL_XOUT_H </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getmotiondetectioncounterdecrement","title":"function mpu_getMotionDetectionCounterDecrement","text":"<pre><code>uint8_t mpu_getMotionDetectionCounterDecrement () </code></pre> <p>Get Motion detection counter decrement configuration. Detection is registered by the Motion detection module after accelerometer measurements meet their respective threshold conditions over a specified number of samples. When the threshold conditions are met, the corresponding detection counter increments by 1. The user may control the rate at which the detection counter decrements when the threshold condition is not met by configuring MOT_COUNT. The decrement rate can be set according to the following table:</p> <p>When MOT_COUNT is configured to 0 (reset), any non-qualifying sample will reset the counter to 0. For further information on Motion detection, please refer to Registers 29 to 32. </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getmotiondetectionduration","title":"function mpu_getMotionDetectionDuration","text":"<pre><code>uint8_t mpu_getMotionDetectionDuration () </code></pre> <p>Get motion detection event duration threshold. This register configures the duration counter threshold for Motion interrupt generation. The duration counter ticks at 1 kHz, therefore MOT_DUR has a unit of 1LSB = 1ms. The Motion detection duration counter increments when the absolute value of any of the accelerometer measurements exceeds the Motion detection threshold (Register 31). The Motion detection interrupt is triggered when the Motion detection counter reaches the time count specified in this register.</p> <p>For more details on the Motion detection interrupt, see Section 8.3 of the MPU-6000/MPU-6050 Product Specification document.</p> <p>Returns:</p> <p>Current motion detection duration threshold value (LSB = 1ms) </p> <p>See also: mpu_RA_MOT_DUR </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getmotiondetectionthreshold","title":"function mpu_getMotionDetectionThreshold","text":"<pre><code>uint8_t mpu_getMotionDetectionThreshold () </code></pre> <p>Get motion detection event acceleration threshold. This register configures the detection threshold for Motion interrupt generation. The unit of MOT_THR is 1LSB = 2mg. Motion is detected when the absolute value of any of the accelerometer measurements exceeds this Motion detection threshold. This condition increments the Motion detection duration counter (Register 32). The Motion detection interrupt is triggered when the Motion Detection counter reaches the time count specified in MOT_DUR (Register 32).</p> <p>The Motion interrupt will indicate the axis and polarity of detected motion in MOT_DETECT_STATUS (Register 97).</p> <p>For more details on the Motion detection interrupt, see Section 8.3 of the MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and 58 of this document.</p> <p>Returns:</p> <p>Current motion detection acceleration threshold value (LSB = 2mg) </p> <p>See also: mpu_RA_MOT_THR </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getmultimasterenabled","title":"function mpu_getMultiMasterEnabled","text":"<pre><code>bool mpu_getMultiMasterEnabled () </code></pre> <p>Get multi-master enabled value. Multi-master capability allows multiple I2C masters to operate on the same bus. In circuits where multi-master capability is required, set MULT_MST_EN to 1. This will increase current drawn by approximately 30uA.</p> <p>In circuits where multi-master capability is required, the state of the I2C bus must always be monitored by each separate I2C Master. Before an I2C Master can assume arbitration of the bus, it must first confirm that no other I2C Master has arbitration of the bus. When MULT_MST_EN is set to 1, the MPU-60X0's bus arbitration detection logic is turned on, enabling it to detect when the bus is available.</p> <p>Returns:</p> <p>Current multi-master enabled value </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getpassthroughstatus","title":"function mpu_getPassthroughStatus","text":"<pre><code>bool mpu_getPassthroughStatus () </code></pre> <p>Get FSYNC interrupt status. This bit reflects the status of the FSYNC interrupt from an external device into the MPU-60X0. This is used as a way to pass an external interrupt through the MPU-60X0 to the host application processor. When set to 1, this bit will cause an interrupt if FSYNC_INT_EN is asserted in INT_PIN_CFG (Register 55). </p> <p>Returns:</p> <p>FSYNC interrupt status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getrate","title":"function mpu_getRate","text":"<pre><code>uint8_t mpu_getRate () </code></pre> <p>Get gyroscope output rate divider. The sensor register output, FIFO output, DMP sampling, Motion detection, Zero Motion detection, and Free Fall detection are all based on the Sample Rate. The Sample Rate is generated by dividing the gyroscope output rate by SMPLRT_DIV:</p> <p>Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)</p> <p>where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or 7), and 1kHz when the DLPF is enabled (see Register 26).</p> <p>Note: The accelerometer output rate is 1kHz. This means that for a Sample Rate greater than 1kHz, the same accelerometer sample may be output to the FIFO, DMP, and sensor registers more than once.</p> <p>For a diagram of the gyroscope and accelerometer signal paths, see Section 8 of the MPU-6000/MPU-6050 Product Specification document.</p> <p>Returns:</p> <p>Current sample rate </p> <p>See also: mpu_RA_SMPLRT_DIV </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getrotation","title":"function mpu_getRotation","text":"<pre><code>void mpu_getRotation (\nint16_t * x,\nint16_t * y,\nint16_t * z\n) </code></pre> <p>Get 3-axis gyroscope readings. These gyroscope measurement registers, along with the accelerometer measurement registers, temperature measurement registers, and external sensor data registers, are composed of two sets of registers: an internal register set and a user-facing read register set. The data within the gyroscope sensors' internal register set is always updated at the Sample Rate. Meanwhile, the user-facing read register set duplicates the internal register set's data values whenever the serial interface is idle. This guarantees that a burst read of sensor registers will read measurements from the same sampling instant. Note that if burst reads are not used, the user is responsible for ensuring a set of single byte reads correspond to a single sampling instant by checking the Data Ready interrupt.</p> <p>Each 16-bit gyroscope measurement has a full scale defined in FS_SEL (Register 27). For each full scale setting, the gyroscopes' sensitivity per LSB in GYRO_xOUT is shown in the table below:</p> <p>Parameters:</p> <ul> <li><code>x</code> 16-bit signed integer container for X-axis rotation </li> <li><code>y</code> 16-bit signed integer container for Y-axis rotation </li> <li><code>z</code> 16-bit signed integer container for Z-axis rotation </li> </ul> <p>See also: getMotion6() </p> <p>See also: mpu_RA_GYRO_XOUT_H </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getrotationx","title":"function mpu_getRotationX","text":"<pre><code>int16_t mpu_getRotationX () </code></pre> <p>Get X-axis gyroscope reading. </p> <p>Returns:</p> <p>X-axis rotation measurement in 16-bit 2's complement format </p> <p>See also: getMotion6() </p> <p>See also: mpu_RA_GYRO_XOUT_H </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getrotationy","title":"function mpu_getRotationY","text":"<pre><code>int16_t mpu_getRotationY () </code></pre> <p>Get Y-axis gyroscope reading. </p> <p>Returns:</p> <p>Y-axis rotation measurement in 16-bit 2's complement format </p> <p>See also: getMotion6() </p> <p>See also: mpu_RA_GYRO_YOUT_H </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getrotationz","title":"function mpu_getRotationZ","text":"<pre><code>int16_t mpu_getRotationZ () </code></pre> <p>Get Z-axis gyroscope reading. </p> <p>Returns:</p> <p>Z-axis rotation measurement in 16-bit 2's complement format </p> <p>See also: getMotion6() </p> <p>See also: mpu_RA_GYRO_ZOUT_H </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslate4inputbyte","title":"function mpu_getSlate4InputByte","text":"<pre><code>uint8_t mpu_getSlate4InputByte () </code></pre> <p>Get last available byte read from Slave 4. This register stores the data read from Slave 4. This field is populated after a read transaction. </p> <p>Returns:</p> <p>Last available byte read from to Slave 4 </p> <p>See also: mpu_RA_I2C_SLV4_DI </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslave0fifoenabled","title":"function mpu_getSlave0FIFOEnabled","text":"<pre><code>bool mpu_getSlave0FIFOEnabled () </code></pre> <p>Get Slave 0 FIFO enabled value. When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 0 to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current Slave 0 FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslave0nack","title":"function mpu_getSlave0Nack","text":"<pre><code>bool mpu_getSlave0Nack () </code></pre> <p>Get Slave 0 NACK status. This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 0. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted. </p> <p>Returns:</p> <p>Slave 0 NACK interrupt status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslave1fifoenabled","title":"function mpu_getSlave1FIFOEnabled","text":"<pre><code>bool mpu_getSlave1FIFOEnabled () </code></pre> <p>Get Slave 1 FIFO enabled value. When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 1 to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current Slave 1 FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslave1nack","title":"function mpu_getSlave1Nack","text":"<pre><code>bool mpu_getSlave1Nack () </code></pre> <p>Get Slave 1 NACK status. This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 1. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted. </p> <p>Returns:</p> <p>Slave 1 NACK interrupt status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslave2fifoenabled","title":"function mpu_getSlave2FIFOEnabled","text":"<pre><code>bool mpu_getSlave2FIFOEnabled () </code></pre> <p>Get Slave 2 FIFO enabled value. When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 2 to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current Slave 2 FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslave2nack","title":"function mpu_getSlave2Nack","text":"<pre><code>bool mpu_getSlave2Nack () </code></pre> <p>Get Slave 2 NACK status. This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 2. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted. </p> <p>Returns:</p> <p>Slave 2 NACK interrupt status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslave3fifoenabled","title":"function mpu_getSlave3FIFOEnabled","text":"<pre><code>bool mpu_getSlave3FIFOEnabled () </code></pre> <p>Get Slave 3 FIFO enabled value. When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 3 to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current Slave 3 FIFO enabled value </p> <p>See also: mpu_RA_MST_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslave3nack","title":"function mpu_getSlave3Nack","text":"<pre><code>bool mpu_getSlave3Nack () </code></pre> <p>Get Slave 3 NACK status. This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 3. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted. </p> <p>Returns:</p> <p>Slave 3 NACK interrupt status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslave4address","title":"function mpu_getSlave4Address","text":"<pre><code>uint8_t mpu_getSlave4Address () </code></pre> <p>Get the I2C address of Slave 4. Note that Bit 7 (MSB) controls read/write mode. If Bit 7 is set, it's a read operation, and if it is cleared, then it's a write operation. The remaining bits (6-0) are the 7-bit device address of the slave device.</p> <p>Returns:</p> <p>Current address for Slave 4 </p> <p>See also: getSlaveAddress() </p> <p>See also: mpu_RA_I2C_SLV4_ADDR </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslave4enabled","title":"function mpu_getSlave4Enabled","text":"<pre><code>bool mpu_getSlave4Enabled () </code></pre> <p>Get the enabled value for the Slave 4. When set to 1, this bit enables Slave 4 for data transfer operations. When cleared to 0, this bit disables Slave 4 from data transfer operations. </p> <p>Returns:</p> <p>Current enabled value for Slave 4 </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslave4interruptenabled","title":"function mpu_getSlave4InterruptEnabled","text":"<pre><code>bool mpu_getSlave4InterruptEnabled () </code></pre> <p>Get the enabled value for Slave 4 transaction interrupts. When set to 1, this bit enables the generation of an interrupt signal upon completion of a Slave 4 transaction. When cleared to 0, this bit disables the generation of an interrupt signal upon completion of a Slave 4 transaction. The interrupt status can be observed in Register 54.</p> <p>Returns:</p> <p>Current enabled value for Slave 4 transaction interrupts. </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslave4isdone","title":"function mpu_getSlave4IsDone","text":"<pre><code>bool mpu_getSlave4IsDone () </code></pre> <p>Get Slave 4 transaction done status. Automatically sets to 1 when a Slave 4 transaction has completed. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted and if the SLV_4_DONE_INT bit is asserted in the I2C_SLV4_CTRL register (Register 52). </p> <p>Returns:</p> <p>Slave 4 transaction done status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslave4masterdelay","title":"function mpu_getSlave4MasterDelay","text":"<pre><code>uint8_t mpu_getSlave4MasterDelay () </code></pre> <p>Get Slave 4 master delay value. This configures the reduced access rate of I2C slaves relative to the Sample Rate. When a slave's access rate is decreased relative to the Sample Rate, the slave is accessed every:  This base Sample Rate in turn is determined by SMPLRT_DIV (register 25) and DLPF_CFG (register 26). Whether a slave's access rate is reduced relative to the Sample Rate is determined by I2C_MST_DELAY_CTRL (register 103). For further information regarding the Sample Rate, please refer to register 25.</p> <p>Returns:</p> <p>Current Slave 4 master delay value </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslave4nack","title":"function mpu_getSlave4Nack","text":"<pre><code>bool mpu_getSlave4Nack () </code></pre> <p>Get Slave 4 NACK status. This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 4. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted. </p> <p>Returns:</p> <p>Slave 4 NACK interrupt status </p> <p>See also: mpu_RA_I2C_MST_STATUS </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslave4register","title":"function mpu_getSlave4Register","text":"<pre><code>uint8_t mpu_getSlave4Register () </code></pre> <p>Get the active internal register for the Slave 4. Read/write operations for this slave will be done to whatever internal register address is stored in this MPU register.</p> <p>Returns:</p> <p>Current active register for Slave 4 </p> <p>See also: mpu_RA_I2C_SLV4_REG </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslave4writemode","title":"function mpu_getSlave4WriteMode","text":"<pre><code>bool mpu_getSlave4WriteMode () </code></pre> <p>Get write mode for Slave 4. When set to 1, the transaction will read or write data only. When cleared to 0, the transaction will write a register address prior to reading or writing data. This should equal 0 when specifying the register address within the Slave device to/from which the ensuing data transaction will take place.</p> <p>Returns:</p> <p>Current write mode for Slave 4 (0 = register address + data, 1 = data only) </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslaveaddress","title":"function mpu_getSlaveAddress","text":"<pre><code>uint8_t mpu_getSlaveAddress (\nuint8_t num\n) </code></pre> <p>Get the I2C address of the specified slave (0-3). Note that Bit 7 (MSB) controls read/write mode. If Bit 7 is set, it's a read operation, and if it is cleared, then it's a write operation. The remaining bits (6-0) are the 7-bit device address of the slave device.</p> <p>In read mode, the result of the read is placed in the lowest available EXT_SENS_DATA register. For further information regarding the allocation of read results, please refer to the EXT_SENS_DATA register description (Registers 73 - 96).</p> <p>The MPU-6050 supports a total of five slaves, but Slave 4 has unique characteristics, and so it has its own functions (getSlave4* and setSlave4*).</p> <p>I2C data transactions are performed at the Sample Rate, as defined in Register 25. The user is responsible for ensuring that I2C data transactions to and from each enabled Slave can be completed within a single period of the Sample Rate.</p> <p>The I2C slave access rate can be reduced relative to the Sample Rate. This reduced access rate is determined by I2C_MST_DLY (Register 52). Whether a slave's access rate is reduced relative to the Sample Rate is determined by I2C_MST_DELAY_CTRL (Register 103).</p> <p>The processing order for the slaves is fixed. The sequence followed for processing the slaves is Slave 0, Slave 1, Slave 2, Slave 3 and Slave 4. If a particular Slave is disabled it will be skipped.</p> <p>Each slave can either be accessed at the sample rate or at a reduced sample rate. In a case where some slaves are accessed at the Sample Rate and some slaves are accessed at the reduced rate, the sequence of accessing the slaves (Slave 0 to Slave 4) is still followed. However, the reduced rate slaves will be skipped if their access rate dictates that they should not be accessed during that particular cycle. For further information regarding the reduced access rate, please refer to Register 52. Whether a slave is accessed at the Sample Rate or at the reduced rate is determined by the Delay Enable bits in Register 103.</p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Current address for specified slave </p> <p>See also: mpu_RA_I2C_SLV0_ADDR </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslavedatalength","title":"function mpu_getSlaveDataLength","text":"<pre><code>uint8_t mpu_getSlaveDataLength (\nuint8_t num\n) </code></pre> <p>Get number of bytes to read for the specified slave (0-3). Specifies the number of bytes transferred to and from Slave 0. Clearing this bit to 0 is equivalent to disabling the register by writing 0 to I2C_SLV0_EN. </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Number of bytes to read for specified slave </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslavedelayenabled","title":"function mpu_getSlaveDelayEnabled","text":"<pre><code>bool mpu_getSlaveDelayEnabled (\nuint8_t num\n) </code></pre> <p>Get slave delay enabled status. When a particular slave delay is enabled, the rate of access for the that slave device is reduced. When a slave's access rate is decreased relative to the Sample Rate, the slave is accessed every:  This base Sample Rate in turn is determined by SMPLRT_DIV (register * 25) and DLPF_CFG (register 26).</p> <p>For further information regarding I2C_MST_DLY, please refer to register 52. For further information regarding the Sample Rate, please refer to register 25.</p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-4) </li> </ul> <p>Returns:</p> <p>Current slave delay enabled status. </p> <p>See also: mpu_RA_I2C_MST_DELAY_CTRL </p> <p>See also: mpu_DELAYCTRL_I2C_SLV0_DLY_EN_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslaveenabled","title":"function mpu_getSlaveEnabled","text":"<pre><code>bool mpu_getSlaveEnabled (\nuint8_t num\n) </code></pre> <p>Get the enabled value for the specified slave (0-3). When set to 1, this bit enables Slave 0 for data transfer operations. When cleared to 0, this bit disables Slave 0 from data transfer operations. </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Current enabled value for specified slave </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslavereadwritetransitionenabled","title":"function mpu_getSlaveReadWriteTransitionEnabled","text":"<pre><code>bool mpu_getSlaveReadWriteTransitionEnabled () </code></pre> <p>Get slave read/write transition enabled value. The I2C_MST_P_NSR bit configures the I2C Master's transition from one slave read to the next slave read. If the bit equals 0, there will be a restart between reads. If the bit equals 1, there will be a stop followed by a start of the following read. When a write transaction follows a read transaction, the stop followed by a start of the successive write will be always used.</p> <p>Returns:</p> <p>Current slave read/write transition enabled value </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslaveregister","title":"function mpu_getSlaveRegister","text":"<pre><code>uint8_t mpu_getSlaveRegister (\nuint8_t num\n) </code></pre> <p>Get the active internal register for the specified slave (0-3). Read/write operations for this slave will be done to whatever internal register address is stored in this MPU register.</p> <p>The MPU-6050 supports a total of five slaves, but Slave 4 has unique characteristics, and so it has its own functions.</p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Current active register for specified slave </p> <p>See also: mpu_RA_I2C_SLV0_REG </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslavewordbyteswap","title":"function mpu_getSlaveWordByteSwap","text":"<pre><code>bool mpu_getSlaveWordByteSwap (\nuint8_t num\n) </code></pre> <p>Get word pair byte-swapping enabled for the specified slave (0-3). When set to 1, this bit enables byte swapping. When byte swapping is enabled, the high and low bytes of a word pair are swapped. Please refer to I2C_SLV0_GRP for the pairing convention of the word pairs. When cleared to 0, bytes transferred to and from Slave 0 will be written to EXT_SENS_DATA registers in the order they were transferred.</p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Current word pair byte-swapping enabled value for specified slave </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslavewordgroupoffset","title":"function mpu_getSlaveWordGroupOffset","text":"<pre><code>bool mpu_getSlaveWordGroupOffset (\nuint8_t num\n) </code></pre> <p>Get word pair grouping order offset for the specified slave (0-3). This sets specifies the grouping order of word pairs received from registers. When cleared to 0, bytes from register addresses 0 and 1, 2 and 3, etc (even, then odd register addresses) are paired to form a word. When set to 1, bytes from register addresses are paired 1 and 2, 3 and 4, etc. (odd, then even register addresses) are paired to form a word.</p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Current word pair grouping order offset for specified slave </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getslavewritemode","title":"function mpu_getSlaveWriteMode","text":"<pre><code>bool mpu_getSlaveWriteMode (\nuint8_t num\n) </code></pre> <p>Get write mode for the specified slave (0-3). When set to 1, the transaction will read or write data only. When cleared to 0, the transaction will write a register address prior to reading or writing data. This should equal 0 when specifying the register address within the Slave device to/from which the ensuing data transaction will take place.</p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> </ul> <p>Returns:</p> <p>Current write mode for specified slave (0 = register address + data, 1 = data only) </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getsleepenabled","title":"function mpu_getSleepEnabled","text":"<pre><code>bool mpu_getSleepEnabled () </code></pre> <p>Get sleep mode status. Setting the SLEEP bit in the register puts the device into very low power sleep mode. In this mode, only the serial interface and internal registers remain active, allowing for a very low standby current. Clearing this bit puts the device back into normal mode. To save power, the individual standby selections for each of the gyros should be used if any gyro axis is not used by the application. </p> <p>Returns:</p> <p>Current sleep mode enabled status </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_SLEEP_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_gettempfifoenabled","title":"function mpu_getTempFIFOEnabled","text":"<pre><code>bool mpu_getTempFIFOEnabled () </code></pre> <p>Get temperature FIFO enabled value. When set to 1, this bit enables TEMP_OUT_H and TEMP_OUT_L (Registers 65 and 66) to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current temperature FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_gettempsensorenabled","title":"function mpu_getTempSensorEnabled","text":"<pre><code>bool mpu_getTempSensorEnabled () </code></pre> <p>Get temperature sensor enabled status. Control the usage of the internal temperature sensor.</p> <p>Note: this register stores the disabled value, but for consistency with the rest of the code, the function is named and used with standard true/false values to indicate whether the sensor is enabled or disabled, respectively.</p> <p>Returns:</p> <p>Current temperature sensor enabled status </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_TEMP_DIS_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_gettemperature","title":"function mpu_getTemperature","text":"<pre><code>int16_t mpu_getTemperature () </code></pre> <p>Get current internal temperature. </p> <p>Returns:</p> <p>Temperature reading in 16-bit 2's complement format </p> <p>See also: mpu_RA_TEMP_OUT_H </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getwaitforexternalsensorenabled","title":"function mpu_getWaitForExternalSensorEnabled","text":"<pre><code>bool mpu_getWaitForExternalSensorEnabled () </code></pre> <p>Get wait-for-external-sensor-data enabled value. When the WAIT_FOR_ES bit is set to 1, the Data Ready interrupt will be delayed until External Sensor data from the Slave Devices are loaded into the EXT_SENS_DATA registers. This is used to ensure that both the internal sensor data (i.e. from gyro and accel) and external sensor data have been loaded to their respective data registers (i.e. the data is synced) when the Data Ready interrupt is triggered.</p> <p>Returns:</p> <p>Current wait-for-external-sensor-data enabled value </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getwakecycleenabled","title":"function mpu_getWakeCycleEnabled","text":"<pre><code>bool mpu_getWakeCycleEnabled () </code></pre> <p>Get wake cycle enabled status. When this bit is set to 1 and SLEEP is disabled, the MPU-60X0 will cycle between sleep mode and waking up to take a single sample of data from active sensors at a rate determined by LP_WAKE_CTRL (register 108). </p> <p>Returns:</p> <p>Current sleep mode enabled status </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_CYCLE_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getxgyrofifoenabled","title":"function mpu_getXGyroFIFOEnabled","text":"<pre><code>bool mpu_getXGyroFIFOEnabled () </code></pre> <p>Get gyroscope X-axis FIFO enabled value. When set to 1, this bit enables GYRO_XOUT_H and GYRO_XOUT_L (Registers 67 and 68) to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current gyroscope X-axis FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getxnegmotiondetected","title":"function mpu_getXNegMotionDetected","text":"<pre><code>bool mpu_getXNegMotionDetected () </code></pre> <p>Get X-axis negative motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_XNEG_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getxposmotiondetected","title":"function mpu_getXPosMotionDetected","text":"<pre><code>bool mpu_getXPosMotionDetected () </code></pre> <p>Get X-axis positive motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_XPOS_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getygyrofifoenabled","title":"function mpu_getYGyroFIFOEnabled","text":"<pre><code>bool mpu_getYGyroFIFOEnabled () </code></pre> <p>Get gyroscope Y-axis FIFO enabled value. When set to 1, this bit enables GYRO_YOUT_H and GYRO_YOUT_L (Registers 69 and 70) to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current gyroscope Y-axis FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getynegmotiondetected","title":"function mpu_getYNegMotionDetected","text":"<pre><code>bool mpu_getYNegMotionDetected () </code></pre> <p>Get Y-axis negative motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_YNEG_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getyposmotiondetected","title":"function mpu_getYPosMotionDetected","text":"<pre><code>bool mpu_getYPosMotionDetected () </code></pre> <p>Get Y-axis positive motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_YPOS_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getzgyrofifoenabled","title":"function mpu_getZGyroFIFOEnabled","text":"<pre><code>bool mpu_getZGyroFIFOEnabled () </code></pre> <p>Get gyroscope Z-axis FIFO enabled value. When set to 1, this bit enables GYRO_ZOUT_H and GYRO_ZOUT_L (Registers 71 and 72) to be written into the FIFO mpu6050.buffer. </p> <p>Returns:</p> <p>Current gyroscope Z-axis FIFO enabled value </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getznegmotiondetected","title":"function mpu_getZNegMotionDetected","text":"<pre><code>bool mpu_getZNegMotionDetected () </code></pre> <p>Get Z-axis negative motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_ZNEG_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getzposmotiondetected","title":"function mpu_getZPosMotionDetected","text":"<pre><code>bool mpu_getZPosMotionDetected () </code></pre> <p>Get Z-axis positive motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_ZPOS_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getzeromotiondetected","title":"function mpu_getZeroMotionDetected","text":"<pre><code>bool mpu_getZeroMotionDetected () </code></pre> <p>Get zero motion detection interrupt status. </p> <p>Returns:</p> <p>Motion detection status </p> <p>See also: mpu_RA_MOT_DETECT_STATUS </p> <p>See also: mpu_MOTION_MOT_ZRMOT_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getzeromotiondetectionduration","title":"function mpu_getZeroMotionDetectionDuration","text":"<pre><code>uint8_t mpu_getZeroMotionDetectionDuration () </code></pre> <p>Get zero motion detection event duration threshold. This register configures the duration counter threshold for Zero Motion interrupt generation. The duration counter ticks at 16 Hz, therefore ZRMOT_DUR has a unit of 1 LSB = 64 ms. The Zero Motion duration counter increments while the absolute value of the accelerometer measurements are each less than the detection threshold (Register 33). The Zero Motion interrupt is triggered when the Zero Motion duration counter reaches the time count specified in this register.</p> <p>For more details on the Zero Motion detection interrupt, see Section 8.4 of the MPU-6000/MPU-6050 Product Specification document, as well as Registers 56 and 58 of this document.</p> <p>Returns:</p> <p>Current zero motion detection duration threshold value (LSB = 64ms) </p> <p>See also: mpu_RA_ZRMOT_DUR </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_getzeromotiondetectionthreshold","title":"function mpu_getZeroMotionDetectionThreshold","text":"<pre><code>uint8_t mpu_getZeroMotionDetectionThreshold () </code></pre> <p>Get zero motion detection event acceleration threshold. This register configures the detection threshold for Zero Motion interrupt generation. The unit of ZRMOT_THR is 1LSB = 2mg. Zero Motion is detected when the absolute value of the accelerometer measurements for the 3 axes are each less than the detection threshold. This condition increments the Zero Motion duration counter (Register 34). The Zero Motion interrupt is triggered when the Zero Motion duration counter reaches the time count specified in ZRMOT_DUR (Register 34).</p> <p>Unlike Free Fall or Motion detection, Zero Motion detection triggers an interrupt both when Zero Motion is first detected and when Zero Motion is no longer detected.</p> <p>When a zero motion event is detected, a Zero Motion Status will be indicated in the MOT_DETECT_STATUS register (Register 97). When a motion-to-zero-motion condition is detected, the status bit is set to 1. When a zero-motion-to- motion condition is detected, the status bit is set to 0.</p> <p>For more details on the Zero Motion detection interrupt, see Section 8.4 of the MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and 58 of this document.</p> <p>Returns:</p> <p>Current zero motion detection acceleration threshold value (LSB = 2mg) </p> <p>See also: mpu_RA_ZRMOT_THR </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_reset","title":"function mpu_reset","text":"<pre><code>void mpu_reset () </code></pre> <p>Trigger a full device reset. A small delay of ~50ms may be desirable after triggering a reset. </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_DEVICE_RESET_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_resetaccelerometerpath","title":"function mpu_resetAccelerometerPath","text":"<pre><code>void mpu_resetAccelerometerPath () </code></pre> <p>Reset accelerometer signal path. The reset will revert the signal path analog to digital converters and filters to their power up configurations. </p> <p>See also: mpu_RA_SIGNAL_PATH_RESET </p> <p>See also: mpu_PATHRESET_ACCEL_RESET_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_resetfifo","title":"function mpu_resetFIFO","text":"<pre><code>void mpu_resetFIFO () </code></pre> <p>Reset the FIFO. This bit resets the FIFO mpu6050.buffer when set to 1 while FIFO_EN equals 0. This bit automatically clears to 0 after the reset has been triggered. </p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_FIFO_RESET_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_resetgyroscopepath","title":"function mpu_resetGyroscopePath","text":"<pre><code>void mpu_resetGyroscopePath () </code></pre> <p>Reset gyroscope signal path. The reset will revert the signal path analog to digital converters and filters to their power up configurations. </p> <p>See also: mpu_RA_SIGNAL_PATH_RESET </p> <p>See also: mpu_PATHRESET_GYRO_RESET_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_reseti2cmaster","title":"function mpu_resetI2CMaster","text":"<pre><code>void mpu_resetI2CMaster () </code></pre> <p>Reset the I2C Master. This bit resets the I2C Master when set to 1 while I2C_MST_EN equals 0. This bit automatically clears to 0 after the reset has been triggered. </p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_I2C_MST_RESET_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_resetsensors","title":"function mpu_resetSensors","text":"<pre><code>void mpu_resetSensors () </code></pre> <p>Reset all sensor registers and signal paths. When set to 1, this bit resets the signal paths for all sensors (gyroscopes, accelerometers, and temperature sensor). This operation will also clear the sensor registers. This bit automatically clears to 0 after the reset has been triggered.</p> <p>When resetting only the signal path (and not the sensor registers), please use Register 104, SIGNAL_PATH_RESET.</p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_SIG_COND_RESET_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_resettemperaturepath","title":"function mpu_resetTemperaturePath","text":"<pre><code>void mpu_resetTemperaturePath () </code></pre> <p>Reset temperature sensor signal path. The reset will revert the signal path analog to digital converters and filters to their power up configurations. </p> <p>See also: mpu_RA_SIGNAL_PATH_RESET </p> <p>See also: mpu_PATHRESET_TEMP_RESET_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setaccelfifoenabled","title":"function mpu_setAccelFIFOEnabled","text":"<pre><code>void mpu_setAccelFIFOEnabled (\nbool enabled\n) </code></pre> <p>Set accelerometer FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New accelerometer FIFO enabled value </li> </ul> <p>See also: getAccelFIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setaccelxselftest","title":"function mpu_setAccelXSelfTest","text":"<pre><code>void mpu_setAccelXSelfTest (\nbool enabled\n) </code></pre> <p>Get self-test enabled setting for accelerometer X axis. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> Self-test enabled value </li> </ul> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setaccelyselftest","title":"function mpu_setAccelYSelfTest","text":"<pre><code>void mpu_setAccelYSelfTest (\nbool enabled\n) </code></pre> <p>Get self-test enabled value for accelerometer Y axis. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> Self-test enabled value </li> </ul> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setaccelzselftest","title":"function mpu_setAccelZSelfTest","text":"<pre><code>void mpu_setAccelZSelfTest (\nbool enabled\n) </code></pre> <p>Set self-test enabled value for accelerometer Z axis. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> Self-test enabled value </li> </ul> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setaccelerometerpowerondelay","title":"function mpu_setAccelerometerPowerOnDelay","text":"<pre><code>void mpu_setAccelerometerPowerOnDelay (\nuint8_t delay\n) </code></pre> <p>Set accelerometer power-on delay. </p> <p>Parameters:</p> <ul> <li><code>delay</code> New accelerometer power-on delay (0-3) </li> </ul> <p>See also: getAccelerometerPowerOnDelay() </p> <p>See also: mpu_RA_MOT_DETECT_CTRL </p> <p>See also: mpu_DETECT_ACCEL_ON_DELAY_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setauxvddiolevel","title":"function mpu_setAuxVDDIOLevel","text":"<pre><code>void mpu_setAuxVDDIOLevel (\nuint8_t level\n) </code></pre> <p>Set the auxiliary I2C supply voltage level. When set to 1, the auxiliary I2C bus high logic level is VDD. When cleared to 0, the auxiliary I2C bus high logic level is VLOGIC. This does not apply to the MPU-6000, which does not have a VLOGIC pin. </p> <p>Parameters:</p> <ul> <li><code>level</code> I2C supply voltage level (0=VLOGIC, 1=VDD) </li> </ul>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setclockoutputenabled","title":"function mpu_setClockOutputEnabled","text":"<pre><code>void mpu_setClockOutputEnabled (\nbool enabled\n) </code></pre> <p>Set reference clock output enabled status. When this bit is equal to 1, a reference clock output is provided at the CLKOUT pin. When this bit is equal to 0, the clock output is disabled. For further information regarding CLKOUT, please refer to the MPU-60X0 Product Specification document. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New reference clock output enabled status </li> </ul> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_CLKOUT_EN_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setclocksource","title":"function mpu_setClockSource","text":"<pre><code>void mpu_setClockSource (\nuint8_t source\n) </code></pre> <p>Set clock source setting. An internal 8MHz oscillator, gyroscope based clock, or external sources can be selected as the MPU-60X0 clock source. When the internal 8 MHz oscillator or an external source is chosen as the clock source, the MPU-60X0 can operate in low power modes with the gyroscopes disabled.</p> <p>Upon power up, the MPU-60X0 clock source defaults to the internal oscillator. However, it is highly recommended that the device be configured to use one of the gyroscopes (or an external clock source) as the clock reference for improved stability. The clock source can be selected according to the following table:</p> <p>Parameters:</p> <ul> <li><code>source</code> New clock source setting </li> </ul> <p>See also: getClockSource() </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_CLKSEL_BIT </p> <p>See also: mpu_PWR1_CLKSEL_LENGTH </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setdhpfmode","title":"function mpu_setDHPFMode","text":"<pre><code>void mpu_setDHPFMode (\nuint8_t bandwidth\n) </code></pre> <p>Set the high-pass filter configuration. </p> <p>Parameters:</p> <ul> <li><code>bandwidth</code> New high-pass filter configuration </li> </ul> <p>See also: setDHPFMode() </p> <p>See also: mpu_DHPF_RESET </p> <p>See also: mpu_RA_ACCEL_CONFIG </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setdlpfmode","title":"function mpu_setDLPFMode","text":"<pre><code>void mpu_setDLPFMode (\nuint8_t mode\n) </code></pre> <p>Set digital low-pass filter configuration. </p> <p>Parameters:</p> <ul> <li><code>mode</code> New DLFP configuration setting </li> </ul> <p>See also: getDLPFBandwidth() </p> <p>See also: mpu_DLPF_BW_256 </p> <p>See also: mpu_RA_CONFIG </p> <p>See also: mpu_CFG_DLPF_CFG_BIT </p> <p>See also: mpu_CFG_DLPF_CFG_LENGTH </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setexternalframesync","title":"function mpu_setExternalFrameSync","text":"<pre><code>void mpu_setExternalFrameSync (\nuint8_t sync\n) </code></pre> <p>Set external FSYNC configuration. </p> <p>See also: getExternalFrameSync() </p> <p>See also: mpu_RA_CONFIG </p> <p>Parameters:</p> <ul> <li><code>sync</code> New FSYNC configuration value </li> </ul>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setexternalshadowdelayenabled","title":"function mpu_setExternalShadowDelayEnabled","text":"<pre><code>void mpu_setExternalShadowDelayEnabled (\nbool enabled\n) </code></pre> <p>Set external data shadow delay enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New external data shadow delay enabled status. </li> </ul> <p>See also: getExternalShadowDelayEnabled() </p> <p>See also: mpu_RA_I2C_MST_DELAY_CTRL </p> <p>See also: mpu_DELAYCTRL_DELAY_ES_SHADOW_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setfifoenabled","title":"function mpu_setFIFOEnabled","text":"<pre><code>void mpu_setFIFOEnabled (\nbool enabled\n) </code></pre> <p>Set FIFO enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New FIFO enabled status </li> </ul> <p>See also: getFIFOEnabled() </p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_FIFO_EN_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setfsyncinterruptenabled","title":"function mpu_setFSyncInterruptEnabled","text":"<pre><code>void mpu_setFSyncInterruptEnabled (\nbool enabled\n) </code></pre> <p>Set FSYNC pin interrupt enabled setting. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New FSYNC pin interrupt enabled setting </li> </ul> <p>See also: getFSyncInterruptEnabled() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_FSYNC_INT_EN_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setfsyncinterruptlevel","title":"function mpu_setFSyncInterruptLevel","text":"<pre><code>void mpu_setFSyncInterruptLevel (\nbool level\n) </code></pre> <p>Set FSYNC interrupt logic level mode. </p> <p>Parameters:</p> <ul> <li><code>mode</code> New FSYNC interrupt mode (0=active-high, 1=active-low) </li> </ul> <p>See also: getFSyncInterruptMode() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_FSYNC_INT_LEVEL_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setfreefalldetectioncounterdecrement","title":"function mpu_setFreefallDetectionCounterDecrement","text":"<pre><code>void mpu_setFreefallDetectionCounterDecrement (\nuint8_t decrement\n) </code></pre> <p>Set Free Fall detection counter decrement configuration. </p> <p>Parameters:</p> <ul> <li><code>decrement</code> New decrement configuration value </li> </ul> <p>See also: getFreefallDetectionCounterDecrement() </p> <p>See also: mpu_RA_MOT_DETECT_CTRL </p> <p>See also: mpu_DETECT_FF_COUNT_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setfreefalldetectionduration","title":"function mpu_setFreefallDetectionDuration","text":"<pre><code>void mpu_setFreefallDetectionDuration (\nuint8_t duration\n) </code></pre> <p>Get free-fall event duration threshold. </p> <p>Parameters:</p> <ul> <li><code>duration</code> New free-fall duration threshold value (LSB = 1ms) </li> </ul> <p>See also: getFreefallDetectionDuration() </p> <p>See also: mpu_RA_FF_DUR </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setfreefalldetectionthreshold","title":"function mpu_setFreefallDetectionThreshold","text":"<pre><code>void mpu_setFreefallDetectionThreshold (\nuint8_t threshold\n) </code></pre> <p>Get free-fall event acceleration threshold. </p> <p>Parameters:</p> <ul> <li><code>threshold</code> New free-fall acceleration threshold value (LSB = 2mg) </li> </ul> <p>See also: getFreefallDetectionThreshold() </p> <p>See also: mpu_RA_FF_THR </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setfullscaleaccelrange","title":"function mpu_setFullScaleAccelRange","text":"<pre><code>void mpu_setFullScaleAccelRange (\nuint8_t range\n) </code></pre> <p>Set full-scale accelerometer range. </p> <p>Parameters:</p> <ul> <li><code>range</code> New full-scale accelerometer range setting </li> </ul> <p>See also: getFullScaleAccelRange() </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setfullscalegyrorange","title":"function mpu_setFullScaleGyroRange","text":"<pre><code>void mpu_setFullScaleGyroRange (\nuint8_t range\n) </code></pre> <p>Set full-scale gyroscope range. </p> <p>Parameters:</p> <ul> <li><code>range</code> New full-scale gyroscope range value </li> </ul> <p>See also: getFullScaleRange() </p> <p>See also: mpu_GYRO_FS_250 </p> <p>See also: mpu_RA_GYRO_CONFIG </p> <p>See also: mpu_GCONFIG_FS_SEL_BIT </p> <p>See also: mpu_GCONFIG_FS_SEL_LENGTH </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_seti2cbypassenabled","title":"function mpu_setI2CBypassEnabled","text":"<pre><code>void mpu_setI2CBypassEnabled (\nbool enabled\n) </code></pre> <p>Set I2C bypass enabled status. When this bit is equal to 1 and I2C_MST_EN (Register 106 bit[5]) is equal to 0, the host application processor will be able to directly access the auxiliary I2C bus of the MPU-60X0. When this bit is equal to 0, the host application processor will not be able to directly access the auxiliary I2C bus of the MPU-60X0 regardless of the state of I2C_MST_EN (Register 106 bit[5]). </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New I2C bypass enabled status </li> </ul> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_I2C_BYPASS_EN_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_seti2cmastermodeenabled","title":"function mpu_setI2CMasterModeEnabled","text":"<pre><code>void mpu_setI2CMasterModeEnabled (\nbool enabled\n) </code></pre> <p>Set I2C Master Mode enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New I2C Master Mode enabled status </li> </ul> <p>See also: getI2CMasterModeEnabled() </p> <p>See also: mpu_RA_USER_CTRL </p> <p>See also: mpu_USERCTRL_I2C_MST_EN_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setintdatareadyenabled","title":"function mpu_setIntDataReadyEnabled","text":"<pre><code>void mpu_setIntDataReadyEnabled (\nbool enabled\n) </code></pre> <p>Set Data Ready interrupt enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntDataReadyEnabled() </p> <p>See also: mpu_RA_INT_CFG </p> <p>See also: mpu_INTERRUPT_DATA_RDY_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setintenabled","title":"function mpu_setIntEnabled","text":"<pre><code>void mpu_setIntEnabled (\nuint8_t enabled\n) </code></pre> <p>Set full interrupt enabled status. Full register byte for all interrupts, for quick reading. Each bit should be set 0 for disabled, 1 for enabled. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntFreefallEnabled() </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_FF_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setintfifobufferoverflowenabled","title":"function mpu_setIntFIFOBufferOverflowEnabled","text":"<pre><code>void mpu_setIntFIFOBufferOverflowEnabled (\nbool enabled\n) </code></pre> <p>Set FIFO Buffer Overflow interrupt enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntFIFOBufferOverflowEnabled() </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_FIFO_OFLOW_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setintfreefallenabled","title":"function mpu_setIntFreefallEnabled","text":"<pre><code>void mpu_setIntFreefallEnabled (\nbool enabled\n) </code></pre> <p>Set Free Fall interrupt enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntFreefallEnabled() </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_FF_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setinti2cmasterenabled","title":"function mpu_setIntI2CMasterEnabled","text":"<pre><code>void mpu_setIntI2CMasterEnabled (\nbool enabled\n) </code></pre> <p>Set I2C Master interrupt enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntI2CMasterEnabled() </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_I2C_MST_INT_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setintmotionenabled","title":"function mpu_setIntMotionEnabled","text":"<pre><code>void mpu_setIntMotionEnabled (\nbool enabled\n) </code></pre> <p>Set Motion Detection interrupt enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntMotionEnabled() </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_MOT_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setintzeromotionenabled","title":"function mpu_setIntZeroMotionEnabled","text":"<pre><code>void mpu_setIntZeroMotionEnabled (\nbool enabled\n) </code></pre> <p>Set Zero Motion Detection interrupt enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New interrupt enabled status </li> </ul> <p>See also: getIntZeroMotionEnabled() </p> <p>See also: mpu_RA_INT_ENABLE </p> <p>See also: mpu_INTERRUPT_ZMOT_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setinterruptdrive","title":"function mpu_setInterruptDrive","text":"<pre><code>void mpu_setInterruptDrive (\nbool drive\n) </code></pre> <p>Set interrupt drive mode. </p> <p>Parameters:</p> <ul> <li><code>drive</code> New interrupt drive mode (0=push-pull, 1=open-drain) </li> </ul> <p>See also: getInterruptDrive() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_INT_OPEN_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setinterruptlatch","title":"function mpu_setInterruptLatch","text":"<pre><code>void mpu_setInterruptLatch (\nbool latch\n) </code></pre> <p>Set interrupt latch mode. </p> <p>Parameters:</p> <ul> <li><code>latch</code> New latch mode (0=50us-pulse, 1=latch-until-int-cleared) </li> </ul> <p>See also: getInterruptLatch() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_LATCH_INT_EN_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setinterruptlatchclear","title":"function mpu_setInterruptLatchClear","text":"<pre><code>void mpu_setInterruptLatchClear (\nbool clear\n) </code></pre> <p>Set interrupt latch clear mode. </p> <p>Parameters:</p> <ul> <li><code>clear</code> New latch clear mode (0=status-read-only, 1=any-register-read) </li> </ul> <p>See also: getInterruptLatchClear() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_INT_RD_CLEAR_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setinterruptmode","title":"function mpu_setInterruptMode","text":"<pre><code>void mpu_setInterruptMode (\nbool mode\n) </code></pre> <p>Set interrupt logic level mode. </p> <p>Parameters:</p> <ul> <li><code>mode</code> New interrupt mode (0=active-high, 1=active-low) </li> </ul> <p>See also: getInterruptMode() </p> <p>See also: mpu_RA_INT_PIN_CFG </p> <p>See also: mpu_INTCFG_INT_LEVEL_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setmasterclockspeed","title":"function mpu_setMasterClockSpeed","text":"<pre><code>void mpu_setMasterClockSpeed (\nuint8_t speed\n) </code></pre> <p>Set I2C master clock speed. @reparam speed Current I2C master clock speed </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setmotiondetectioncounterdecrement","title":"function mpu_setMotionDetectionCounterDecrement","text":"<pre><code>void mpu_setMotionDetectionCounterDecrement (\nuint8_t decrement\n) </code></pre> <p>Set Motion detection counter decrement configuration. </p> <p>Parameters:</p> <ul> <li><code>decrement</code> New decrement configuration value </li> </ul> <p>See also: getMotionDetectionCounterDecrement() </p> <p>See also: mpu_RA_MOT_DETECT_CTRL </p> <p>See also: mpu_DETECT_MOT_COUNT_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setmotiondetectionduration","title":"function mpu_setMotionDetectionDuration","text":"<pre><code>void mpu_setMotionDetectionDuration (\nuint8_t duration\n) </code></pre> <p>Set motion detection event duration threshold. </p> <p>Parameters:</p> <ul> <li><code>duration</code> New motion detection duration threshold value (LSB = 1ms) </li> </ul> <p>See also: getMotionDetectionDuration() </p> <p>See also: mpu_RA_MOT_DUR </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setmotiondetectionthreshold","title":"function mpu_setMotionDetectionThreshold","text":"<pre><code>void mpu_setMotionDetectionThreshold (\nuint8_t threshold\n) </code></pre> <p>Set free-fall event acceleration threshold. </p> <p>Parameters:</p> <ul> <li><code>threshold</code> New motion detection acceleration threshold value (LSB = 2mg) </li> </ul> <p>See also: getMotionDetectionThreshold() </p> <p>See also: mpu_RA_MOT_THR </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setmultimasterenabled","title":"function mpu_setMultiMasterEnabled","text":"<pre><code>void mpu_setMultiMasterEnabled (\nbool enabled\n) </code></pre> <p>Set multi-master enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New multi-master enabled value </li> </ul> <p>See also: getMultiMasterEnabled() </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setrate","title":"function mpu_setRate","text":"<pre><code>void mpu_setRate (\nuint8_t rate\n) </code></pre> <p>Set gyroscope sample rate divider. </p> <p>Parameters:</p> <ul> <li><code>rate</code> New sample rate divider </li> </ul> <p>See also: getRate() </p> <p>See also: mpu_RA_SMPLRT_DIV </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setslave0fifoenabled","title":"function mpu_setSlave0FIFOEnabled","text":"<pre><code>void mpu_setSlave0FIFOEnabled (\nbool enabled\n) </code></pre> <p>Set Slave 0 FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New Slave 0 FIFO enabled value </li> </ul> <p>See also: getSlave0FIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setslave1fifoenabled","title":"function mpu_setSlave1FIFOEnabled","text":"<pre><code>void mpu_setSlave1FIFOEnabled (\nbool enabled\n) </code></pre> <p>Set Slave 1 FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New Slave 1 FIFO enabled value </li> </ul> <p>See also: getSlave1FIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setslave2fifoenabled","title":"function mpu_setSlave2FIFOEnabled","text":"<pre><code>void mpu_setSlave2FIFOEnabled (\nbool enabled\n) </code></pre> <p>Set Slave 2 FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New Slave 2 FIFO enabled value </li> </ul> <p>See also: getSlave2FIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setslave3fifoenabled","title":"function mpu_setSlave3FIFOEnabled","text":"<pre><code>void mpu_setSlave3FIFOEnabled (\nbool enabled\n) </code></pre> <p>Set Slave 3 FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New Slave 3 FIFO enabled value </li> </ul> <p>See also: getSlave3FIFOEnabled() </p> <p>See also: mpu_RA_MST_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setslave4address","title":"function mpu_setSlave4Address","text":"<pre><code>void mpu_setSlave4Address (\nuint8_t address\n) </code></pre> <p>Set the I2C address of Slave 4. </p> <p>Parameters:</p> <ul> <li><code>address</code> New address for Slave 4 </li> </ul> <p>See also: getSlave4Address() </p> <p>See also: mpu_RA_I2C_SLV4_ADDR </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setslave4enabled","title":"function mpu_setSlave4Enabled","text":"<pre><code>void mpu_setSlave4Enabled (\nbool enabled\n) </code></pre> <p>Set the enabled value for Slave 4. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New enabled value for Slave 4 </li> </ul> <p>See also: getSlave4Enabled() </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setslave4interruptenabled","title":"function mpu_setSlave4InterruptEnabled","text":"<pre><code>void mpu_setSlave4InterruptEnabled (\nbool enabled\n) </code></pre> <p>Set the enabled value for Slave 4 transaction interrupts. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New enabled value for Slave 4 transaction interrupts. </li> </ul> <p>See also: getSlave4InterruptEnabled() </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setslave4masterdelay","title":"function mpu_setSlave4MasterDelay","text":"<pre><code>void mpu_setSlave4MasterDelay (\nuint8_t delay\n) </code></pre> <p>Set Slave 4 master delay value. </p> <p>Parameters:</p> <ul> <li><code>delay</code> New Slave 4 master delay value </li> </ul> <p>See also: getSlave4MasterDelay() </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setslave4outputbyte","title":"function mpu_setSlave4OutputByte","text":"<pre><code>void mpu_setSlave4OutputByte (\nuint8_t data\n) </code></pre> <p>Set new byte to write to Slave 4. This register stores the data to be written into the Slave 4. If I2C_SLV4_RW is set 1 (set to read), this register has no effect. </p> <p>Parameters:</p> <ul> <li><code>data</code> New byte to write to Slave 4 </li> </ul> <p>See also: mpu_RA_I2C_SLV4_DO </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setslave4register","title":"function mpu_setSlave4Register","text":"<pre><code>void mpu_setSlave4Register (\nuint8_t reg\n) </code></pre> <p>Set the active internal register for Slave 4. </p> <p>Parameters:</p> <ul> <li><code>reg</code> New active register for Slave 4 </li> </ul> <p>See also: getSlave4Register() </p> <p>See also: mpu_RA_I2C_SLV4_REG </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setslave4writemode","title":"function mpu_setSlave4WriteMode","text":"<pre><code>void mpu_setSlave4WriteMode (\nbool mode\n) </code></pre> <p>Set write mode for the Slave 4. </p> <p>Parameters:</p> <ul> <li><code>mode</code> New write mode for Slave 4 (0 = register address + data, 1 = data only) </li> </ul> <p>See also: getSlave4WriteMode() </p> <p>See also: mpu_RA_I2C_SLV4_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setslaveaddress","title":"function mpu_setSlaveAddress","text":"<pre><code>void mpu_setSlaveAddress (\nuint8_t num,\nuint8_t address\n) </code></pre> <p>Set the I2C address of the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>address</code> New address for specified slave </li> </ul> <p>See also: getSlaveAddress() </p> <p>See also: mpu_RA_I2C_SLV0_ADDR </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setslavedatalength","title":"function mpu_setSlaveDataLength","text":"<pre><code>void mpu_setSlaveDataLength (\nuint8_t num,\nuint8_t length\n) </code></pre> <p>Set number of bytes to read for the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>length</code> Number of bytes to read for specified slave </li> </ul> <p>See also: getSlaveDataLength() </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setslavedelayenabled","title":"function mpu_setSlaveDelayEnabled","text":"<pre><code>void mpu_setSlaveDelayEnabled (\nuint8_t num,\nbool enabled\n) </code></pre> <p>Set slave delay enabled status. </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-4) </li> <li><code>enabled</code> New slave delay enabled status. </li> </ul> <p>See also: mpu_RA_I2C_MST_DELAY_CTRL </p> <p>See also: mpu_DELAYCTRL_I2C_SLV0_DLY_EN_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setslaveenabled","title":"function mpu_setSlaveEnabled","text":"<pre><code>void mpu_setSlaveEnabled (\nuint8_t num,\nbool enabled\n) </code></pre> <p>Set the enabled value for the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>enabled</code> New enabled value for specified slave </li> </ul> <p>See also: getSlaveEnabled() </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setslaveoutputbyte","title":"function mpu_setSlaveOutputByte","text":"<pre><code>void mpu_setSlaveOutputByte (\nuint8_t num,\nuint8_t data\n) </code></pre> <p>Write byte to Data Output container for specified slave. This register holds the output data written into Slave when Slave is set to write mode. For further information regarding Slave control, please refer to Registers 37 to 39 and immediately following. </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>data</code> Byte to write </li> </ul> <p>See also: mpu_RA_I2C_SLV0_DO </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setslavereadwritetransitionenabled","title":"function mpu_setSlaveReadWriteTransitionEnabled","text":"<pre><code>void mpu_setSlaveReadWriteTransitionEnabled (\nbool enabled\n) </code></pre> <p>Set slave read/write transition enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New slave read/write transition enabled value </li> </ul> <p>See also: getSlaveReadWriteTransitionEnabled() </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setslaveregister","title":"function mpu_setSlaveRegister","text":"<pre><code>void mpu_setSlaveRegister (\nuint8_t num,\nuint8_t reg\n) </code></pre> <p>Set the active internal register for the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>reg</code> New active register for specified slave </li> </ul> <p>See also: getSlaveRegister() </p> <p>See also: mpu_RA_I2C_SLV0_REG </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setslavewordbyteswap","title":"function mpu_setSlaveWordByteSwap","text":"<pre><code>void mpu_setSlaveWordByteSwap (\nuint8_t num,\nbool enabled\n) </code></pre> <p>Set word pair byte-swapping enabled for the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>enabled</code> New word pair byte-swapping enabled value for specified slave </li> </ul> <p>See also: getSlaveWordByteSwap() </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setslavewordgroupoffset","title":"function mpu_setSlaveWordGroupOffset","text":"<pre><code>void mpu_setSlaveWordGroupOffset (\nuint8_t num,\nbool enabled\n) </code></pre> <p>Set word pair grouping order offset for the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>enabled</code> New word pair grouping order offset for specified slave </li> </ul> <p>See also: getSlaveWordGroupOffset() </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setslavewritemode","title":"function mpu_setSlaveWriteMode","text":"<pre><code>void mpu_setSlaveWriteMode (\nuint8_t num,\nbool mode\n) </code></pre> <p>Set write mode for the specified slave (0-3). </p> <p>Parameters:</p> <ul> <li><code>num</code> Slave number (0-3) </li> <li><code>mode</code> New write mode for specified slave (0 = register address + data, 1 = data only) </li> </ul> <p>See also: getSlaveWriteMode() </p> <p>See also: mpu_RA_I2C_SLV0_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setsleepenabled","title":"function mpu_setSleepEnabled","text":"<pre><code>void mpu_setSleepEnabled (\nbool enabled\n) </code></pre> <p>Set sleep mode status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New sleep mode enabled status </li> </ul> <p>See also: getSleepEnabled() </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_SLEEP_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_settempfifoenabled","title":"function mpu_setTempFIFOEnabled","text":"<pre><code>void mpu_setTempFIFOEnabled (\nbool enabled\n) </code></pre> <p>Set temperature FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New temperature FIFO enabled value </li> </ul> <p>See also: getTempFIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_settempsensorenabled","title":"function mpu_setTempSensorEnabled","text":"<pre><code>void mpu_setTempSensorEnabled (\nbool enabled\n) </code></pre> <p>Set temperature sensor enabled status. Note: this register stores the disabled value, but for consistency with the rest of the code, the function is named and used with standard true/false values to indicate whether the sensor is enabled or disabled, respectively.</p> <p>Parameters:</p> <ul> <li><code>enabled</code> New temperature sensor enabled status </li> </ul> <p>See also: getTempSensorEnabled() </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_TEMP_DIS_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setwaitforexternalsensorenabled","title":"function mpu_setWaitForExternalSensorEnabled","text":"<pre><code>void mpu_setWaitForExternalSensorEnabled (\nbool enabled\n) </code></pre> <p>Set wait-for-external-sensor-data enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New wait-for-external-sensor-data enabled value </li> </ul> <p>See also: getWaitForExternalSensorEnabled() </p> <p>See also: mpu_RA_I2C_MST_CTRL </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setwakecycleenabled","title":"function mpu_setWakeCycleEnabled","text":"<pre><code>void mpu_setWakeCycleEnabled (\nbool enabled\n) </code></pre> <p>Set wake cycle enabled status. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New sleep mode enabled status </li> </ul> <p>See also: getWakeCycleEnabled() </p> <p>See also: mpu_RA_PWR_MGMT_1 </p> <p>See also: mpu_PWR1_CYCLE_BIT </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setxgyrofifoenabled","title":"function mpu_setXGyroFIFOEnabled","text":"<pre><code>void mpu_setXGyroFIFOEnabled (\nbool enabled\n) </code></pre> <p>Set gyroscope X-axis FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New gyroscope X-axis FIFO enabled value </li> </ul> <p>See also: getXGyroFIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setygyrofifoenabled","title":"function mpu_setYGyroFIFOEnabled","text":"<pre><code>void mpu_setYGyroFIFOEnabled (\nbool enabled\n) </code></pre> <p>Set gyroscope Y-axis FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New gyroscope Y-axis FIFO enabled value </li> </ul> <p>See also: getYGyroFIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setzgyrofifoenabled","title":"function mpu_setZGyroFIFOEnabled","text":"<pre><code>void mpu_setZGyroFIFOEnabled (\nbool enabled\n) </code></pre> <p>Set gyroscope Z-axis FIFO enabled value. </p> <p>Parameters:</p> <ul> <li><code>enabled</code> New gyroscope Z-axis FIFO enabled value </li> </ul> <p>See also: getZGyroFIFOEnabled() </p> <p>See also: mpu_RA_FIFO_EN </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setzeromotiondetectionduration","title":"function mpu_setZeroMotionDetectionDuration","text":"<pre><code>void mpu_setZeroMotionDetectionDuration (\nuint8_t duration\n) </code></pre> <p>Set zero motion detection event duration threshold. </p> <p>Parameters:</p> <ul> <li><code>duration</code> New zero motion detection duration threshold value (LSB = 1ms) </li> </ul> <p>See also: getZeroMotionDetectionDuration() </p> <p>See also: mpu_RA_ZRMOT_DUR </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_setzeromotiondetectionthreshold","title":"function mpu_setZeroMotionDetectionThreshold","text":"<pre><code>void mpu_setZeroMotionDetectionThreshold (\nuint8_t threshold\n) </code></pre> <p>Set zero motion detection event acceleration threshold. </p> <p>Parameters:</p> <ul> <li><code>threshold</code> New zero motion detection acceleration threshold value (LSB = 2mg) </li> </ul> <p>See also: getZeroMotionDetectionThreshold() </p> <p>See also: mpu_RA_ZRMOT_THR </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_switchspienabled","title":"function mpu_switchSPIEnabled","text":"<pre><code>void mpu_switchSPIEnabled (\nbool enabled\n) </code></pre> <p>Switch from I2C to SPI mode (MPU-6000 only) If this is set, the primary SPI interface will be enabled in place of the disabled primary I2C interface. </p>"},{"location":"apiStm/MpuController_8cpp/#function-mpu_testconnection","title":"function mpu_testConnection","text":"<pre><code>bool mpu_testConnection () </code></pre> <p>Verify the I2C connection. Make sure the device is connected and responds as expected. </p> <p>Returns:</p> <p>True if connection is valid, false otherwise </p>"},{"location":"apiStm/MpuController_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"apiStm/MpuController_8cpp/#function-mpuread","title":"function mpuRead","text":"<pre><code>static void mpuRead (\nMpuMotion6 &amp; data\n) </code></pre>"},{"location":"apiStm/MpuController_8cpp/#function-mpusend","title":"function mpuSend","text":"<pre><code>static void mpuSend (\nconst MpuMotion32 &amp; data\n) </code></pre>"},{"location":"apiStm/MpuController_8cpp/#function-mputickcallback","title":"function mpuTickCallback","text":"<pre><code>static void mpuTickCallback (\nTimerHandle_t tim\n) </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/MpuController.cpp</code></p>"},{"location":"apiStm/MpuController_8cpp_source/","title":"File MpuController.cpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; src &gt; MpuController.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>// I2Cdev library collection - mpu I2C device class\n// Based on InvenSense MPU-6050 register map document rev. 2.0, 5/19/2011 (RM-MPU-6000A-00)\n// 8/24/2011 by Jeff Rowberg &lt;jeff@rowberg.net&gt;\n// 11/28/2014 by Marton Sebok &lt;sebokmarton@gmail.com&gt;\n//\n// Updates should (hopefully) always be available at https://github.com/jrowberg/i2cdevlib\n//\n// Changelog:\n//     ...        - ongoing debug release\n//     2014-11-28 - ported to PIC18 peripheral library from Arduino code\n//     2017-03-28 - tested basic function on STM32\n\n// NOTE: THIS IS ONLY A PARIAL RELEASE. THIS DEVICE CLASS IS CURRENTLY UNDERGOING ACTIVE\n// DEVELOPMENT AND IS STILL MISSING SOME IMPORTANT FEATURES. PLEASE KEEP THIS IN MIND IF\n// YOU DECIDE TO USE THIS PARTICULAR CODE FOR ANYTHING.\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2012 Jeff Rowberg\nCopyright (c) 2014 Marton Sebok\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n\n#include \"MpuController.hpp\"\n#include \"Dispatcher.hpp\"\n#include \"utils/TickTimer.hpp\"\n\n#include \"Bsp.hpp\"\n\n#include \"utils/QueueWrapper.hpp\"\n#include \"utils/TaskWrapper.hpp\"\n\n#include \"FreeRTOS.h\"\n#include \"timers.h\"\n\n#include \"event_groups.h\"\n\ntypedef struct MpuVector {\nint16_t x;\nint16_t y;\nint16_t z;\n} MpuVector;\n\ntypedef struct MpuVector32 {\nint32_t x;\nint32_t y;\nint32_t z;\n} MpuVector32;\n\ntypedef struct MpuMotion6 {\nMpuVector accel;\nMpuVector gyro;\n} MpuMotion6;\n\ntypedef struct MpuMotion32 {\nMpuVector32 accel;\nMpuVector32 gyro;\n} MpuMotion32;\n\nstatic mpu_t mpu6050;\nstatic MpuMotion32 mpuAggrData;\n\nstatic constexpr uint32_t mpuTickPeriodMs = 10;\nstatic uint32_t mpuAggrCounter = 0;\nstatic TimerHandle_t mpuTimerHandle;\nstatic StaticTimer_t mpuTimerBuffer;\nstatic uint16_t compressCoef = 4;\nstatic void mpuTickCallback(TimerHandle_t tim) {\nxEventGroupSetBits(i2cEventGroup, I2C_MPU_TICK);\n}\n\nstatic void mpuRead(MpuMotion6&amp; data) {\nmpu_getMotion6(&amp;data.accel.x, &amp;data.accel.y, &amp;data.accel.z, &amp;data.gyro.x,\n&amp;data.gyro.y, &amp;data.gyro.z);\n}\n\nstatic void mpuSend(const MpuMotion32&amp; data) {\n// DEBUG(\n//     \"DEBUG MPU SEND [%d] acc: x:%d; y:%d; z:%d | gyro: x:%d; y:%d; z:%d\\n\",\n//     mpuAggrCounter, data.accel.x, data.accel.y, data.accel.z, data.gyro.x,\n//     data.gyro.y, data.gyro.z);\n\nCoprocStat status = {\n.which_payload = CoprocStat_mpuStat_tag,\n};\n\nstatus.payload.mpuStat.accel.x = data.accel.x;\nstatus.payload.mpuStat.accel.y = data.accel.y;\nstatus.payload.mpuStat.accel.z = data.accel.z;\nstatus.payload.mpuStat.has_accel = true;\n\nstatus.payload.mpuStat.gyro.x = data.gyro.x;\nstatus.payload.mpuStat.gyro.y = data.gyro.y;\nstatus.payload.mpuStat.gyro.z = data.gyro.z;\nstatus.payload.mpuStat.has_gyro = true;\nstatus.payload.mpuStat.compressCoef = compressCoef;\ndispatcherEnqueueStatus(status);\n}\n\nvoid mpuDispatch(const CoprocReq_MpuReq&amp; req) {\nswitch (req.which_mpuCmd) {\ncase CoprocReq_MpuReq_init_tag:\nmpuInitialize();\nbreak;\ncase CoprocReq_MpuReq_oneSend_tag:\nMpuMotion6 data;\nMpuMotion32 data32;\nmpuRead(data);\ndata32.accel.x = data.accel.x;\ndata32.accel.y = data.accel.y;\ndata32.accel.z = data.accel.z;\ndata32.gyro.x = data.gyro.x;\ndata32.gyro.y = data.gyro.y;\ndata32.gyro.z = data.gyro.z;\nmpuSend(data32);\nbreak;\ncase CoprocReq_MpuReq_startSend_tag: {\nif (xTimerStart(mpuTimerHandle, 0) == pdFALSE) {\nDEBUG(\"MPU6050 timer start failure\\n\");\n}\nmpuAggrCounter = 0;\nbreak;\n}\n\ncase CoprocReq_MpuReq_stopSend_tag: {\nif (xTimerStop(mpuTimerHandle, 0) == pdFALSE) {\nDEBUG(\"MPU6050 timer stop failure\\n\");\n}\nbreak;\n}\n\ncase CoprocReq_MpuReq_setCompressCoef_tag: {\nuint16_t coef = req.mpuCmd.setCompressCoef;\nif (coef &gt; 0 &amp;&amp; coef &lt;= 20) {\ncompressCoef = coef;\nDEBUGLN(\"MPU6050 set new compression coef: %d\", compressCoef);\n}\nbreak;\n}\n\ncase CoprocReq_MpuReq_getCompressCoef_tag: {\nCoprocStat status = {\n.which_payload = CoprocStat_mpuStat_tag,\n.payload = {\n.mpuStat = {\n.compressCoef = compressCoef,\n},\n},\n};\ndispatcherEnqueueStatus(status);\nbreak;\n}\n};\n}\n\nvoid mpuTick() {\nMpuMotion6 data;\nmpuRead(data);\n// DEBUG(\"MPU6050 [%d] acc: x:%d; y:%d; z:%d | gyro: x:%d; y:%d; z:%d\\n\",\n//     mpuAggrCounter, data.accel.x, data.accel.y, data.accel.z, data.gyro.x,\n//     data.gyro.y, data.gyro.z);\n\nmpuAggrData.accel.x += data.accel.x;\nmpuAggrData.accel.y += data.accel.y;\nmpuAggrData.accel.z += data.accel.z;\nmpuAggrData.gyro.x += data.gyro.x;\nmpuAggrData.gyro.y += data.gyro.y;\nmpuAggrData.gyro.z += data.gyro.z;\n\nmpuAggrCounter++;\nif (mpuAggrCounter &gt;= compressCoef) {\nmpuSend(mpuAggrData);\n\nmpuAggrData.accel.x = 0;\nmpuAggrData.accel.y = 0;\nmpuAggrData.accel.z = 0;\nmpuAggrData.gyro.x = 0;\nmpuAggrData.gyro.y = 0;\nmpuAggrData.gyro.z = 0;\nmpuAggrCounter = 0;\n}\n}\n\nvoid mpuCreate() {\nmpu6050.devAddr = mpu_ADDRESS_AD0_HIGH;\nmpuTimerHandle\n= xTimerCreateStatic(\"mpuTimer\", pdMS_TO_TICKS(mpuTickPeriodMs), true,\nnullptr, mpuTickCallback, &amp;mpuTimerBuffer);\n}\n\nvoid mpuInitialize() {\nmpuReset();\n\nif (mpu_testConnection()) {\nmpu_setClockSource(mpu_CLOCK_PLL_XGYRO);\nmpu_setFullScaleGyroRange(mpu_GYRO_FS_250);\nmpu_setFullScaleAccelRange(mpu_ACCEL_FS_2);\nmpu_setSleepEnabled(false);\n} else {\nDEBUG(\"MPU6050 is not connected\\n\");\nCoprocStat status = {\n.which_payload = CoprocStat_faultStat_tag,\n.payload = { .faultStat = {\n.which_fault = CoprocStat_FaultStat_mpuFault_tag,\n},\n},\n};\ndispatcherEnqueueStatus(status);\n}\n}\n\nvoid mpuReset() {\nif (xTimerStop(mpuTimerHandle, 0) == pdFALSE) {\nDEBUG(\"Time queue overflow\\n\");\n}\n}\n\nbool mpu_testConnection() { return mpu_getDeviceID() == 0x34; }\n\n// AUX_VDDIO register (InvenSense demo code calls this RA_*G_OFFS_TC)\n\nuint8_t mpu_getAuxVDDIOLevel() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_YG_OFFS_TC, mpu_TC_PWR_MODE_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setAuxVDDIOLevel(uint8_t level) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_YG_OFFS_TC, mpu_TC_PWR_MODE_BIT, level);\n}\n\n// SMPLRT_DIV register\n\nuint8_t mpu_getRate() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_SMPLRT_DIV, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setRate(uint8_t rate) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_SMPLRT_DIV, rate);\n}\n\n// CONFIG register\n\nuint8_t mpu_getExternalFrameSync() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_CONFIG, mpu_CFG_EXT_SYNC_SET_BIT,\nmpu_CFG_EXT_SYNC_SET_LENGTH, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setExternalFrameSync(uint8_t sync) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_CONFIG, mpu_CFG_EXT_SYNC_SET_BIT,\nmpu_CFG_EXT_SYNC_SET_LENGTH, sync);\n}\nuint8_t mpu_getDLPFMode() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_CONFIG, mpu_CFG_DLPF_CFG_BIT,\nmpu_CFG_DLPF_CFG_LENGTH, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setDLPFMode(uint8_t mode) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_CONFIG, mpu_CFG_DLPF_CFG_BIT,\nmpu_CFG_DLPF_CFG_LENGTH, mode);\n}\n\n// GYRO_CONFIG register\n\nuint8_t mpu_getFullScaleGyroRange() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_GYRO_CONFIG, mpu_GCONFIG_FS_SEL_BIT,\nmpu_GCONFIG_FS_SEL_LENGTH, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setFullScaleGyroRange(uint8_t range) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_GYRO_CONFIG,\nmpu_GCONFIG_FS_SEL_BIT, mpu_GCONFIG_FS_SEL_LENGTH, range);\n}\n\n// ACCEL_CONFIG register\n\nbool mpu_getAccelXSelfTest() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_ACCEL_CONFIG, mpu_ACONFIG_XA_ST_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setAccelXSelfTest(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_ACCEL_CONFIG, mpu_ACONFIG_XA_ST_BIT, enabled);\n}\nbool mpu_getAccelYSelfTest() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_ACCEL_CONFIG, mpu_ACONFIG_YA_ST_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setAccelYSelfTest(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_ACCEL_CONFIG, mpu_ACONFIG_YA_ST_BIT, enabled);\n}\nbool mpu_getAccelZSelfTest() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_ACCEL_CONFIG, mpu_ACONFIG_ZA_ST_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setAccelZSelfTest(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_ACCEL_CONFIG, mpu_ACONFIG_ZA_ST_BIT, enabled);\n}\nuint8_t mpu_getFullScaleAccelRange() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_ACCEL_CONFIG,\nmpu_ACONFIG_AFS_SEL_BIT, mpu_ACONFIG_AFS_SEL_LENGTH, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setFullScaleAccelRange(uint8_t range) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_ACCEL_CONFIG,\nmpu_ACONFIG_AFS_SEL_BIT, mpu_ACONFIG_AFS_SEL_LENGTH, range);\n}\nuint8_t mpu_getDHPFMode() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_ACCEL_CONFIG,\nmpu_ACONFIG_ACCEL_HPF_BIT, mpu_ACONFIG_ACCEL_HPF_LENGTH, mpu6050.buffer,\n0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setDHPFMode(uint8_t bandwidth) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_ACCEL_CONFIG,\nmpu_ACONFIG_ACCEL_HPF_BIT, mpu_ACONFIG_ACCEL_HPF_LENGTH, bandwidth);\n}\n\n// FF_THR register\n\nuint8_t mpu_getFreefallDetectionThreshold() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_FF_THR, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setFreefallDetectionThreshold(uint8_t threshold) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_FF_THR, threshold);\n}\n\n// FF_DUR register\n\nuint8_t mpu_getFreefallDetectionDuration() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_FF_DUR, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setFreefallDetectionDuration(uint8_t duration) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_FF_DUR, duration);\n}\n\n// MOT_THR register\n\nuint8_t mpu_getMotionDetectionThreshold() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_MOT_THR, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setMotionDetectionThreshold(uint8_t threshold) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_MOT_THR, threshold);\n}\n\n// MOT_DUR register\n\nuint8_t mpu_getMotionDetectionDuration() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_MOT_DUR, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setMotionDetectionDuration(uint8_t duration) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_MOT_DUR, duration);\n}\n\n// ZRMOT_THR register\n\nuint8_t mpu_getZeroMotionDetectionThreshold() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_ZRMOT_THR, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setZeroMotionDetectionThreshold(uint8_t threshold) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_ZRMOT_THR, threshold);\n}\n\n// ZRMOT_DUR register\n\nuint8_t mpu_getZeroMotionDetectionDuration() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_ZRMOT_DUR, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setZeroMotionDetectionDuration(uint8_t duration) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_ZRMOT_DUR, duration);\n}\n\n// FIFO_EN register\n\nbool mpu_getTempFIFOEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_FIFO_EN, mpu_TEMP_FIFO_EN_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setTempFIFOEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_FIFO_EN, mpu_TEMP_FIFO_EN_BIT, enabled);\n}\nbool mpu_getXGyroFIFOEnabled() {\nI2Cdev_readBit(\nmpu6050.devAddr, mpu_RA_FIFO_EN, mpu_XG_FIFO_EN_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setXGyroFIFOEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_FIFO_EN, mpu_XG_FIFO_EN_BIT, enabled);\n}\nbool mpu_getYGyroFIFOEnabled() {\nI2Cdev_readBit(\nmpu6050.devAddr, mpu_RA_FIFO_EN, mpu_YG_FIFO_EN_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setYGyroFIFOEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_FIFO_EN, mpu_YG_FIFO_EN_BIT, enabled);\n}\nbool mpu_getZGyroFIFOEnabled() {\nI2Cdev_readBit(\nmpu6050.devAddr, mpu_RA_FIFO_EN, mpu_ZG_FIFO_EN_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setZGyroFIFOEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_FIFO_EN, mpu_ZG_FIFO_EN_BIT, enabled);\n}\nbool mpu_getAccelFIFOEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_FIFO_EN, mpu_ACCEL_FIFO_EN_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setAccelFIFOEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_FIFO_EN, mpu_ACCEL_FIFO_EN_BIT, enabled);\n}\nbool mpu_getSlave2FIFOEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_FIFO_EN, mpu_SLV2_FIFO_EN_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlave2FIFOEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_FIFO_EN, mpu_SLV2_FIFO_EN_BIT, enabled);\n}\nbool mpu_getSlave1FIFOEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_FIFO_EN, mpu_SLV1_FIFO_EN_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlave1FIFOEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_FIFO_EN, mpu_SLV1_FIFO_EN_BIT, enabled);\n}\nbool mpu_getSlave0FIFOEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_FIFO_EN, mpu_SLV0_FIFO_EN_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlave0FIFOEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_FIFO_EN, mpu_SLV0_FIFO_EN_BIT, enabled);\n}\n\n// I2C_MST_CTRL register\n\nbool mpu_getMultiMasterEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_CTRL, mpu_MULT_MST_EN_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setMultiMasterEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_I2C_MST_CTRL, mpu_MULT_MST_EN_BIT, enabled);\n}\nbool mpu_getWaitForExternalSensorEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_CTRL, mpu_WAIT_FOR_ES_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setWaitForExternalSensorEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_I2C_MST_CTRL, mpu_WAIT_FOR_ES_BIT, enabled);\n}\nbool mpu_getSlave3FIFOEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_CTRL, mpu_SLV_3_FIFO_EN_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlave3FIFOEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_I2C_MST_CTRL, mpu_SLV_3_FIFO_EN_BIT, enabled);\n}\nbool mpu_getSlaveReadWriteTransitionEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_CTRL, mpu_I2C_MST_P_NSR_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlaveReadWriteTransitionEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_I2C_MST_CTRL, mpu_I2C_MST_P_NSR_BIT, enabled);\n}\nuint8_t mpu_getMasterClockSpeed() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_I2C_MST_CTRL, mpu_I2C_MST_CLK_BIT,\nmpu_I2C_MST_CLK_LENGTH, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setMasterClockSpeed(uint8_t speed) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_I2C_MST_CTRL, mpu_I2C_MST_CLK_BIT,\nmpu_I2C_MST_CLK_LENGTH, speed);\n}\n\n// I2C_SLV* registers (Slave 0-3)\n\nuint8_t mpu_getSlaveAddress(uint8_t num) {\nif (num &gt; 3)\nreturn 0;\nI2Cdev_readByte(\nmpu6050.devAddr, mpu_RA_I2C_SLV0_ADDR + num * 3, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlaveAddress(uint8_t num, uint8_t address) {\nif (num &gt; 3)\nreturn;\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_I2C_SLV0_ADDR + num * 3, address);\n}\nuint8_t mpu_getSlaveRegister(uint8_t num) {\nif (num &gt; 3)\nreturn 0;\nI2Cdev_readByte(\nmpu6050.devAddr, mpu_RA_I2C_SLV0_REG + num * 3, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlaveRegister(uint8_t num, uint8_t reg) {\nif (num &gt; 3)\nreturn;\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_I2C_SLV0_REG + num * 3, reg);\n}\nbool mpu_getSlaveEnabled(uint8_t num) {\nif (num &gt; 3)\nreturn 0;\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_SLV0_CTRL + num * 3,\nmpu_I2C_SLV_EN_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlaveEnabled(uint8_t num, bool enabled) {\nif (num &gt; 3)\nreturn;\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_I2C_SLV0_CTRL + num * 3,\nmpu_I2C_SLV_EN_BIT, enabled);\n}\nbool mpu_getSlaveWordByteSwap(uint8_t num) {\nif (num &gt; 3)\nreturn 0;\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_SLV0_CTRL + num * 3,\nmpu_I2C_SLV_BYTE_SW_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlaveWordByteSwap(uint8_t num, bool enabled) {\nif (num &gt; 3)\nreturn;\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_I2C_SLV0_CTRL + num * 3,\nmpu_I2C_SLV_BYTE_SW_BIT, enabled);\n}\nbool mpu_getSlaveWriteMode(uint8_t num) {\nif (num &gt; 3)\nreturn 0;\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_SLV0_CTRL + num * 3,\nmpu_I2C_SLV_REG_DIS_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlaveWriteMode(uint8_t num, bool mode) {\nif (num &gt; 3)\nreturn;\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_I2C_SLV0_CTRL + num * 3,\nmpu_I2C_SLV_REG_DIS_BIT, mode);\n}\nbool mpu_getSlaveWordGroupOffset(uint8_t num) {\nif (num &gt; 3)\nreturn 0;\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_SLV0_CTRL + num * 3,\nmpu_I2C_SLV_GRP_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlaveWordGroupOffset(uint8_t num, bool enabled) {\nif (num &gt; 3)\nreturn;\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_I2C_SLV0_CTRL + num * 3,\nmpu_I2C_SLV_GRP_BIT, enabled);\n}\nuint8_t mpu_getSlaveDataLength(uint8_t num) {\nif (num &gt; 3)\nreturn 0;\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_I2C_SLV0_CTRL + num * 3,\nmpu_I2C_SLV_LEN_BIT, mpu_I2C_SLV_LEN_LENGTH, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlaveDataLength(uint8_t num, uint8_t length) {\nif (num &gt; 3)\nreturn;\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_I2C_SLV0_CTRL + num * 3,\nmpu_I2C_SLV_LEN_BIT, mpu_I2C_SLV_LEN_LENGTH, length);\n}\n\n// I2C_SLV* registers (Slave 4)\n\nuint8_t mpu_getSlave4Address() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_I2C_SLV4_ADDR, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlave4Address(uint8_t address) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_I2C_SLV4_ADDR, address);\n}\nuint8_t mpu_getSlave4Register() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_I2C_SLV4_REG, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlave4Register(uint8_t reg) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_I2C_SLV4_REG, reg);\n}\nvoid mpu_setSlave4OutputByte(uint8_t data) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_I2C_SLV4_DO, data);\n}\nbool mpu_getSlave4Enabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_SLV4_CTRL, mpu_I2C_SLV4_EN_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlave4Enabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_I2C_SLV4_CTRL, mpu_I2C_SLV4_EN_BIT, enabled);\n}\nbool mpu_getSlave4InterruptEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_SLV4_CTRL,\nmpu_I2C_SLV4_INT_EN_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlave4InterruptEnabled(bool enabled) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_I2C_SLV4_CTRL,\nmpu_I2C_SLV4_INT_EN_BIT, enabled);\n}\nbool mpu_getSlave4WriteMode() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_SLV4_CTRL,\nmpu_I2C_SLV4_REG_DIS_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlave4WriteMode(bool mode) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_I2C_SLV4_CTRL, mpu_I2C_SLV4_REG_DIS_BIT, mode);\n}\nuint8_t mpu_getSlave4MasterDelay() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_I2C_SLV4_CTRL,\nmpu_I2C_SLV4_MST_DLY_BIT, mpu_I2C_SLV4_MST_DLY_LENGTH, mpu6050.buffer,\n0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlave4MasterDelay(uint8_t delay) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_I2C_SLV4_CTRL,\nmpu_I2C_SLV4_MST_DLY_BIT, mpu_I2C_SLV4_MST_DLY_LENGTH, delay);\n}\nuint8_t mpu_getSlate4InputByte() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_I2C_SLV4_DI, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\n\n// I2C_MST_STATUS register\n\nbool mpu_getPassthroughStatus() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_STATUS,\nmpu_MST_PASS_THROUGH_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getSlave4IsDone() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_STATUS,\nmpu_MST_I2C_SLV4_DONE_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getLostArbitration() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_STATUS,\nmpu_MST_I2C_LOST_ARB_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getSlave4Nack() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_STATUS,\nmpu_MST_I2C_SLV4_NACK_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getSlave3Nack() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_STATUS,\nmpu_MST_I2C_SLV3_NACK_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getSlave2Nack() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_STATUS,\nmpu_MST_I2C_SLV2_NACK_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getSlave1Nack() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_STATUS,\nmpu_MST_I2C_SLV1_NACK_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getSlave0Nack() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_STATUS,\nmpu_MST_I2C_SLV0_NACK_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\n\n// INT_PIN_CFG register\n\nbool mpu_getInterruptMode() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG,\nmpu_INTCFG_INT_LEVEL_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setInterruptMode(bool mode) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_INT_PIN_CFG, mpu_INTCFG_INT_LEVEL_BIT, mode);\n}\nbool mpu_getInterruptDrive() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG, mpu_INTCFG_INT_OPEN_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setInterruptDrive(bool drive) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_INT_PIN_CFG, mpu_INTCFG_INT_OPEN_BIT, drive);\n}\nbool mpu_getInterruptLatch() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG,\nmpu_INTCFG_LATCH_INT_EN_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setInterruptLatch(bool latch) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG,\nmpu_INTCFG_LATCH_INT_EN_BIT, latch);\n}\nbool mpu_getInterruptLatchClear() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG,\nmpu_INTCFG_INT_RD_CLEAR_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setInterruptLatchClear(bool clear) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG,\nmpu_INTCFG_INT_RD_CLEAR_BIT, clear);\n}\nbool mpu_getFSyncInterruptLevel() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG,\nmpu_INTCFG_FSYNC_INT_LEVEL_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setFSyncInterruptLevel(bool level) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG,\nmpu_INTCFG_FSYNC_INT_LEVEL_BIT, level);\n}\nbool mpu_getFSyncInterruptEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG,\nmpu_INTCFG_FSYNC_INT_EN_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setFSyncInterruptEnabled(bool enabled) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG,\nmpu_INTCFG_FSYNC_INT_EN_BIT, enabled);\n}\nbool mpu_getI2CBypassEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG,\nmpu_INTCFG_I2C_BYPASS_EN_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setI2CBypassEnabled(bool enabled) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG,\nmpu_INTCFG_I2C_BYPASS_EN_BIT, enabled);\n}\nbool mpu_getClockOutputEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_PIN_CFG,\nmpu_INTCFG_CLKOUT_EN_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setClockOutputEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_INT_PIN_CFG, mpu_INTCFG_CLKOUT_EN_BIT, enabled);\n}\n\n// INT_ENABLE register\n\nuint8_t mpu_getIntEnabled() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_INT_ENABLE, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setIntEnabled(uint8_t enabled) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_INT_ENABLE, enabled);\n}\nbool mpu_getIntFreefallEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_ENABLE, mpu_INTERRUPT_FF_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setIntFreefallEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_INT_ENABLE, mpu_INTERRUPT_FF_BIT, enabled);\n}\nbool mpu_getIntMotionEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_ENABLE, mpu_INTERRUPT_MOT_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setIntMotionEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_INT_ENABLE, mpu_INTERRUPT_MOT_BIT, enabled);\n}\nbool mpu_getIntZeroMotionEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_ENABLE, mpu_INTERRUPT_ZMOT_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setIntZeroMotionEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_INT_ENABLE, mpu_INTERRUPT_ZMOT_BIT, enabled);\n}\nbool mpu_getIntFIFOBufferOverflowEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_ENABLE,\nmpu_INTERRUPT_FIFO_OFLOW_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setIntFIFOBufferOverflowEnabled(bool enabled) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_INT_ENABLE,\nmpu_INTERRUPT_FIFO_OFLOW_BIT, enabled);\n}\nbool mpu_getIntI2CMasterEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_ENABLE,\nmpu_INTERRUPT_I2C_MST_INT_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setIntI2CMasterEnabled(bool enabled) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_INT_ENABLE,\nmpu_INTERRUPT_I2C_MST_INT_BIT, enabled);\n}\nbool mpu_getIntDataReadyEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_ENABLE,\nmpu_INTERRUPT_DATA_RDY_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setIntDataReadyEnabled(bool enabled) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_INT_ENABLE,\nmpu_INTERRUPT_DATA_RDY_BIT, enabled);\n}\n\n// INT_STATUS register\n\nuint8_t mpu_getIntStatus() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_INT_STATUS, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getIntFreefallStatus() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_STATUS, mpu_INTERRUPT_FF_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getIntMotionStatus() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_STATUS, mpu_INTERRUPT_MOT_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getIntZeroMotionStatus() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_STATUS, mpu_INTERRUPT_ZMOT_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getIntFIFOBufferOverflowStatus() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_STATUS,\nmpu_INTERRUPT_FIFO_OFLOW_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getIntI2CMasterStatus() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_STATUS,\nmpu_INTERRUPT_I2C_MST_INT_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getIntDataReadyStatus() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_STATUS,\nmpu_INTERRUPT_DATA_RDY_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\n\n// ACCEL_*OUT_* registers\n\nvoid mpu_getMotion9(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx,\nint16_t* gy, int16_t* gz, int16_t* mx, int16_t* my, int16_t* mz) {\nmpu_getMotion6(ax, ay, az, gx, gy, gz);\n// TODO: magnetometer integration\n}\nvoid mpu_getMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx,\nint16_t* gy, int16_t* gz) {\nI2Cdev_readBytes(\nmpu6050.devAddr, mpu_RA_ACCEL_XOUT_H, 14, mpu6050.buffer, 0);\n*ax = (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n*ay = (((int16_t)mpu6050.buffer[2]) &lt;&lt; 8) | mpu6050.buffer[3];\n*az = (((int16_t)mpu6050.buffer[4]) &lt;&lt; 8) | mpu6050.buffer[5];\n*gx = (((int16_t)mpu6050.buffer[8]) &lt;&lt; 8) | mpu6050.buffer[9];\n*gy = (((int16_t)mpu6050.buffer[10]) &lt;&lt; 8) | mpu6050.buffer[11];\n*gz = (((int16_t)mpu6050.buffer[12]) &lt;&lt; 8) | mpu6050.buffer[13];\n}\nvoid mpu_getAcceleration(int16_t* x, int16_t* y, int16_t* z) {\n// void mpu_getAcceleration(int32_t* x, int32_t* y, int32_t* z) {\nI2Cdev_readBytes(\nmpu6050.devAddr, mpu_RA_ACCEL_XOUT_H, 6, mpu6050.buffer, 0);\n*x = (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n*y = (((int16_t)mpu6050.buffer[2]) &lt;&lt; 8) | mpu6050.buffer[3];\n*z = (((int16_t)mpu6050.buffer[4]) &lt;&lt; 8) | mpu6050.buffer[5];\n}\nint16_t mpu_getAccelerationX() {\nI2Cdev_readBytes(\nmpu6050.devAddr, mpu_RA_ACCEL_XOUT_H, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\nint16_t mpu_getAccelerationY() {\nI2Cdev_readBytes(\nmpu6050.devAddr, mpu_RA_ACCEL_YOUT_H, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\nint16_t mpu_getAccelerationZ() {\nI2Cdev_readBytes(\nmpu6050.devAddr, mpu_RA_ACCEL_ZOUT_H, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\n\n// TEMP_OUT_* registers\n\nint16_t mpu_getTemperature() {\nI2Cdev_readBytes(mpu6050.devAddr, mpu_RA_TEMP_OUT_H, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\n\n// GYRO_*OUT_* registers\n\nvoid mpu_getRotation(int16_t* x, int16_t* y, int16_t* z) {\n// void mpu_getRotation(int32_t* x, int32_t* y, int32_t* z) {\nI2Cdev_readBytes(mpu6050.devAddr, mpu_RA_GYRO_XOUT_H, 6, mpu6050.buffer, 0);\n*x = (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n*y = (((int16_t)mpu6050.buffer[2]) &lt;&lt; 8) | mpu6050.buffer[3];\n*z = (((int16_t)mpu6050.buffer[4]) &lt;&lt; 8) | mpu6050.buffer[5];\n}\nint16_t mpu_getRotationX() {\nI2Cdev_readBytes(mpu6050.devAddr, mpu_RA_GYRO_XOUT_H, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\nint16_t mpu_getRotationY() {\nI2Cdev_readBytes(mpu6050.devAddr, mpu_RA_GYRO_YOUT_H, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\nint16_t mpu_getRotationZ() {\nI2Cdev_readBytes(mpu6050.devAddr, mpu_RA_GYRO_ZOUT_H, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\n\n// EXT_SENS_DATA_* registers\n\nuint8_t mpu_getExternalSensorByte(int position) {\nI2Cdev_readByte(\nmpu6050.devAddr, mpu_RA_EXT_SENS_DATA_00 + position, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nuint16_t mpu_getExternalSensorWord(int position) {\nI2Cdev_readBytes(mpu6050.devAddr, mpu_RA_EXT_SENS_DATA_00 + position, 2,\nmpu6050.buffer, 0);\nreturn (((uint16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\nuint32_t mpu_getExternalSensorDWord(int position) {\nI2Cdev_readBytes(mpu6050.devAddr, mpu_RA_EXT_SENS_DATA_00 + position, 4,\nmpu6050.buffer, 0);\nreturn (((uint32_t)mpu6050.buffer[0]) &lt;&lt; 24)\n| (((uint32_t)mpu6050.buffer[1]) &lt;&lt; 16)\n| (((uint16_t)mpu6050.buffer[2]) &lt;&lt; 8) | mpu6050.buffer[3];\n}\n\n// MOT_DETECT_STATUS register\n\nbool mpu_getXNegMotionDetected() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_MOT_DETECT_STATUS,\nmpu_MOTION_MOT_XNEG_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getXPosMotionDetected() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_MOT_DETECT_STATUS,\nmpu_MOTION_MOT_XPOS_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getYNegMotionDetected() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_MOT_DETECT_STATUS,\nmpu_MOTION_MOT_YNEG_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getYPosMotionDetected() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_MOT_DETECT_STATUS,\nmpu_MOTION_MOT_YPOS_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getZNegMotionDetected() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_MOT_DETECT_STATUS,\nmpu_MOTION_MOT_ZNEG_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getZPosMotionDetected() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_MOT_DETECT_STATUS,\nmpu_MOTION_MOT_ZPOS_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getZeroMotionDetected() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_MOT_DETECT_STATUS,\nmpu_MOTION_MOT_ZRMOT_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\n\n// I2C_SLV*_DO register\n\nvoid mpu_setSlaveOutputByte(uint8_t num, uint8_t data) {\nif (num &gt; 3)\nreturn;\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_I2C_SLV0_DO + num, data);\n}\n\n// I2C_MST_DELAY_CTRL register\n\nbool mpu_getExternalShadowDelayEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_I2C_MST_DELAY_CTRL,\nmpu_DELAYCTRL_DELAY_ES_SHADOW_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setExternalShadowDelayEnabled(bool enabled) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_I2C_MST_DELAY_CTRL,\nmpu_DELAYCTRL_DELAY_ES_SHADOW_BIT, enabled);\n}\nbool mpu_getSlaveDelayEnabled(uint8_t num) {\n// mpu_DELAYCTRL_I2C_SLV4_DLY_EN_BIT is 4, SLV3 is 3, etc.\nif (num &gt; 4)\nreturn 0;\nI2Cdev_readBit(\nmpu6050.devAddr, mpu_RA_I2C_MST_DELAY_CTRL, num, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSlaveDelayEnabled(uint8_t num, bool enabled) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_I2C_MST_DELAY_CTRL, num, enabled);\n}\n\n// SIGNAL_PATH_RESET register\n\nvoid mpu_resetGyroscopePath() {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_SIGNAL_PATH_RESET,\nmpu_PATHRESET_GYRO_RESET_BIT, true);\n}\nvoid mpu_resetAccelerometerPath() {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_SIGNAL_PATH_RESET,\nmpu_PATHRESET_ACCEL_RESET_BIT, true);\n}\nvoid mpu_resetTemperaturePath() {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_SIGNAL_PATH_RESET,\nmpu_PATHRESET_TEMP_RESET_BIT, true);\n}\n\n// MOT_DETECT_CTRL register\n\nuint8_t mpu_getAccelerometerPowerOnDelay() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_MOT_DETECT_CTRL,\nmpu_DETECT_ACCEL_ON_DELAY_BIT, mpu_DETECT_ACCEL_ON_DELAY_LENGTH,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setAccelerometerPowerOnDelay(uint8_t delay) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_MOT_DETECT_CTRL,\nmpu_DETECT_ACCEL_ON_DELAY_BIT, mpu_DETECT_ACCEL_ON_DELAY_LENGTH, delay);\n}\nuint8_t mpu_getFreefallDetectionCounterDecrement() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_MOT_DETECT_CTRL,\nmpu_DETECT_FF_COUNT_BIT, mpu_DETECT_FF_COUNT_LENGTH, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setFreefallDetectionCounterDecrement(uint8_t decrement) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_MOT_DETECT_CTRL,\nmpu_DETECT_FF_COUNT_BIT, mpu_DETECT_FF_COUNT_LENGTH, decrement);\n}\nuint8_t mpu_getMotionDetectionCounterDecrement() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_MOT_DETECT_CTRL,\nmpu_DETECT_MOT_COUNT_BIT, mpu_DETECT_MOT_COUNT_LENGTH, mpu6050.buffer,\n0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setMotionDetectionCounterDecrement(uint8_t decrement) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_MOT_DETECT_CTRL,\nmpu_DETECT_MOT_COUNT_BIT, mpu_DETECT_MOT_COUNT_LENGTH, decrement);\n}\n\n// USER_CTRL register\n\nbool mpu_getFIFOEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_USER_CTRL, mpu_USERCTRL_FIFO_EN_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setFIFOEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_USER_CTRL, mpu_USERCTRL_FIFO_EN_BIT, enabled);\n}\nbool mpu_getI2CMasterModeEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_USER_CTRL,\nmpu_USERCTRL_I2C_MST_EN_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setI2CMasterModeEnabled(bool enabled) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_USER_CTRL,\nmpu_USERCTRL_I2C_MST_EN_BIT, enabled);\n}\nvoid mpu_switchSPIEnabled(bool enabled) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_USER_CTRL,\nmpu_USERCTRL_I2C_IF_DIS_BIT, enabled);\n}\nvoid mpu_resetFIFO() {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_USER_CTRL, mpu_USERCTRL_FIFO_RESET_BIT, true);\n}\nvoid mpu_resetI2CMaster() {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_USER_CTRL,\nmpu_USERCTRL_I2C_MST_RESET_BIT, true);\n}\nvoid mpu_resetSensors() {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_USER_CTRL,\nmpu_USERCTRL_SIG_COND_RESET_BIT, true);\n}\n\n// PWR_MGMT_1 register\n\nvoid mpu_reset() {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_PWR_MGMT_1, mpu_PWR1_DEVICE_RESET_BIT, true);\n}\nbool mpu_getSleepEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_PWR_MGMT_1, mpu_PWR1_SLEEP_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setSleepEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_PWR_MGMT_1, mpu_PWR1_SLEEP_BIT, enabled);\n}\nbool mpu_getWakeCycleEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_PWR_MGMT_1, mpu_PWR1_CYCLE_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setWakeCycleEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_PWR_MGMT_1, mpu_PWR1_CYCLE_BIT, enabled);\n}\nbool mpu_getTempSensorEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_PWR_MGMT_1, mpu_PWR1_TEMP_DIS_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0] == 0; // 1 is actually disabled here\n}\nvoid mpu_setTempSensorEnabled(bool enabled) {\n// 1 is actually disabled here\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_PWR_MGMT_1, mpu_PWR1_TEMP_DIS_BIT, !enabled);\n}\nuint8_t mpu_getClockSource() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_PWR_MGMT_1, mpu_PWR1_CLKSEL_BIT,\nmpu_PWR1_CLKSEL_LENGTH, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setClockSource(uint8_t source) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_PWR_MGMT_1, mpu_PWR1_CLKSEL_BIT,\nmpu_PWR1_CLKSEL_LENGTH, source);\n}\n\n// PWR_MGMT_2 register\n\nuint8_t mpu_getWakeFrequency() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_PWR_MGMT_2,\nmpu_PWR2_LP_WAKE_CTRL_BIT, mpu_PWR2_LP_WAKE_CTRL_LENGTH, mpu6050.buffer,\n0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setWakeFrequency(uint8_t frequency) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_PWR_MGMT_2,\nmpu_PWR2_LP_WAKE_CTRL_BIT, mpu_PWR2_LP_WAKE_CTRL_LENGTH, frequency);\n}\n\nbool mpu_getStandbyXAccelEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_PWR_MGMT_2, mpu_PWR2_STBY_XA_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setStandbyXAccelEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_PWR_MGMT_2, mpu_PWR2_STBY_XA_BIT, enabled);\n}\nbool mpu_getStandbyYAccelEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_PWR_MGMT_2, mpu_PWR2_STBY_YA_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setStandbyYAccelEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_PWR_MGMT_2, mpu_PWR2_STBY_YA_BIT, enabled);\n}\nbool mpu_getStandbyZAccelEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_PWR_MGMT_2, mpu_PWR2_STBY_ZA_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setStandbyZAccelEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_PWR_MGMT_2, mpu_PWR2_STBY_ZA_BIT, enabled);\n}\nbool mpu_getStandbyXGyroEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_PWR_MGMT_2, mpu_PWR2_STBY_XG_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setStandbyXGyroEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_PWR_MGMT_2, mpu_PWR2_STBY_XG_BIT, enabled);\n}\nbool mpu_getStandbyYGyroEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_PWR_MGMT_2, mpu_PWR2_STBY_YG_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setStandbyYGyroEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_PWR_MGMT_2, mpu_PWR2_STBY_YG_BIT, enabled);\n}\nbool mpu_getStandbyZGyroEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_PWR_MGMT_2, mpu_PWR2_STBY_ZG_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setStandbyZGyroEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_PWR_MGMT_2, mpu_PWR2_STBY_ZG_BIT, enabled);\n}\n\n// FIFO_COUNT* registers\n\nuint16_t mpu_getFIFOCount() {\nI2Cdev_readBytes(mpu6050.devAddr, mpu_RA_FIFO_COUNTH, 2, mpu6050.buffer, 0);\nreturn (((uint16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\n\n// FIFO_R_W register\n\nuint8_t mpu_getFIFOByte() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_FIFO_R_W, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_getFIFOBytes(uint8_t* data, uint8_t length) {\nI2Cdev_readBytes(mpu6050.devAddr, mpu_RA_FIFO_R_W, length, data, 0);\n}\nvoid mpu_setFIFOByte(uint8_t data) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_FIFO_R_W, data);\n}\n\n// WHO_AM_I register\n\nuint8_t mpu_getDeviceID() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_WHO_AM_I, mpu_WHO_AM_I_BIT,\nmpu_WHO_AM_I_LENGTH, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setDeviceID(uint8_t id) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_WHO_AM_I, mpu_WHO_AM_I_BIT,\nmpu_WHO_AM_I_LENGTH, id);\n}\n\n// ======== UNDOCUMENTED/DMP REGISTERS/METHODS ========\n\n// XG_OFFS_TC register\n\nuint8_t mpu_getOTPBankValid() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_XG_OFFS_TC, mpu_TC_OTP_BNK_VLD_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setOTPBankValid(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_XG_OFFS_TC, mpu_TC_OTP_BNK_VLD_BIT, enabled);\n}\nint8_t mpu_getXGyroOffsetTC() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_XG_OFFS_TC, mpu_TC_OFFSET_BIT,\nmpu_TC_OFFSET_LENGTH, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setXGyroOffsetTC(int8_t offset) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_XG_OFFS_TC, mpu_TC_OFFSET_BIT,\nmpu_TC_OFFSET_LENGTH, offset);\n}\n\n// YG_OFFS_TC register\n\nint8_t mpu_getYGyroOffsetTC() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_YG_OFFS_TC, mpu_TC_OFFSET_BIT,\nmpu_TC_OFFSET_LENGTH, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setYGyroOffsetTC(int8_t offset) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_YG_OFFS_TC, mpu_TC_OFFSET_BIT,\nmpu_TC_OFFSET_LENGTH, offset);\n}\n\n// ZG_OFFS_TC register\n\nint8_t mpu_getZGyroOffsetTC() {\nI2Cdev_readBits(mpu6050.devAddr, mpu_RA_ZG_OFFS_TC, mpu_TC_OFFSET_BIT,\nmpu_TC_OFFSET_LENGTH, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setZGyroOffsetTC(int8_t offset) {\nI2Cdev_writeBits(mpu6050.devAddr, mpu_RA_ZG_OFFS_TC, mpu_TC_OFFSET_BIT,\nmpu_TC_OFFSET_LENGTH, offset);\n}\n\n// X_FINE_GAIN register\n\nint8_t mpu_getXFineGain() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_X_FINE_GAIN, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setXFineGain(int8_t gain) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_X_FINE_GAIN, gain);\n}\n\n// Y_FINE_GAIN register\n\nint8_t mpu_getYFineGain() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_Y_FINE_GAIN, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setYFineGain(int8_t gain) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_Y_FINE_GAIN, gain);\n}\n\n// Z_FINE_GAIN register\n\nint8_t mpu_getZFineGain() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_Z_FINE_GAIN, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setZFineGain(int8_t gain) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_Z_FINE_GAIN, gain);\n}\n\n// XA_OFFS_* registers\n\nint16_t mpu_getXAccelOffset() {\nI2Cdev_readBytes(mpu6050.devAddr, mpu_RA_XA_OFFS_H, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\nvoid mpu_setXAccelOffset(int16_t offset) {\nI2Cdev_writeWord(mpu6050.devAddr, mpu_RA_XA_OFFS_H, offset);\n}\n\n// YA_OFFS_* register\n\nint16_t mpu_getYAccelOffset() {\nI2Cdev_readBytes(mpu6050.devAddr, mpu_RA_YA_OFFS_H, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\nvoid mpu_setYAccelOffset(int16_t offset) {\nI2Cdev_writeWord(mpu6050.devAddr, mpu_RA_YA_OFFS_H, offset);\n}\n\n// ZA_OFFS_* register\n\nint16_t mpu_getZAccelOffset() {\nI2Cdev_readBytes(mpu6050.devAddr, mpu_RA_ZA_OFFS_H, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\nvoid mpu_setZAccelOffset(int16_t offset) {\nI2Cdev_writeWord(mpu6050.devAddr, mpu_RA_ZA_OFFS_H, offset);\n}\n\n// XG_OFFS_USR* registers\n\nint16_t mpu_getXGyroOffset() {\nI2Cdev_readBytes(\nmpu6050.devAddr, mpu_RA_XG_OFFS_USRH, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\nvoid mpu_setXGyroOffset(int16_t offset) {\nI2Cdev_writeWord(mpu6050.devAddr, mpu_RA_XG_OFFS_USRH, offset);\n}\n\n// YG_OFFS_USR* register\n\nint16_t mpu_getYGyroOffset() {\nI2Cdev_readBytes(\nmpu6050.devAddr, mpu_RA_YG_OFFS_USRH, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\nvoid mpu_setYGyroOffset(int16_t offset) {\nI2Cdev_writeWord(mpu6050.devAddr, mpu_RA_YG_OFFS_USRH, offset);\n}\n\n// ZG_OFFS_USR* register\n\nint16_t mpu_getZGyroOffset() {\nI2Cdev_readBytes(\nmpu6050.devAddr, mpu_RA_ZG_OFFS_USRH, 2, mpu6050.buffer, 0);\nreturn (((int16_t)mpu6050.buffer[0]) &lt;&lt; 8) | mpu6050.buffer[1];\n}\nvoid mpu_setZGyroOffset(int16_t offset) {\nI2Cdev_writeWord(mpu6050.devAddr, mpu_RA_ZG_OFFS_USRH, offset);\n}\n\n// INT_ENABLE register (DMP functions)\n\nbool mpu_getIntPLLReadyEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_ENABLE,\nmpu_INTERRUPT_PLL_RDY_INT_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setIntPLLReadyEnabled(bool enabled) {\nI2Cdev_writeBit(mpu6050.devAddr, mpu_RA_INT_ENABLE,\nmpu_INTERRUPT_PLL_RDY_INT_BIT, enabled);\n}\nbool mpu_getIntDMPEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_ENABLE,\nmpu_INTERRUPT_DMP_INT_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setIntDMPEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_INT_ENABLE, mpu_INTERRUPT_DMP_INT_BIT, enabled);\n}\n\n// DMP_INT_STATUS\n\nbool mpu_getDMPInt5Status() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_DMP_INT_STATUS, mpu_DMPINT_5_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getDMPInt4Status() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_DMP_INT_STATUS, mpu_DMPINT_4_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getDMPInt3Status() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_DMP_INT_STATUS, mpu_DMPINT_3_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getDMPInt2Status() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_DMP_INT_STATUS, mpu_DMPINT_2_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getDMPInt1Status() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_DMP_INT_STATUS, mpu_DMPINT_1_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getDMPInt0Status() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_DMP_INT_STATUS, mpu_DMPINT_0_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\n\n// INT_STATUS register (DMP functions)\n\nbool mpu_getIntPLLReadyStatus() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_STATUS,\nmpu_INTERRUPT_PLL_RDY_INT_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nbool mpu_getIntDMPStatus() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_INT_STATUS,\nmpu_INTERRUPT_DMP_INT_BIT, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\n\n// USER_CTRL register (DMP functions)\n\nbool mpu_getDMPEnabled() {\nI2Cdev_readBit(mpu6050.devAddr, mpu_RA_USER_CTRL, mpu_USERCTRL_DMP_EN_BIT,\nmpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setDMPEnabled(bool enabled) {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_USER_CTRL, mpu_USERCTRL_DMP_EN_BIT, enabled);\n}\nvoid mpu_resetDMP() {\nI2Cdev_writeBit(\nmpu6050.devAddr, mpu_RA_USER_CTRL, mpu_USERCTRL_DMP_RESET_BIT, true);\n}\n\n// BANK_SEL register\n\nvoid mpu_setMemoryBank(uint8_t bank, bool prefetchEnabled, bool userBank) {\nbank &amp;= 0x1F;\nif (userBank)\nbank |= 0x20;\nif (prefetchEnabled)\nbank |= 0x40;\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_BANK_SEL, bank);\n}\n\n// MEM_START_ADDR register\n\nvoid mpu_setMemoryStartAddress(uint8_t address) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_MEM_START_ADDR, address);\n}\n\n// MEM_R_W register\n\nuint8_t mpu_readMemoryByte() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_MEM_R_W, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_writeMemoryByte(uint8_t data) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_MEM_R_W, data);\n}\nvoid mpu_readMemoryBlock(\nuint8_t* data, uint16_t dataSize, uint8_t bank, uint8_t address) {\nmpu_setMemoryBank(bank, false, false);\nmpu_setMemoryStartAddress(address);\nuint8_t chunkSize;\nfor (uint16_t i = 0; i &lt; dataSize;) {\n// determine correct chunk size according to bank position and data size\nchunkSize = mpu_DMP_MEMORY_CHUNK_SIZE;\n\n// make sure we don't go past the data size\nif (i + chunkSize &gt; dataSize)\nchunkSize = dataSize - i;\n\n// make sure this chunk doesn't go past the bank boundary (256 bytes)\nif (chunkSize &gt; 256 - address)\nchunkSize = 256 - address;\n\n// read the chunk of data as specified\nI2Cdev_readBytes(\nmpu6050.devAddr, mpu_RA_MEM_R_W, chunkSize, data + i, 0);\n\n// increase byte index by [chunkSize]\ni += chunkSize;\n\n// uint8_t automatically wraps to 0 at 256\naddress += chunkSize;\n\n// if we aren't done, update bank (if necessary) and address\nif (i &lt; dataSize) {\nif (address == 0)\nbank++;\nmpu_setMemoryBank(bank, false, false);\nmpu_setMemoryStartAddress(address);\n}\n}\n}\n/*bool mpu_writeMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify, bool useProgMem) {\n    mpu_setMemoryBank(bank, false, false);\n    mpu_setMemoryStartAddress(address);\n    uint8_t chunkSize;\n    uint8_t *verifyBuffer;\n    uint8_t *progBuffer;\n    uint16_t i;\n    uint8_t j;\n    if (verify) verifyBuffer = (uint8_t *)malloc(mpu_DMP_MEMORY_CHUNK_SIZE);\n    if (useProgMem) progBuffer = (uint8_t *)malloc(mpu_DMP_MEMORY_CHUNK_SIZE);\n    for (i = 0; i &lt; dataSize;) {\n        // determine correct chunk size according to bank position and data size\n        chunkSize = mpu_DMP_MEMORY_CHUNK_SIZE;\n\n        // make sure we don't go past the data size\n        if (i + chunkSize &gt; dataSize) chunkSize = dataSize - i;\n\n        // make sure this chunk doesn't go past the bank boundary (256 bytes)\n        if (chunkSize &gt; 256 - address) chunkSize = 256 - address;\n\n        if (useProgMem) {\n            // write the chunk of data as specified\n            for (j = 0; j &lt; chunkSize; j++) progBuffer[j] = pgm_read_byte(data + i + j);\n        } else {\n            // write the chunk of data as specified\n            progBuffer = (uint8_t *)data + i;\n        }\n\n        I2Cdev_writeBytes(mpu6050.devAddr, mpu_RA_MEM_R_W, chunkSize, progBuffer);\n\n        // verify data if needed\n        if (verify &amp;&amp; verifyBuffer) {\n            mpu_setMemoryBank(bank, false, false);\n            mpu_setMemoryStartAddress(address);\n            I2Cdev_readBytes(mpu6050.devAddr, mpu_RA_MEM_R_W, chunkSize, verifyBuffer);\n            if (memcmp(progBuffer, verifyBuffer, chunkSize) != 0) {\n                //Serial.print(\"Block write verification error, bank \");\n                //Serial.print(bank, DEC);\n                //Serial.print(\", address \");\n                //Serial.print(address, DEC);\n                //Serial.print(\"!\\nExpected:\");\n                //for (j = 0; j &lt; chunkSize; j++) {\n                //    Serial.print(\" 0x\");\n                //    if (progBuffer[j] &lt; 16) Serial.print(\"0\");\n                //    Serial.print(progBuffer[j], HEX);\n                //}\n                //Serial.print(\"\\nReceived:\");\n                //for (uint8_t j = 0; j &lt; chunkSize; j++) {\n                //    Serial.print(\" 0x\");\n                //    if (verifyBuffer[i + j] &lt; 16) Serial.print(\"0\");\n                //    Serial.print(verifyBuffer[i + j], HEX);\n                //}\n                Serial.print(\"\\n\");\n                free(verifyBuffer);\n                if (useProgMem) free(progBuffer);\n                return false; // uh oh.\n            }\n        }\n\n        // increase byte index by [chunkSize]\n        i += chunkSize;\n\n        // uint8_t automatically wraps to 0 at 256\n        address += chunkSize;\n\n        // if we aren't done, update bank (if necessary) and address\n        if (i &lt; dataSize) {\n            if (address == 0) bank++;\n            mpu_setMemoryBank(bank, false, false);\n            mpu_setMemoryStartAddress(address);\n        }\n    }\n    if (verify) free(verifyBuffer);\n    if (useProgMem) free(progBuffer);\n    return true;\n}\nbool mpu_writeProgMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify) {\n    return mpu_writeMemoryBlock(data, dataSize, bank, address, verify, true);\n}\nbool mpu_writeDMPConfigurationSet(const uint8_t *data, uint16_t dataSize, bool useProgMem) {\n    uint8_t *progBuffer, success, special;\n    uint16_t i, j;\n    if (useProgMem) {\n        progBuffer = (uint8_t *)malloc(8); // assume 8-byte blocks, realloc later if necessary\n    }\n\n    // config set data is a long string of blocks with the following structure:\n    // [bank] [offset] [length] [byte[0], byte[1], ..., byte[length]]\n    uint8_t bank, offset, length;\n    for (i = 0; i &lt; dataSize;) {\n        if (useProgMem) {\n            bank = pgm_read_byte(data + i++);\n            offset = pgm_read_byte(data + i++);\n            length = pgm_read_byte(data + i++);\n        } else {\n            bank = data[i++];\n            offset = data[i++];\n            length = data[i++];\n        }\n\n        // write data or perform special action\n        if (length &gt; 0) {\n            // regular block of data to write\n            //Serial.print(\"Writing config block to bank \");\n            //Serial.print(bank);\n            //Serial.print(\", offset \");\n            //Serial.print(offset);\n            //Serial.print(\", length=\");\n            //Serial.println(length);\n            if (useProgMem) {\n                if (sizeof(progBuffer) &lt; length) progBuffer = (uint8_t *)realloc(progBuffer, length);\n                for (j = 0; j &lt; length; j++) progBuffer[j] = pgm_read_byte(data + i + j);\n            } else {\n                progBuffer = (uint8_t *)data + i;\n            }\n            success = mpu_writeMemoryBlock(progBuffer, length, bank, offset, true);\n            i += length;\n        } else {\n            // special instruction\n            // NOTE: this kind of behavior (what and when to do certain things)\n            // is totally undocumented. This code is in here based on observed\n            // behavior only, and exactly why (or even whether) it has to be here\n            // is anybody's guess for now.\n            if (useProgMem) {\n                special = pgm_read_byte(data + i++);\n            } else {\n                special = data[i++];\n            }\n            //Serial.print(\"Special command code \");\n            //Serial.print(special, HEX);\n            //Serial.println(\" found...\");\n            if (special == 0x01) {\n                // enable DMP-related interrupts\n\n                //setIntZeroMotionEnabled(true);\n                //setIntFIFOBufferOverflowEnabled(true);\n                //setIntDMPEnabled(true);\n                I2Cdev_writeByte(mpu6050.devAddr, mpu_RA_INT_ENABLE, 0x32);  // single operation\n\n                success = true;\n            } else {\n                // unknown special command\n                success = false;\n            }\n        }\n\n        if (!success) {\n            if (useProgMem) free(progBuffer);\n            return false; // uh oh\n        }\n    }\n    if (useProgMem) free(progBuffer);\n    return true;\n}\nbool mpu_writeProgDMPConfigurationSet(const uint8_t *data, uint16_t dataSize) {\n    return mpu_writeDMPConfigurationSet(data, dataSize, true);\n}*/\n\n// DMP_CFG_1 register\n\nuint8_t mpu_getDMPConfig1() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_DMP_CFG_1, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setDMPConfig1(uint8_t config) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_DMP_CFG_1, config);\n}\n\n// DMP_CFG_2 register\n\nuint8_t mpu_getDMPConfig2() {\nI2Cdev_readByte(mpu6050.devAddr, mpu_RA_DMP_CFG_2, mpu6050.buffer, 0);\nreturn mpu6050.buffer[0];\n}\nvoid mpu_setDMPConfig2(uint8_t config) {\nI2Cdev_writeByte(mpu6050.devAddr, mpu_RA_DMP_CFG_2, config);\n}\n</code></pre>"},{"location":"apiStm/OledController_8cpp/","title":"File OledController.cpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; src &gt; OledController.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"OledController.hpp\"</code></li> <li><code>#include \"Dispatcher.hpp\"</code></li> <li><code>#include \"string.h\"</code></li> <li><code>#include \"utils/Debug.hpp\"</code></li> <li><code>#include &lt;math.h&gt;</code></li> <li><code>#include &lt;stdlib.h&gt;</code></li> </ul>"},{"location":"apiStm/OledController_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name OLED_t OLED uint8_t OLED_Buffer uint8_t oled_height   = = 64 uint8_t oled_width   = = 128"},{"location":"apiStm/OledController_8cpp/#public-functions","title":"Public Functions","text":"Type Name void oledDispatch (const CoprocReq_OledReq &amp; request)  void oledDrawArc (uint8_t x, uint8_t y, uint8_t radius, uint16_t start_angle, uint16_t sweep, OLED_COLOR color)  void oledDrawCircle (uint8_t par_x, uint8_t par_y, uint8_t par_r, OLED_COLOR par_color)  void oledDrawLine (uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, OLED_COLOR color)  void oledDrawPixel (uint8_t x, uint8_t y, OLED_COLOR color)  void oledDrawRectangle (uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, OLED_COLOR color)  void oledFill (OLED_COLOR color)  OLED_Error_t oledFillBuffer (uint8_t * buf, uint32_t len)  bool oledGetDisplayOn () Reads DisplayOn state. void oledInit (const CoprocReq_OledInit &amp; init)  void oledPolyline (const OLED_VERTEX * par_vertex, uint16_t par_size, OLED_COLOR color)  void oledSetContrast (const uint8_t value) Sets the contrast of the display. void oledSetCursor (uint8_t x, uint8_t y)  void oledSetDisplayOn (const bool on) Set Display ON/OFF. bool oledTestConnection ()  void oledUpdateScreen (void)  char oledWriteChar (char ch, FontDef Font, OLED_COLOR color)  void oledWriteCommand (uint8_t byte)  void oledWriteData (uint8_t * buffer, size_t buff_size)  char oledWriteString (const char * str, FontDef Font, OLED_COLOR color)"},{"location":"apiStm/OledController_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name float oledDegToRad (float par_deg)  uint16_t oledNormalizeTo0_360 (uint16_t par_deg)"},{"location":"apiStm/OledController_8cpp/#macros","title":"Macros","text":"Type Name define CIRCLE_APPROXIMATION_SEGMENTS  36"},{"location":"apiStm/OledController_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"apiStm/OledController_8cpp/#variable-oled","title":"variable OLED","text":"<pre><code>OLED_t OLED;\n</code></pre>"},{"location":"apiStm/OledController_8cpp/#variable-oled_buffer","title":"variable OLED_Buffer","text":"<pre><code>uint8_t OLED_Buffer[OLED_BUFFER_SIZE];\n</code></pre>"},{"location":"apiStm/OledController_8cpp/#variable-oled_height","title":"variable oled_height","text":"<pre><code>uint8_t oled_height;\n</code></pre>"},{"location":"apiStm/OledController_8cpp/#variable-oled_width","title":"variable oled_width","text":"<pre><code>uint8_t oled_width;\n</code></pre>"},{"location":"apiStm/OledController_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/OledController_8cpp/#function-oleddispatch","title":"function oledDispatch","text":"<pre><code>void oledDispatch (\nconst CoprocReq_OledReq &amp; request\n) </code></pre>"},{"location":"apiStm/OledController_8cpp/#function-oleddrawarc","title":"function oledDrawArc","text":"<pre><code>void oledDrawArc (\nuint8_t x,\nuint8_t y,\nuint8_t radius,\nuint16_t start_angle,\nuint16_t sweep,\nOLED_COLOR color\n) </code></pre>"},{"location":"apiStm/OledController_8cpp/#function-oleddrawcircle","title":"function oledDrawCircle","text":"<pre><code>void oledDrawCircle (\nuint8_t par_x,\nuint8_t par_y,\nuint8_t par_r,\nOLED_COLOR par_color\n) </code></pre>"},{"location":"apiStm/OledController_8cpp/#function-oleddrawline","title":"function oledDrawLine","text":"<pre><code>void oledDrawLine (\nuint8_t x1,\nuint8_t y1,\nuint8_t x2,\nuint8_t y2,\nOLED_COLOR color\n) </code></pre>"},{"location":"apiStm/OledController_8cpp/#function-oleddrawpixel","title":"function oledDrawPixel","text":"<pre><code>void oledDrawPixel (\nuint8_t x,\nuint8_t y,\nOLED_COLOR color\n) </code></pre>"},{"location":"apiStm/OledController_8cpp/#function-oleddrawrectangle","title":"function oledDrawRectangle","text":"<pre><code>void oledDrawRectangle (\nuint8_t x1,\nuint8_t y1,\nuint8_t x2,\nuint8_t y2,\nOLED_COLOR color\n) </code></pre>"},{"location":"apiStm/OledController_8cpp/#function-oledfill","title":"function oledFill","text":"<pre><code>void oledFill (\nOLED_COLOR color\n) </code></pre>"},{"location":"apiStm/OledController_8cpp/#function-oledfillbuffer","title":"function oledFillBuffer","text":"<pre><code>OLED_Error_t oledFillBuffer (\nuint8_t * buf,\nuint32_t len\n) </code></pre>"},{"location":"apiStm/OledController_8cpp/#function-oledgetdisplayon","title":"function oledGetDisplayOn","text":"<p>Reads DisplayOn state. <pre><code>bool oledGetDisplayOn () </code></pre></p> <p>Returns:</p> <p>0: OFF. 1: ON. </p>"},{"location":"apiStm/OledController_8cpp/#function-oledinit","title":"function oledInit","text":"<pre><code>void oledInit (\nconst CoprocReq_OledInit &amp; init\n) </code></pre>"},{"location":"apiStm/OledController_8cpp/#function-oledpolyline","title":"function oledPolyline","text":"<pre><code>void oledPolyline (\nconst OLED_VERTEX * par_vertex,\nuint16_t par_size,\nOLED_COLOR color\n) </code></pre>"},{"location":"apiStm/OledController_8cpp/#function-oledsetcontrast","title":"function oledSetContrast","text":"<p>Sets the contrast of the display. <pre><code>void oledSetContrast (\nconst uint8_t value\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>value</code> contrast to set. </li> </ul> <p>Note:</p> <p>Contrast increases as the value increases. </p> <p>Note:</p> <p>RESET = 7Fh. </p>"},{"location":"apiStm/OledController_8cpp/#function-oledsetcursor","title":"function oledSetCursor","text":"<pre><code>void oledSetCursor (\nuint8_t x,\nuint8_t y\n) </code></pre>"},{"location":"apiStm/OledController_8cpp/#function-oledsetdisplayon","title":"function oledSetDisplayOn","text":"<p>Set Display ON/OFF. <pre><code>void oledSetDisplayOn (\nconst bool on\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>on</code> 0 for OFF, any for ON. </li> </ul>"},{"location":"apiStm/OledController_8cpp/#function-oledtestconnection","title":"function oledTestConnection","text":"<pre><code>bool oledTestConnection () </code></pre>"},{"location":"apiStm/OledController_8cpp/#function-oledupdatescreen","title":"function oledUpdateScreen","text":"<pre><code>void oledUpdateScreen (\nvoid\n) </code></pre>"},{"location":"apiStm/OledController_8cpp/#function-oledwritechar","title":"function oledWriteChar","text":"<pre><code>char oledWriteChar (\nchar ch,\nFontDef Font,\nOLED_COLOR color\n) </code></pre>"},{"location":"apiStm/OledController_8cpp/#function-oledwritecommand","title":"function oledWriteCommand","text":"<pre><code>void oledWriteCommand (\nuint8_t byte\n) </code></pre>"},{"location":"apiStm/OledController_8cpp/#function-oledwritedata","title":"function oledWriteData","text":"<pre><code>void oledWriteData (\nuint8_t * buffer,\nsize_t buff_size\n) </code></pre>"},{"location":"apiStm/OledController_8cpp/#function-oledwritestring","title":"function oledWriteString","text":"<pre><code>char oledWriteString (\nconst char * str,\nFontDef Font,\nOLED_COLOR color\n) </code></pre>"},{"location":"apiStm/OledController_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"apiStm/OledController_8cpp/#function-oleddegtorad","title":"function oledDegToRad","text":"<pre><code>static float oledDegToRad (\nfloat par_deg\n) </code></pre>"},{"location":"apiStm/OledController_8cpp/#function-olednormalizeto0_360","title":"function oledNormalizeTo0_360","text":"<pre><code>static uint16_t oledNormalizeTo0_360 (\nuint16_t par_deg\n) </code></pre>"},{"location":"apiStm/OledController_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/OledController_8cpp/#define-circle_approximation_segments","title":"define CIRCLE_APPROXIMATION_SEGMENTS","text":"<pre><code>#define CIRCLE_APPROXIMATION_SEGMENTS 36\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/OledController.cpp</code></p>"},{"location":"apiStm/OledController_8cpp_source/","title":"File OledController.cpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; src &gt; OledController.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"OledController.hpp\"\n#include \"Dispatcher.hpp\"\n#include \"string.h\"\n#include \"utils/Debug.hpp\"\n#include &lt;math.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt; // For memcpy\n\n// OLED OLED height in pixels\nstatic uint8_t oled_height = 64;\n\n// OLED width in pixels\nstatic uint8_t oled_width = 128;\n\n// Screenbuffer\nstatic uint8_t OLED_Buffer[OLED_BUFFER_SIZE];\n\n// Screen object\nstatic OLED_t OLED;\n\nvoid oledDispatch(const CoprocReq_OledReq&amp; request) {\nswitch (request.which_oledCmd) {\ncase CoprocReq_OledReq_init_tag:\noledInit(request.oledCmd.init);\nbreak;\n\ncase CoprocReq_OledReq_fill_tag:\noledFill(OLED_COLOR(request.oledCmd.fill));\nbreak;\n\ncase CoprocReq_OledReq_update_tag:\noledUpdateScreen();\nbreak;\n\ncase CoprocReq_OledReq_drawPixel_tag: {\nconst auto&amp; drawPixel = request.oledCmd.drawPixel;\noledDrawPixel(drawPixel.x, drawPixel.y, OLED_COLOR(drawPixel.color));\nbreak;\n}\ncase CoprocReq_OledReq_writeString_tag: {\n\nconst auto&amp; writeString = request.oledCmd.writeString;\nchar text[33];\nstrcpy(text, writeString.text);\nFontDef* font;\nswitch (writeString.font) {\ncase CoprocReq_OledFont_OLED_FONT_6X8:\nfont = &amp;Font_6x8;\nbreak;\ncase CoprocReq_OledFont_OLED_FONT_7X10:\nfont = &amp;Font_7x10;\nbreak;\ncase CoprocReq_OledFont_OLED_FONT_11X18:\nfont = &amp;Font_11x18;\nbreak;\ncase CoprocReq_OledFont_OLED_FONT_16X26:\nfont = &amp;Font_16x26;\nbreak;\ndefault:\nfont = &amp;Font_7x10;\n}\noledWriteString(text, *font, OLED_COLOR(writeString.color));\nbreak;\n}\ncase CoprocReq_OledReq_setCursor_tag: {\nconst auto&amp; setCursor = request.oledCmd.setCursor;\noledSetCursor(setCursor.x, setCursor.y);\nbreak;\n}\n\ncase CoprocReq_OledReq_drawLine_tag: {\nconst auto&amp; drawLine = request.oledCmd.drawLine;\noledDrawLine(drawLine.x1, drawLine.y1, drawLine.x2, drawLine.y2,\nOLED_COLOR(drawLine.color));\nbreak;\n}\n\ncase CoprocReq_OledReq_drawArc_tag: {\nconst auto&amp; drawArc = request.oledCmd.drawArc;\noledDrawArc(drawArc.x, drawArc.y, drawArc.radius, drawArc.start_angle,\ndrawArc.sweep, OLED_COLOR(drawArc.color));\nbreak;\n}\n\ncase CoprocReq_OledReq_drawCircle_tag: {\nconst auto&amp; drawCircle = request.oledCmd.drawCircle;\noledDrawCircle(drawCircle.x, drawCircle.y, drawCircle.radius,\nOLED_COLOR(drawCircle.color));\nbreak;\n}\n\ncase CoprocReq_OledReq_drawRectangle_tag: {\nconst auto&amp; drawRectangle = request.oledCmd.drawRectangle;\noledDrawRectangle(drawRectangle.x1, drawRectangle.y1, drawRectangle.x2,\ndrawRectangle.y2, OLED_COLOR(drawRectangle.color));\nbreak;\n}\n};\n}\n\nbool oledTestConnection() { return I2Cdev_IsDeviceReady(OLED_I2C_ADDR, 1, 10); }\n\n// Initialize the oled screen\nvoid oledInit(const CoprocReq_OledInit&amp; init) {\n\nif (oledTestConnection()) {\n// Init OLED\noledSetDisplayOn(false); //display off\n\noledWriteCommand(0x20); //Set Memory Addressing Mode\noledWriteCommand(\n0x00); // 00b,Horizontal Addressing Mode; 01b,Vertical Addressing Mode;\n// 10b,Page Addressing Mode (RESET); 11b,Invalid\n\noledWriteCommand(\n0xB0); //Set Page Start Address for Page Addressing Mode,0-7\n\nif (init.rotate) {\noledWriteCommand(0xC0); // Mirror vertically\n} else {\noledWriteCommand(0xC8); //Set COM Output Scan Direction\n}\n\noledWriteCommand(0x00); //---set low column address\noledWriteCommand(0x10); //---set high column address\n\noledWriteCommand(0x40); //--set start line address - CHECK\n\noledSetContrast(0xFF);\n\nif (init.rotate) {\noledWriteCommand(0xA0); // Mirror horizontally\n} else {\noledWriteCommand(0xA1); //--set segment re-map 0 to 127 - CHECK\n}\n\nif (init.inverseColor) {\noledWriteCommand(0xA7); //--set inverse color\n} else {\noledWriteCommand(0xA6); //--set normal color\n}\n\noledWriteCommand(0xA8); //--set multiplex ratio(1 to 64) - CHECK\n\nif (init.height == 32) {\noledWriteCommand(0x1F); //\n} else if (init.height == 64) {\noledWriteCommand(0x3F); //\n} else {\n//TO DO warning message\n}\n\noledWriteCommand(\n0xA4); //0xa4,Output follows RAM content;0xa5,Output ignores RAM content\n\noledWriteCommand(0xD3); //-set display offset - CHECK\noledWriteCommand(0x00); //-not offset\n\noledWriteCommand(\n0xD5); //--set display clock divide ratio/oscillator frequency\noledWriteCommand(0xF0); //--set divide ratio\n\noledWriteCommand(0xD9); //--set pre-charge period\noledWriteCommand(0x22); //\n\noledWriteCommand(0xDA); //--set com pins hardware configuration - CHECK\n\nif (init.height == 32) {\noledWriteCommand(0x02);\n} else if (init.height == 64) {\noledWriteCommand(0x12);\n} else {\n//TO DO warning message\n}\n\noledWriteCommand(0xDB); //--set vcomh\noledWriteCommand(0x20); //0x20,0.77xVcc\n\noledWriteCommand(0x8D); //--set DC-DC enable\noledWriteCommand(0x14); //\noledSetDisplayOn(true); //--turn on OLED panel\n\n// Clear screen\noledFill(Black);\n\n// Flush buffer to screen\noledUpdateScreen();\n\n// Set default values for screen object\nOLED.CurrentX = 0;\nOLED.CurrentY = 0;\n\n} else {\nDEBUG(\"Oled not connected-init\\n\");\nCoprocStat status = {\n.which_payload = CoprocStat_faultStat_tag,\n.payload = {\n.faultStat = {\n.which_fault = CoprocStat_FaultStat_oledFault_tag,\n},\n},\n};\ndispatcherEnqueueStatus(status);\n}\n}\n\n// Fill the whole screen with the given color\nvoid oledFill(OLED_COLOR color) {\n/* Set memory */\nuint32_t i;\n\nfor (i = 0; i &lt; sizeof(OLED_Buffer); i++) {\nOLED_Buffer[i] = (color == Black) ? 0x00 : 0xFF;\n}\n}\n\n// Write the screenbuffer with changed to the screen\nvoid oledUpdateScreen(void) {\nif (!oledTestConnection()) {\nDEBUG(\"Oled not connected\\n\");\nCoprocStat status = {\n.which_payload = CoprocStat_faultStat_tag,\n.payload = {\n.faultStat = {\n.which_fault = CoprocStat_FaultStat_oledFault_tag,\n},\n},\n};\ndispatcherEnqueueStatus(status);\n}\n// Write data to each page of RAM. Number of pages\n// depends on the screen height:\n//\n//  * 32px   ==  4 pages\n//  * 64px   ==  8 pages\n//  * 128px  ==  16 pages\nfor (uint8_t i = 0; i &lt; oled_height / 8; i++) {\noledWriteCommand(0xB0 + i); // Set the current RAM page address.\noledWriteCommand(0x00);\noledWriteCommand(0x10);\noledWriteData(&amp;OLED_Buffer[oled_width * i], oled_width);\n}\n}\n\n//    Draw one pixel in the screenbuffer\n//    X =&gt; X Coordinate\n//    Y =&gt; Y Coordinate\n//    color =&gt; Pixel color\nvoid oledDrawPixel(uint8_t x, uint8_t y, OLED_COLOR color) {\nif (x &gt;= oled_width || y &gt;= oled_height) {\n// Don't write outside the buffer\nreturn;\n}\n\n// Check if pixel should be inverted\nif (OLED.Inverted) {\ncolor = (OLED_COLOR)!color;\n}\n\n// Draw in the right color\nif (color == White) {\nOLED_Buffer[x + (y / 8) * oled_width] |= 1 &lt;&lt; (y % 8);\n} else {\nOLED_Buffer[x + (y / 8) * oled_width] &amp;= ~(1 &lt;&lt; (y % 8));\n}\n}\n\n// Draw 1 char to the screen buffer\n// ch       =&gt; char om weg te schrijven\n// Font     =&gt; Font waarmee we gaan schrijven\n// color    =&gt; Black or White\nchar oledWriteChar(char ch, FontDef Font, OLED_COLOR color) {\nuint32_t i, b, j;\n\n// Check if character is valid\nif (ch &lt; 32 || ch &gt; 126)\nreturn 0;\n\n// Check remaining space on current line\nif (oled_width &lt; (OLED.CurrentX + Font.FontWidth)\n|| oled_height &lt; (OLED.CurrentY + Font.FontHeight)) {\n// Not enough space on current line\nreturn 0;\n}\n\n// Use the font to write\nfor (i = 0; i &lt; Font.FontHeight; i++) {\nb = Font.data[(ch - 32) * Font.FontHeight + i];\nfor (j = 0; j &lt; Font.FontWidth; j++) {\nif ((b &lt;&lt; j) &amp; 0x8000) {\noledDrawPixel(\nOLED.CurrentX + j, (OLED.CurrentY + i), (OLED_COLOR)color);\n} else {\noledDrawPixel(\nOLED.CurrentX + j, (OLED.CurrentY + i), (OLED_COLOR)!color);\n}\n}\n}\n\n// The current space is now taken\nOLED.CurrentX += Font.FontWidth;\n\n// Return written char for validation\nreturn ch;\n}\n\n// Write full string to screenbuffer\nchar oledWriteString(const char* str, FontDef Font, OLED_COLOR color) {\n// Write until null-byte\nwhile (*str) {\nif (oledWriteChar(*str, Font, color) != *str) {\n// Char could not be written\nreturn *str;\n}\n\n// Next char\nstr++;\n}\n\n// Everything ok\nreturn *str;\n}\n\n// Position the cursor\nvoid oledSetCursor(uint8_t x, uint8_t y) {\nOLED.CurrentX = x;\nOLED.CurrentY = y;\n}\n\n// Draw line by Bresenhem's algorithm\nvoid oledDrawLine(\nuint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, OLED_COLOR color) {\nint32_t deltaX = abs(x2 - x1);\nint32_t deltaY = abs(y2 - y1);\nint32_t signX = ((x1 &lt; x2) ? 1 : -1);\nint32_t signY = ((y1 &lt; y2) ? 1 : -1);\nint32_t error = deltaX - deltaY;\nint32_t error2;\n\noledDrawPixel(x2, y2, color);\nwhile ((x1 != x2) || (y1 != y2)) {\noledDrawPixel(x1, y1, color);\nerror2 = error * 2;\nif (error2 &gt; -deltaY) {\nerror -= deltaY;\nx1 += signX;\n} else {\n/*nothing to do*/\n}\n\nif (error2 &lt; deltaX) {\nerror += deltaX;\ny1 += signY;\n} else {\n/*nothing to do*/\n}\n}\nreturn;\n}\n//Draw polyline\nvoid oledPolyline(\nconst OLED_VERTEX* par_vertex, uint16_t par_size, OLED_COLOR color) {\nuint16_t i;\nif (par_vertex != 0) {\nfor (i = 1; i &lt; par_size; i++) {\noledDrawLine(par_vertex[i - 1].x, par_vertex[i - 1].y,\npar_vertex[i].x, par_vertex[i].y, color);\n}\n} else {\n/*nothing to do*/\n}\nreturn;\n}\n/*Convert Degrees to Radians*/\nstatic float oledDegToRad(float par_deg) { return par_deg * 3.14 / 180.0; }\n/*Normalize degree to [0;360]*/\nstatic uint16_t oledNormalizeTo0_360(uint16_t par_deg) {\nuint16_t loc_angle;\nif (par_deg &lt;= 360) {\nloc_angle = par_deg;\n} else {\nloc_angle = par_deg % 360;\nloc_angle = ((par_deg != 0) ? par_deg : 360);\n}\nreturn loc_angle;\n}\n/*DrawArc. Draw angle is beginning from 4 quart of trigonometric circle (3pi/2)\n * start_angle in degree\n * sweep in degree\n */\nvoid oledDrawArc(uint8_t x, uint8_t y, uint8_t radius, uint16_t start_angle,\nuint16_t sweep, OLED_COLOR color) {\n#define CIRCLE_APPROXIMATION_SEGMENTS 36\nfloat approx_degree;\nuint32_t approx_segments;\nuint8_t xp1, xp2;\nuint8_t yp1, yp2;\nuint32_t count = 0;\nuint32_t loc_sweep = 0;\nfloat rad;\n\nloc_sweep = oledNormalizeTo0_360(sweep);\n\ncount = (oledNormalizeTo0_360(start_angle) * CIRCLE_APPROXIMATION_SEGMENTS)\n/ 360;\napprox_segments = (loc_sweep * CIRCLE_APPROXIMATION_SEGMENTS) / 360;\napprox_degree = loc_sweep / (float)approx_segments;\nwhile (count &lt; approx_segments) {\nrad = oledDegToRad(count * approx_degree);\nxp1 = x + (int8_t)(sin(rad) * radius);\nyp1 = y + (int8_t)(cos(rad) * radius);\ncount++;\nif (count != approx_segments) {\nrad = oledDegToRad(count * approx_degree);\n} else {\nrad = oledDegToRad(loc_sweep);\n}\nxp2 = x + (int8_t)(sin(rad) * radius);\nyp2 = y + (int8_t)(cos(rad) * radius);\noledDrawLine(xp1, yp1, xp2, yp2, color);\n}\n\nreturn;\n}\n//Draw circle by Bresenhem's algorithm\nvoid oledDrawCircle(\nuint8_t par_x, uint8_t par_y, uint8_t par_r, OLED_COLOR par_color) {\nint32_t x = -par_r;\nint32_t y = 0;\nint32_t err = 2 - 2 * par_r;\nint32_t e2;\n\nif (par_x &gt;= oled_width || par_y &gt;= oled_height) {\nreturn;\n}\n\ndo {\noledDrawPixel(par_x - x, par_y + y, par_color);\noledDrawPixel(par_x + x, par_y + y, par_color);\noledDrawPixel(par_x + x, par_y - y, par_color);\noledDrawPixel(par_x - x, par_y - y, par_color);\ne2 = err;\nif (e2 &lt;= y) {\ny++;\nerr = err + (y * 2 + 1);\nif (-x == y &amp;&amp; e2 &lt;= x) {\ne2 = 0;\n} else {\n/*nothing to do*/\n}\n} else {\n/*nothing to do*/\n}\nif (e2 &gt; x) {\nx++;\nerr = err + (x * 2 + 1);\n} else {\n/*nothing to do*/\n}\n} while (x &lt;= 0);\n\nreturn;\n}\n\n//Draw rectangle\nvoid oledDrawRectangle(\nuint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, OLED_COLOR color) {\noledDrawLine(x1, y1, x2, y1, color);\noledDrawLine(x2, y1, x2, y2, color);\noledDrawLine(x2, y2, x1, y2, color);\noledDrawLine(x1, y2, x1, y1, color);\n\nreturn;\n}\n\nvoid oledSetContrast(const uint8_t value) {\nconst uint8_t kSetContrastControlRegister = 0x81;\noledWriteCommand(kSetContrastControlRegister);\noledWriteCommand(value);\n}\n\nvoid oledSetDisplayOn(const bool on) {\nuint8_t value;\nif (on) {\nvalue = 0xAF; // Display on\nOLED.DisplayOn = true;\n} else {\nvalue = 0xAE; // Display off\nOLED.DisplayOn = false;\n}\noledWriteCommand(value);\n}\n\nbool oledGetDisplayOn() { return OLED.DisplayOn; }\n\n// Send a byte to the command register\nvoid oledWriteCommand(uint8_t byte) {\nI2Cdev_Mem_Write(OLED_I2C_ADDR, 0x00, 1, &amp;byte, 1, HAL_MAX_DELAY);\n}\n\n// Send data\nvoid oledWriteData(uint8_t* buffer, size_t buff_size) {\nI2Cdev_Mem_Write(OLED_I2C_ADDR, 0x40, 1, buffer, buff_size, HAL_MAX_DELAY);\n}\n\n/* Fills the Screenbuffer with values from a given buffer of a fixed length */\nOLED_Error_t oledFillBuffer(uint8_t* buf, uint32_t len) {\nOLED_Error_t ret = OLED_ERR;\nif (len &lt;= OLED_BUFFER_SIZE) {\nmemcpy(OLED_Buffer, buf, len);\nret = OLED_OK;\n}\nreturn ret;\n}\n</code></pre>"},{"location":"apiStm/OledController__fonts_8cpp/","title":"File OledController_fonts.cpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; src &gt; OledController_fonts.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"OledController_fonts.hpp\"</code></li> </ul>"},{"location":"apiStm/OledController__fonts_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name FontDef Font_11x18   = = { 11, 18, Font11x18 } FontDef Font_16x26   = = { 16, 26, Font16x26 } FontDef Font_6x8   = = { 6, 8, Font6x8 } FontDef Font_7x10   = = { 7, 10, Font7x10 }"},{"location":"apiStm/OledController__fonts_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const uint16_t Font11x18 const uint16_t Font16x26 const uint16_t Font6x8 const uint16_t Font7x10"},{"location":"apiStm/OledController__fonts_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/OledController__fonts_8cpp/#variable-font_11x18","title":"variable Font_11x18","text":"<pre><code>FontDef Font_11x18;\n</code></pre>"},{"location":"apiStm/OledController__fonts_8cpp/#variable-font_16x26","title":"variable Font_16x26","text":"<pre><code>FontDef Font_16x26;\n</code></pre>"},{"location":"apiStm/OledController__fonts_8cpp/#variable-font_6x8","title":"variable Font_6x8","text":"<pre><code>FontDef Font_6x8;\n</code></pre>"},{"location":"apiStm/OledController__fonts_8cpp/#variable-font_7x10","title":"variable Font_7x10","text":"<pre><code>FontDef Font_7x10;\n</code></pre>"},{"location":"apiStm/OledController__fonts_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"apiStm/OledController__fonts_8cpp/#variable-font11x18","title":"variable Font11x18","text":"<pre><code>const uint16_t Font11x18[];\n</code></pre>"},{"location":"apiStm/OledController__fonts_8cpp/#variable-font16x26","title":"variable Font16x26","text":"<pre><code>const uint16_t Font16x26[];\n</code></pre>"},{"location":"apiStm/OledController__fonts_8cpp/#variable-font6x8","title":"variable Font6x8","text":"<pre><code>const uint16_t Font6x8[];\n</code></pre>"},{"location":"apiStm/OledController__fonts_8cpp/#variable-font7x10","title":"variable Font7x10","text":"<pre><code>const uint16_t Font7x10[];\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/OledController_fonts.cpp</code></p>"},{"location":"apiStm/OledController__fonts_8cpp_source/","title":"File OledController_fonts.cpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; src &gt; OledController_fonts.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"OledController_fonts.hpp\"\n\nstatic const uint16_t Font7x10[] = {\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // sp\n0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000, 0x1000, 0x0000,\n0x0000, // !\n0x2800, 0x2800, 0x2800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // \"\n0x2400, 0x2400, 0x7C00, 0x2400, 0x4800, 0x7C00, 0x4800, 0x4800, 0x0000,\n0x0000, // #\n0x3800, 0x5400, 0x5000, 0x3800, 0x1400, 0x5400, 0x5400, 0x3800, 0x1000,\n0x0000, // $\n0x2000, 0x5400, 0x5800, 0x3000, 0x2800, 0x5400, 0x1400, 0x0800, 0x0000,\n0x0000, // %\n0x1000, 0x2800, 0x2800, 0x1000, 0x3400, 0x4800, 0x4800, 0x3400, 0x0000,\n0x0000, // &amp;\n0x1000, 0x1000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // '\n0x0800, 0x1000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x1000,\n0x0800, // (\n0x2000, 0x1000, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x1000,\n0x2000, // )\n0x1000, 0x3800, 0x1000, 0x2800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // *\n0x0000, 0x0000, 0x1000, 0x1000, 0x7C00, 0x1000, 0x1000, 0x0000, 0x0000,\n0x0000, // +\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1000, 0x1000,\n0x1000, // ,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3800, 0x0000, 0x0000, 0x0000,\n0x0000, // -\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1000, 0x0000,\n0x0000, // .\n0x0800, 0x0800, 0x1000, 0x1000, 0x1000, 0x1000, 0x2000, 0x2000, 0x0000,\n0x0000, // /\n0x3800, 0x4400, 0x4400, 0x5400, 0x4400, 0x4400, 0x4400, 0x3800, 0x0000,\n0x0000, // 0\n0x1000, 0x3000, 0x5000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000,\n0x0000, // 1\n0x3800, 0x4400, 0x4400, 0x0400, 0x0800, 0x1000, 0x2000, 0x7C00, 0x0000,\n0x0000, // 2\n0x3800, 0x4400, 0x0400, 0x1800, 0x0400, 0x0400, 0x4400, 0x3800, 0x0000,\n0x0000, // 3\n0x0800, 0x1800, 0x2800, 0x2800, 0x4800, 0x7C00, 0x0800, 0x0800, 0x0000,\n0x0000, // 4\n0x7C00, 0x4000, 0x4000, 0x7800, 0x0400, 0x0400, 0x4400, 0x3800, 0x0000,\n0x0000, // 5\n0x3800, 0x4400, 0x4000, 0x7800, 0x4400, 0x4400, 0x4400, 0x3800, 0x0000,\n0x0000, // 6\n0x7C00, 0x0400, 0x0800, 0x1000, 0x1000, 0x2000, 0x2000, 0x2000, 0x0000,\n0x0000, // 7\n0x3800, 0x4400, 0x4400, 0x3800, 0x4400, 0x4400, 0x4400, 0x3800, 0x0000,\n0x0000, // 8\n0x3800, 0x4400, 0x4400, 0x4400, 0x3C00, 0x0400, 0x4400, 0x3800, 0x0000,\n0x0000, // 9\n0x0000, 0x0000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1000, 0x0000,\n0x0000, // :\n0x0000, 0x0000, 0x0000, 0x1000, 0x0000, 0x0000, 0x0000, 0x1000, 0x1000,\n0x1000, // ;\n0x0000, 0x0000, 0x0C00, 0x3000, 0x4000, 0x3000, 0x0C00, 0x0000, 0x0000,\n0x0000, // &lt;\n0x0000, 0x0000, 0x0000, 0x7C00, 0x0000, 0x7C00, 0x0000, 0x0000, 0x0000,\n0x0000, // =\n0x0000, 0x0000, 0x6000, 0x1800, 0x0400, 0x1800, 0x6000, 0x0000, 0x0000,\n0x0000, // &gt;\n0x3800, 0x4400, 0x0400, 0x0800, 0x1000, 0x1000, 0x0000, 0x1000, 0x0000,\n0x0000, // ?\n0x3800, 0x4400, 0x4C00, 0x5400, 0x5C00, 0x4000, 0x4000, 0x3800, 0x0000,\n0x0000, // @\n0x1000, 0x2800, 0x2800, 0x2800, 0x2800, 0x7C00, 0x4400, 0x4400, 0x0000,\n0x0000, // A\n0x7800, 0x4400, 0x4400, 0x7800, 0x4400, 0x4400, 0x4400, 0x7800, 0x0000,\n0x0000, // B\n0x3800, 0x4400, 0x4000, 0x4000, 0x4000, 0x4000, 0x4400, 0x3800, 0x0000,\n0x0000, // C\n0x7000, 0x4800, 0x4400, 0x4400, 0x4400, 0x4400, 0x4800, 0x7000, 0x0000,\n0x0000, // D\n0x7C00, 0x4000, 0x4000, 0x7C00, 0x4000, 0x4000, 0x4000, 0x7C00, 0x0000,\n0x0000, // E\n0x7C00, 0x4000, 0x4000, 0x7800, 0x4000, 0x4000, 0x4000, 0x4000, 0x0000,\n0x0000, // F\n0x3800, 0x4400, 0x4000, 0x4000, 0x5C00, 0x4400, 0x4400, 0x3800, 0x0000,\n0x0000, // G\n0x4400, 0x4400, 0x4400, 0x7C00, 0x4400, 0x4400, 0x4400, 0x4400, 0x0000,\n0x0000, // H\n0x3800, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x3800, 0x0000,\n0x0000, // I\n0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x4400, 0x3800, 0x0000,\n0x0000, // J\n0x4400, 0x4800, 0x5000, 0x6000, 0x5000, 0x4800, 0x4800, 0x4400, 0x0000,\n0x0000, // K\n0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x7C00, 0x0000,\n0x0000, // L\n0x4400, 0x6C00, 0x6C00, 0x5400, 0x4400, 0x4400, 0x4400, 0x4400, 0x0000,\n0x0000, // M\n0x4400, 0x6400, 0x6400, 0x5400, 0x5400, 0x4C00, 0x4C00, 0x4400, 0x0000,\n0x0000, // N\n0x3800, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x3800, 0x0000,\n0x0000, // O\n0x7800, 0x4400, 0x4400, 0x4400, 0x7800, 0x4000, 0x4000, 0x4000, 0x0000,\n0x0000, // P\n0x3800, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x5400, 0x3800, 0x0400,\n0x0000, // Q\n0x7800, 0x4400, 0x4400, 0x4400, 0x7800, 0x4800, 0x4800, 0x4400, 0x0000,\n0x0000, // R\n0x3800, 0x4400, 0x4000, 0x3000, 0x0800, 0x0400, 0x4400, 0x3800, 0x0000,\n0x0000, // S\n0x7C00, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000,\n0x0000, // T\n0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x3800, 0x0000,\n0x0000, // U\n0x4400, 0x4400, 0x4400, 0x2800, 0x2800, 0x2800, 0x1000, 0x1000, 0x0000,\n0x0000, // V\n0x4400, 0x4400, 0x5400, 0x5400, 0x5400, 0x6C00, 0x2800, 0x2800, 0x0000,\n0x0000, // W\n0x4400, 0x2800, 0x2800, 0x1000, 0x1000, 0x2800, 0x2800, 0x4400, 0x0000,\n0x0000, // X\n0x4400, 0x4400, 0x2800, 0x2800, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000,\n0x0000, // Y\n0x7C00, 0x0400, 0x0800, 0x1000, 0x1000, 0x2000, 0x4000, 0x7C00, 0x0000,\n0x0000, // Z\n0x1800, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000,\n0x1800, // [\n0x2000, 0x2000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0800, 0x0800, 0x0000,\n0x0000, /* \\ */\n0x3000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000,\n0x3000, // ]\n0x1000, 0x2800, 0x2800, 0x4400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // ^\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0xFE00, // _\n0x2000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // `\n0x0000, 0x0000, 0x3800, 0x4400, 0x3C00, 0x4400, 0x4C00, 0x3400, 0x0000,\n0x0000, // a\n0x4000, 0x4000, 0x5800, 0x6400, 0x4400, 0x4400, 0x6400, 0x5800, 0x0000,\n0x0000, // b\n0x0000, 0x0000, 0x3800, 0x4400, 0x4000, 0x4000, 0x4400, 0x3800, 0x0000,\n0x0000, // c\n0x0400, 0x0400, 0x3400, 0x4C00, 0x4400, 0x4400, 0x4C00, 0x3400, 0x0000,\n0x0000, // d\n0x0000, 0x0000, 0x3800, 0x4400, 0x7C00, 0x4000, 0x4400, 0x3800, 0x0000,\n0x0000, // e\n0x0C00, 0x1000, 0x7C00, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000,\n0x0000, // f\n0x0000, 0x0000, 0x3400, 0x4C00, 0x4400, 0x4400, 0x4C00, 0x3400, 0x0400,\n0x7800, // g\n0x4000, 0x4000, 0x5800, 0x6400, 0x4400, 0x4400, 0x4400, 0x4400, 0x0000,\n0x0000, // h\n0x1000, 0x0000, 0x7000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000,\n0x0000, // i\n0x1000, 0x0000, 0x7000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000,\n0xE000, // j\n0x4000, 0x4000, 0x4800, 0x5000, 0x6000, 0x5000, 0x4800, 0x4400, 0x0000,\n0x0000, // k\n0x7000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000,\n0x0000, // l\n0x0000, 0x0000, 0x7800, 0x5400, 0x5400, 0x5400, 0x5400, 0x5400, 0x0000,\n0x0000, // m\n0x0000, 0x0000, 0x5800, 0x6400, 0x4400, 0x4400, 0x4400, 0x4400, 0x0000,\n0x0000, // n\n0x0000, 0x0000, 0x3800, 0x4400, 0x4400, 0x4400, 0x4400, 0x3800, 0x0000,\n0x0000, // o\n0x0000, 0x0000, 0x5800, 0x6400, 0x4400, 0x4400, 0x6400, 0x5800, 0x4000,\n0x4000, // p\n0x0000, 0x0000, 0x3400, 0x4C00, 0x4400, 0x4400, 0x4C00, 0x3400, 0x0400,\n0x0400, // q\n0x0000, 0x0000, 0x5800, 0x6400, 0x4000, 0x4000, 0x4000, 0x4000, 0x0000,\n0x0000, // r\n0x0000, 0x0000, 0x3800, 0x4400, 0x3000, 0x0800, 0x4400, 0x3800, 0x0000,\n0x0000, // s\n0x2000, 0x2000, 0x7800, 0x2000, 0x2000, 0x2000, 0x2000, 0x1800, 0x0000,\n0x0000, // t\n0x0000, 0x0000, 0x4400, 0x4400, 0x4400, 0x4400, 0x4C00, 0x3400, 0x0000,\n0x0000, // u\n0x0000, 0x0000, 0x4400, 0x4400, 0x2800, 0x2800, 0x2800, 0x1000, 0x0000,\n0x0000, // v\n0x0000, 0x0000, 0x5400, 0x5400, 0x5400, 0x6C00, 0x2800, 0x2800, 0x0000,\n0x0000, // w\n0x0000, 0x0000, 0x4400, 0x2800, 0x1000, 0x1000, 0x2800, 0x4400, 0x0000,\n0x0000, // x\n0x0000, 0x0000, 0x4400, 0x4400, 0x2800, 0x2800, 0x1000, 0x1000, 0x1000,\n0x6000, // y\n0x0000, 0x0000, 0x7C00, 0x0800, 0x1000, 0x2000, 0x4000, 0x7C00, 0x0000,\n0x0000, // z\n0x1800, 0x1000, 0x1000, 0x1000, 0x2000, 0x2000, 0x1000, 0x1000, 0x1000,\n0x1800, // {\n0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000,\n0x1000, // |\n0x3000, 0x1000, 0x1000, 0x1000, 0x0800, 0x0800, 0x1000, 0x1000, 0x1000,\n0x3000, // }\n0x0000, 0x0000, 0x0000, 0x7400, 0x4C00, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // ~\n};\n\nstatic const uint16_t Font11x18[] = {\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // sp\n0x0000, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00,\n0x0C00, 0x0C00, 0x0C00, 0x0000, 0x0C00, 0x0C00, 0x0000, 0x0000, 0x0000, // !\n0x0000, 0x1B00, 0x1B00, 0x1B00, 0x1B00, 0x1B00, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // \"\n0x0000, 0x1980, 0x1980, 0x1980, 0x1980, 0x7FC0, 0x7FC0, 0x1980, 0x3300,\n0x7FC0, 0x7FC0, 0x3300, 0x3300, 0x3300, 0x3300, 0x0000, 0x0000, 0x0000, // #\n0x0000, 0x1E00, 0x3F00, 0x7580, 0x6580, 0x7400, 0x3C00, 0x1E00, 0x0700,\n0x0580, 0x6580, 0x6580, 0x7580, 0x3F00, 0x1E00, 0x0400, 0x0400, 0x0000, // $\n0x0000, 0x7000, 0xD800, 0xD840, 0xD8C0, 0xD980, 0x7300, 0x0600, 0x0C00,\n0x1B80, 0x36C0, 0x66C0, 0x46C0, 0x06C0, 0x0380, 0x0000, 0x0000, 0x0000, // %\n0x0000, 0x1E00, 0x3F00, 0x3300, 0x3300, 0x3300, 0x1E00, 0x0C00, 0x3CC0,\n0x66C0, 0x6380, 0x6180, 0x6380, 0x3EC0, 0x1C80, 0x0000, 0x0000, 0x0000, // &amp;\n0x0000, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // '\n0x0080, 0x0100, 0x0300, 0x0600, 0x0600, 0x0400, 0x0C00, 0x0C00, 0x0C00,\n0x0C00, 0x0C00, 0x0C00, 0x0400, 0x0600, 0x0600, 0x0300, 0x0100, 0x0080, // (\n0x2000, 0x1000, 0x1800, 0x0C00, 0x0C00, 0x0400, 0x0600, 0x0600, 0x0600,\n0x0600, 0x0600, 0x0600, 0x0400, 0x0C00, 0x0C00, 0x1800, 0x1000, 0x2000, // )\n0x0000, 0x0C00, 0x2D00, 0x3F00, 0x1E00, 0x3300, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // *\n0x0000, 0x0000, 0x0000, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0xFFC0, 0xFFC0,\n0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // +\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0C00, 0x0C00, 0x0400, 0x0400, 0x0800, // ,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x1E00, 0x1E00, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // -\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0C00, 0x0C00, 0x0000, 0x0000, 0x0000, // .\n0x0000, 0x0300, 0x0300, 0x0300, 0x0600, 0x0600, 0x0600, 0x0600, 0x0C00,\n0x0C00, 0x0C00, 0x0C00, 0x1800, 0x1800, 0x1800, 0x0000, 0x0000, 0x0000, // /\n0x0000, 0x1E00, 0x3F00, 0x3300, 0x6180, 0x6180, 0x6180, 0x6D80, 0x6D80,\n0x6180, 0x6180, 0x6180, 0x3300, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // 0\n0x0000, 0x0600, 0x0E00, 0x1E00, 0x3600, 0x2600, 0x0600, 0x0600, 0x0600,\n0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0000, 0x0000, 0x0000, // 1\n0x0000, 0x1E00, 0x3F00, 0x7380, 0x6180, 0x6180, 0x0180, 0x0300, 0x0600,\n0x0C00, 0x1800, 0x3000, 0x6000, 0x7F80, 0x7F80, 0x0000, 0x0000, 0x0000, // 2\n0x0000, 0x1C00, 0x3E00, 0x6300, 0x6300, 0x0300, 0x0E00, 0x0E00, 0x0300,\n0x0180, 0x0180, 0x6180, 0x7380, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // 3\n0x0000, 0x0600, 0x0E00, 0x0E00, 0x1E00, 0x1E00, 0x1600, 0x3600, 0x3600,\n0x6600, 0x7F80, 0x7F80, 0x0600, 0x0600, 0x0600, 0x0000, 0x0000, 0x0000, // 4\n0x0000, 0x7F00, 0x7F00, 0x6000, 0x6000, 0x6000, 0x6E00, 0x7F00, 0x6380,\n0x0180, 0x0180, 0x6180, 0x7380, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // 5\n0x0000, 0x1E00, 0x3F00, 0x3380, 0x6180, 0x6000, 0x6E00, 0x7F00, 0x7380,\n0x6180, 0x6180, 0x6180, 0x3380, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // 6\n0x0000, 0x7F80, 0x7F80, 0x0180, 0x0300, 0x0300, 0x0600, 0x0600, 0x0C00,\n0x0C00, 0x0C00, 0x0800, 0x1800, 0x1800, 0x1800, 0x0000, 0x0000, 0x0000, // 7\n0x0000, 0x1E00, 0x3F00, 0x6380, 0x6180, 0x6180, 0x2100, 0x1E00, 0x3F00,\n0x6180, 0x6180, 0x6180, 0x6180, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // 8\n0x0000, 0x1E00, 0x3F00, 0x7300, 0x6180, 0x6180, 0x6180, 0x7380, 0x3F80,\n0x1D80, 0x0180, 0x6180, 0x7300, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // 9\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0C00, 0x0C00, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0C00, 0x0C00, 0x0000, 0x0000, 0x0000, // :\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0C00, 0x0C00, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0C00, 0x0C00, 0x0400, 0x0400, 0x0800, // ;\n0x0000, 0x0000, 0x0000, 0x0000, 0x0080, 0x0380, 0x0E00, 0x3800, 0x6000,\n0x3800, 0x0E00, 0x0380, 0x0080, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // &lt;\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x7F80, 0x7F80, 0x0000, 0x0000,\n0x7F80, 0x7F80, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // =\n0x0000, 0x0000, 0x0000, 0x0000, 0x4000, 0x7000, 0x1C00, 0x0700, 0x0180,\n0x0700, 0x1C00, 0x7000, 0x4000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // &gt;\n0x0000, 0x1F00, 0x3F80, 0x71C0, 0x60C0, 0x00C0, 0x01C0, 0x0380, 0x0700,\n0x0E00, 0x0C00, 0x0C00, 0x0000, 0x0C00, 0x0C00, 0x0000, 0x0000, 0x0000, // ?\n0x0000, 0x1E00, 0x3F00, 0x3180, 0x7180, 0x6380, 0x6F80, 0x6D80, 0x6D80,\n0x6F80, 0x6780, 0x6000, 0x3200, 0x3E00, 0x1C00, 0x0000, 0x0000, 0x0000, // @\n0x0000, 0x0E00, 0x0E00, 0x1B00, 0x1B00, 0x1B00, 0x1B00, 0x3180, 0x3180,\n0x3F80, 0x3F80, 0x3180, 0x60C0, 0x60C0, 0x60C0, 0x0000, 0x0000, 0x0000, // A\n0x0000, 0x7C00, 0x7E00, 0x6300, 0x6300, 0x6300, 0x6300, 0x7E00, 0x7E00,\n0x6300, 0x6180, 0x6180, 0x6380, 0x7F00, 0x7E00, 0x0000, 0x0000, 0x0000, // B\n0x0000, 0x1E00, 0x3F00, 0x3180, 0x6180, 0x6000, 0x6000, 0x6000, 0x6000,\n0x6000, 0x6000, 0x6180, 0x3180, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // C\n0x0000, 0x7C00, 0x7F00, 0x6300, 0x6380, 0x6180, 0x6180, 0x6180, 0x6180,\n0x6180, 0x6180, 0x6300, 0x6300, 0x7E00, 0x7C00, 0x0000, 0x0000, 0x0000, // D\n0x0000, 0x7F80, 0x7F80, 0x6000, 0x6000, 0x6000, 0x6000, 0x7F00, 0x7F00,\n0x6000, 0x6000, 0x6000, 0x6000, 0x7F80, 0x7F80, 0x0000, 0x0000, 0x0000, // E\n0x0000, 0x7F80, 0x7F80, 0x6000, 0x6000, 0x6000, 0x6000, 0x7F00, 0x7F00,\n0x6000, 0x6000, 0x6000, 0x6000, 0x6000, 0x6000, 0x0000, 0x0000, 0x0000, // F\n0x0000, 0x1E00, 0x3F00, 0x3180, 0x6180, 0x6000, 0x6000, 0x6000, 0x6380,\n0x6380, 0x6180, 0x6180, 0x3180, 0x3F80, 0x1E00, 0x0000, 0x0000, 0x0000, // G\n0x0000, 0x6180, 0x6180, 0x6180, 0x6180, 0x6180, 0x6180, 0x7F80, 0x7F80,\n0x6180, 0x6180, 0x6180, 0x6180, 0x6180, 0x6180, 0x0000, 0x0000, 0x0000, // H\n0x0000, 0x3F00, 0x3F00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00,\n0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x3F00, 0x3F00, 0x0000, 0x0000, 0x0000, // I\n0x0000, 0x0180, 0x0180, 0x0180, 0x0180, 0x0180, 0x0180, 0x0180, 0x0180,\n0x0180, 0x6180, 0x6180, 0x7380, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // J\n0x0000, 0x60C0, 0x6180, 0x6300, 0x6600, 0x6600, 0x6C00, 0x7800, 0x7C00,\n0x6600, 0x6600, 0x6300, 0x6180, 0x6180, 0x60C0, 0x0000, 0x0000, 0x0000, // K\n0x0000, 0x6000, 0x6000, 0x6000, 0x6000, 0x6000, 0x6000, 0x6000, 0x6000,\n0x6000, 0x6000, 0x6000, 0x6000, 0x7F80, 0x7F80, 0x0000, 0x0000, 0x0000, // L\n0x0000, 0x71C0, 0x71C0, 0x7BC0, 0x7AC0, 0x6AC0, 0x6AC0, 0x6EC0, 0x64C0,\n0x60C0, 0x60C0, 0x60C0, 0x60C0, 0x60C0, 0x60C0, 0x0000, 0x0000, 0x0000, // M\n0x0000, 0x7180, 0x7180, 0x7980, 0x7980, 0x7980, 0x6D80, 0x6D80, 0x6D80,\n0x6580, 0x6780, 0x6780, 0x6780, 0x6380, 0x6380, 0x0000, 0x0000, 0x0000, // N\n0x0000, 0x1E00, 0x3F00, 0x3300, 0x6180, 0x6180, 0x6180, 0x6180, 0x6180,\n0x6180, 0x6180, 0x6180, 0x3300, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // O\n0x0000, 0x7E00, 0x7F00, 0x6380, 0x6180, 0x6180, 0x6180, 0x6380, 0x7F00,\n0x7E00, 0x6000, 0x6000, 0x6000, 0x6000, 0x6000, 0x0000, 0x0000, 0x0000, // P\n0x0000, 0x1E00, 0x3F00, 0x3300, 0x6180, 0x6180, 0x6180, 0x6180, 0x6180,\n0x6180, 0x6580, 0x6780, 0x3300, 0x3F80, 0x1E40, 0x0000, 0x0000, 0x0000, // Q\n0x0000, 0x7E00, 0x7F00, 0x6380, 0x6180, 0x6180, 0x6380, 0x7F00, 0x7E00,\n0x6600, 0x6300, 0x6300, 0x6180, 0x6180, 0x60C0, 0x0000, 0x0000, 0x0000, // R\n0x0000, 0x0E00, 0x1F00, 0x3180, 0x3180, 0x3000, 0x3800, 0x1E00, 0x0700,\n0x0380, 0x6180, 0x6180, 0x3180, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // S\n0x0000, 0xFFC0, 0xFFC0, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00,\n0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0000, 0x0000, 0x0000, // T\n0x0000, 0x6180, 0x6180, 0x6180, 0x6180, 0x6180, 0x6180, 0x6180, 0x6180,\n0x6180, 0x6180, 0x6180, 0x7380, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // U\n0x0000, 0x60C0, 0x60C0, 0x60C0, 0x3180, 0x3180, 0x3180, 0x1B00, 0x1B00,\n0x1B00, 0x1B00, 0x0E00, 0x0E00, 0x0E00, 0x0400, 0x0000, 0x0000, 0x0000, // V\n0x0000, 0xC0C0, 0xC0C0, 0xC0C0, 0xC0C0, 0xC0C0, 0xCCC0, 0x4C80, 0x4C80,\n0x5E80, 0x5280, 0x5280, 0x7380, 0x6180, 0x6180, 0x0000, 0x0000, 0x0000, // W\n0x0000, 0xC0C0, 0x6080, 0x6180, 0x3300, 0x3B00, 0x1E00, 0x0C00, 0x0C00,\n0x1E00, 0x1F00, 0x3B00, 0x7180, 0x6180, 0xC0C0, 0x0000, 0x0000, 0x0000, // X\n0x0000, 0xC0C0, 0x6180, 0x6180, 0x3300, 0x3300, 0x1E00, 0x1E00, 0x0C00,\n0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0000, 0x0000, 0x0000, // Y\n0x0000, 0x3F80, 0x3F80, 0x0180, 0x0300, 0x0300, 0x0600, 0x0C00, 0x0C00,\n0x1800, 0x1800, 0x3000, 0x6000, 0x7F80, 0x7F80, 0x0000, 0x0000, 0x0000, // Z\n0x0F00, 0x0F00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00,\n0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0F00, 0x0F00, // [\n0x0000, 0x1800, 0x1800, 0x1800, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0600,\n0x0600, 0x0600, 0x0600, 0x0300, 0x0300, 0x0300, 0x0000, 0x0000,\n0x0000, /* \\ */\n0x1E00, 0x1E00, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600,\n0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x1E00, 0x1E00, // ]\n0x0000, 0x0C00, 0x0C00, 0x1E00, 0x1200, 0x3300, 0x3300, 0x6180, 0x6180,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // ^\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFE0, 0x0000, // _\n0x0000, 0x3800, 0x1800, 0x0C00, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // `\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1F00, 0x3F80, 0x6180, 0x0180,\n0x1F80, 0x3F80, 0x6180, 0x6380, 0x7F80, 0x38C0, 0x0000, 0x0000, 0x0000, // a\n0x0000, 0x6000, 0x6000, 0x6000, 0x6000, 0x6E00, 0x7F00, 0x7380, 0x6180,\n0x6180, 0x6180, 0x6180, 0x7380, 0x7F00, 0x6E00, 0x0000, 0x0000, 0x0000, // b\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1E00, 0x3F00, 0x7380, 0x6180,\n0x6000, 0x6000, 0x6180, 0x7380, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // c\n0x0000, 0x0180, 0x0180, 0x0180, 0x0180, 0x1D80, 0x3F80, 0x7380, 0x6180,\n0x6180, 0x6180, 0x6180, 0x7380, 0x3F80, 0x1D80, 0x0000, 0x0000, 0x0000, // d\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1E00, 0x3F00, 0x7300, 0x6180,\n0x7F80, 0x7F80, 0x6000, 0x7180, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // e\n0x0000, 0x07C0, 0x0FC0, 0x0C00, 0x0C00, 0x7F80, 0x7F80, 0x0C00, 0x0C00,\n0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0000, 0x0000, 0x0000, // f\n0x0000, 0x0000, 0x0000, 0x0000, 0x1D80, 0x3F80, 0x7380, 0x6180, 0x6180,\n0x6180, 0x6180, 0x7380, 0x3F80, 0x1D80, 0x0180, 0x6380, 0x7F00, 0x3E00, // g\n0x0000, 0x6000, 0x6000, 0x6000, 0x6000, 0x6F00, 0x7F80, 0x7180, 0x6180,\n0x6180, 0x6180, 0x6180, 0x6180, 0x6180, 0x6180, 0x0000, 0x0000, 0x0000, // h\n0x0000, 0x0600, 0x0600, 0x0000, 0x0000, 0x3E00, 0x3E00, 0x0600, 0x0600,\n0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0000, 0x0000, 0x0000, // i\n0x0600, 0x0600, 0x0000, 0x0000, 0x3E00, 0x3E00, 0x0600, 0x0600, 0x0600,\n0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x4600, 0x7E00, 0x3C00, // j\n0x0000, 0x6000, 0x6000, 0x6000, 0x6000, 0x6180, 0x6300, 0x6600, 0x6C00,\n0x7C00, 0x7600, 0x6300, 0x6300, 0x6180, 0x60C0, 0x0000, 0x0000, 0x0000, // k\n0x0000, 0x3E00, 0x3E00, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600,\n0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0000, 0x0000, 0x0000, // l\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xDD80, 0xFFC0, 0xCEC0, 0xCCC0,\n0xCCC0, 0xCCC0, 0xCCC0, 0xCCC0, 0xCCC0, 0xCCC0, 0x0000, 0x0000, 0x0000, // m\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x6F00, 0x7F80, 0x7180, 0x6180,\n0x6180, 0x6180, 0x6180, 0x6180, 0x6180, 0x6180, 0x0000, 0x0000, 0x0000, // n\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1E00, 0x3F00, 0x7380, 0x6180,\n0x6180, 0x6180, 0x6180, 0x7380, 0x3F00, 0x1E00, 0x0000, 0x0000, 0x0000, // o\n0x0000, 0x0000, 0x0000, 0x0000, 0x6E00, 0x7F00, 0x7380, 0x6180, 0x6180,\n0x6180, 0x6180, 0x7380, 0x7F00, 0x6E00, 0x6000, 0x6000, 0x6000, 0x6000, // p\n0x0000, 0x0000, 0x0000, 0x0000, 0x1D80, 0x3F80, 0x7380, 0x6180, 0x6180,\n0x6180, 0x6180, 0x7380, 0x3F80, 0x1D80, 0x0180, 0x0180, 0x0180, 0x0180, // q\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x6700, 0x3F80, 0x3900, 0x3000,\n0x3000, 0x3000, 0x3000, 0x3000, 0x3000, 0x3000, 0x0000, 0x0000, 0x0000, // r\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1E00, 0x3F80, 0x6180, 0x6000,\n0x7F00, 0x3F80, 0x0180, 0x6180, 0x7F00, 0x1E00, 0x0000, 0x0000, 0x0000, // s\n0x0000, 0x0000, 0x0800, 0x1800, 0x1800, 0x7F00, 0x7F00, 0x1800, 0x1800,\n0x1800, 0x1800, 0x1800, 0x1800, 0x1F80, 0x0F80, 0x0000, 0x0000, 0x0000, // t\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x6180, 0x6180, 0x6180, 0x6180,\n0x6180, 0x6180, 0x6180, 0x6380, 0x7F80, 0x3D80, 0x0000, 0x0000, 0x0000, // u\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x60C0, 0x3180, 0x3180, 0x3180,\n0x1B00, 0x1B00, 0x1B00, 0x0E00, 0x0E00, 0x0600, 0x0000, 0x0000, 0x0000, // v\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xDD80, 0xDD80, 0xDD80, 0x5500,\n0x5500, 0x5500, 0x7700, 0x7700, 0x2200, 0x2200, 0x0000, 0x0000, 0x0000, // w\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x6180, 0x3300, 0x3300, 0x1E00,\n0x0C00, 0x0C00, 0x1E00, 0x3300, 0x3300, 0x6180, 0x0000, 0x0000, 0x0000, // x\n0x0000, 0x0000, 0x0000, 0x0000, 0x6180, 0x6180, 0x3180, 0x3300, 0x3300,\n0x1B00, 0x1B00, 0x1B00, 0x0E00, 0x0E00, 0x0E00, 0x1C00, 0x7C00, 0x7000, // y\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x7FC0, 0x7FC0, 0x0180, 0x0300,\n0x0600, 0x0C00, 0x1800, 0x3000, 0x7FC0, 0x7FC0, 0x0000, 0x0000, 0x0000, // z\n0x0380, 0x0780, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0E00, 0x1C00,\n0x1C00, 0x0E00, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0780, 0x0380, // {\n0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600,\n0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, 0x0600, // |\n0x3800, 0x3C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0E00, 0x0700,\n0x0700, 0x0E00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x0C00, 0x3C00, 0x3800, // }\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3880, 0x7F80,\n0x4700, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // ~\n};\n\nstatic const uint16_t Font16x26[] = {\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [ ]\n0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03C0,\n0x03C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x0000, 0x0000, 0x0000,\n0x03E0, 0x03E0, 0x03E0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [!]\n0x1E3C, 0x1E3C, 0x1E3C, 0x1E3C, 0x1E3C, 0x1E3C, 0x1E3C, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [\"]\n0x01CE, 0x03CE, 0x03DE, 0x039E, 0x039C, 0x079C, 0x3FFF, 0x7FFF, 0x0738,\n0x0F38, 0x0F78, 0x0F78, 0x0E78, 0xFFFF, 0xFFFF, 0x1EF0, 0x1CF0, 0x1CE0,\n0x3CE0, 0x3DE0, 0x39E0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [#]\n0x03FC, 0x0FFE, 0x1FEE, 0x1EE0, 0x1EE0, 0x1EE0, 0x1EE0, 0x1FE0, 0x0FE0,\n0x07E0, 0x03F0, 0x01FC, 0x01FE, 0x01FE, 0x01FE, 0x01FE, 0x01FE, 0x01FE,\n0x3DFE, 0x3FFC, 0x0FF0, 0x01E0, 0x01E0, 0x0000, 0x0000,\n0x0000, // Ascii = [$]\n0x3E03, 0xF707, 0xE78F, 0xE78E, 0xE39E, 0xE3BC, 0xE7B8, 0xE7F8, 0xF7F0,\n0x3FE0, 0x01C0, 0x03FF, 0x07FF, 0x07F3, 0x0FF3, 0x1EF3, 0x3CF3, 0x38F3,\n0x78F3, 0xF07F, 0xE03F, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [%]\n0x07E0, 0x0FF8, 0x0F78, 0x1F78, 0x1F78, 0x1F78, 0x0F78, 0x0FF0, 0x0FE0,\n0x1F80, 0x7FC3, 0xFBC3, 0xF3E7, 0xF1F7, 0xF0F7, 0xF0FF, 0xF07F, 0xF83E,\n0x7C7F, 0x3FFF, 0x1FEF, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [&amp;]\n0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03C0, 0x01C0, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [']\n0x003F, 0x007C, 0x01F0, 0x01E0, 0x03C0, 0x07C0, 0x0780, 0x0780, 0x0F80,\n0x0F00, 0x0F00, 0x0F00, 0x0F00, 0x0F00, 0x0F00, 0x0F80, 0x0780, 0x0780,\n0x07C0, 0x03C0, 0x01E0, 0x01F0, 0x007C, 0x003F, 0x000F,\n0x0000, // Ascii = [(]\n0x7E00, 0x1F00, 0x07C0, 0x03C0, 0x01E0, 0x01F0, 0x00F0, 0x00F0, 0x00F8,\n0x0078, 0x0078, 0x0078, 0x0078, 0x0078, 0x0078, 0x00F8, 0x00F0, 0x00F0,\n0x01F0, 0x01E0, 0x03C0, 0x07C0, 0x1F00, 0x7E00, 0x7800,\n0x0000, // Ascii = [)]\n0x03E0, 0x03C0, 0x01C0, 0x39CE, 0x3FFF, 0x3F7F, 0x0320, 0x0370, 0x07F8,\n0x0F78, 0x1F3C, 0x0638, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [*]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x01C0, 0x01C0, 0x01C0,\n0x01C0, 0x01C0, 0x01C0, 0x01C0, 0xFFFF, 0xFFFF, 0x01C0, 0x01C0, 0x01C0,\n0x01C0, 0x01C0, 0x01C0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [+]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x03E0,\n0x03E0, 0x03E0, 0x03E0, 0x01E0, 0x01E0, 0x01E0, 0x01C0,\n0x0380, // Ascii = [,]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x3FFE, 0x3FFE, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [-]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x03E0,\n0x03E0, 0x03E0, 0x03E0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [.]\n0x000F, 0x000F, 0x001E, 0x001E, 0x003C, 0x003C, 0x0078, 0x0078, 0x00F0,\n0x00F0, 0x01E0, 0x01E0, 0x03C0, 0x03C0, 0x0780, 0x0780, 0x0F00, 0x0F00,\n0x1E00, 0x1E00, 0x3C00, 0x3C00, 0x7800, 0x7800, 0xF000,\n0x0000, // Ascii = [/]\n0x07F0, 0x0FF8, 0x1F7C, 0x3E3E, 0x3C1E, 0x7C1F, 0x7C1F, 0x780F, 0x780F,\n0x780F, 0x780F, 0x780F, 0x780F, 0x780F, 0x7C1F, 0x7C1F, 0x3C1E, 0x3E3E,\n0x1F7C, 0x0FF8, 0x07F0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [0]\n0x00F0, 0x07F0, 0x3FF0, 0x3FF0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0,\n0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0,\n0x01F0, 0x3FFF, 0x3FFF, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [1]\n0x0FE0, 0x3FF8, 0x3C7C, 0x003C, 0x003E, 0x003E, 0x003E, 0x003C, 0x003C,\n0x007C, 0x00F8, 0x01F0, 0x03E0, 0x07C0, 0x0780, 0x0F00, 0x1E00, 0x3E00,\n0x3C00, 0x3FFE, 0x3FFE, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [2]\n0x0FF0, 0x1FF8, 0x1C7C, 0x003E, 0x003E, 0x003E, 0x003C, 0x003C, 0x00F8,\n0x0FF0, 0x0FF8, 0x007C, 0x003E, 0x001E, 0x001E, 0x001E, 0x001E, 0x003E,\n0x1C7C, 0x1FF8, 0x1FE0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [3]\n0x0078, 0x00F8, 0x00F8, 0x01F8, 0x03F8, 0x07F8, 0x07F8, 0x0F78, 0x1E78,\n0x1E78, 0x3C78, 0x7878, 0x7878, 0xFFFF, 0xFFFF, 0x0078, 0x0078, 0x0078,\n0x0078, 0x0078, 0x0078, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [4]\n0x1FFC, 0x1FFC, 0x1FFC, 0x1E00, 0x1E00, 0x1E00, 0x1E00, 0x1E00, 0x1FE0,\n0x1FF8, 0x00FC, 0x007C, 0x003E, 0x003E, 0x001E, 0x003E, 0x003E, 0x003C,\n0x1C7C, 0x1FF8, 0x1FE0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [5]\n0x01FC, 0x07FE, 0x0F8E, 0x1F00, 0x1E00, 0x3E00, 0x3C00, 0x3C00, 0x3DF8,\n0x3FFC, 0x7F3E, 0x7E1F, 0x3C0F, 0x3C0F, 0x3C0F, 0x3C0F, 0x3E0F, 0x1E1F,\n0x1F3E, 0x0FFC, 0x03F0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [6]\n0x3FFF, 0x3FFF, 0x3FFF, 0x000F, 0x001E, 0x001E, 0x003C, 0x0038, 0x0078,\n0x00F0, 0x00F0, 0x01E0, 0x01E0, 0x03C0, 0x03C0, 0x0780, 0x0F80, 0x0F80,\n0x0F00, 0x1F00, 0x1F00, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [7]\n0x07F8, 0x0FFC, 0x1F3E, 0x1E1E, 0x3E1E, 0x3E1E, 0x1E1E, 0x1F3C, 0x0FF8,\n0x07F0, 0x0FF8, 0x1EFC, 0x3E3E, 0x3C1F, 0x7C1F, 0x7C0F, 0x7C0F, 0x3C1F,\n0x3F3E, 0x1FFC, 0x07F0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [8]\n0x07F0, 0x0FF8, 0x1E7C, 0x3C3E, 0x3C1E, 0x7C1F, 0x7C1F, 0x7C1F, 0x7C1F,\n0x3C1F, 0x3E3F, 0x1FFF, 0x07EF, 0x001F, 0x001E, 0x001E, 0x003E, 0x003C,\n0x38F8, 0x3FF0, 0x1FE0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [9]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x03E0, 0x03E0, 0x03E0,\n0x03E0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x03E0,\n0x03E0, 0x03E0, 0x03E0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [:]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x03E0, 0x03E0, 0x03E0,\n0x03E0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x03E0,\n0x03E0, 0x03E0, 0x03E0, 0x01E0, 0x01E0, 0x01E0, 0x03C0,\n0x0380, // Ascii = [;]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0003, 0x000F, 0x003F,\n0x00FC, 0x03F0, 0x0FC0, 0x3F00, 0xFE00, 0x3F00, 0x0FC0, 0x03F0, 0x00FC,\n0x003F, 0x000F, 0x0003, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [&lt;]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0xFFFF, 0xFFFF, 0x0000, 0x0000, 0x0000, 0xFFFF, 0xFFFF, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [=]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xE000, 0xF800, 0x7E00,\n0x1F80, 0x07E0, 0x01F8, 0x007E, 0x001F, 0x007E, 0x01F8, 0x07E0, 0x1F80,\n0x7E00, 0xF800, 0xE000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [&gt;]\n0x1FF0, 0x3FFC, 0x383E, 0x381F, 0x381F, 0x001E, 0x001E, 0x003C, 0x0078,\n0x00F0, 0x01E0, 0x03C0, 0x03C0, 0x07C0, 0x07C0, 0x0000, 0x0000, 0x0000,\n0x07C0, 0x07C0, 0x07C0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [?]\n0x03F8, 0x0FFE, 0x1F1E, 0x3E0F, 0x3C7F, 0x78FF, 0x79EF, 0x73C7, 0xF3C7,\n0xF38F, 0xF38F, 0xF38F, 0xF39F, 0xF39F, 0x73FF, 0x7BFF, 0x79F7, 0x3C00,\n0x1F1C, 0x0FFC, 0x03F8, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [@]\n0x0000, 0x0000, 0x0000, 0x03E0, 0x03E0, 0x07F0, 0x07F0, 0x07F0, 0x0F78,\n0x0F78, 0x0E7C, 0x1E3C, 0x1E3C, 0x3C3E, 0x3FFE, 0x3FFF, 0x781F, 0x780F,\n0xF00F, 0xF007, 0xF007, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [A]\n0x0000, 0x0000, 0x0000, 0x3FF8, 0x3FFC, 0x3C3E, 0x3C1E, 0x3C1E, 0x3C1E,\n0x3C3E, 0x3C7C, 0x3FF0, 0x3FF8, 0x3C7E, 0x3C1F, 0x3C1F, 0x3C0F, 0x3C0F,\n0x3C1F, 0x3FFE, 0x3FF8, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [B]\n0x0000, 0x0000, 0x0000, 0x01FF, 0x07FF, 0x1F87, 0x3E00, 0x3C00, 0x7C00,\n0x7800, 0x7800, 0x7800, 0x7800, 0x7800, 0x7C00, 0x7C00, 0x3E00, 0x3F00,\n0x1F83, 0x07FF, 0x01FF, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [C]\n0x0000, 0x0000, 0x0000, 0x7FF0, 0x7FFC, 0x787E, 0x781F, 0x781F, 0x780F,\n0x780F, 0x780F, 0x780F, 0x780F, 0x780F, 0x780F, 0x780F, 0x781F, 0x781E,\n0x787E, 0x7FF8, 0x7FE0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [D]\n0x0000, 0x0000, 0x0000, 0x3FFF, 0x3FFF, 0x3E00, 0x3E00, 0x3E00, 0x3E00,\n0x3E00, 0x3E00, 0x3FFE, 0x3FFE, 0x3E00, 0x3E00, 0x3E00, 0x3E00, 0x3E00,\n0x3E00, 0x3FFF, 0x3FFF, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [E]\n0x0000, 0x0000, 0x0000, 0x1FFF, 0x1FFF, 0x1E00, 0x1E00, 0x1E00, 0x1E00,\n0x1E00, 0x1E00, 0x1FFF, 0x1FFF, 0x1E00, 0x1E00, 0x1E00, 0x1E00, 0x1E00,\n0x1E00, 0x1E00, 0x1E00, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [F]\n0x0000, 0x0000, 0x0000, 0x03FE, 0x0FFF, 0x1F87, 0x3E00, 0x7C00, 0x7C00,\n0x7800, 0xF800, 0xF800, 0xF87F, 0xF87F, 0x780F, 0x7C0F, 0x7C0F, 0x3E0F,\n0x1F8F, 0x0FFF, 0x03FE, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [G]\n0x0000, 0x0000, 0x0000, 0x7C1F, 0x7C1F, 0x7C1F, 0x7C1F, 0x7C1F, 0x7C1F,\n0x7C1F, 0x7C1F, 0x7FFF, 0x7FFF, 0x7C1F, 0x7C1F, 0x7C1F, 0x7C1F, 0x7C1F,\n0x7C1F, 0x7C1F, 0x7C1F, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [H]\n0x0000, 0x0000, 0x0000, 0x3FFF, 0x3FFF, 0x03E0, 0x03E0, 0x03E0, 0x03E0,\n0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0,\n0x03E0, 0x3FFF, 0x3FFF, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [I]\n0x0000, 0x0000, 0x0000, 0x1FFC, 0x1FFC, 0x007C, 0x007C, 0x007C, 0x007C,\n0x007C, 0x007C, 0x007C, 0x007C, 0x007C, 0x007C, 0x007C, 0x0078, 0x0078,\n0x38F8, 0x3FF0, 0x3FC0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [J]\n0x0000, 0x0000, 0x0000, 0x3C1F, 0x3C1E, 0x3C3C, 0x3C78, 0x3CF0, 0x3DE0,\n0x3FE0, 0x3FC0, 0x3F80, 0x3FC0, 0x3FE0, 0x3DF0, 0x3CF0, 0x3C78, 0x3C7C,\n0x3C3E, 0x3C1F, 0x3C0F, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [K]\n0x0000, 0x0000, 0x0000, 0x3E00, 0x3E00, 0x3E00, 0x3E00, 0x3E00, 0x3E00,\n0x3E00, 0x3E00, 0x3E00, 0x3E00, 0x3E00, 0x3E00, 0x3E00, 0x3E00, 0x3E00,\n0x3E00, 0x3FFF, 0x3FFF, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [L]\n0x0000, 0x0000, 0x0000, 0xF81F, 0xFC1F, 0xFC1F, 0xFE3F, 0xFE3F, 0xFE3F,\n0xFF7F, 0xFF77, 0xFF77, 0xF7F7, 0xF7E7, 0xF3E7, 0xF3E7, 0xF3C7, 0xF007,\n0xF007, 0xF007, 0xF007, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [M]\n0x0000, 0x0000, 0x0000, 0x7C0F, 0x7C0F, 0x7E0F, 0x7F0F, 0x7F0F, 0x7F8F,\n0x7F8F, 0x7FCF, 0x7BEF, 0x79EF, 0x79FF, 0x78FF, 0x78FF, 0x787F, 0x783F,\n0x783F, 0x781F, 0x781F, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [N]\n0x0000, 0x0000, 0x0000, 0x07F0, 0x1FFC, 0x3E3E, 0x7C1F, 0x780F, 0x780F,\n0xF80F, 0xF80F, 0xF80F, 0xF80F, 0xF80F, 0xF80F, 0x780F, 0x780F, 0x7C1F,\n0x3E3E, 0x1FFC, 0x07F0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [O]\n0x0000, 0x0000, 0x0000, 0x3FFC, 0x3FFF, 0x3E1F, 0x3E0F, 0x3E0F, 0x3E0F,\n0x3E0F, 0x3E1F, 0x3E3F, 0x3FFC, 0x3FF0, 0x3E00, 0x3E00, 0x3E00, 0x3E00,\n0x3E00, 0x3E00, 0x3E00, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [P]\n0x0000, 0x0000, 0x0000, 0x07F0, 0x1FFC, 0x3E3E, 0x7C1F, 0x780F, 0x780F,\n0xF80F, 0xF80F, 0xF80F, 0xF80F, 0xF80F, 0xF80F, 0x780F, 0x780F, 0x7C1F,\n0x3E3E, 0x1FFC, 0x07F8, 0x007C, 0x003F, 0x000F, 0x0003,\n0x0000, // Ascii = [Q]\n0x0000, 0x0000, 0x0000, 0x3FF0, 0x3FFC, 0x3C7E, 0x3C3E, 0x3C1E, 0x3C1E,\n0x3C3E, 0x3C3C, 0x3CFC, 0x3FF0, 0x3FE0, 0x3DF0, 0x3CF8, 0x3C7C, 0x3C3E,\n0x3C1E, 0x3C1F, 0x3C0F, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [R]\n0x0000, 0x0000, 0x0000, 0x07FC, 0x1FFE, 0x3E0E, 0x3C00, 0x3C00, 0x3C00,\n0x3E00, 0x1FC0, 0x0FF8, 0x03FE, 0x007F, 0x001F, 0x000F, 0x000F, 0x201F,\n0x3C3E, 0x3FFC, 0x1FF0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [S]\n0x0000, 0x0000, 0x0000, 0xFFFF, 0xFFFF, 0x03E0, 0x03E0, 0x03E0, 0x03E0,\n0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0,\n0x03E0, 0x03E0, 0x03E0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [T]\n0x0000, 0x0000, 0x0000, 0x7C0F, 0x7C0F, 0x7C0F, 0x7C0F, 0x7C0F, 0x7C0F,\n0x7C0F, 0x7C0F, 0x7C0F, 0x7C0F, 0x7C0F, 0x7C0F, 0x7C0F, 0x3C1E, 0x3C1E,\n0x3E3E, 0x1FFC, 0x07F0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [U]\n0x0000, 0x0000, 0x0000, 0xF007, 0xF007, 0xF807, 0x780F, 0x7C0F, 0x3C1E,\n0x3C1E, 0x3E1E, 0x1E3C, 0x1F3C, 0x1F78, 0x0F78, 0x0FF8, 0x07F0, 0x07F0,\n0x07F0, 0x03E0, 0x03E0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [V]\n0x0000, 0x0000, 0x0000, 0xE003, 0xF003, 0xF003, 0xF007, 0xF3E7, 0xF3E7,\n0xF3E7, 0x73E7, 0x7BF7, 0x7FF7, 0x7FFF, 0x7F7F, 0x7F7F, 0x7F7E, 0x3F7E,\n0x3E3E, 0x3E3E, 0x3E3E, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [W]\n0x0000, 0x0000, 0x0000, 0xF807, 0x7C0F, 0x3E1E, 0x3E3E, 0x1F3C, 0x0FF8,\n0x07F0, 0x07E0, 0x03E0, 0x03E0, 0x07F0, 0x0FF8, 0x0F7C, 0x1E7C, 0x3C3E,\n0x781F, 0x780F, 0xF00F, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [X]\n0x0000, 0x0000, 0x0000, 0xF807, 0x7807, 0x7C0F, 0x3C1E, 0x3E1E, 0x1F3C,\n0x0F78, 0x0FF8, 0x07F0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0, 0x03E0,\n0x03E0, 0x03E0, 0x03E0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [Y]\n0x0000, 0x0000, 0x0000, 0x7FFF, 0x7FFF, 0x000F, 0x001F, 0x003E, 0x007C,\n0x00F8, 0x00F0, 0x01E0, 0x03E0, 0x07C0, 0x0F80, 0x0F00, 0x1E00, 0x3E00,\n0x7C00, 0x7FFF, 0x7FFF, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [Z]\n0x07FF, 0x0780, 0x0780, 0x0780, 0x0780, 0x0780, 0x0780, 0x0780, 0x0780,\n0x0780, 0x0780, 0x0780, 0x0780, 0x0780, 0x0780, 0x0780, 0x0780, 0x0780,\n0x0780, 0x0780, 0x0780, 0x0780, 0x0780, 0x07FF, 0x07FF,\n0x0000, // Ascii = [[]\n0x7800, 0x7800, 0x3C00, 0x3C00, 0x1E00, 0x1E00, 0x0F00, 0x0F00, 0x0780,\n0x0780, 0x03C0, 0x03C0, 0x01E0, 0x01E0, 0x00F0, 0x00F0, 0x0078, 0x0078,\n0x003C, 0x003C, 0x001E, 0x001E, 0x000F, 0x000F, 0x0007,\n0x0000, // Ascii = [\\]\n0x7FF0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0,\n0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0,\n0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x7FF0, 0x7FF0,\n0x0000, // Ascii = []]\n0x00C0, 0x01C0, 0x01C0, 0x03E0, 0x03E0, 0x07F0, 0x07F0, 0x0778, 0x0F78,\n0x0F38, 0x1E3C, 0x1E3C, 0x3C1E, 0x3C1E, 0x380F, 0x780F, 0x7807, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [^]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0xFFFF, 0xFFFF, 0x0000, 0x0000,\n0x0000, // Ascii = [_]\n0x00F0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [`]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0FF8, 0x3FFC, 0x3C7C,\n0x003E, 0x003E, 0x003E, 0x07FE, 0x1FFE, 0x3E3E, 0x7C3E, 0x783E, 0x7C3E,\n0x7C7E, 0x3FFF, 0x1FCF, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [a]\n0x3C00, 0x3C00, 0x3C00, 0x3C00, 0x3C00, 0x3C00, 0x3DF8, 0x3FFE, 0x3F3E,\n0x3E1F, 0x3C0F, 0x3C0F, 0x3C0F, 0x3C0F, 0x3C0F, 0x3C0F, 0x3C1F, 0x3C1E,\n0x3F3E, 0x3FFC, 0x3BF0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [b]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x03FE, 0x0FFF, 0x1F87,\n0x3E00, 0x3E00, 0x3C00, 0x7C00, 0x7C00, 0x7C00, 0x3C00, 0x3E00, 0x3E00,\n0x1F87, 0x0FFF, 0x03FE, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [c]\n0x001F, 0x001F, 0x001F, 0x001F, 0x001F, 0x001F, 0x07FF, 0x1FFF, 0x3E3F,\n0x3C1F, 0x7C1F, 0x7C1F, 0x7C1F, 0x781F, 0x781F, 0x7C1F, 0x7C1F, 0x3C3F,\n0x3E7F, 0x1FFF, 0x0FDF, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [d]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x03F8, 0x0FFC, 0x1F3E,\n0x3E1E, 0x3C1F, 0x7C1F, 0x7FFF, 0x7FFF, 0x7C00, 0x7C00, 0x3C00, 0x3E00,\n0x1F07, 0x0FFF, 0x03FE, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [e]\n0x01FF, 0x03E1, 0x03C0, 0x07C0, 0x07C0, 0x07C0, 0x7FFF, 0x7FFF, 0x07C0,\n0x07C0, 0x07C0, 0x07C0, 0x07C0, 0x07C0, 0x07C0, 0x07C0, 0x07C0, 0x07C0,\n0x07C0, 0x07C0, 0x07C0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [f]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x07EF, 0x1FFF, 0x3E7F,\n0x3C1F, 0x7C1F, 0x7C1F, 0x781F, 0x781F, 0x781F, 0x7C1F, 0x7C1F, 0x3C3F,\n0x3E7F, 0x1FFF, 0x0FDF, 0x001E, 0x001E, 0x001E, 0x387C,\n0x3FF8, // Ascii = [g]\n0x3C00, 0x3C00, 0x3C00, 0x3C00, 0x3C00, 0x3C00, 0x3DFC, 0x3FFE, 0x3F9E,\n0x3F1F, 0x3E1F, 0x3C1F, 0x3C1F, 0x3C1F, 0x3C1F, 0x3C1F, 0x3C1F, 0x3C1F,\n0x3C1F, 0x3C1F, 0x3C1F, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [h]\n0x01F0, 0x01F0, 0x0000, 0x0000, 0x0000, 0x0000, 0x7FE0, 0x7FE0, 0x01E0,\n0x01E0, 0x01E0, 0x01E0, 0x01E0, 0x01E0, 0x01E0, 0x01E0, 0x01E0, 0x01E0,\n0x01E0, 0x01E0, 0x01E0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [i]\n0x00F8, 0x00F8, 0x0000, 0x0000, 0x0000, 0x0000, 0x3FF8, 0x3FF8, 0x00F8,\n0x00F8, 0x00F8, 0x00F8, 0x00F8, 0x00F8, 0x00F8, 0x00F8, 0x00F8, 0x00F8,\n0x00F8, 0x00F8, 0x00F8, 0x00F8, 0x00F8, 0x00F0, 0x71F0,\n0x7FE0, // Ascii = [j]\n0x3C00, 0x3C00, 0x3C00, 0x3C00, 0x3C00, 0x3C00, 0x3C1F, 0x3C3E, 0x3C7C,\n0x3CF8, 0x3DF0, 0x3DE0, 0x3FC0, 0x3FC0, 0x3FE0, 0x3DF0, 0x3CF8, 0x3C7C,\n0x3C3E, 0x3C1F, 0x3C1F, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [k]\n0x7FF0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0,\n0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0, 0x01F0,\n0x01F0, 0x01F0, 0x01F0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [l]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xF79E, 0xFFFF, 0xFFFF,\n0xFFFF, 0xFBE7, 0xF9E7, 0xF1C7, 0xF1C7, 0xF1C7, 0xF1C7, 0xF1C7, 0xF1C7,\n0xF1C7, 0xF1C7, 0xF1C7, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [m]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3DFC, 0x3FFE, 0x3F9E,\n0x3F1F, 0x3E1F, 0x3C1F, 0x3C1F, 0x3C1F, 0x3C1F, 0x3C1F, 0x3C1F, 0x3C1F,\n0x3C1F, 0x3C1F, 0x3C1F, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [n]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x07F0, 0x1FFC, 0x3E3E,\n0x3C1F, 0x7C1F, 0x780F, 0x780F, 0x780F, 0x780F, 0x780F, 0x7C1F, 0x3C1F,\n0x3E3E, 0x1FFC, 0x07F0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [o]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3DF8, 0x3FFE, 0x3F3E,\n0x3E1F, 0x3C0F, 0x3C0F, 0x3C0F, 0x3C0F, 0x3C0F, 0x3C0F, 0x3C1F, 0x3E1E,\n0x3F3E, 0x3FFC, 0x3FF8, 0x3C00, 0x3C00, 0x3C00, 0x3C00,\n0x3C00, // Ascii = [p]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x07EE, 0x1FFE, 0x3E7E,\n0x3C1E, 0x7C1E, 0x781E, 0x781E, 0x781E, 0x781E, 0x781E, 0x7C1E, 0x7C3E,\n0x3E7E, 0x1FFE, 0x0FDE, 0x001E, 0x001E, 0x001E, 0x001E,\n0x001E, // Ascii = [q]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1F7F, 0x1FFF, 0x1FE7,\n0x1FC7, 0x1F87, 0x1F00, 0x1F00, 0x1F00, 0x1F00, 0x1F00, 0x1F00, 0x1F00,\n0x1F00, 0x1F00, 0x1F00, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [r]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x07FC, 0x1FFE, 0x1E0E,\n0x3E00, 0x3E00, 0x3F00, 0x1FE0, 0x07FC, 0x00FE, 0x003E, 0x001E, 0x001E,\n0x3C3E, 0x3FFC, 0x1FF0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [s]\n0x0000, 0x0000, 0x0000, 0x0780, 0x0780, 0x0780, 0x7FFF, 0x7FFF, 0x0780,\n0x0780, 0x0780, 0x0780, 0x0780, 0x0780, 0x0780, 0x0780, 0x0780, 0x0780,\n0x07C0, 0x03FF, 0x01FF, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [t]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3C1E, 0x3C1E, 0x3C1E,\n0x3C1E, 0x3C1E, 0x3C1E, 0x3C1E, 0x3C1E, 0x3C1E, 0x3C1E, 0x3C3E, 0x3C7E,\n0x3EFE, 0x1FFE, 0x0FDE, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [u]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xF007, 0x780F, 0x780F,\n0x3C1E, 0x3C1E, 0x3E1E, 0x1E3C, 0x1E3C, 0x0F78, 0x0F78, 0x0FF0, 0x07F0,\n0x07F0, 0x03E0, 0x03E0, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [v]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xF003, 0xF1E3, 0xF3E3,\n0xF3E7, 0xF3F7, 0xF3F7, 0x7FF7, 0x7F77, 0x7F7F, 0x7F7F, 0x7F7F, 0x3E3E,\n0x3E3E, 0x3E3E, 0x3E3E, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [w]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x7C0F, 0x3E1E, 0x3E3C,\n0x1F3C, 0x0FF8, 0x07F0, 0x07F0, 0x03E0, 0x07F0, 0x07F8, 0x0FF8, 0x1E7C,\n0x3E3E, 0x3C1F, 0x781F, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [x]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xF807, 0x780F, 0x7C0F,\n0x3C1E, 0x3C1E, 0x1E3C, 0x1E3C, 0x1F3C, 0x0F78, 0x0FF8, 0x07F0, 0x07F0,\n0x03E0, 0x03E0, 0x03C0, 0x03C0, 0x03C0, 0x0780, 0x0F80,\n0x7F00, // Ascii = [y]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3FFF, 0x3FFF, 0x001F,\n0x003E, 0x007C, 0x00F8, 0x01F0, 0x03E0, 0x07C0, 0x0F80, 0x1F00, 0x1E00,\n0x3C00, 0x7FFF, 0x7FFF, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [z]\n0x01FE, 0x03E0, 0x03C0, 0x03C0, 0x03C0, 0x03C0, 0x01E0, 0x01E0, 0x01E0,\n0x01C0, 0x03C0, 0x3F80, 0x3F80, 0x03C0, 0x01C0, 0x01E0, 0x01E0, 0x01E0,\n0x03C0, 0x03C0, 0x03C0, 0x03C0, 0x03E0, 0x01FE, 0x007E,\n0x0000, // Ascii = [{]\n0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0,\n0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0,\n0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0, 0x01C0,\n0x0000, // Ascii = [|]\n0x3FC0, 0x03E0, 0x01E0, 0x01E0, 0x01E0, 0x01E0, 0x01C0, 0x03C0, 0x03C0,\n0x01C0, 0x01E0, 0x00FE, 0x00FE, 0x01E0, 0x01C0, 0x03C0, 0x03C0, 0x01C0,\n0x01E0, 0x01E0, 0x01E0, 0x01E0, 0x03E0, 0x3FC0, 0x3F00,\n0x0000, // Ascii = [}]\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, 0x0000, 0x3F07, 0x7FC7, 0x73E7, 0xF1FF, 0xF07E, 0x0000, 0x0000,\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n0x0000, // Ascii = [~]\n};\n\nstatic const uint16_t Font6x8[] = {\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // sp\n0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x0000, 0x2000, 0x0000, // !\n0x5000, 0x5000, 0x5000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // \"\n0x5000, 0x5000, 0xf800, 0x5000, 0xf800, 0x5000, 0x5000, 0x0000, // #\n0x2000, 0x7800, 0xa000, 0x7000, 0x2800, 0xf000, 0x2000, 0x0000, // $\n0xc000, 0xc800, 0x1000, 0x2000, 0x4000, 0x9800, 0x1800, 0x0000, // %\n0x4000, 0xa000, 0xa000, 0x4000, 0xa800, 0x9000, 0x6800, 0x0000, // &amp;\n0x3000, 0x3000, 0x2000, 0x4000, 0x0000, 0x0000, 0x0000, 0x0000, // '\n0x1000, 0x2000, 0x4000, 0x4000, 0x4000, 0x2000, 0x1000, 0x0000, // (\n0x4000, 0x2000, 0x1000, 0x1000, 0x1000, 0x2000, 0x4000, 0x0000, // )\n0x2000, 0xa800, 0x7000, 0xf800, 0x7000, 0xa800, 0x2000, 0x0000, // *\n0x0000, 0x2000, 0x2000, 0xf800, 0x2000, 0x2000, 0x0000, 0x0000, // +\n0x0000, 0x0000, 0x0000, 0x0000, 0x3000, 0x3000, 0x2000, 0x0000, // ,\n0x0000, 0x0000, 0x0000, 0xf800, 0x0000, 0x0000, 0x0000, 0x0000, // -\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3000, 0x3000, 0x0000, // .\n0x0000, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000, 0x0000, 0x0000, // /\n0x7000, 0x8800, 0x9800, 0xa800, 0xc800, 0x8800, 0x7000, 0x0000, // 0\n0x2000, 0x6000, 0x2000, 0x2000, 0x2000, 0x2000, 0x7000, 0x0000, // 1\n0x7000, 0x8800, 0x0800, 0x7000, 0x8000, 0x8000, 0xf800, 0x0000, // 2\n0xf800, 0x0800, 0x1000, 0x3000, 0x0800, 0x8800, 0x7000, 0x0000, // 3\n0x1000, 0x3000, 0x5000, 0x9000, 0xf800, 0x1000, 0x1000, 0x0000, // 4\n0xf800, 0x8000, 0xf000, 0x0800, 0x0800, 0x8800, 0x7000, 0x0000, // 5\n0x3800, 0x4000, 0x8000, 0xf000, 0x8800, 0x8800, 0x7000, 0x0000, // 6\n0xf800, 0x0800, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000, 0x0000, // 7\n0x7000, 0x8800, 0x8800, 0x7000, 0x8800, 0x8800, 0x7000, 0x0000, // 8\n0x7000, 0x8800, 0x8800, 0x7800, 0x0800, 0x1000, 0xe000, 0x0000, // 9\n0x0000, 0x0000, 0x2000, 0x0000, 0x2000, 0x0000, 0x0000, 0x0000, // :\n0x0000, 0x0000, 0x2000, 0x0000, 0x2000, 0x2000, 0x4000, 0x0000, // ;\n0x0800, 0x1000, 0x2000, 0x4000, 0x2000, 0x1000, 0x0800, 0x0000, // &lt;\n0x0000, 0x0000, 0xf800, 0x0000, 0xf800, 0x0000, 0x0000, 0x0000, // =\n0x4000, 0x2000, 0x1000, 0x0800, 0x1000, 0x2000, 0x4000, 0x0000, // &gt;\n0x7000, 0x8800, 0x0800, 0x3000, 0x2000, 0x0000, 0x2000, 0x0000, // ?\n0x7000, 0x8800, 0xa800, 0xb800, 0xb000, 0x8000, 0x7800, 0x0000, // @\n0x2000, 0x5000, 0x8800, 0x8800, 0xf800, 0x8800, 0x8800, 0x0000, // A\n0xf000, 0x8800, 0x8800, 0xf000, 0x8800, 0x8800, 0xf000, 0x0000, // B\n0x7000, 0x8800, 0x8000, 0x8000, 0x8000, 0x8800, 0x7000, 0x0000, // C\n0xf000, 0x8800, 0x8800, 0x8800, 0x8800, 0x8800, 0xf000, 0x0000, // D\n0xf800, 0x8000, 0x8000, 0xf000, 0x8000, 0x8000, 0xf800, 0x0000, // E\n0xf800, 0x8000, 0x8000, 0xf000, 0x8000, 0x8000, 0x8000, 0x0000, // F\n0x7800, 0x8800, 0x8000, 0x8000, 0x9800, 0x8800, 0x7800, 0x0000, // G\n0x8800, 0x8800, 0x8800, 0xf800, 0x8800, 0x8800, 0x8800, 0x0000, // H\n0x7000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x7000, 0x0000, // I\n0x3800, 0x1000, 0x1000, 0x1000, 0x1000, 0x9000, 0x6000, 0x0000, // J\n0x8800, 0x9000, 0xa000, 0xc000, 0xa000, 0x9000, 0x8800, 0x0000, // K\n0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0xf800, 0x0000, // L\n0x8800, 0xd800, 0xa800, 0xa800, 0xa800, 0x8800, 0x8800, 0x0000, // M\n0x8800, 0x8800, 0xc800, 0xa800, 0x9800, 0x8800, 0x8800, 0x0000, // N\n0x7000, 0x8800, 0x8800, 0x8800, 0x8800, 0x8800, 0x7000, 0x0000, // O\n0xf000, 0x8800, 0x8800, 0xf000, 0x8000, 0x8000, 0x8000, 0x0000, // P\n0x7000, 0x8800, 0x8800, 0x8800, 0xa800, 0x9000, 0x6800, 0x0000, // Q\n0xf000, 0x8800, 0x8800, 0xf000, 0xa000, 0x9000, 0x8800, 0x0000, // R\n0x7000, 0x8800, 0x8000, 0x7000, 0x0800, 0x8800, 0x7000, 0x0000, // S\n0xf800, 0xa800, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x0000, // T\n0x8800, 0x8800, 0x8800, 0x8800, 0x8800, 0x8800, 0x7000, 0x0000, // U\n0x8800, 0x8800, 0x8800, 0x8800, 0x8800, 0x5000, 0x2000, 0x0000, // V\n0x8800, 0x8800, 0x8800, 0xa800, 0xa800, 0xa800, 0x5000, 0x0000, // W\n0x8800, 0x8800, 0x5000, 0x2000, 0x5000, 0x8800, 0x8800, 0x0000, // X\n0x8800, 0x8800, 0x5000, 0x2000, 0x2000, 0x2000, 0x2000, 0x0000, // Y\n0xf800, 0x0800, 0x1000, 0x7000, 0x4000, 0x8000, 0xf800, 0x0000, // Z\n0x7800, 0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x7800, 0x0000, // [\n0x0000, 0x8000, 0x4000, 0x2000, 0x1000, 0x0800, 0x0000, 0x0000, /* \\ */\n0x7800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x7800, 0x0000, // ]\n0x2000, 0x5000, 0x8800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // ^\n0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xf800, 0x0000, // _\n0x6000, 0x6000, 0x2000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, // `\n0x0000, 0x0000, 0x6000, 0x1000, 0x7000, 0x9000, 0x7800, 0x0000, // a\n0x8000, 0x8000, 0xb000, 0xc800, 0x8800, 0xc800, 0xb000, 0x0000, // b\n0x0000, 0x0000, 0x7000, 0x8800, 0x8000, 0x8800, 0x7000, 0x0000, // c\n0x0800, 0x0800, 0x6800, 0x9800, 0x8800, 0x9800, 0x6800, 0x0000, // d\n0x0000, 0x0000, 0x7000, 0x8800, 0xf800, 0x8000, 0x7000, 0x0000, // e\n0x1000, 0x2800, 0x2000, 0x7000, 0x2000, 0x2000, 0x2000, 0x0000, // f\n0x0000, 0x0000, 0x7000, 0x9800, 0x9800, 0x6800, 0x0800, 0x0000, // g\n0x8000, 0x8000, 0xb000, 0xc800, 0x8800, 0x8800, 0x8800, 0x0000, // h\n0x2000, 0x0000, 0x6000, 0x2000, 0x2000, 0x2000, 0x7000, 0x0000, // i\n0x1000, 0x0000, 0x1000, 0x1000, 0x1000, 0x9000, 0x6000, 0x0000, // j\n0x8000, 0x8000, 0x9000, 0xa000, 0xc000, 0xa000, 0x9000, 0x0000, // k\n0x6000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x7000, 0x0000, // l\n0x0000, 0x0000, 0xd000, 0xa800, 0xa800, 0xa800, 0xa800, 0x0000, // m\n0x0000, 0x0000, 0xb000, 0xc800, 0x8800, 0x8800, 0x8800, 0x0000, // n\n0x0000, 0x0000, 0x7000, 0x8800, 0x8800, 0x8800, 0x7000, 0x0000, // o\n0x0000, 0x0000, 0xb000, 0xc800, 0xc800, 0xb000, 0x8000, 0x0000, // p\n0x0000, 0x0000, 0x6800, 0x9800, 0x9800, 0x6800, 0x0800, 0x0000, // q\n0x0000, 0x0000, 0xb000, 0xc800, 0x8000, 0x8000, 0x8000, 0x0000, // r\n0x0000, 0x0000, 0x7800, 0x8000, 0x7000, 0x0800, 0xf000, 0x0000, // s\n0x2000, 0x2000, 0xf800, 0x2000, 0x2000, 0x2800, 0x1000, 0x0000, // t\n0x0000, 0x0000, 0x8800, 0x8800, 0x8800, 0x9800, 0x6800, 0x0000, // u\n0x0000, 0x0000, 0x8800, 0x8800, 0x8800, 0x5000, 0x2000, 0x0000, // v\n0x0000, 0x0000, 0x8800, 0x8800, 0xa800, 0xa800, 0x5000, 0x0000, // w\n0x0000, 0x0000, 0x8800, 0x5000, 0x2000, 0x5000, 0x8800, 0x0000, // x\n0x0000, 0x0000, 0x8800, 0x8800, 0x7800, 0x0800, 0x8800, 0x0000, // y\n0x0000, 0x0000, 0xf800, 0x1000, 0x2000, 0x4000, 0xf800, 0x0000, // z\n0x1000, 0x2000, 0x2000, 0x4000, 0x2000, 0x2000, 0x1000, 0x0000, // {\n0x2000, 0x2000, 0x2000, 0x0000, 0x2000, 0x2000, 0x2000, 0x0000, // |\n0x4000, 0x2000, 0x2000, 0x1000, 0x2000, 0x2000, 0x4000, 0x0000, // }\n0x4000, 0xa800, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // ~\n};\n\nFontDef Font_6x8 = { 6, 8, Font6x8 };\nFontDef Font_7x10 = { 7, 10, Font7x10 };\nFontDef Font_11x18 = { 11, 18, Font11x18 };\nFontDef Font_16x26 = { 16, 26, Font16x26 };\n</code></pre>"},{"location":"apiStm/Power_8cpp/","title":"File Power.cpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; src &gt; Power.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"stm32f1xx_ll_adc.h\"</code></li> <li><code>#include \"stm32f1xx_ll_rcc.h\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"BuzzerController.hpp\"</code></li> <li><code>#include \"Dispatcher.hpp\"</code></li> <li><code>#include \"Power.hpp\"</code></li> <li><code>#include \"utils/Debug.hpp\"</code></li> <li><code>#include \"utils/Flash.hpp\"</code></li> <li><code>#include \"utils/TaskWrapper.hpp\"</code></li> <li><code>#include \"utils/TickTimer.hpp\"</code></li> <li><code>#include \"rbcx.pb.h\"</code></li> </ul>"},{"location":"apiStm/Power_8cpp/#classes","title":"Classes","text":"Type Name struct CalibrationData"},{"location":"apiStm/Power_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr uint16_t ThresholdNoBatteryMv   = = 5000 constexpr uint16_t ThresholdPowerOffMv   = = 6600 CalibrationData calib   = = calibrationDefaults constexpr uint32_t calibrationDataMagic   = = 0x4BCA001 constexpr CalibrationData calibrationDefaults   = = { .magic = calibrationDataMagic, .batteryCoef = 3.4f, .batteryMidCoef = 1.56f, .internalVrefMv = 1200, .tempTypicalMv = 1430, .tempTypicalAtC = 25, } constexpr uint32_t dispatchStatPeriodMs   = = 250 TickTimer dispatchStatTimer uint16_t rawBattery   = = 0 uint16_t rawInternalRef   = = 0 uint16_t rawMidBattery   = = 0 uint16_t rawTemperature   = = 0 constexpr uint16_t tempAvgSlope   = = 4300 int undervoltageCounter   = = 0 constexpr int undervoltageShutdownThreshold   = = 5000 / dispatchStatPeriodMs bool undervoltageWarningOn   = = false uint16_t vrefMv   = = 0"},{"location":"apiStm/Power_8cpp/#public-functions","title":"Public Functions","text":"Type Name void AUXILIARY_AND_MOTOR_ADC_IRQ_HANDLER ()  uint16_t powerBatteryMidMv ()  uint16_t powerBatteryMv ()  void powerCalibrate (uint16_t vccMv, uint16_t bMidMv, uint16_t vref33Mv, uint16_t currentTemperatureC)  void powerInit ()  void powerPoll ()  void powerShutDown ()  uint16_t powerTemperatureC ()  uint16_t powerVrefMv ()"},{"location":"apiStm/Power_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void adcWait (uint32_t clockCycles)  void checkBatteryVoltage (uint16_t vccMv)  void loadCalibration ()"},{"location":"apiStm/Power_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"apiStm/Power_8cpp/#variable-thresholdnobatterymv","title":"variable ThresholdNoBatteryMv","text":"<pre><code>constexpr uint16_t ThresholdNoBatteryMv;\n</code></pre>"},{"location":"apiStm/Power_8cpp/#variable-thresholdpoweroffmv","title":"variable ThresholdPowerOffMv","text":"<pre><code>constexpr uint16_t ThresholdPowerOffMv;\n</code></pre>"},{"location":"apiStm/Power_8cpp/#variable-calib","title":"variable calib","text":"<pre><code>CalibrationData calib;\n</code></pre>"},{"location":"apiStm/Power_8cpp/#variable-calibrationdatamagic","title":"variable calibrationDataMagic","text":"<pre><code>constexpr uint32_t calibrationDataMagic;\n</code></pre>"},{"location":"apiStm/Power_8cpp/#variable-calibrationdefaults","title":"variable calibrationDefaults","text":"<pre><code>constexpr CalibrationData calibrationDefaults;\n</code></pre>"},{"location":"apiStm/Power_8cpp/#variable-dispatchstatperiodms","title":"variable dispatchStatPeriodMs","text":"<pre><code>constexpr uint32_t dispatchStatPeriodMs;\n</code></pre>"},{"location":"apiStm/Power_8cpp/#variable-dispatchstattimer","title":"variable dispatchStatTimer","text":"<pre><code>TickTimer dispatchStatTimer;\n</code></pre>"},{"location":"apiStm/Power_8cpp/#variable-rawbattery","title":"variable rawBattery","text":"<pre><code>uint16_t rawBattery;\n</code></pre>"},{"location":"apiStm/Power_8cpp/#variable-rawinternalref","title":"variable rawInternalRef","text":"<pre><code>uint16_t rawInternalRef;\n</code></pre>"},{"location":"apiStm/Power_8cpp/#variable-rawmidbattery","title":"variable rawMidBattery","text":"<pre><code>uint16_t rawMidBattery;\n</code></pre>"},{"location":"apiStm/Power_8cpp/#variable-rawtemperature","title":"variable rawTemperature","text":"<pre><code>uint16_t rawTemperature;\n</code></pre>"},{"location":"apiStm/Power_8cpp/#variable-tempavgslope","title":"variable tempAvgSlope","text":"<pre><code>constexpr uint16_t tempAvgSlope;\n</code></pre>"},{"location":"apiStm/Power_8cpp/#variable-undervoltagecounter","title":"variable undervoltageCounter","text":"<pre><code>int undervoltageCounter;\n</code></pre>"},{"location":"apiStm/Power_8cpp/#variable-undervoltageshutdownthreshold","title":"variable undervoltageShutdownThreshold","text":"<pre><code>constexpr int undervoltageShutdownThreshold;\n</code></pre>"},{"location":"apiStm/Power_8cpp/#variable-undervoltagewarningon","title":"variable undervoltageWarningOn","text":"<pre><code>bool undervoltageWarningOn;\n</code></pre>"},{"location":"apiStm/Power_8cpp/#variable-vrefmv","title":"variable vrefMv","text":"<pre><code>uint16_t vrefMv;\n</code></pre>"},{"location":"apiStm/Power_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/Power_8cpp/#function-auxiliary_and_motor_adc_irq_handler","title":"function AUXILIARY_AND_MOTOR_ADC_IRQ_HANDLER","text":"<pre><code>void AUXILIARY_AND_MOTOR_ADC_IRQ_HANDLER () </code></pre>"},{"location":"apiStm/Power_8cpp/#function-powerbatterymidmv","title":"function powerBatteryMidMv","text":"<pre><code>uint16_t powerBatteryMidMv () </code></pre>"},{"location":"apiStm/Power_8cpp/#function-powerbatterymv","title":"function powerBatteryMv","text":"<pre><code>uint16_t powerBatteryMv () </code></pre>"},{"location":"apiStm/Power_8cpp/#function-powercalibrate","title":"function powerCalibrate","text":"<pre><code>void powerCalibrate (\nuint16_t vccMv,\nuint16_t bMidMv,\nuint16_t vref33Mv,\nuint16_t currentTemperatureC\n) </code></pre>"},{"location":"apiStm/Power_8cpp/#function-powerinit","title":"function powerInit","text":"<pre><code>void powerInit () </code></pre>"},{"location":"apiStm/Power_8cpp/#function-powerpoll","title":"function powerPoll","text":"<pre><code>void powerPoll () </code></pre>"},{"location":"apiStm/Power_8cpp/#function-powershutdown","title":"function powerShutDown","text":"<pre><code>void powerShutDown () </code></pre>"},{"location":"apiStm/Power_8cpp/#function-powertemperaturec","title":"function powerTemperatureC","text":"<pre><code>uint16_t powerTemperatureC () </code></pre>"},{"location":"apiStm/Power_8cpp/#function-powervrefmv","title":"function powerVrefMv","text":"<pre><code>uint16_t powerVrefMv () </code></pre>"},{"location":"apiStm/Power_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"apiStm/Power_8cpp/#function-adcwait","title":"function adcWait","text":"<pre><code>static void adcWait (\nuint32_t clockCycles\n) </code></pre>"},{"location":"apiStm/Power_8cpp/#function-checkbatteryvoltage","title":"function checkBatteryVoltage","text":"<pre><code>static void checkBatteryVoltage (\nuint16_t vccMv\n) </code></pre>"},{"location":"apiStm/Power_8cpp/#function-loadcalibration","title":"function loadCalibration","text":"<pre><code>static void loadCalibration () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/Power.cpp</code></p>"},{"location":"apiStm/Power_8cpp_source/","title":"File Power.cpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; src &gt; Power.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"stm32f1xx_ll_adc.h\"\n#include \"stm32f1xx_ll_rcc.h\"\n\n#include \"Bsp.hpp\"\n#include \"BuzzerController.hpp\"\n#include \"Dispatcher.hpp\"\n#include \"Power.hpp\"\n#include \"utils/Debug.hpp\"\n#include \"utils/Flash.hpp\"\n#include \"utils/TaskWrapper.hpp\"\n#include \"utils/TickTimer.hpp\"\n\n#include \"rbcx.pb.h\"\n\nstatic constexpr uint16_t ThresholdNoBatteryMv = 5000;\nstatic constexpr uint16_t ThresholdPowerOffMv = 6600;\n\nstatic constexpr uint32_t dispatchStatPeriodMs = 250;\nstatic TickTimer dispatchStatTimer;\n\nstatic uint16_t rawBattery = 0;\nstatic uint16_t rawMidBattery = 0;\nstatic uint16_t rawInternalRef = 0;\nstatic uint16_t rawTemperature = 0;\nstatic uint16_t vrefMv = 0;\n\nstatic constexpr int undervoltageShutdownThreshold\n= 5000 / dispatchStatPeriodMs;\nstatic int undervoltageCounter = 0;\nstatic bool undervoltageWarningOn = false;\n\nstatic constexpr uint16_t tempAvgSlope = 4300;\n\n// Make sure to change the magic when CalibrationData changes.\nstatic constexpr uint32_t calibrationDataMagic = 0x4BCA001;\nstruct CalibrationData {\nuint32_t magic;\nfloat batteryCoef;\nfloat batteryMidCoef;\nuint16_t internalVrefMv;\nuint16_t tempTypicalMv;\nuint16_t tempTypicalAtC;\n};\n\nstatic constexpr CalibrationData calibrationDefaults = {\n.magic = calibrationDataMagic,\n.batteryCoef = 3.4f,\n.batteryMidCoef = 1.56f,\n.internalVrefMv = 1200,\n.tempTypicalMv = 1430,\n.tempTypicalAtC = 25,\n};\n\nstatic CalibrationData calib = calibrationDefaults;\n\nstatic void adcWait(uint32_t clockCycles) {\nif (clockCycles == 0)\nreturn;\nuint32_t adcPrescaler = 1;\nconst uint32_t APB2prescaler = LL_RCC_GetAPB2Prescaler();\nif (APB2prescaler != 0)\nadcPrescaler\n&lt;&lt;= ((APB2prescaler - RCC_CFGR_PPRE2_DIV2) &gt;&gt; RCC_CFGR_PPRE2_Pos)\n+ 1;\nadcPrescaler *= 2\n* ((LL_RCC_GetADCClockSource(RCC_CFGR_ADCPRE) &gt;&gt; RCC_CFGR_ADCPRE_Pos)\n+ 1);\nclockCycles *= adcPrescaler;\nwhile (--clockCycles != 0)\n;\n}\n\nstatic void loadCalibration() {\nconst volatile auto* flashData\n= (volatile CalibrationData*)FLASH_PAGE_POWER_CALIBRATION;\n\nswitch (flashData-&gt;magic) {\ncase calibrationDataMagic:\nbreak;\ncase 0xFFFFFFFF:\nDEBUG(\"No calibration data found, using defaults.\\n\");\nreturn;\ndefault:\nDEBUG(\"Calibration data found, but wrong magic: %08lX, using defaults.\",\nflashData-&gt;magic);\nreturn;\n}\n\nmemcpy(&amp;calib, (void*)flashData, sizeof(CalibrationData));\n\nDEBUG(\n\"Loaded calibration data - VCC:%f BMID:%f VREFINT:%dmV temp:%dmV@%dC\\n\",\ncalib.batteryCoef, calib.batteryMidCoef, calib.internalVrefMv,\ncalib.tempTypicalMv, calib.tempTypicalAtC);\n}\n\nvoid powerInit() {\npinInit(\nbatteryVoltagePin, GPIO_MODE_ANALOG, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW);\npinInit(batteryMiddleVoltagePin, GPIO_MODE_ANALOG, GPIO_NOPULL,\nGPIO_SPEED_FREQ_LOW);\n\nloadCalibration();\n\nLL_ADC_InitTypeDef cfg;\nLL_ADC_StructInit(&amp;cfg);\ncfg.DataAlignment = LL_ADC_DATA_ALIGN_RIGHT;\ncfg.SequencersScanMode = LL_ADC_SEQ_SCAN_ENABLE;\nif (LL_ADC_Init(auxiliaryAdc, &amp;cfg) != SUCCESS)\nabort();\n\nLL_ADC_REG_InitTypeDef cfgReg;\nLL_ADC_REG_StructInit(&amp;cfgReg);\ncfgReg.ContinuousMode = LL_ADC_REG_CONV_CONTINUOUS;\ncfgReg.SequencerLength = LL_ADC_REG_SEQ_SCAN_ENABLE_2RANKS;\ncfgReg.TriggerSource = LL_ADC_REG_TRIG_SOFTWARE;\nif (LL_ADC_REG_Init(auxiliaryAdc, &amp;cfgReg) != SUCCESS)\nabort();\n\nLL_ADC_INJ_InitTypeDef cfgInj;\nLL_ADC_INJ_StructInit(&amp;cfgInj);\ncfgInj.TriggerSource = LL_ADC_INJ_TRIG_SOFTWARE;\ncfgInj.TrigAuto = LL_ADC_INJ_TRIG_FROM_GRP_REGULAR;\nif (LL_ADC_INJ_Init(auxiliaryAdc, &amp;cfgInj) != SUCCESS)\nabort();\n\nLL_ADC_SetCommonPathInternalCh(ADC12_COMMON, LL_ADC_PATH_INTERNAL_VREFINT);\n\nLL_ADC_Enable(auxiliaryAdc);\nadcWait(LL_ADC_DELAY_ENABLE_CALIB_ADC_CYCLES);\nLL_ADC_StartCalibration(auxiliaryAdc);\nwhile (LL_ADC_IsCalibrationOnGoing(auxiliaryAdc))\n;\n\nLL_ADC_SetChannelSamplingTimeFix(\nauxiliaryAdc, batteryVoltageAdcChannel, LL_ADC_SAMPLINGTIME_1CYCLE_5);\nLL_ADC_SetChannelSamplingTimeFix(auxiliaryAdc,\nbatteryMiddleVoltageAdcChannel, LL_ADC_SAMPLINGTIME_1CYCLE_5);\nLL_ADC_SetChannelSamplingTimeFix(\nauxiliaryAdc, LL_ADC_CHANNEL_VREFINT, LL_ADC_SAMPLINGTIME_239CYCLES_5);\nLL_ADC_SetChannelSamplingTimeFix(auxiliaryAdc, LL_ADC_CHANNEL_TEMPSENSOR,\nLL_ADC_SAMPLINGTIME_239CYCLES_5);\n\nauxiliaryAdc-&gt;JSQR = ADC_JSQR_JL\n| (batteryVoltageAdcChannel &amp; ADC_JSQR_JSQ1)\n&lt;&lt; (ADC_JSQR_JSQ2_Pos * ((batteryVoltageAdcRank - 1) &amp; 3))\n| (LL_ADC_CHANNEL_VREFINT &amp; ADC_JSQR_JSQ1)\n&lt;&lt; (ADC_JSQR_JSQ2_Pos * ((internalReferenceVoltageAdcRank - 1) &amp; 3))\n| (batteryMiddleVoltageAdcChannel &amp; ADC_JSQR_JSQ1)\n&lt;&lt; (ADC_JSQR_JSQ2_Pos * ((batteryMiddleVoltageAdcRank - 1) &amp; 3))\n| (LL_ADC_CHANNEL_TEMPSENSOR &amp; ADC_JSQR_JSQ1)\n&lt;&lt; (ADC_JSQR_JSQ2_Pos * ((temperatureAdcRank - 1) &amp; 3));\n\nLL_ADC_EnableIT_JEOS(auxiliaryAdc);\nHAL_NVIC_SetPriority(\nauxiliaryAndMotorAdcIRQn, auxiliaryAndMotorAdcIrqPrio, 0);\nHAL_NVIC_EnableIRQ(auxiliaryAndMotorAdcIRQn);\n\nLL_ADC_REG_StartConversionSWStart(auxiliaryAdc);\nLL_ADC_INJ_StartConversionSWStart(auxiliaryAdc);\n\ndispatchStatTimer.restart(dispatchStatPeriodMs);\n}\n\nextern \"C\" void AUXILIARY_AND_MOTOR_ADC_IRQ_HANDLER() {\nif (LL_ADC_IsEnabledIT_JEOS(auxiliaryAdc)\n&amp;&amp; LL_ADC_IsActiveFlag_JEOS(auxiliaryAdc)) {\n\nrawBattery = LL_ADC_INJ_ReadConversionData12(\nauxiliaryAdc, batteryVoltageAdcRank);\nrawMidBattery = LL_ADC_INJ_ReadConversionData12(\nauxiliaryAdc, batteryMiddleVoltageAdcRank);\nrawTemperature\n= LL_ADC_INJ_ReadConversionData12(auxiliaryAdc, temperatureAdcRank);\nrawInternalRef = LL_ADC_INJ_ReadConversionData12(\nauxiliaryAdc, internalReferenceVoltageAdcRank);\n\nvrefMv = calib.internalVrefMv\n* __LL_ADC_DIGITAL_SCALE(LL_ADC_RESOLUTION_12B) / rawInternalRef;\n\nLL_ADC_ClearFlag_JEOS(auxiliaryAdc);\n}\nHAL_NVIC_ClearPendingIRQ(auxiliaryAndMotorAdcIRQn);\n}\n\nuint16_t powerBatteryMv() {\nreturn __LL_ADC_CALC_DATA_TO_VOLTAGE(\nvrefMv, rawBattery, LL_ADC_RESOLUTION_12B)\n* calib.batteryCoef;\n}\n\nuint16_t powerBatteryMidMv() {\nreturn __LL_ADC_CALC_DATA_TO_VOLTAGE(\nvrefMv, rawMidBattery, LL_ADC_RESOLUTION_12B)\n* calib.batteryMidCoef;\n}\n\nuint16_t powerTemperatureC() {\nreturn __LL_ADC_CALC_TEMPERATURE_TYP_PARAMS(tempAvgSlope,\ncalib.tempTypicalMv, calib.tempTypicalAtC, vrefMv, rawTemperature,\nLL_ADC_RESOLUTION_12B);\n}\n\nuint16_t powerVrefMv() { return vrefMv; }\n\nvoid powerCalibrate(uint16_t vccMv, uint16_t bMidMv, uint16_t vref33Mv,\nuint16_t currentTemperatureC) {\n\nwhile (vrefMv == 0)\n;\n\nportTICK_TYPE_ENTER_CRITICAL();\n\nif (vref33Mv == POWER_CALIBRATE_DEFAULT) {\ncalib.internalVrefMv = calibrationDefaults.internalVrefMv;\n} else if (vref33Mv != POWER_CALIBRATE_NO_CHANGE) {\nvrefMv = vref33Mv;\ncalib.internalVrefMv = vrefMv * rawInternalRef\n/ __LL_ADC_DIGITAL_SCALE(LL_ADC_RESOLUTION_12B);\n}\n\nif (vccMv == POWER_CALIBRATE_DEFAULT) {\ncalib.batteryCoef = calibrationDefaults.batteryCoef;\n} else if (vccMv != POWER_CALIBRATE_NO_CHANGE) {\ncalib.batteryCoef = float(vccMv)\n/ float(__LL_ADC_CALC_DATA_TO_VOLTAGE(\nvrefMv, rawBattery, LL_ADC_RESOLUTION_12B));\n}\n\nif (bMidMv == POWER_CALIBRATE_DEFAULT) {\ncalib.batteryMidCoef = calibrationDefaults.batteryMidCoef;\n} else if (bMidMv != POWER_CALIBRATE_NO_CHANGE) {\ncalib.batteryMidCoef = float(bMidMv)\n/ float(__LL_ADC_CALC_DATA_TO_VOLTAGE(\nvrefMv, rawMidBattery, LL_ADC_RESOLUTION_12B));\n}\n\nif (currentTemperatureC == POWER_CALIBRATE_DEFAULT) {\ncalib.tempTypicalMv = calibrationDefaults.tempTypicalMv;\ncalib.tempTypicalAtC = calibrationDefaults.tempTypicalAtC;\n} else if (currentTemperatureC != POWER_CALIBRATE_NO_CHANGE) {\ncalib.tempTypicalMv = __LL_ADC_CALC_DATA_TO_VOLTAGE(\nvrefMv, rawTemperature, LL_ADC_RESOLUTION_12B);\ncalib.tempTypicalAtC = currentTemperatureC;\n}\n\nportTICK_TYPE_EXIT_CRITICAL();\n\nflashWritePage(FLASH_PAGE_POWER_CALIBRATION, (uint8_t*)&amp;calib,\nsizeof(CalibrationData));\n\nDEBUG(\"New coefs set, internalRef: %dmv bat: %f mid %f temp %d@%d\\n\",\ncalib.internalVrefMv, calib.batteryCoef, calib.batteryMidCoef,\ncalib.tempTypicalMv, calib.tempTypicalAtC);\n}\n\nvoid powerShutDown() {\nDEBUG(\"Shutting down battery power...\\n\");\n\nif (pinRead(usbBusDetectionPin)) {\npinWrite(powerPin, 0);\nreturn;\n}\n\nvTaskDelay(1);\n\n__disable_irq();\n\npinWrite(powerPin, 0);\n\n// Blink red LED \"pretty fast\"\nuint32_t leds = 0;\nwhile (true) {\nleds ^= CoprocReq_LedsEnum_L3;\nsetLeds(leds);\n\nfor (volatile int i = 0; i &lt; 200000; i++)\n;\n}\n}\n\nstatic void checkBatteryVoltage(uint16_t vccMv) {\nif (vccMv &lt; ThresholdNoBatteryMv) {\nif (undervoltageWarningOn) {\nundervoltageWarningOn = false;\npinWrite(led3Pin, false);\nbuzzerSetState(false);\n}\nreturn;\n}\n\nif (vccMv &lt; ThresholdPowerOffMv &amp;&amp; pinRead(powerPin)) {\n++undervoltageCounter;\nundervoltageWarningOn = !undervoltageWarningOn;\npinWrite(led3Pin, undervoltageWarningOn);\nbuzzerSetState(undervoltageWarningOn);\nDEBUG(\"Battery voltage is low, %dmv.\\n\", vccMv);\n\nif (undervoltageCounter &gt; undervoltageShutdownThreshold) {\nundervoltageCounter = 0;\nDEBUG(\"Battery voltage low, %dmv. Shutting down.\\n\", vccMv);\npowerShutDown();\n}\n} else if (undervoltageCounter &gt; 0) {\n--undervoltageCounter;\nif (undervoltageWarningOn) {\nundervoltageWarningOn = false;\npinWrite(led3Pin, false);\nbuzzerSetState(false);\n}\n}\n}\n\nvoid powerPoll() {\nif (dispatchStatTimer.poll()) {\nconst auto vccMv = powerBatteryMv();\ncheckBatteryVoltage(vccMv);\n\nCoprocStat status = {\n.which_payload = CoprocStat_powerAdcStat_tag,\n};\nstatus.payload.powerAdcStat.vccMv = vccMv;\nstatus.payload.powerAdcStat.battMidMv = powerBatteryMidMv();\nstatus.payload.powerAdcStat.temperatureC = powerTemperatureC();\ndispatcherEnqueueStatus(status);\n\ndispatchStatTimer.restart(dispatchStatPeriodMs);\n}\n}\n</code></pre>"},{"location":"apiStm/SmartServoController_8cpp/","title":"File SmartServoController.cpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; src &gt; SmartServoController.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"SmartServoController.hpp\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"ControlLink.hpp\"</code></li> <li><code>#include \"stm32f1xx_ll_gpio.h\"</code></li> <li><code>#include \"stm32f1xx_ll_usart.h\"</code></li> <li><code>#include \"utils/Debug.hpp\"</code></li> <li><code>#include \"utils/TickTimer.hpp\"</code></li> </ul>"},{"location":"apiStm/SmartServoController_8cpp/#public-types","title":"Public Types","text":"Type Name enum SmartServoState"},{"location":"apiStm/SmartServoController_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name std::array&lt; uint8_t, sizeof(CoprocReq_SmartServoReq_data_t::bytes)&gt; gBuff size_t gBuffIndex   = = 0 size_t gBuffSize   = = 0 bool gExpectResponse   = = false bool gResponseReady   = = false TickTimer gResponseTimeout SmartServoState gState   = = IDLE TickTimer gStateTimeout"},{"location":"apiStm/SmartServoController_8cpp/#public-functions","title":"Public Functions","text":"Type Name void SERVOUART_HANDLER (void)  void smartServoInit ()  void smartServoPoll ()  void smartServoSendRequest (const CoprocReq_SmartServoReq &amp; req)"},{"location":"apiStm/SmartServoController_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void smartServoSetResponseReady ()  void smartServoStopRx ()"},{"location":"apiStm/SmartServoController_8cpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/SmartServoController_8cpp/#enum-smartservostate","title":"enum SmartServoState","text":"<pre><code>enum SmartServoState {\nIDLE,\nTX,\nRX\n};\n</code></pre>"},{"location":"apiStm/SmartServoController_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"apiStm/SmartServoController_8cpp/#variable-gbuff","title":"variable gBuff","text":"<pre><code>std::array&lt;uint8_t, sizeof(CoprocReq_SmartServoReq_data_t::bytes)&gt; gBuff;\n</code></pre>"},{"location":"apiStm/SmartServoController_8cpp/#variable-gbuffindex","title":"variable gBuffIndex","text":"<pre><code>size_t gBuffIndex;\n</code></pre>"},{"location":"apiStm/SmartServoController_8cpp/#variable-gbuffsize","title":"variable gBuffSize","text":"<pre><code>size_t gBuffSize;\n</code></pre>"},{"location":"apiStm/SmartServoController_8cpp/#variable-gexpectresponse","title":"variable gExpectResponse","text":"<pre><code>bool gExpectResponse;\n</code></pre>"},{"location":"apiStm/SmartServoController_8cpp/#variable-gresponseready","title":"variable gResponseReady","text":"<pre><code>bool gResponseReady;\n</code></pre>"},{"location":"apiStm/SmartServoController_8cpp/#variable-gresponsetimeout","title":"variable gResponseTimeout","text":"<pre><code>TickTimer gResponseTimeout;\n</code></pre>"},{"location":"apiStm/SmartServoController_8cpp/#variable-gstate","title":"variable gState","text":"<pre><code>SmartServoState gState;\n</code></pre>"},{"location":"apiStm/SmartServoController_8cpp/#variable-gstatetimeout","title":"variable gStateTimeout","text":"<pre><code>TickTimer gStateTimeout;\n</code></pre>"},{"location":"apiStm/SmartServoController_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/SmartServoController_8cpp/#function-servouart_handler","title":"function SERVOUART_HANDLER","text":"<pre><code>void SERVOUART_HANDLER (\nvoid\n) </code></pre>"},{"location":"apiStm/SmartServoController_8cpp/#function-smartservoinit","title":"function smartServoInit","text":"<pre><code>void smartServoInit () </code></pre>"},{"location":"apiStm/SmartServoController_8cpp/#function-smartservopoll","title":"function smartServoPoll","text":"<pre><code>void smartServoPoll () </code></pre>"},{"location":"apiStm/SmartServoController_8cpp/#function-smartservosendrequest","title":"function smartServoSendRequest","text":"<pre><code>void smartServoSendRequest (\nconst CoprocReq_SmartServoReq &amp; req\n) </code></pre>"},{"location":"apiStm/SmartServoController_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"apiStm/SmartServoController_8cpp/#function-smartservosetresponseready","title":"function smartServoSetResponseReady","text":"<pre><code>static void smartServoSetResponseReady () </code></pre>"},{"location":"apiStm/SmartServoController_8cpp/#function-smartservostoprx","title":"function smartServoStopRx","text":"<pre><code>static void smartServoStopRx () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/SmartServoController.cpp</code></p>"},{"location":"apiStm/SmartServoController_8cpp_source/","title":"File SmartServoController.cpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; src &gt; SmartServoController.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"SmartServoController.hpp\"\n#include \"Bsp.hpp\"\n#include \"ControlLink.hpp\"\n#include \"stm32f1xx_ll_gpio.h\"\n#include \"stm32f1xx_ll_usart.h\"\n#include \"utils/Debug.hpp\"\n#include \"utils/TickTimer.hpp\"\n\nenum SmartServoState { IDLE, TX, RX };\n\n// assert that response fits into gBuff\nstatic_assert(sizeof(CoprocStat_SmartServoStat_data_t::bytes)\n&lt;= sizeof(CoprocReq_SmartServoReq_data_t::bytes));\n\nstatic std::array&lt;uint8_t, sizeof(CoprocReq_SmartServoReq_data_t::bytes)&gt; gBuff;\n\nstatic size_t gBuffSize = 0;\nstatic size_t gBuffIndex = 0;\n\nstatic SmartServoState gState = IDLE;\nstatic bool gExpectResponse = false;\nstatic bool gResponseReady = false;\n\nstatic TickTimer gResponseTimeout;\nstatic TickTimer gStateTimeout;\n\nvoid smartServoInit() {\nLL_USART_InitTypeDef init;\nLL_USART_StructInit(&amp;init);\ninit.BaudRate = 115200;\ninit.DataWidth = LL_USART_DATAWIDTH_8B;\ninit.HardwareFlowControl = LL_USART_HWCONTROL_NONE;\ninit.Parity = LL_USART_PARITY_NONE;\ninit.StopBits = LL_USART_STOPBITS_1;\ninit.TransferDirection = LL_USART_DIRECTION_TX;\n\nif (LL_USART_Init(servoUart, &amp;init) != SUCCESS)\nabort();\n\nLL_USART_ConfigHalfDuplexMode(servoUart);\nLL_USART_Enable(servoUart);\n\nHAL_NVIC_SetPriority(servoUartIRQn, servoUartIrqPrio, 0);\nHAL_NVIC_EnableIRQ(servoUartIRQn);\n\npinInit(\nservoUartTxRxPin, GPIO_MODE_AF_OD, GPIO_NOPULL, GPIO_SPEED_FREQ_HIGH);\n}\n\nstatic void smartServoSetResponseReady() {\nif (gResponseReady) {\nDEBUGLN(\n\"Invalid smartServoSetResponseReady call, it was already ready\");\n}\ngResponseReady = true;\n}\n\nstatic void smartServoStopRx() {\nLL_USART_DisableIT_TC(servoUart);\nLL_USART_DisableIT_RXNE(servoUart);\nsmartServoSetResponseReady();\ngState = IDLE;\ngResponseTimeout.stop();\n}\n\nvoid smartServoPoll() {\nif (gResponseReady) {\nCoprocStat stat = {\n.which_payload = CoprocStat_smartServoStat_tag,\n.payload = {\n.smartServoStat = {\n.data = {\n.size = gBuffSize,\n},\n},\n},\n};\nmemcpy(stat.payload.smartServoStat.data.bytes, gBuff.data(), gBuffSize);\ngResponseReady = false;\ncontrolLinkTx(stat);\n}\n\nif (gResponseTimeout.poll()) {\nsmartServoStopRx();\n}\n\nif (gStateTimeout.poll() &amp;&amp; gState != IDLE) {\nLL_USART_DisableIT_TXE(servoUart);\nsmartServoStopRx();\n}\n}\n\nextern \"C\" void SERVOUART_HANDLER(void) {\n// TX empty\nif (gState == TX &amp;&amp; LL_USART_IsActiveFlag_TXE(servoUart)) {\nif (gBuffIndex &lt; gBuffSize) {\nLL_USART_TransmitData8(servoUart, gBuff[gBuffIndex++]);\n} else {\nLL_USART_DisableIT_TXE(servoUart);\n\ngBuffSize = 0;\n\nif (!gExpectResponse) {\nsmartServoSetResponseReady();\ngState = IDLE;\n} else {\ngState = RX;\nLL_USART_EnableIT_TC(servoUart);\n\ngResponseTimeout.restart(5);\n}\n}\n}\n\nif (gState == RX) {\n// Transmission complete\nif (LL_USART_IsActiveFlag_TC(servoUart)) {\nLL_USART_DisableIT_TC(servoUart);\nLL_USART_ClearFlag_TC(servoUart);\nLL_USART_ClearFlag_IDLE(servoUart);\n\nLL_USART_SetTransferDirection(servoUart, LL_USART_DIRECTION_RX);\n\nLL_USART_ReceiveData8(servoUart);\nLL_USART_EnableIT_RXNE(servoUart);\n\ngResponseTimeout.restart(2);\n}\n\n// RX not empty\nif (LL_USART_IsActiveFlag_RXNE(servoUart)) {\nconst uint8_t ch = LL_USART_ReceiveData8(servoUart);\n\nif (gBuffSize &lt; gBuff.size()) {\ngBuff[gBuffSize++] = ch;\n} else {\nDEBUGLN(\"SmartServo RX buffer overrun!\");\n}\ngResponseTimeout.restart(2);\n}\n\n// RX overrun, is enabled by the same bit as RXNE so we have to clear it\nif (LL_USART_IsActiveFlag_ORE(servoUart)) {\nLL_USART_ClearFlag_ORE(servoUart);\nDEBUGLN(\"SmartServo ORE bit set!\");\n}\n}\n}\n\nvoid smartServoSendRequest(const CoprocReq_SmartServoReq&amp; req) {\nif (gState != IDLE) {\nDEBUGLN(\"Invalid CoprocReq_SmartServoReq, state is %d\", gState);\nreturn;\n}\n\nif (req.data.size == 0) {\ngBuffSize = 0;\nsmartServoSetResponseReady();\nreturn;\n}\n\ngStateTimeout.restart(10);\ngState = TX;\n\nmemcpy(gBuff.data(), req.data.bytes, req.data.size);\ngBuffSize = req.data.size;\ngBuffIndex = 1;\ngExpectResponse = req.expect_response;\n\nLL_USART_SetTransferDirection(servoUart, LL_USART_DIRECTION_TX);\n\nLL_USART_ClearFlag_TC(servoUart);\nLL_USART_TransmitData8(servoUart, gBuff[0]);\nLL_USART_EnableIT_TXE(servoUart);\n}\n</code></pre>"},{"location":"apiStm/StupidServoController_8cpp/","title":"File StupidServoController.cpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; src &gt; StupidServoController.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"StupidServoController.hpp\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"ControlLink.hpp\"</code></li> <li><code>#include \"stm32f1xx_hal_rcc.h\"</code></li> <li><code>#include \"stm32f1xx_ll_tim.h\"</code></li> </ul>"},{"location":"apiStm/StupidServoController_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name uint32_t pwmCenterValue float pwmCoef"},{"location":"apiStm/StupidServoController_8cpp/#public-functions","title":"Public Functions","text":"Type Name void stupidServoDispatch (const CoprocReq_SetStupidServo &amp; request)  void stupidServoInit ()  void stupidServoReset ()"},{"location":"apiStm/StupidServoController_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void stupidServoDisable (int servoIndex)  void stupidServoSetPosition (int servoIndex, float position)"},{"location":"apiStm/StupidServoController_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"apiStm/StupidServoController_8cpp/#variable-pwmcentervalue","title":"variable pwmCenterValue","text":"<pre><code>uint32_t pwmCenterValue;\n</code></pre>"},{"location":"apiStm/StupidServoController_8cpp/#variable-pwmcoef","title":"variable pwmCoef","text":"<pre><code>float pwmCoef;\n</code></pre>"},{"location":"apiStm/StupidServoController_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/StupidServoController_8cpp/#function-stupidservodispatch","title":"function stupidServoDispatch","text":"<pre><code>void stupidServoDispatch (\nconst CoprocReq_SetStupidServo &amp; request\n) </code></pre>"},{"location":"apiStm/StupidServoController_8cpp/#function-stupidservoinit","title":"function stupidServoInit","text":"<pre><code>void stupidServoInit () </code></pre>"},{"location":"apiStm/StupidServoController_8cpp/#function-stupidservoreset","title":"function stupidServoReset","text":"<pre><code>void stupidServoReset () </code></pre>"},{"location":"apiStm/StupidServoController_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"apiStm/StupidServoController_8cpp/#function-stupidservodisable","title":"function stupidServoDisable","text":"<pre><code>static void stupidServoDisable (\nint servoIndex\n) </code></pre>"},{"location":"apiStm/StupidServoController_8cpp/#function-stupidservosetposition","title":"function stupidServoSetPosition","text":"<pre><code>static void stupidServoSetPosition (\nint servoIndex,\nfloat position\n) </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/StupidServoController.cpp</code></p>"},{"location":"apiStm/StupidServoController_8cpp_source/","title":"File StupidServoController.cpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; src &gt; StupidServoController.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"StupidServoController.hpp\"\n\n#include \"Bsp.hpp\"\n#include \"ControlLink.hpp\"\n#include \"stm32f1xx_hal_rcc.h\"\n#include \"stm32f1xx_ll_tim.h\"\n\nstatic uint32_t pwmCenterValue;\nstatic float pwmCoef;\n\nvoid stupidServoInit() {\nLL_TIM_InitTypeDef pwmInit;\nLL_TIM_StructInit(&amp;pwmInit);\nauto apb1TimClk = 2 * HAL_RCC_GetPCLK1Freq();\n\n// 1/50 s :\npwmInit.Autoreload = 65535;\npwmInit.Prescaler = (apb1TimClk / 50) / pwmInit.Autoreload;\npwmInit.CounterMode = LL_TIM_COUNTERMODE_UP;\npwmInit.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;\npwmInit.RepetitionCounter = 0;\n\n// Center at 1.5ms within 1/50s\npwmCenterValue = uint32_t(pwmInit.Autoreload * 0.075f);\n// Range +- 0.5ms within 1/50s\npwmCoef = pwmInit.Autoreload * 0.025f;\n\nLL_TIM_OC_InitTypeDef ocInit;\nLL_TIM_OC_StructInit(&amp;ocInit);\nocInit.OCMode = LL_TIM_OCMODE_PWM1;\nocInit.OCState = LL_TIM_OCSTATE_DISABLE;\nocInit.CompareValue = pwmCenterValue;\nocInit.OCPolarity = LL_TIM_OCPOLARITY_HIGH;\nocInit.OCIdleState = LL_TIM_OCIDLESTATE_LOW;\nLL_TIM_Init(servoTimer, &amp;pwmInit);\n\nfor (uint16_t channel = LL_TIM_CHANNEL_CH1; channel != 0; channel &lt;&lt;= 4) {\nLL_TIM_OC_Init(servoTimer, channel, &amp;ocInit);\nLL_TIM_OC_EnablePreload(servoTimer, channel);\n}\nLL_TIM_SetOffStates(servoTimer, LL_TIM_OSSI_DISABLE, LL_TIM_OSSR_ENABLE);\nLL_TIM_GenerateEvent_UPDATE(servoTimer);\nLL_TIM_EnableCounter(servoTimer);\nLL_TIM_EnableAllOutputs(servoTimer);\n}\n\nstatic void stupidServoDisable(int servoIndex) {\nswitch (servoIndex) {\ncase 0:\nLL_TIM_CC_DisableChannel(servoTimer, LL_TIM_CHANNEL_CH1);\nbreak;\ncase 1:\nLL_TIM_CC_DisableChannel(servoTimer, LL_TIM_CHANNEL_CH2);\nbreak;\ncase 2:\nLL_TIM_CC_DisableChannel(servoTimer, LL_TIM_CHANNEL_CH3);\nbreak;\ncase 3:\nLL_TIM_CC_DisableChannel(servoTimer, LL_TIM_CHANNEL_CH4);\nbreak;\n}\n}\n\nstatic void stupidServoSetPosition(int servoIndex, float position) {\nuint32_t value = pwmCenterValue + int32_t(pwmCoef * position);\n\nswitch (servoIndex) {\ncase 0:\nLL_TIM_CC_EnableChannel(servoTimer, LL_TIM_CHANNEL_CH1);\nLL_TIM_OC_SetCompareCH1(servoTimer, value);\nbreak;\ncase 1:\nLL_TIM_CC_EnableChannel(servoTimer, LL_TIM_CHANNEL_CH2);\nLL_TIM_OC_SetCompareCH2(servoTimer, value);\nbreak;\ncase 2:\nLL_TIM_CC_EnableChannel(servoTimer, LL_TIM_CHANNEL_CH3);\nLL_TIM_OC_SetCompareCH3(servoTimer, value);\nbreak;\ncase 3:\nLL_TIM_CC_EnableChannel(servoTimer, LL_TIM_CHANNEL_CH4);\nLL_TIM_OC_SetCompareCH4(servoTimer, value);\nbreak;\n}\n}\n\nvoid stupidServoDispatch(const CoprocReq_SetStupidServo&amp; request) {\nswitch (request.which_servoCmd) {\ncase CoprocReq_SetStupidServo_disable_tag:\nstupidServoDisable(request.servoIndex);\nbreak;\ncase CoprocReq_SetStupidServo_setPosition_tag:\nstupidServoSetPosition(\nrequest.servoIndex, request.servoCmd.setPosition);\nbreak;\n}\n\nCoprocStat status;\nstatus.which_payload = CoprocStat_stupidServoStat_tag;\ncontrolLinkTx(status);\n}\n\nvoid stupidServoReset() {\nfor (int i = 0; i &lt; 4; ++i) {\nstupidServoDisable(i);\n}\n}\n</code></pre>"},{"location":"apiStm/UltrasoundController_8cpp/","title":"File UltrasoundController.cpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; src &gt; UltrasoundController.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"UltrasoundController.hpp\"</code></li> <li><code>#include \"stm32f1xx_hal.h\"</code></li> <li><code>#include \"stm32f1xx_hal_rcc.h\"</code></li> <li><code>#include \"stm32f1xx_ll_exti.h\"</code></li> <li><code>#include \"stm32f1xx_ll_tim.h\"</code></li> <li><code>#include \"utils/Debug.hpp\"</code></li> <li><code>#include \"utils/QueueWrapper.hpp\"</code></li> <li><code>#include \"utils/TaskWrapper.hpp\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"Dispatcher.hpp\"</code></li> </ul>"},{"location":"apiStm/UltrasoundController_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const uint16_t echoRestoreTimeoutMs   = = 180 const uint16_t pingTimeoutMs   = = 30 uint32_t risingMicros CoprocStat status QueueWrapper&lt; int, 16 &gt; trigQueue int utsActiveIndex TaskWrapper&lt; 512 &gt; utsTask"},{"location":"apiStm/UltrasoundController_8cpp/#public-functions","title":"Public Functions","text":"Type Name void ultrasoundDispatch (const CoprocReq_UltrasoundReq &amp; request)  void ultrasoundInit ()  void ultrasoundOnEchoEdge ()  void ultrasoundReset ()"},{"location":"apiStm/UltrasoundController_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"apiStm/UltrasoundController_8cpp/#variable-echorestoretimeoutms","title":"variable echoRestoreTimeoutMs","text":"<pre><code>const uint16_t echoRestoreTimeoutMs;\n</code></pre>"},{"location":"apiStm/UltrasoundController_8cpp/#variable-pingtimeoutms","title":"variable pingTimeoutMs","text":"<pre><code>const uint16_t pingTimeoutMs;\n</code></pre>"},{"location":"apiStm/UltrasoundController_8cpp/#variable-risingmicros","title":"variable risingMicros","text":"<pre><code>uint32_t risingMicros;\n</code></pre>"},{"location":"apiStm/UltrasoundController_8cpp/#variable-status","title":"variable status","text":"<pre><code>CoprocStat status;\n</code></pre>"},{"location":"apiStm/UltrasoundController_8cpp/#variable-trigqueue","title":"variable trigQueue","text":"<pre><code>QueueWrapper&lt;int, 16&gt; trigQueue;\n</code></pre>"},{"location":"apiStm/UltrasoundController_8cpp/#variable-utsactiveindex","title":"variable utsActiveIndex","text":"<pre><code>int utsActiveIndex;\n</code></pre>"},{"location":"apiStm/UltrasoundController_8cpp/#variable-utstask","title":"variable utsTask","text":"<pre><code>TaskWrapper&lt;512&gt; utsTask;\n</code></pre>"},{"location":"apiStm/UltrasoundController_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/UltrasoundController_8cpp/#function-ultrasounddispatch","title":"function ultrasoundDispatch","text":"<pre><code>void ultrasoundDispatch (\nconst CoprocReq_UltrasoundReq &amp; request\n) </code></pre>"},{"location":"apiStm/UltrasoundController_8cpp/#function-ultrasoundinit","title":"function ultrasoundInit","text":"<pre><code>void ultrasoundInit () </code></pre>"},{"location":"apiStm/UltrasoundController_8cpp/#function-ultrasoundonechoedge","title":"function ultrasoundOnEchoEdge","text":"<pre><code>void ultrasoundOnEchoEdge () </code></pre>"},{"location":"apiStm/UltrasoundController_8cpp/#function-ultrasoundreset","title":"function ultrasoundReset","text":"<pre><code>void ultrasoundReset () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/UltrasoundController.cpp</code></p>"},{"location":"apiStm/UltrasoundController_8cpp_source/","title":"File UltrasoundController.cpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; src &gt; UltrasoundController.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"UltrasoundController.hpp\"\n#include \"stm32f1xx_hal.h\"\n#include \"stm32f1xx_hal_rcc.h\"\n#include \"stm32f1xx_ll_exti.h\"\n#include \"stm32f1xx_ll_tim.h\"\n#include \"utils/Debug.hpp\"\n#include \"utils/QueueWrapper.hpp\"\n#include \"utils/TaskWrapper.hpp\"\n\n#include \"Bsp.hpp\"\n#include \"Dispatcher.hpp\"\n\nstatic const uint16_t pingTimeoutMs = 30;\nstatic const uint16_t echoRestoreTimeoutMs = 180;\nstatic CoprocStat status;\nstatic int utsActiveIndex;\nstatic uint32_t risingMicros;\nstatic TaskWrapper&lt;512&gt; utsTask;\nstatic QueueWrapper&lt;int, 16&gt; trigQueue;\n\nvoid ultrasoundInit() {\nLL_TIM_InitTypeDef timInit;\nLL_TIM_StructInit(&amp;timInit);\nauto apb1TimClk = 2 * HAL_RCC_GetPCLK1Freq();\n\ntimInit.Autoreload = pingTimeoutMs * 1000;\ntimInit.Prescaler = apb1TimClk / 1'000'000; // 1 us ticks\nLL_TIM_Init(utsTimer, &amp;timInit);\nLL_TIM_SetOnePulseMode(utsTimer, LL_TIM_ONEPULSEMODE_SINGLE);\nLL_TIM_SetUpdateSource(utsTimer, LL_TIM_UPDATESOURCE_COUNTER);\nLL_TIM_ClearFlag_UPDATE(utsTimer);\n\nfor (const auto&amp; p : utsEchoPin) {\nLL_EXTI_DisableIT_0_31(p.second);\n}\n\ntrigQueue.create();\nutsTask.start(\"ultrasound\", ultrasoundTaskPrio, []() {\nwhile (true) {\nint utsIndex;\ntrigQueue.pop_front(utsIndex);\n\n// Wait for potential ECHO high\nauto echoWait = [=]() {\nTickType_t before = xTaskGetTickCount();\nwhile (pinRead(utsEchoPin[utsIndex])) {\nif ((xTaskGetTickCount() - before)\n&gt; pdMS_TO_TICKS(echoRestoreTimeoutMs)) {\nreturn false;\n}\nvTaskDelay(pdMS_TO_TICKS(5));\n}\nreturn true;\n};\nif (!echoWait()) {\nDEBUG(\"Ultrasound ECHO %d hanging high\\n\", utsIndex);\ncontinue;\n}\n\n// Reset timer\nLL_TIM_GenerateEvent_UPDATE(utsTimer);\nLL_TIM_ClearFlag_UPDATE(utsTimer);\n\n// Perform TRIG pulse\ntaskENTER_CRITICAL();\nLL_TIM_EnableCounter(utsTimer);\npinWrite(utsTrigPin[utsIndex], true);\nwhile (LL_TIM_GetCounter(utsTimer) &lt; 10\n&amp;&amp; !LL_TIM_IsActiveFlag_UPDATE(utsTimer)) { // 10 us pulse\n}\npinWrite(utsTrigPin[utsIndex], false);\ntaskEXIT_CRITICAL();\n\n// Wait for ECHO measurement from ISR\nutsActiveIndex = utsIndex;\nxTaskNotifyStateClear(nullptr);\nLL_EXTI_EnableIT_0_31(utsEchoPin[utsIndex].second);\nuint32_t micros = 0;\nauto ok = xTaskNotifyWait(\n0U, ~0U, &amp;micros, pdMS_TO_TICKS(pingTimeoutMs));\nLL_EXTI_DisableIT_0_31(utsEchoPin[utsIndex].second);\n\n// Send measurement\nstatus = CoprocStat_init_default;\nstatus.which_payload = CoprocStat_ultrasoundStat_tag;\nstatus.payload.ultrasoundStat.utsIndex = utsIndex;\nstatus.payload.ultrasoundStat.roundtripMicrosecs = ok ? micros : 0;\ndispatcherEnqueueStatus(status);\n}\n});\n}\n\nvoid ultrasoundDispatch(const CoprocReq_UltrasoundReq&amp; request) {\nif (request.utsIndex &gt; 3) {\nDEBUG(\"Ultrasound index %lu out of range\\n\", request.utsIndex);\nreturn;\n}\n\nswitch (request.which_utsCmd) {\ncase CoprocReq_UltrasoundReq_singlePing_tag:\nif (!trigQueue.push_back(request.utsIndex, 0)) {\nDEBUG(\"Ultrasound TRIG queue overflow\\n\");\n}\nbreak;\n}\n}\n\nvoid ultrasoundOnEchoEdge() {\nauto nowMicros = LL_TIM_GetCounter(utsTimer);\n\nif (pinRead(utsEchoPin[utsActiveIndex])) {\nrisingMicros = nowMicros;\n} else if (risingMicros &gt; 0) {\nuint32_t resultMicros = nowMicros - risingMicros;\nif (nowMicros &lt; risingMicros) {\nresultMicros = 0;\n}\n\nBaseType_t woken = 0;\nxTaskNotifyFromISR(\nutsTask.handle(), resultMicros, eSetValueWithoutOverwrite, &amp;woken);\nportYIELD_FROM_ISR(woken);\n}\n}\n\nvoid ultrasoundReset() { trigQueue.reset(); }\n</code></pre>"},{"location":"apiStm/UsbCdcDescriptors_8c/","title":"File UsbCdcDescriptors.c","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; src &gt; UsbCdcDescriptors.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include \"usb.h\"</code></li> </ul>"},{"location":"apiStm/UsbCdcDescriptors_8c/#public-attributes","title":"Public Attributes","text":"Type Name const struct usb_string_descriptor cdc_iface_desc_en   = = USB_STRING_DESC(\"RBCX ESP32 Tunnel\") const struct usb_string_descriptor debug_iface_desc_en   = = USB_STRING_DESC(\"RBCX Debug UART\") const struct usb_string_descriptor lang_desc   = = USB_ARRAY_DESC(USB_LANGID_ENG_US) const struct usb_string_descriptor manuf_desc_en   = = USB_STRING_DESC(\"robotikabrno.cz\") const struct usb_string_descriptor prod_desc_en   = = USB_STRING_DESC(\"RBCX\") struct usb_string_descriptor serial_number_desc_en   = = USB_STRING_DESC(\"ffffffffffffffffffffffff\")"},{"location":"apiStm/UsbCdcDescriptors_8c/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/UsbCdcDescriptors_8c/#variable-cdc_iface_desc_en","title":"variable cdc_iface_desc_en","text":"<pre><code>const struct usb_string_descriptor cdc_iface_desc_en;\n</code></pre>"},{"location":"apiStm/UsbCdcDescriptors_8c/#variable-debug_iface_desc_en","title":"variable debug_iface_desc_en","text":"<pre><code>const struct usb_string_descriptor debug_iface_desc_en;\n</code></pre>"},{"location":"apiStm/UsbCdcDescriptors_8c/#variable-lang_desc","title":"variable lang_desc","text":"<pre><code>const struct usb_string_descriptor lang_desc;\n</code></pre>"},{"location":"apiStm/UsbCdcDescriptors_8c/#variable-manuf_desc_en","title":"variable manuf_desc_en","text":"<pre><code>const struct usb_string_descriptor manuf_desc_en;\n</code></pre>"},{"location":"apiStm/UsbCdcDescriptors_8c/#variable-prod_desc_en","title":"variable prod_desc_en","text":"<pre><code>const struct usb_string_descriptor prod_desc_en;\n</code></pre>"},{"location":"apiStm/UsbCdcDescriptors_8c/#variable-serial_number_desc_en","title":"variable serial_number_desc_en","text":"<pre><code>struct usb_string_descriptor serial_number_desc_en;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/UsbCdcDescriptors.c</code></p>"},{"location":"apiStm/UsbCdcDescriptors_8c_source/","title":"File UsbCdcDescriptors.c","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; src &gt; UsbCdcDescriptors.c</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;stdint.h&gt;\n\n#include \"usb.h\"\n\nconst struct usb_string_descriptor lang_desc\n= USB_ARRAY_DESC(USB_LANGID_ENG_US);\nconst struct usb_string_descriptor manuf_desc_en\n= USB_STRING_DESC(\"robotikabrno.cz\");\nconst struct usb_string_descriptor prod_desc_en = USB_STRING_DESC(\"RBCX\");\nconst struct usb_string_descriptor cdc_iface_desc_en\n= USB_STRING_DESC(\"RBCX ESP32 Tunnel\");\nconst struct usb_string_descriptor debug_iface_desc_en\n= USB_STRING_DESC(\"RBCX Debug UART\");\nstruct usb_string_descriptor serial_number_desc_en\n= USB_STRING_DESC(\"ffffffffffffffffffffffff\");\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/","title":"File UsbCdcLink.cpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; src &gt; UsbCdcLink.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdbool.h&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;string.h&gt;</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"CdcUartTunnel.hpp\"</code></li> <li><code>#include \"Esp32Manager.hpp\"</code></li> <li><code>#include \"UsbCdcLink.h\"</code></li> <li><code>#include \"usb_cdc.h\"</code></li> <li><code>#include \"utils/Debug.hpp\"</code></li> </ul>"},{"location":"apiStm/UsbCdcLink_8cpp/#classes","title":"Classes","text":"Type Name struct __debug_descriptors struct cdc_config"},{"location":"apiStm/UsbCdcLink_8cpp/#public-types","title":"Public Types","text":"Type Name enum @2 Implements USB CDC using libusb_stm. enum @3"},{"location":"apiStm/UsbCdcLink_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name const struct usb_string_descriptor cdc_iface_desc_en struct usb_config_descriptor config const struct usb_string_descriptor debug_iface_desc_en const struct usb_string_descriptor lang_desc const struct usb_string_descriptor manuf_desc_en const struct usb_string_descriptor prod_desc_en struct usb_string_descriptor serial_number_desc_en struct usb_cdc_acm_desc tunnel_cdc_acm struct usb_cdc_header_desc tunnel_cdc_hdr struct usb_cdc_call_mgmt_desc tunnel_cdc_mgmt struct usb_cdc_union_desc tunnel_cdc_union struct usb_interface_descriptor tunnel_comm struct usb_endpoint_descriptor tunnel_comm_ep struct usb_iad_descriptor tunnel_comm_iad struct usb_interface_descriptor tunnel_data struct usb_endpoint_descriptor tunnel_data_eprx struct usb_endpoint_descriptor tunnel_data_eptx usbd_device udev"},{"location":"apiStm/UsbCdcLink_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr size_t DebugDescriptorsSize   = = sizeof(__debug_descriptors) struct usb_cdc_line_coding cdc_line_debug   = = { .dwDTERate = 115200, .bCharFormat = USB_CDC_1_STOP_BITS, .bParityType = USB_CDC_NO_PARITY, .bDataBits = 8, } struct usb_cdc_line_coding cdc_line_tunnel   = = { .dwDTERate = 115200, .bCharFormat = USB_CDC_1_STOP_BITS, .bParityType = USB_CDC_NO_PARITY, .bDataBits = 8, } struct cdc_config config_desc const struct usb_device_descriptor device_desc   = = { .bLength = sizeof(struct usb_device_descriptor), .bDescriptorType = USB_DTYPE_DEVICE, .bcdUSB = VERSION_BCD(2, 0, 0), .bDeviceClass = USB_CLASS_IAD, .bDeviceSubClass = USB_SUBCLASS_IAD, .bDeviceProtocol = USB_PROTO_IAD, .bMaxPacketSize0 = CDC_EP0_SIZE, .idVendor = 0x0483, .idProduct = 0x5740, .bcdDevice = VERSION_BCD(1, 0, 0), .iManufacturer = STRDESC_MANUFACTURER, .iProduct = STRDESC_PRODUCT, .iSerialNumber = STRDESC_SERIAL, .bNumConfigurations = 1, } const struct usb_string_descriptor *const dtable   = = { &amp;lang_desc, &amp;manuf_desc_en, &amp;prod_desc_en, &amp;cdc_iface_desc_en, &amp;debug_iface_desc_en, &amp;serial_number_desc_en, } bool enableDebugEp   = = false uint32_t ubuf"},{"location":"apiStm/UsbCdcLink_8cpp/#public-functions","title":"Public Functions","text":"Type Name void USB_LP_IRQ_HANDLER (void)  struct __debug_descriptors __attribute__ ((packed))  void cdcLinkInit ()  bool cdcLinkIsDebugEpEnabled ()"},{"location":"apiStm/UsbCdcLink_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name usbd_respond cdc_control (usbd_device * dev, usbd_ctlreq * req, usbd_rqc_callback * callback)  usbd_respond cdc_control_debug (usbd_device * dev, usbd_ctlreq * req)  usbd_respond cdc_control_tunnel (usbd_device * dev, usbd_ctlreq * req)  usbd_respond cdc_getdesc (usbd_ctlreq * req, void ** address, uint16_t * length)  usbd_respond cdc_setconf (usbd_device * dev, uint8_t cfg)  void tunnel_check_for_dfu_request (const struct usb_cdc_line_coding * coding)"},{"location":"apiStm/UsbCdcLink_8cpp/#macros","title":"Macros","text":"Type Name define DEBUG_DESCRIPTORS"},{"location":"apiStm/UsbCdcLink_8cpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiStm/UsbCdcLink_8cpp/#enum-2","title":"enum @2","text":"<pre><code>enum @2 {\nSTRDESC_LANG,\nSTRDESC_MANUFACTURER,\nSTRDESC_PRODUCT,\nSTRDESC_CDC_IFACE,\nSTRDESC_DEBUG_IFACE,\nSTRDESC_SERIAL,\nSTRDESC_MAX\n};\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#enum-3","title":"enum @3","text":"<pre><code>enum @3 {\nINTERFACE_TUNNEL_COMM,\nINTERFACE_TUNNEL_DATA,\nINTERFACE_DEBUG_COMM,\nINTERFACE_DEBUG_DATA,\nINTERFACE_COUNT_ALL,\nINTERFACE_COUNT_NODEBUG = INTERFACE_DEBUG_COMM\n};\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiStm/UsbCdcLink_8cpp/#variable-cdc_iface_desc_en","title":"variable cdc_iface_desc_en","text":"<pre><code>const struct usb_string_descriptor cdc_iface_desc_en;\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#variable-config","title":"variable config","text":"<pre><code>struct usb_config_descriptor config;\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#variable-debug_iface_desc_en","title":"variable debug_iface_desc_en","text":"<pre><code>const struct usb_string_descriptor debug_iface_desc_en;\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#variable-lang_desc","title":"variable lang_desc","text":"<pre><code>const struct usb_string_descriptor lang_desc;\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#variable-manuf_desc_en","title":"variable manuf_desc_en","text":"<pre><code>const struct usb_string_descriptor manuf_desc_en;\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#variable-prod_desc_en","title":"variable prod_desc_en","text":"<pre><code>const struct usb_string_descriptor prod_desc_en;\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#variable-serial_number_desc_en","title":"variable serial_number_desc_en","text":"<pre><code>struct usb_string_descriptor serial_number_desc_en;\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#variable-tunnel_cdc_acm","title":"variable tunnel_cdc_acm","text":"<pre><code>struct usb_cdc_acm_desc tunnel_cdc_acm;\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#variable-tunnel_cdc_hdr","title":"variable tunnel_cdc_hdr","text":"<pre><code>struct usb_cdc_header_desc tunnel_cdc_hdr;\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#variable-tunnel_cdc_mgmt","title":"variable tunnel_cdc_mgmt","text":"<pre><code>struct usb_cdc_call_mgmt_desc tunnel_cdc_mgmt;\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#variable-tunnel_cdc_union","title":"variable tunnel_cdc_union","text":"<pre><code>struct usb_cdc_union_desc tunnel_cdc_union;\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#variable-tunnel_comm","title":"variable tunnel_comm","text":"<pre><code>struct usb_interface_descriptor tunnel_comm;\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#variable-tunnel_comm_ep","title":"variable tunnel_comm_ep","text":"<pre><code>struct usb_endpoint_descriptor tunnel_comm_ep;\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#variable-tunnel_comm_iad","title":"variable tunnel_comm_iad","text":"<pre><code>struct usb_iad_descriptor tunnel_comm_iad;\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#variable-tunnel_data","title":"variable tunnel_data","text":"<pre><code>struct usb_interface_descriptor tunnel_data;\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#variable-tunnel_data_eprx","title":"variable tunnel_data_eprx","text":"<pre><code>struct usb_endpoint_descriptor tunnel_data_eprx;\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#variable-tunnel_data_eptx","title":"variable tunnel_data_eptx","text":"<pre><code>struct usb_endpoint_descriptor tunnel_data_eptx;\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#variable-udev","title":"variable udev","text":"<pre><code>usbd_device udev;\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"apiStm/UsbCdcLink_8cpp/#variable-debugdescriptorssize","title":"variable DebugDescriptorsSize","text":"<pre><code>constexpr size_t DebugDescriptorsSize;\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#variable-cdc_line_debug","title":"variable cdc_line_debug","text":"<pre><code>struct usb_cdc_line_coding cdc_line_debug;\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#variable-cdc_line_tunnel","title":"variable cdc_line_tunnel","text":"<pre><code>struct usb_cdc_line_coding cdc_line_tunnel;\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#variable-config_desc","title":"variable config_desc","text":"<pre><code>struct cdc_config config_desc;\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#variable-device_desc","title":"variable device_desc","text":"<pre><code>const struct usb_device_descriptor device_desc;\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#variable-dtable","title":"variable dtable","text":"<pre><code>const struct usb_string_descriptor* const dtable[STRDESC_MAX];\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#variable-enabledebugep","title":"variable enableDebugEp","text":"<pre><code>bool enableDebugEp;\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#variable-ubuf","title":"variable ubuf","text":"<pre><code>uint32_t ubuf[0x20];\n</code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/UsbCdcLink_8cpp/#function-usb_lp_irq_handler","title":"function USB_LP_IRQ_HANDLER","text":"<pre><code>void USB_LP_IRQ_HANDLER (\nvoid\n) </code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#function-__attribute__","title":"function __attribute__","text":"<pre><code>struct __debug_descriptors __attribute__ (\n(packed)\n) </code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#function-cdclinkinit","title":"function cdcLinkInit","text":"<pre><code>void cdcLinkInit () </code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#function-cdclinkisdebugepenabled","title":"function cdcLinkIsDebugEpEnabled","text":"<pre><code>bool cdcLinkIsDebugEpEnabled () </code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"apiStm/UsbCdcLink_8cpp/#function-cdc_control","title":"function cdc_control","text":"<pre><code>static usbd_respond cdc_control (\nusbd_device * dev,\nusbd_ctlreq * req,\nusbd_rqc_callback * callback\n) </code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#function-cdc_control_debug","title":"function cdc_control_debug","text":"<pre><code>static usbd_respond cdc_control_debug (\nusbd_device * dev,\nusbd_ctlreq * req\n) </code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#function-cdc_control_tunnel","title":"function cdc_control_tunnel","text":"<pre><code>static usbd_respond cdc_control_tunnel (\nusbd_device * dev,\nusbd_ctlreq * req\n) </code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#function-cdc_getdesc","title":"function cdc_getdesc","text":"<pre><code>static usbd_respond cdc_getdesc (\nusbd_ctlreq * req,\nvoid ** address,\nuint16_t * length\n) </code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#function-cdc_setconf","title":"function cdc_setconf","text":"<pre><code>static usbd_respond cdc_setconf (\nusbd_device * dev,\nuint8_t cfg\n) </code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#function-tunnel_check_for_dfu_request","title":"function tunnel_check_for_dfu_request","text":"<pre><code>static void tunnel_check_for_dfu_request (\nconst struct usb_cdc_line_coding * coding\n) </code></pre>"},{"location":"apiStm/UsbCdcLink_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiStm/UsbCdcLink_8cpp/#define-debug_descriptors","title":"define DEBUG_DESCRIPTORS","text":"<pre><code>#define DEBUG_DESCRIPTORS struct usb_iad_descriptor debug_comm_iad;                                  \\\n    struct usb_interface_descriptor debug_comm;                                \\\n    struct usb_cdc_header_desc debug_cdc_hdr;                                  \\\n    struct usb_cdc_call_mgmt_desc debug_cdc_mgmt;                              \\\n    struct usb_cdc_acm_desc debug_cdc_acm;                                     \\\n    struct usb_cdc_union_desc debug_cdc_union;                                 \\\n    struct usb_endpoint_descriptor debug_comm_ep;                              \\\n    struct usb_interface_descriptor debug_data;                                \\\n    struct usb_endpoint_descriptor debug_data_eprx;                            \\\n    struct usb_endpoint_descriptor debug_data_eptx;\n</code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/UsbCdcLink.cpp</code></p>"},{"location":"apiStm/UsbCdcLink_8cpp_source/","title":"File UsbCdcLink.cpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; src &gt; UsbCdcLink.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;stdbool.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;string.h&gt;\n\n#include \"Bsp.hpp\"\n#include \"CdcUartTunnel.hpp\"\n#include \"Esp32Manager.hpp\"\n#include \"UsbCdcLink.h\"\n#include \"usb_cdc.h\"\n#include \"utils/Debug.hpp\"\n\nenum {\nSTRDESC_LANG,\nSTRDESC_MANUFACTURER,\nSTRDESC_PRODUCT,\nSTRDESC_CDC_IFACE,\nSTRDESC_DEBUG_IFACE,\nSTRDESC_SERIAL,\n\nSTRDESC_MAX,\n};\n\nenum {\nINTERFACE_TUNNEL_COMM,\nINTERFACE_TUNNEL_DATA,\nINTERFACE_DEBUG_COMM,\nINTERFACE_DEBUG_DATA,\n\nINTERFACE_COUNT_ALL,\nINTERFACE_COUNT_NODEBUG = INTERFACE_DEBUG_COMM,\n};\n\nextern \"C\" {\nextern const struct usb_string_descriptor lang_desc;\nextern const struct usb_string_descriptor manuf_desc_en;\nextern const struct usb_string_descriptor prod_desc_en;\nextern const struct usb_string_descriptor cdc_iface_desc_en;\nextern const struct usb_string_descriptor debug_iface_desc_en;\nextern struct usb_string_descriptor serial_number_desc_en;\n};\n\nstatic const struct usb_string_descriptor* const dtable[STRDESC_MAX] = {\n&amp;lang_desc,\n&amp;manuf_desc_en,\n&amp;prod_desc_en,\n&amp;cdc_iface_desc_en,\n&amp;debug_iface_desc_en,\n&amp;serial_number_desc_en,\n};\n\n#define DEBUG_DESCRIPTORS                                                      \\\n    struct usb_iad_descriptor debug_comm_iad;                                  \\\n    struct usb_interface_descriptor debug_comm;                                \\\n    struct usb_cdc_header_desc debug_cdc_hdr;                                  \\\n    struct usb_cdc_call_mgmt_desc debug_cdc_mgmt;                              \\\n    struct usb_cdc_acm_desc debug_cdc_acm;                                     \\\n    struct usb_cdc_union_desc debug_cdc_union;                                 \\\n    struct usb_endpoint_descriptor debug_comm_ep;                              \\\n    struct usb_interface_descriptor debug_data;                                \\\n    struct usb_endpoint_descriptor debug_data_eprx;                            \\\n    struct usb_endpoint_descriptor debug_data_eptx;\n\nstruct __debug_descriptors {\nDEBUG_DESCRIPTORS\n} __attribute__((packed));\n\nstatic constexpr size_t DebugDescriptorsSize = sizeof(__debug_descriptors);\n\nstruct cdc_config {\nstruct usb_config_descriptor config;\n\nstruct usb_iad_descriptor tunnel_comm_iad;\nstruct usb_interface_descriptor tunnel_comm;\nstruct usb_cdc_header_desc tunnel_cdc_hdr;\nstruct usb_cdc_call_mgmt_desc tunnel_cdc_mgmt;\nstruct usb_cdc_acm_desc tunnel_cdc_acm;\nstruct usb_cdc_union_desc tunnel_cdc_union;\nstruct usb_endpoint_descriptor tunnel_comm_ep;\nstruct usb_interface_descriptor tunnel_data;\nstruct usb_endpoint_descriptor tunnel_data_eprx;\nstruct usb_endpoint_descriptor tunnel_data_eptx;\n\nDEBUG_DESCRIPTORS\n} __attribute__((packed));\n\nstatic const struct usb_device_descriptor device_desc = {\n.bLength = sizeof(struct usb_device_descriptor),\n.bDescriptorType = USB_DTYPE_DEVICE,\n.bcdUSB = VERSION_BCD(2, 0, 0),\n.bDeviceClass = USB_CLASS_IAD,\n.bDeviceSubClass = USB_SUBCLASS_IAD,\n.bDeviceProtocol = USB_PROTO_IAD,\n.bMaxPacketSize0 = CDC_EP0_SIZE,\n.idVendor = 0x0483,\n.idProduct = 0x5740,\n.bcdDevice = VERSION_BCD(1, 0, 0),\n.iManufacturer = STRDESC_MANUFACTURER,\n.iProduct = STRDESC_PRODUCT,\n.iSerialNumber = STRDESC_SERIAL,\n.bNumConfigurations = 1,\n};\n\nstatic struct cdc_config config_desc = {\n.config = {\n.bLength = sizeof(struct usb_config_descriptor),\n.bDescriptorType = USB_DTYPE_CONFIGURATION,\n.wTotalLength = sizeof(struct cdc_config),\n.bNumInterfaces = INTERFACE_COUNT_ALL,\n.bConfigurationValue = 1,\n.iConfiguration = NO_DESCRIPTOR,\n.bmAttributes = USB_CFG_ATTR_RESERVED | USB_CFG_ATTR_SELFPOWERED,\n.bMaxPower = USB_CFG_POWER_MA(100),\n},\n\n.tunnel_comm_iad = {\n.bLength = sizeof(struct usb_iad_descriptor),\n.bDescriptorType = USB_DTYPE_INTERFASEASSOC,\n.bFirstInterface = INTERFACE_TUNNEL_COMM,\n.bInterfaceCount = 2,\n.bFunctionClass = USB_CLASS_CDC,\n.bFunctionSubClass = USB_CDC_SUBCLASS_ACM,\n.bFunctionProtocol = USB_PROTO_NONE,\n.iFunction = NO_DESCRIPTOR,\n},\n.tunnel_comm = {\n.bLength = sizeof(struct usb_interface_descriptor),\n.bDescriptorType = USB_DTYPE_INTERFACE,\n.bInterfaceNumber = INTERFACE_TUNNEL_COMM,\n.bAlternateSetting = 0,\n.bNumEndpoints = 1,\n.bInterfaceClass = USB_CLASS_CDC,\n.bInterfaceSubClass = USB_CDC_SUBCLASS_ACM,\n.bInterfaceProtocol = USB_PROTO_NONE,\n.iInterface = NO_DESCRIPTOR,\n},\n.tunnel_cdc_hdr = {\n.bFunctionLength = sizeof(struct usb_cdc_header_desc),\n.bDescriptorType = USB_DTYPE_CS_INTERFACE,\n.bDescriptorSubType = USB_DTYPE_CDC_HEADER,\n.bcdCDC = VERSION_BCD(1, 1, 0),\n},\n.tunnel_cdc_mgmt = {\n.bFunctionLength = sizeof(struct usb_cdc_call_mgmt_desc),\n.bDescriptorType = USB_DTYPE_CS_INTERFACE,\n.bDescriptorSubType = USB_DTYPE_CDC_CALL_MANAGEMENT,\n.bmCapabilities = 0,\n.bDataInterface = INTERFACE_TUNNEL_DATA,\n},\n.tunnel_cdc_acm = {\n.bFunctionLength = sizeof(struct usb_cdc_acm_desc),\n.bDescriptorType = USB_DTYPE_CS_INTERFACE,\n.bDescriptorSubType = USB_DTYPE_CDC_ACM,\n.bmCapabilities = 0,\n},\n.tunnel_cdc_union = {\n.bFunctionLength = sizeof(struct usb_cdc_union_desc),\n.bDescriptorType = USB_DTYPE_CS_INTERFACE,\n.bDescriptorSubType = USB_DTYPE_CDC_UNION,\n.bMasterInterface0 = INTERFACE_TUNNEL_COMM,\n.bSlaveInterface0 = INTERFACE_TUNNEL_DATA,\n},\n.tunnel_comm_ep = {\n.bLength = sizeof(struct usb_endpoint_descriptor),\n.bDescriptorType = USB_DTYPE_ENDPOINT,\n.bEndpointAddress = CDC_TUNNEL_NTF_EP,\n.bmAttributes = USB_EPTYPE_INTERRUPT,\n.wMaxPacketSize = CDC_NTF_SZ,\n.bInterval = 0xFF,\n},\n.tunnel_data = {\n.bLength = sizeof(struct usb_interface_descriptor),\n.bDescriptorType = USB_DTYPE_INTERFACE,\n.bInterfaceNumber = INTERFACE_TUNNEL_DATA,\n.bAlternateSetting = 0,\n.bNumEndpoints = 2,\n.bInterfaceClass = USB_CLASS_CDC_DATA,\n.bInterfaceSubClass = USB_SUBCLASS_NONE,\n.bInterfaceProtocol = USB_PROTO_NONE,\n.iInterface = STRDESC_CDC_IFACE,\n},\n.tunnel_data_eprx = {\n.bLength = sizeof(struct usb_endpoint_descriptor),\n.bDescriptorType = USB_DTYPE_ENDPOINT,\n.bEndpointAddress = CDC_TUNNEL_RXD_EP,\n.bmAttributes = USB_EPTYPE_BULK,\n.wMaxPacketSize = CDC_DATA_SZ,\n.bInterval = 0x01,\n},\n.tunnel_data_eptx = {\n.bLength = sizeof(struct usb_endpoint_descriptor),\n.bDescriptorType = USB_DTYPE_ENDPOINT,\n.bEndpointAddress = CDC_TUNNEL_TXD_EP,\n.bmAttributes = USB_EPTYPE_BULK,\n.wMaxPacketSize = CDC_DATA_SZ,\n.bInterval = 0x01,\n},\n\n\n.debug_comm_iad = {\n.bLength = sizeof(struct usb_iad_descriptor),\n.bDescriptorType = USB_DTYPE_INTERFASEASSOC,\n.bFirstInterface = INTERFACE_DEBUG_COMM,\n.bInterfaceCount = 2,\n.bFunctionClass = USB_CLASS_CDC,\n.bFunctionSubClass = USB_CDC_SUBCLASS_ACM,\n.bFunctionProtocol = USB_PROTO_NONE,\n.iFunction = NO_DESCRIPTOR,\n},\n.debug_comm = {\n.bLength = sizeof(struct usb_interface_descriptor),\n.bDescriptorType = USB_DTYPE_INTERFACE,\n.bInterfaceNumber = INTERFACE_DEBUG_COMM,\n.bAlternateSetting = 0,\n.bNumEndpoints = 1,\n.bInterfaceClass = USB_CLASS_CDC,\n.bInterfaceSubClass = USB_CDC_SUBCLASS_ACM,\n.bInterfaceProtocol = USB_PROTO_NONE,\n.iInterface = NO_DESCRIPTOR,\n},\n.debug_cdc_hdr = {\n.bFunctionLength = sizeof(struct usb_cdc_header_desc),\n.bDescriptorType = USB_DTYPE_CS_INTERFACE,\n.bDescriptorSubType = USB_DTYPE_CDC_HEADER,\n.bcdCDC = VERSION_BCD(1, 1, 0),\n},\n.debug_cdc_mgmt = {\n.bFunctionLength = sizeof(struct usb_cdc_call_mgmt_desc),\n.bDescriptorType = USB_DTYPE_CS_INTERFACE,\n.bDescriptorSubType = USB_DTYPE_CDC_CALL_MANAGEMENT,\n.bmCapabilities = 0,\n.bDataInterface = INTERFACE_DEBUG_DATA,\n},\n.debug_cdc_acm = {\n.bFunctionLength = sizeof(struct usb_cdc_acm_desc),\n.bDescriptorType = USB_DTYPE_CS_INTERFACE,\n.bDescriptorSubType = USB_DTYPE_CDC_ACM,\n.bmCapabilities = 0,\n},\n.debug_cdc_union = {\n.bFunctionLength = sizeof(struct usb_cdc_union_desc),\n.bDescriptorType = USB_DTYPE_CS_INTERFACE,\n.bDescriptorSubType = USB_DTYPE_CDC_UNION,\n.bMasterInterface0 = INTERFACE_DEBUG_COMM,\n.bSlaveInterface0 = INTERFACE_DEBUG_DATA,\n},\n.debug_comm_ep = {\n.bLength = sizeof(struct usb_endpoint_descriptor),\n.bDescriptorType = USB_DTYPE_ENDPOINT,\n.bEndpointAddress = CDC_DEBUG_NTF_EP,\n.bmAttributes = USB_EPTYPE_INTERRUPT,\n.wMaxPacketSize = CDC_NTF_SZ,\n.bInterval = 0xFF,\n},\n.debug_data = {\n.bLength = sizeof(struct usb_interface_descriptor),\n.bDescriptorType = USB_DTYPE_INTERFACE,\n.bInterfaceNumber = INTERFACE_DEBUG_DATA,\n.bAlternateSetting = 0,\n.bNumEndpoints = 2,\n.bInterfaceClass = USB_CLASS_CDC_DATA,\n.bInterfaceSubClass = USB_SUBCLASS_NONE,\n.bInterfaceProtocol = USB_PROTO_NONE,\n.iInterface = STRDESC_DEBUG_IFACE,\n},\n.debug_data_eprx = {\n.bLength = sizeof(struct usb_endpoint_descriptor),\n.bDescriptorType = USB_DTYPE_ENDPOINT,\n.bEndpointAddress = CDC_DEBUG_RXD_EP,\n.bmAttributes = USB_EPTYPE_BULK,\n.wMaxPacketSize = CDC_DATA_SZ,\n.bInterval = 0x01,\n},\n.debug_data_eptx = {\n.bLength = sizeof(struct usb_endpoint_descriptor),\n.bDescriptorType = USB_DTYPE_ENDPOINT,\n.bEndpointAddress = CDC_DEBUG_TXD_EP,\n.bmAttributes = USB_EPTYPE_BULK,\n.wMaxPacketSize = CDC_DATA_SZ,\n.bInterval = 0x01,\n},\n};\n\nusbd_device udev;\nstatic uint32_t ubuf[0x20];\nstatic bool enableDebugEp = false;\n\nstatic struct usb_cdc_line_coding cdc_line_tunnel = {\n.dwDTERate = 115200,\n.bCharFormat = USB_CDC_1_STOP_BITS,\n.bParityType = USB_CDC_NO_PARITY,\n.bDataBits = 8,\n};\n\nstatic struct usb_cdc_line_coding cdc_line_debug = {\n.dwDTERate = 115200,\n.bCharFormat = USB_CDC_1_STOP_BITS,\n.bParityType = USB_CDC_NO_PARITY,\n.bDataBits = 8,\n};\n\nstatic usbd_respond cdc_getdesc(\nusbd_ctlreq* req, void** address, uint16_t* length) {\nconst uint8_t dtype = req-&gt;wValue &gt;&gt; 8;\nconst uint8_t dnumber = req-&gt;wValue &amp; 0xFF;\nconst void* desc;\nuint16_t len = 0;\nswitch (dtype) {\ncase USB_DTYPE_DEVICE:\ndesc = &amp;device_desc;\nbreak;\ncase USB_DTYPE_CONFIGURATION:\ndesc = &amp;config_desc;\nlen = config_desc.config.wTotalLength;\nbreak;\ncase USB_DTYPE_STRING:\nif (dnumber &lt; STRDESC_MAX) {\ndesc = dtable[dnumber];\n} else {\nreturn usbd_fail;\n}\nbreak;\ndefault:\nreturn usbd_fail;\n}\nif (len == 0) {\nlen = ((struct usb_header_descriptor*)desc)-&gt;bLength;\n}\n*address = (void*)desc;\n*length = len;\nreturn usbd_ack;\n};\n\nstatic void tunnel_check_for_dfu_request(\nconst struct usb_cdc_line_coding* coding) {\n#ifdef RBCX_SBOOT\nif (coding-&gt;dwDTERate == 12345 &amp;&amp; coding-&gt;bParityType == USB_CDC_EVEN_PARITY\n&amp;&amp; coding-&gt;bCharFormat == USB_CDC_2_STOP_BITS) {\nrebootToDfu();\n}\n#endif\n}\n\nstatic usbd_respond cdc_control_tunnel(usbd_device* dev, usbd_ctlreq* req) {\nswitch (req-&gt;bRequest) {\ncase USB_CDC_SET_CONTROL_LINE_STATE: {\nconst bool dtr = req-&gt;wValue &amp; 0x01;\nconst bool rts = req-&gt;wValue &amp; 0x02;\n//DEBUG(\"CONTROL_LINE_STATE DTR %d RTS %d\\n\", (int)dtr, (int)rts);\nsEsp32Manager.onSerialBreakInIrq(dtr, rts);\nreturn usbd_ack;\n}\ncase USB_CDC_SET_LINE_CODING: {\nif (req-&gt;wLength &lt; sizeof(cdc_line_tunnel))\nreturn usbd_fail;\n\nauto* newCoding = (struct usb_cdc_line_coding*)req-&gt;data;\n\ntunnel_check_for_dfu_request(newCoding);\n\nif (!tunnelOnSetLineCodingInIrq(cdc_line_tunnel, *newCoding))\nreturn usbd_fail;\n\nmemcpy(&amp;cdc_line_tunnel, req-&gt;data, sizeof(cdc_line_tunnel));\n/*DEBUG(\"USB_CDC_SET_LINE_CODING %d %d %d %d\\n\",\n            cdc_line_tunnel.dwDTERate, cdc_line_tunnel.bCharFormat,\n            cdc_line_tunnel.bDataBits, cdc_line_tunnel.bParityType);*/\nreturn usbd_ack;\n}\ncase USB_CDC_GET_LINE_CODING:\ndev-&gt;status.data_ptr = &amp;cdc_line_tunnel;\ndev-&gt;status.data_count = sizeof(cdc_line_tunnel);\nreturn usbd_ack;\ndefault:\nreturn usbd_fail;\n}\n}\n\nstatic usbd_respond cdc_control_debug(usbd_device* dev, usbd_ctlreq* req) {\nswitch (req-&gt;bRequest) {\ncase USB_CDC_SET_CONTROL_LINE_STATE: {\nreturn usbd_ack;\n}\ncase USB_CDC_SET_LINE_CODING: {\nif (req-&gt;wLength &lt; sizeof(cdc_line_debug))\nreturn usbd_fail;\nmemcpy(&amp;cdc_line_debug, req-&gt;data, sizeof(cdc_line_debug));\n//DEBUG(\"USB_CDC_SET_LINE_CODING %d %d %d %d\\n\", cdc_line.dwDTERate,\n//  cdc_line.bCharFormat, cdc_line.bDataBits, cdc_line.bParityType);\nreturn usbd_ack;\n}\ncase USB_CDC_GET_LINE_CODING:\ndev-&gt;status.data_ptr = &amp;cdc_line_debug;\ndev-&gt;status.data_count = sizeof(cdc_line_debug);\nreturn usbd_ack;\ndefault:\nreturn usbd_fail;\n}\n}\n\nstatic usbd_respond cdc_control(\nusbd_device* dev, usbd_ctlreq* req, usbd_rqc_callback* callback) {\nif (((USB_REQ_RECIPIENT | USB_REQ_TYPE) &amp; req-&gt;bmRequestType)\n== (USB_REQ_INTERFACE | USB_REQ_CLASS)) {\nswitch (req-&gt;wIndex) {\ncase INTERFACE_TUNNEL_COMM:\nreturn cdc_control_tunnel(dev, req);\ncase INTERFACE_DEBUG_COMM:\nreturn cdc_control_debug(dev, req);\n}\n}\nreturn usbd_fail;\n}\n\nstatic usbd_respond cdc_setconf(usbd_device* dev, uint8_t cfg) {\nswitch (cfg) {\ncase 0:\n/* deconfiguring device */\nusbd_ep_deconfig(dev, CDC_TUNNEL_NTF_EP);\nusbd_ep_deconfig(dev, CDC_TUNNEL_TXD_EP);\nusbd_ep_deconfig(dev, CDC_TUNNEL_RXD_EP);\nif (enableDebugEp) {\nusbd_ep_deconfig(dev, CDC_DEBUG_NTF_EP);\nusbd_ep_deconfig(dev, CDC_DEBUG_TXD_EP);\nusbd_ep_deconfig(dev, CDC_DEBUG_RXD_EP);\n}\nreturn usbd_ack;\ncase 1:\n/* configuring device */\nusbd_ep_config(dev, CDC_TUNNEL_RXD_EP,\nUSB_EPTYPE_BULK /*| USB_EPTYPE_DBLBUF*/, CDC_DATA_SZ);\nusbd_ep_config(dev, CDC_TUNNEL_TXD_EP,\nUSB_EPTYPE_BULK /*| USB_EPTYPE_DBLBUF*/, CDC_DATA_SZ);\nusbd_ep_config(\ndev, CDC_TUNNEL_NTF_EP, USB_EPTYPE_INTERRUPT, CDC_NTF_SZ);\n\nif (enableDebugEp) {\nusbd_ep_config(dev, CDC_DEBUG_RXD_EP,\nUSB_EPTYPE_BULK /*| USB_EPTYPE_DBLBUF*/, CDC_DATA_SZ);\nusbd_ep_config(dev, CDC_DEBUG_TXD_EP,\nUSB_EPTYPE_BULK /*| USB_EPTYPE_DBLBUF*/, CDC_DATA_SZ);\nusbd_ep_config(\ndev, CDC_DEBUG_NTF_EP, USB_EPTYPE_INTERRUPT, CDC_NTF_SZ);\n}\nreturn usbd_ack;\ndefault:\nreturn usbd_fail;\n}\n}\n\nvoid cdcLinkInit() {\n__HAL_RCC_USB_CLK_ENABLE();\n\n// quickly charge Button capacitor\npinInit(button3Pin, GPIO_MODE_OUTPUT_PP, GPIO_PULLUP, GPIO_SPEED_FREQ_HIGH,\ntrue);\npinWrite(button3Pin, 1);\n\nstd::array&lt;uint32_t, 3&gt; uid;\nHAL_GetUID(uid.data());\n\nchar buf[9];\nsize_t sn_off = 0;\nfor (auto u : uid) {\nsnprintf(buf, sizeof(buf), \"%08lx\", u);\nfor (int i = 0; i &lt; 8; ++i) {\nserial_number_desc_en.wString[sn_off++] = buf[i];\n}\n}\n\n// reinit button and check\nfor (volatile int i = 0; i &lt; 5000; ++i)\n;\npinInit(\nbutton3Pin, GPIO_MODE_INPUT, GPIO_PULLUP, GPIO_SPEED_FREQ_LOW, true);\nenableDebugEp = !pinRead(button3Pin)\n|| (CoreDebug-&gt;DHCSR &amp; CoreDebug_DHCSR_C_DEBUGEN_Msk);\n\nif (enableDebugEp) {\nconfig_desc.config.bNumInterfaces = INTERFACE_COUNT_ALL;\nconfig_desc.config.wTotalLength = sizeof(config_desc);\n} else {\nconfig_desc.config.bNumInterfaces = INTERFACE_COUNT_NODEBUG;\nconfig_desc.config.wTotalLength\n= sizeof(config_desc) - DebugDescriptorsSize;\n}\n\nusbd_init(&amp;udev, &amp;usbd_hw, CDC_EP0_SIZE, ubuf, sizeof(ubuf));\nusbd_reg_config(&amp;udev, cdc_setconf);\nusbd_reg_control(&amp;udev, cdc_control);\nusbd_reg_descr(&amp;udev, cdc_getdesc);\n\nHAL_NVIC_SetPriority(usbLpIRQn, usbLpIRQnPrio, 0);\nHAL_NVIC_EnableIRQ(usbLpIRQn);\n\nusbd_enable(&amp;udev, true);\nusbd_connect(&amp;udev, true);\n}\n\nbool cdcLinkIsDebugEpEnabled() { return enableDebugEp; }\n\nextern \"C\" void USB_LP_IRQ_HANDLER(void) { usbd_poll(&amp;udev); }\n</code></pre>"},{"location":"apiStm/dir_7e38ef2b59a4add794f9b77518719cbf/","title":"Dir fw/rbcx-coprocessor/src/utils","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; src &gt; utils</p>"},{"location":"apiStm/dir_7e38ef2b59a4add794f9b77518719cbf/#files","title":"Files","text":"Type Name file Debug.cpp <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/utils/</code></p>"},{"location":"apiStm/Debug_8cpp/","title":"File Debug.cpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; src &gt; utils &gt; Debug.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"utils/Debug.hpp\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"UsbCdcLink.h\"</code></li> </ul>"},{"location":"apiStm/Debug_8cpp/#public-functions","title":"Public Functions","text":"Type Name void rebootToDfu ()"},{"location":"apiStm/Debug_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/Debug_8cpp/#function-reboottodfu","title":"function rebootToDfu","text":"<pre><code>void rebootToDfu () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/utils/Debug.cpp</code></p>"},{"location":"apiStm/Debug_8cpp_source/","title":"File Debug.cpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; src &gt; utils &gt; Debug.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"utils/Debug.hpp\"\n#include \"Bsp.hpp\"\n#include \"UsbCdcLink.h\"\n\nvoid rebootToDfu() {\n#ifdef RBCX_SBOOT\n__disable_irq();\n\nusbd_connect(&amp;udev, false);\n\nvolatile uint32_t* st = (uint32_t*)0x02000bffc; // __stack\n*st = 0x157F32D4; // DFU_BOOTKEY\n\nNVIC_SystemReset();\n#else\nabort();\n#endif\n}\n</code></pre>"},{"location":"apiStm/main_8cpp/","title":"File main.cpp","text":"<p>FileList &gt; fw &gt; rbcx-coprocessor &gt; src &gt; main.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include \"stm32f1xx_hal.h\"</code></li> <li><code>#include \"utils/Debug.hpp\"</code></li> <li><code>#include \"utils/TaskWrapper.hpp\"</code></li> <li><code>#include \"ButtonController.hpp\"</code></li> <li><code>#include \"I2cController.hpp\"</code></li> <li><code>#include \"MotorController.hpp\"</code></li> <li><code>#include \"MpuController.hpp\"</code></li> <li><code>#include \"OledController.hpp\"</code></li> <li><code>#include \"StupidServoController.hpp\"</code></li> <li><code>#include \"UltrasoundController.hpp\"</code></li> <li><code>#include \"Bsp.hpp\"</code></li> <li><code>#include \"CdcUartTunnel.hpp\"</code></li> <li><code>#include \"ControlLink.hpp\"</code></li> <li><code>#include \"DebugLink.hpp\"</code></li> <li><code>#include \"Dispatcher.hpp\"</code></li> <li><code>#include \"Esp32Manager.hpp\"</code></li> <li><code>#include \"Power.hpp\"</code></li> <li><code>#include \"SmartServoController.hpp\"</code></li> <li><code>#include \"UsbCdcLink.h\"</code></li> </ul>"},{"location":"apiStm/main_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name TaskWrapper&lt; 3072 &gt; mainTask"},{"location":"apiStm/main_8cpp/#public-functions","title":"Public Functions","text":"Type Name int main ()"},{"location":"apiStm/main_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"apiStm/main_8cpp/#variable-maintask","title":"variable mainTask","text":"<pre><code>TaskWrapper&lt;3072&gt; mainTask;\n</code></pre>"},{"location":"apiStm/main_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiStm/main_8cpp/#function-main","title":"function main","text":"<pre><code>int main () </code></pre> <p>The documentation for this class was generated from the following file <code>fw/rbcx-coprocessor/src/main.cpp</code></p>"},{"location":"apiStm/main_8cpp_source/","title":"File main.cpp","text":"<p>File List &gt; fw &gt; rbcx-coprocessor &gt; src &gt; main.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;array&gt;\n\n#include \"stm32f1xx_hal.h\"\n\n#include \"utils/Debug.hpp\"\n#include \"utils/TaskWrapper.hpp\"\n\n#include \"ButtonController.hpp\"\n#include \"I2cController.hpp\"\n#include \"MotorController.hpp\"\n#include \"MpuController.hpp\"\n#include \"OledController.hpp\"\n#include \"StupidServoController.hpp\"\n#include \"UltrasoundController.hpp\"\n\n#include \"Bsp.hpp\"\n#include \"CdcUartTunnel.hpp\"\n#include \"ControlLink.hpp\"\n#include \"DebugLink.hpp\"\n#include \"Dispatcher.hpp\"\n#include \"Esp32Manager.hpp\"\n#include \"Power.hpp\"\n#include \"SmartServoController.hpp\"\n#include \"UsbCdcLink.h\"\n\nstatic TaskWrapper&lt;3072&gt; mainTask;\n\nint main() {\nclocksInit();\nHAL_Init();\n\n#ifdef RBCX_VECT_TAB_OFFSET\nSCB-&gt;VTOR = FLASH_BASE | RBCX_VECT_TAB_OFFSET;\n#endif\n\npinsInit();\n\nmainTask.start(\"main\", mainTaskPrio, []() {\ndebugUartInit();\nsoftResetInit();\npowerInit();\ndispatcherInit();\ntunnelUartInit();\ncontrolUartInit();\ncdcLinkInit();\nI2Cdev_init();\nsmartServoInit();\nstupidServoInit();\nultrasoundInit();\nmpuCreate();\nsEsp32Manager.init();\nmotorInit();\n\nDEBUG(\"STM32 Coprocessor initialized, v%06x \" RBCX_VER_REVISION\nRBCX_VER_DIRTY_STR \"\\n\",\nRBCX_VER_NUMBER);\nwhile (true) {\nvTaskDelay(pdMS_TO_TICKS(1));\ndebugLinkPoll();\npowerPoll();\ndispatcherPoll();\ntunnelPoll();\nbuttonControllerPoll();\nsmartServoPoll();\nsEsp32Manager.poll();\n}\n});\n\nvTaskStartScheduler();\nabort();\n}\n</code></pre>"},{"location":"apiStm/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"apiStm/classes/","title":"Class Index","text":""},{"location":"apiStm/classes/#a","title":"a","text":"<ul> <li>A_BLOCK_LINK</li> </ul>"},{"location":"apiStm/classes/#b","title":"b","text":"<ul> <li>BasePriorityRaiser</li> <li>ByteFifo</li> </ul>"},{"location":"apiStm/classes/#c","title":"c","text":"<ul> <li>CalibrationData</li> <li>cdc_config</li> <li>corCoRoutineControlBlock</li> </ul>"},{"location":"apiStm/classes/#e","title":"e","text":"<ul> <li>Esp32Manager</li> <li>EventGroupDef_t</li> </ul>"},{"location":"apiStm/classes/#f","title":"f","text":"<ul> <li>FontDef</li> </ul>"},{"location":"apiStm/classes/#h","title":"h","text":"<ul> <li>HeapRegion</li> </ul>"},{"location":"apiStm/classes/#m","title":"m","text":"<ul> <li>MessageBufferWrapper</li> <li>Motor</li> <li>MutexWrapper</li> <li>MPU6050_t</li> <li>MpuMotion32</li> <li>MpuMotion6</li> <li>MpuVector</li> <li>MpuVector32</li> <li>mpu_t</li> </ul>"},{"location":"apiStm/classes/#o","title":"o","text":"<ul> <li>OLED_VERTEX</li> <li>OLED_t</li> </ul>"},{"location":"apiStm/classes/#q","title":"q","text":"<ul> <li>QueueWrapper</li> <li>QueueDefinition</li> <li>QueuePointers</li> </ul>"},{"location":"apiStm/classes/#r","title":"r","text":"<ul> <li>Regulator</li> </ul>"},{"location":"apiStm/classes/#s","title":"s","text":"<ul> <li>StreamBufferWrapper</li> <li>SemaphoreData</li> <li>StreamBufferDef_t</li> </ul>"},{"location":"apiStm/classes/#t","title":"t","text":"<ul> <li>TaskWrapper</li> <li>TickTimer</li> <li>tskTaskControlBlock</li> </ul>"},{"location":"apiStm/classes/#u","title":"u","text":"<ul> <li>usb_cdc_acm_desc</li> <li>usb_cdc_call_mgmt_desc</li> <li>usb_cdc_country_desc</li> <li>usb_cdc_header_desc</li> <li>usb_cdc_line_coding</li> <li>usb_cdc_notification</li> <li>usb_cdc_union_desc</li> <li>usb_config_descriptor</li> <li>usb_debug_descriptor</li> <li>usb_device_descriptor</li> <li>usb_endpoint_descriptor</li> <li>usb_header_descriptor</li> <li>usb_iad_descriptor</li> <li>usb_interface_descriptor</li> <li>usb_qualifier_descriptor</li> <li>usb_string_descriptor</li> <li>usbd_ctlreq</li> <li>usbd_driver</li> <li>usbd_status</li> </ul>"},{"location":"apiStm/classes/#x","title":"x","text":"<ul> <li>XorShift</li> <li>xHeapStats</li> <li>xLIST</li> <li>xLIST_ITEM</li> <li>xMEMORY_REGION</li> <li>xMINI_LIST_ITEM</li> <li>xSTATIC_EVENT_GROUP</li> <li>xSTATIC_LIST</li> <li>xSTATIC_LIST_ITEM</li> <li>xSTATIC_MINI_LIST_ITEM</li> <li>xSTATIC_QUEUE</li> <li>xSTATIC_STREAM_BUFFER</li> <li>xSTATIC_TCB</li> <li>xSTATIC_TIMER</li> <li>xTASK_PARAMETERS</li> <li>xTASK_STATUS</li> <li>xTIME_OUT</li> </ul> <p>## \\</p> <ul> <li>__debug_descriptors</li> <li>_usbd_device</li> </ul>"},{"location":"apiStm/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class BasePriorityRaiser </li> <li>class ByteFifo </li> <li>class Esp32Manager </li> <li>class MessageBufferWrapper </li> <li>class Motor </li> <li>class MutexWrapper </li> <li>class QueueWrapper </li> <li>class StreamBufferWrapper </li> <li>class TaskWrapper </li> <li>class TickTimer </li> <li>class XorShift Fast deterministic PRNG - https://en.wikipedia.org/wiki/Xorshift .</li> <li>struct A_BLOCK_LINK </li> <li>struct CalibrationData </li> <li>struct EventGroupDef_t </li> <li>struct FontDef </li> <li>struct HeapRegion </li> <li>struct MPU6050_t </li> <li>struct MpuMotion32 </li> <li>struct MpuMotion6 </li> <li>struct MpuVector </li> <li>struct MpuVector32 </li> <li>struct OLED_VERTEX </li> <li>struct OLED_t </li> <li>struct QueueDefinition </li> <li>struct QueuePointers </li> <li>struct Regulator </li> <li>struct SemaphoreData </li> <li>struct StreamBufferDef_t </li> <li>struct __debug_descriptors </li> <li>struct _usbd_device Represents a USB device data. </li> <li>struct cdc_config </li> <li>struct corCoRoutineControlBlock </li> <li>struct mpu_t </li> <li>struct tskTaskControlBlock </li> <li>struct usb_cdc_acm_desc Abstract Control Management Functional Descriptor. </li> <li>struct usb_cdc_call_mgmt_desc Call Management Functional Descriptor. </li> <li>struct usb_cdc_country_desc Country Selection Functional Descriptor. </li> <li>struct usb_cdc_header_desc Header Functional Descriptor. </li> <li>struct usb_cdc_line_coding Line Coding Structure. </li> <li>struct usb_cdc_notification Notification structure from CDC. </li> <li>struct usb_cdc_union_desc Union Functional Descriptor. </li> <li>struct usb_config_descriptor USB device configuration descriptor. </li> <li>struct usb_debug_descriptor USB debug descriptor. </li> <li>struct usb_device_descriptor Represents a USB device descriptor. </li> <li>struct usb_endpoint_descriptor USB endpoint descriptor. </li> <li>struct usb_header_descriptor common USB descriptor header </li> <li>struct usb_iad_descriptor USB interface association descriptor. </li> <li>struct usb_interface_descriptor USB interface descriptor. </li> <li>struct usb_qualifier_descriptor USB device qualifier descriptor. </li> <li>struct usb_string_descriptor USB string descriptor. </li> <li>struct usbd_ctlreq Represents generic USB control request. </li> <li>struct usbd_driver Represents a hardware USB driver call table. </li> <li>struct usbd_status </li> <li>struct xHeapStats </li> <li>struct xLIST </li> <li>struct xLIST_ITEM </li> <li>struct xMEMORY_REGION </li> <li>struct xMINI_LIST_ITEM </li> <li>struct xSTATIC_EVENT_GROUP </li> <li>struct xSTATIC_LIST </li> <li>struct xSTATIC_LIST_ITEM </li> <li>struct xSTATIC_MINI_LIST_ITEM </li> <li>struct xSTATIC_QUEUE </li> <li>struct xSTATIC_STREAM_BUFFER </li> <li>struct xSTATIC_TCB </li> <li>struct xSTATIC_TIMER </li> <li>struct xTASK_PARAMETERS </li> <li>struct xTASK_STATUS </li> <li>struct xTIME_OUT </li> </ul>"},{"location":"apiStm/modules/","title":"Modules","text":"<p>Here is a list of all modules:</p> <ul> <li>EventGroup </li> <li>EventGroupHandle_t </li> <li>xEventGroupClearBits </li> <li>xEventGroupClearBitsFromISR </li> <li>xEventGroupCreate </li> <li>xEventGroupGetBits </li> <li>xEventGroupGetBitsFromISR </li> <li>xEventGroupSetBits </li> <li>xEventGroupSetBitsFromISR </li> <li>xEventGroupSync </li> <li>xEventGroupWaitBits </li> <li>TaskHandle_t </li> <li>USB Device HW driver and core API </li> <li>USB device core Contains core API. </li> <li>USB hardware driver Contains HW driver API. </li> <li>USB CDC class Generic USB CDC class definitions. </li> <li>USB Standard This module contains generic USB device framework definitions. </li> <li>USB standard LANGID codes </li> <li>crDELAY </li> <li>crQUEUE_RECEIVE </li> <li>crQUEUE_RECEIVE_FROM_ISR </li> <li>crQUEUE_SEND </li> <li>crQUEUE_SEND_FROM_ISR </li> <li>crSTART </li> <li>pcTaskGetHandle </li> <li>pcTaskGetName </li> <li>taskDISABLE_INTERRUPTS </li> <li>taskENABLE_INTERRUPTS </li> <li>taskENTER_CRITICAL </li> <li>taskEXIT_CRITICAL </li> <li>taskYIELD </li> <li>ulTaskGetIdleRunTimeCounter </li> <li>ulTaskNotifyTake </li> <li>ulTaskNotifyValueClear </li> <li>uxQueueMessagesWaiting </li> <li>uxTaskGetNumberOfTasks </li> <li>uxTaskPriorityGet </li> <li>vCoRoutineSchedule </li> <li>vQueueDelete </li> <li>vSemaphoreCreateBinary </li> <li>vSemaphoreDelete </li> <li>vStreamBufferDelete </li> <li>vTaskDelay </li> <li>vTaskDelayUntil </li> <li>vTaskDelete </li> <li>vTaskEndScheduler </li> <li>vTaskGetInfo </li> <li>vTaskGetRunTimeStats </li> <li>vTaskList </li> <li>vTaskPrioritySet </li> <li>vTaskResume </li> <li>vTaskResumeFromISR </li> <li>vTaskSetTimeOutState </li> <li>vTaskStartScheduler </li> <li>vTaskSuspend </li> <li>vTaskSuspendAll </li> <li>xCoRoutineCreate </li> <li>xMessageBufferCreate </li> <li>xMessageBufferCreateStatic </li> <li>xMessageBufferNextLengthBytes </li> <li>xMessageBufferReceive </li> <li>xMessageBufferReceiveCompletedFromISR </li> <li>xMessageBufferReceiveFromISR </li> <li>xMessageBufferReset </li> <li>xMessageBufferSend </li> <li>xMessageBufferSendCompletedFromISR </li> <li>xMessageBufferSendFromISR </li> <li>xMessageBufferSpaceAvailable </li> <li>xQueueCreate </li> <li>xQueueCreateStatic </li> <li>xQueueOverwrite </li> <li>xQueueOverwriteFromISR </li> <li>xQueuePeek </li> <li>xQueuePeekFromISR </li> <li>xQueueReceive </li> <li>xQueueReceiveFromISR </li> <li>xQueueSend </li> <li>xQueueSendFromISR </li> <li>xSemaphoreCreateBinary </li> <li>xSemaphoreCreateBinaryStatic </li> <li>xSemaphoreCreateCounting </li> <li>xSemaphoreCreateCountingStatic </li> <li>xSemaphoreCreateMutex </li> <li>xSemaphoreCreateMutexStatic </li> <li>xSemaphoreCreateRecursiveMutex </li> <li>xSemaphoreCreateRecursiveMutexStatic </li> <li>xSemaphoreGive </li> <li>xSemaphoreGiveFromISR </li> <li>xSemaphoreGiveRecursive </li> <li>xSemaphoreTake </li> <li>xSemaphoreTakeRecursive </li> <li>xStreamBufferBytesAvailable </li> <li>xStreamBufferCreate </li> <li>xStreamBufferCreateStatic </li> <li>xStreamBufferIsEmpty </li> <li>xStreamBufferIsFull </li> <li>xStreamBufferReceive </li> <li>xStreamBufferReceiveCompletedFromISR </li> <li>xStreamBufferReceiveFromISR </li> <li>xStreamBufferReset </li> <li>xStreamBufferSend </li> <li>xStreamBufferSendCompletedFromISR </li> <li>xStreamBufferSendFromISR </li> <li>xStreamBufferSetTriggerLevel </li> <li>xStreamBufferSpacesAvailable </li> <li>xTaskAbortDelay </li> <li>xTaskCheckForTimeOut </li> <li>xTaskCreate </li> <li>xTaskCreateRestricted </li> <li>xTaskCreateRestrictedStatic </li> <li>xTaskCreateStatic </li> <li>xTaskGetTickCount </li> <li>xTaskGetTickCountFromISR </li> <li>xTaskNotify </li> <li>xTaskNotifyGive </li> <li>xTaskNotifyStateClear </li> <li>xTaskNotifyWait </li> <li>xTaskResumeAll </li> </ul>"},{"location":"apiStm/pages/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p>"},{"location":"apiStm/class_members/","title":"Class Members","text":""},{"location":"apiStm/class_members/#a","title":"a","text":"<ul> <li>adjust (ByteFifo)</li> <li>available (ByteFifo, StreamBufferWrapper)</li> <li>atStandstill (Motor)</li> <li>atTargetPosition (Motor)</li> <li>accel (MpuMotion32, MpuMotion6)</li> </ul>"},{"location":"apiStm/class_members/#b","title":"b","text":"<ul> <li>BasePriorityRaiser (BasePriorityRaiser)</li> <li>ByteFifo (ByteFifo)</li> <li>batteryCoef (CalibrationData)</li> <li>batteryMidCoef (CalibrationData)</li> <li>buffer (MPU6050_t, mpu_t)</li> <li>bDescriptorSubType (usb_cdc_acm_desc, usb_cdc_call_mgmt_desc, usb_cdc_country_desc, usb_cdc_header_desc, usb_cdc_union_desc)</li> <li>bDescriptorType (usb_cdc_acm_desc, usb_cdc_call_mgmt_desc, usb_cdc_country_desc, usb_cdc_header_desc, usb_cdc_union_desc, usb_config_descriptor, usb_debug_descriptor, usb_device_descriptor, usb_endpoint_descriptor, usb_header_descriptor, usb_iad_descriptor, usb_interface_descriptor, usb_qualifier_descriptor, usb_string_descriptor)</li> <li>bFunctionLength (usb_cdc_acm_desc, usb_cdc_call_mgmt_desc, usb_cdc_country_desc, usb_cdc_header_desc, usb_cdc_union_desc)</li> <li>bmCapabilities (usb_cdc_acm_desc, usb_cdc_call_mgmt_desc)</li> <li>bDataInterface (usb_cdc_call_mgmt_desc)</li> <li>bcdCDC (usb_cdc_header_desc)</li> <li>bCharFormat (usb_cdc_line_coding)</li> <li>bDataBits (usb_cdc_line_coding)</li> <li>bParityType (usb_cdc_line_coding)</li> <li>bNotificationType (usb_cdc_notification)</li> <li>bmRequestType (usb_cdc_notification, usbd_ctlreq)</li> <li>bMasterInterface0 (usb_cdc_union_desc)</li> <li>bSlaveInterface0 (usb_cdc_union_desc)</li> <li>bConfigurationValue (usb_config_descriptor)</li> <li>bLength (usb_config_descriptor, usb_debug_descriptor, usb_device_descriptor, usb_endpoint_descriptor, usb_header_descriptor, usb_iad_descriptor, usb_interface_descriptor, usb_qualifier_descriptor, usb_string_descriptor)</li> <li>bMaxPower (usb_config_descriptor)</li> <li>bNumInterfaces (usb_config_descriptor)</li> <li>bmAttributes (usb_config_descriptor, usb_endpoint_descriptor)</li> <li>bDebugInEndpoint (usb_debug_descriptor)</li> <li>bDebugOutEndpoint (usb_debug_descriptor)</li> <li>bDeviceClass (usb_device_descriptor, usb_qualifier_descriptor)</li> <li>bDeviceProtocol (usb_device_descriptor, usb_qualifier_descriptor)</li> <li>bDeviceSubClass (usb_device_descriptor, usb_qualifier_descriptor)</li> <li>bMaxPacketSize0 (usb_device_descriptor, usb_qualifier_descriptor)</li> <li>bNumConfigurations (usb_device_descriptor, usb_qualifier_descriptor)</li> <li>bcdDevice (usb_device_descriptor)</li> <li>bcdUSB (usb_device_descriptor, usb_qualifier_descriptor)</li> <li>bEndpointAddress (usb_endpoint_descriptor)</li> <li>bInterval (usb_endpoint_descriptor)</li> <li>bFirstInterface (usb_iad_descriptor)</li> <li>bFunctionClass (usb_iad_descriptor)</li> <li>bFunctionProtocol (usb_iad_descriptor)</li> <li>bFunctionSubClass (usb_iad_descriptor)</li> <li>bInterfaceCount (usb_iad_descriptor)</li> <li>bAlternateSetting (usb_interface_descriptor)</li> <li>bInterfaceClass (usb_interface_descriptor)</li> <li>bInterfaceNumber (usb_interface_descriptor)</li> <li>bInterfaceProtocol (usb_interface_descriptor)</li> <li>bInterfaceSubClass (usb_interface_descriptor)</li> <li>bNumEndpoints (usb_interface_descriptor)</li> <li>bReserved (usb_qualifier_descriptor)</li> <li>bRequest (usbd_ctlreq)</li> </ul>"},{"location":"apiStm/class_members/#c","title":"c","text":"<ul> <li>clear (ByteFifo, Regulator)</li> <li>create (MessageBufferWrapper, MutexWrapper, QueueWrapper, StreamBufferWrapper)</li> <li>CurrentX (OLED_t)</li> <li>CurrentY (OLED_t)</li> <li>cRxLock (QueueDefinition)</li> <li>cTxLock (QueueDefinition)</li> <li>coef_type (Regulator)</li> <li>complete_callback (_usbd_device)</li> <li>config_callback (_usbd_device)</li> <li>control_callback (_usbd_device)</li> <li>config (cdc_config)</li> <li>connect (usbd_driver)</li> <li>control_state (usbd_status)</li> </ul>"},{"location":"apiStm/class_members/#d","title":"d","text":"<ul> <li>data (ByteFifo, FontDef, usbd_ctlreq)</li> <li>devAddr (MPU6050_t, mpu_t)</li> <li>DisplayOn (OLED_t)</li> <li>D (Regulator)</li> <li>de (Regulator)</li> <li>descriptor_callback (_usbd_device)</li> <li>driver (_usbd_device)</li> <li>dwDTERate (usb_cdc_line_coding)</li> <li>Data (usb_cdc_notification)</li> <li>data_buf (usbd_status)</li> <li>data_count (usbd_status)</li> <li>data_maxsize (usbd_status)</li> <li>data_ptr (usbd_status)</li> <li>device_cfg (usbd_status)</li> <li>device_state (usbd_status)</li> </ul>"},{"location":"apiStm/class_members/#e","title":"e","text":"<ul> <li>EnHolderType (Esp32Manager)</li> <li>Esp32Manager (Esp32Manager)</li> <li>e (Regulator)</li> <li>endpoint (_usbd_device)</li> <li>events (_usbd_device)</li> <li>enable (usbd_driver)</li> <li>ep_config (usbd_driver)</li> <li>ep_deconfig (usbd_driver)</li> <li>ep_isstalled (usbd_driver)</li> <li>ep_read (usbd_driver)</li> <li>ep_setstall (usbd_driver)</li> <li>ep_write (usbd_driver)</li> <li>ep0size (usbd_status)</li> <li>eCurrentState (xTASK_STATUS)</li> </ul>"},{"location":"apiStm/class_members/#f","title":"f","text":"<ul> <li>FontHeight (FontDef)</li> <li>FontWidth (FontDef)</li> <li>freeSpace (StreamBufferWrapper)</li> <li>frame_no (usbd_driver)</li> </ul>"},{"location":"apiStm/class_members/#g","title":"g","text":"<ul> <li>gyro (MpuMotion32, MpuMotion6)</li> <li>get_serialno_desc (usbd_driver)</li> <li>getinfo (usbd_driver)</li> </ul>"},{"location":"apiStm/class_members/#h","title":"h","text":"<ul> <li>hasData (ByteFifo)</li> <li>handleSettings (Esp32Manager)</li> <li>holdReset (Esp32Manager)</li> <li>handle (MessageBufferWrapper, QueueWrapper, StreamBufferWrapper, TaskWrapper)</li> <li>homePosition (Motor)</li> </ul>"},{"location":"apiStm/class_members/#i","title":"i","text":"<ul> <li>internalVrefMv (CalibrationData)</li> <li>init (Esp32Manager)</li> <li>isInBootloader (Esp32Manager)</li> <li>Inverted (OLED_t)</li> <li>I (Regulator)</li> <li>integrator (Regulator)</li> <li>isActive (TickTimer)</li> <li>iCountryCodeRelDate (usb_cdc_country_desc)</li> <li>iConfiguration (usb_config_descriptor)</li> <li>iManufacturer (usb_device_descriptor)</li> <li>iProduct (usb_device_descriptor)</li> <li>iSerialNumber (usb_device_descriptor)</li> <li>idProduct (usb_device_descriptor)</li> <li>idVendor (usb_device_descriptor)</li> <li>iFunction (usb_iad_descriptor)</li> <li>iInterface (usb_interface_descriptor)</li> </ul>"},{"location":"apiStm/class_members/#l","title":"l","text":"<ul> <li>lock (BasePriorityRaiser, MutexWrapper)</li> </ul>"},{"location":"apiStm/class_members/#m","title":"m","text":"<ul> <li>m_fifo (ByteFifo)</li> <li>m_head (ByteFifo)</li> <li>m_tail (ByteFifo)</li> <li>magic (CalibrationData)</li> <li>m_checkBreakTimer (Esp32Manager)</li> <li>m_enPinHolders (Esp32Manager)</li> <li>m_inBootloader (Esp32Manager)</li> <li>m_lastDtr (Esp32Manager)</li> <li>m_lastRts (Esp32Manager)</li> <li>m_previousEnEdge (Esp32Manager)</li> <li>m_queuedReset (Esp32Manager)</li> <li>m_unstrapTimer (Esp32Manager)</li> <li>m_watchdogInhibit (Esp32Manager)</li> <li>m_watchdogTimer (Esp32Manager)</li> <li>MessageBufferWrapper (MessageBufferWrapper)</li> <li>m_buffer (MessageBufferWrapper, MutexWrapper, QueueWrapper, StreamBufferWrapper)</li> <li>m_bufferStruct (MessageBufferWrapper, StreamBufferWrapper)</li> <li>m_handle (MessageBufferWrapper, MutexWrapper, QueueWrapper, StreamBufferWrapper, TaskWrapper)</li> <li>Motor (Motor)</li> <li>m_actualPosition (Motor)</li> <li>m_actualPower (Motor)</li> <li>m_actualTicksPerLoop (Motor)</li> <li>m_dither (Motor)</li> <li>m_lastEncTicks (Motor)</li> <li>m_maxAccel (Motor)</li> <li>m_mode (Motor)</li> <li>m_posEpsilon (Motor)</li> <li>m_positionReg (Motor)</li> <li>m_targetPosition (Motor)</li> <li>m_targetVelocity (Motor)</li> <li>m_velEpsilon (Motor)</li> <li>m_velocityReg (Motor)</li> <li>mode (Motor)</li> <li>modeChange (Motor)</li> <li>MutexWrapper (MutexWrapper)</li> <li>m_queueStruct (QueueWrapper)</li> <li>m_d (Regulator)</li> <li>m_de (Regulator)</li> <li>m_e (Regulator)</li> <li>m_i (Regulator)</li> <li>m_integrator (Regulator)</li> <li>m_le (Regulator)</li> <li>m_max_output (Regulator)</li> <li>m_output (Regulator)</li> <li>m_p (Regulator)</li> <li>m_stop (Regulator)</li> <li>maxOutput (Regulator)</li> <li>m_func (TaskWrapper)</li> <li>m_stack (TaskWrapper)</li> <li>m_taskStruct (TaskWrapper)</li> <li>MaxDelay (TickTimer)</li> <li>m_timeoutAt (TickTimer)</li> <li>m_state (XorShift)</li> </ul>"},{"location":"apiStm/class_members/#n","title":"n","text":"<ul> <li>notifyRead (ByteFifo)</li> <li>notifyWritten (ByteFifo)</li> <li>native_handle (MutexWrapper)</li> <li>next (XorShift)</li> </ul>"},{"location":"apiStm/class_members/#o","title":"o","text":"<ul> <li>onEnRisingInIrq (Esp32Manager)</li> <li>onSerialBreakInIrq (Esp32Manager)</li> <li>overwrite (QueueWrapper)</li> <li>operator= (Regulator)</li> <li>output (Regulator)</li> </ul>"},{"location":"apiStm/class_members/#p","title":"p","text":"<ul> <li>pxNextFreeBlock (A_BLOCK_LINK)</li> <li>peekSpan (ByteFifo)</li> <li>pop (ByteFifo)</li> <li>push (ByteFifo)</li> <li>poll (Esp32Manager, Motor, TickTimer, usbd_driver)</li> <li>pucStartAddress (HeapRegion)</li> <li>pop_front (MessageBufferWrapper, QueueWrapper)</li> <li>push_back (MessageBufferWrapper, QueueWrapper)</li> <li>pcHead (QueueDefinition)</li> <li>pcWriteTo (QueueDefinition)</li> <li>pcReadFrom (QueuePointers)</li> <li>pcTail (QueuePointers)</li> <li>push_front (QueueWrapper)</li> <li>P (Regulator)</li> <li>process (Regulator)</li> <li>pucBuffer (StreamBufferDef_t)</li> <li>pxCoRoutineFunction (corCoRoutineControlBlock)</li> <li>pcTaskName (tskTaskControlBlock, xTASK_STATUS)</li> <li>pxStack (tskTaskControlBlock)</li> <li>pxTopOfStack (tskTaskControlBlock)</li> <li>pxIndex (xLIST)</li> <li>pvOwner (xLIST_ITEM)</li> <li>pxContainer (xLIST_ITEM)</li> <li>pxNext (xLIST_ITEM, xMINI_LIST_ITEM)</li> <li>pxPrevious (xLIST_ITEM, xMINI_LIST_ITEM)</li> <li>pvBaseAddress (xMEMORY_REGION)</li> <li>pvDummy3 (xSTATIC_LIST, xSTATIC_LIST_ITEM, xSTATIC_MINI_LIST_ITEM)</li> <li>pvDummy1 (xSTATIC_QUEUE, xSTATIC_TIMER)</li> <li>pvDummy2 (xSTATIC_QUEUE, xSTATIC_STREAM_BUFFER)</li> <li>pxDummy1 (xSTATIC_TCB)</li> <li>pxDummy6 (xSTATIC_TCB)</li> <li>pvDummy5 (xSTATIC_TIMER)</li> <li>pvDummy6 (xSTATIC_TIMER)</li> <li>pcName (xTASK_PARAMETERS)</li> <li>puxStackBuffer (xTASK_PARAMETERS)</li> <li>pvParameters (xTASK_PARAMETERS)</li> <li>pvTaskCode (xTASK_PARAMETERS)</li> <li>pxStackBase (xTASK_STATUS)</li> </ul>"},{"location":"apiStm/class_members/#q","title":"q","text":"<ul> <li>QueuedReset (Esp32Manager)</li> <li>queueReset (Esp32Manager)</li> <li>QueueWrapper (QueueWrapper)</li> </ul>"},{"location":"apiStm/class_members/#r","title":"r","text":"<ul> <li>readableSpan (ByteFifo)</li> <li>releaseReset (Esp32Manager)</li> <li>resetWatchdog (Esp32Manager)</li> <li>reset (MessageBufferWrapper, Motor, QueueWrapper, StreamBufferWrapper)</li> <li>reportStat (Motor)</li> <li>Regulator (Regulator)</li> <li>read (StreamBufferWrapper)</li> <li>restart (TickTimer)</li> </ul>"},{"location":"apiStm/class_members/#s","title":"s","text":"<ul> <li>setHead (ByteFifo)</li> <li>size (ByteFifo)</li> <li>setWatchdogInhibit (Esp32Manager)</li> <li>strapPins (Esp32Manager)</li> <li>setConfig (Motor)</li> <li>setPositionPid (Motor)</li> <li>setTargetBrakingPower (Motor)</li> <li>setTargetPosition (Motor)</li> <li>setTargetPower (Motor)</li> <li>setTargetVelocity (Motor)</li> <li>setVelocityPid (Motor)</li> <li>setD (Regulator)</li> <li>setI (Regulator)</li> <li>setMaxOutput (Regulator)</li> <li>setP (Regulator)</li> <li>stop (Regulator, TickTimer)</li> <li>StreamBufferWrapper (StreamBufferWrapper)</li> <li>start (TaskWrapper)</li> <li>status (_usbd_device)</li> <li>setaddr (usbd_driver)</li> </ul>"},{"location":"apiStm/class_members/#t","title":"t","text":"<ul> <li>tempTypicalAtC (CalibrationData)</li> <li>tempTypicalMv (CalibrationData)</li> <li>TaskWrapper (TaskWrapper)</li> <li>trampoline (TaskWrapper)</li> <li>TickTimer (TickTimer)</li> <li>tunnel_cdc_acm (cdc_config)</li> <li>tunnel_cdc_hdr (cdc_config)</li> <li>tunnel_cdc_mgmt (cdc_config)</li> <li>tunnel_cdc_union (cdc_config)</li> <li>tunnel_comm (cdc_config)</li> <li>tunnel_comm_ep (cdc_config)</li> <li>tunnel_comm_iad (cdc_config)</li> <li>tunnel_data (cdc_config)</li> <li>tunnel_data_eprx (cdc_config)</li> <li>tunnel_data_eptx (cdc_config)</li> </ul>"},{"location":"apiStm/class_members/#u","title":"u","text":"<ul> <li>unlock (BasePriorityRaiser, MutexWrapper)</li> <li>unstrapPins (Esp32Manager)</li> <li>uxEventBits (EventGroupDef_t)</li> <li>u (QueueDefinition, xSTATIC_QUEUE)</li> <li>uxItemSize (QueueDefinition)</li> <li>uxLength (QueueDefinition)</li> <li>uxMessagesWaiting (QueueDefinition)</li> <li>uxRecursiveCallCount (SemaphoreData)</li> <li>ucFlags (StreamBufferDef_t)</li> <li>uxIndex (corCoRoutineControlBlock)</li> <li>uxPriority (corCoRoutineControlBlock, tskTaskControlBlock, xTASK_PARAMETERS)</li> <li>uxState (corCoRoutineControlBlock)</li> <li>uxNumberOfItems (xLIST)</li> <li>ulLengthInBytes (xMEMORY_REGION)</li> <li>ulParameters (xMEMORY_REGION)</li> <li>uxDummy2 (xSTATIC_LIST, xSTATIC_QUEUE)</li> <li>ucDummy5 (xSTATIC_QUEUE)</li> <li>uxDummy4 (xSTATIC_QUEUE)</li> <li>ucDummy3 (xSTATIC_STREAM_BUFFER)</li> <li>uxDummy1 (xSTATIC_STREAM_BUFFER)</li> <li>ucDummy19 (xSTATIC_TCB)</li> <li>ucDummy7 (xSTATIC_TCB)</li> <li>ulDummy18 (xSTATIC_TCB)</li> <li>uxDummy5 (xSTATIC_TCB)</li> <li>ucDummy8 (xSTATIC_TIMER)</li> <li>usStackDepth (xTASK_PARAMETERS)</li> <li>ulRunTimeCounter (xTASK_STATUS)</li> <li>usStackHighWaterMark (xTASK_STATUS)</li> <li>uxBasePriority (xTASK_STATUS)</li> <li>uxCurrentPriority (xTASK_STATUS)</li> </ul>"},{"location":"apiStm/class_members/#v","title":"v","text":"<ul> <li>value_type (Regulator)</li> </ul>"},{"location":"apiStm/class_members/#w","title":"w","text":"<ul> <li>writeSpan (ByteFifo)</li> <li>writeableSpan (ByteFifo)</li> <li>write (StreamBufferWrapper)</li> <li>wCountyCode0 (usb_cdc_country_desc)</li> <li>wIndex (usb_cdc_notification, usbd_ctlreq)</li> <li>wLength (usb_cdc_notification, usbd_ctlreq)</li> <li>wValue (usb_cdc_notification, usbd_ctlreq)</li> <li>wTotalLength (usb_config_descriptor)</li> <li>wMaxPacketSize (usb_endpoint_descriptor)</li> <li>wString (usb_string_descriptor)</li> </ul>"},{"location":"apiStm/class_members/#x","title":"x","text":"<ul> <li>xBlockSize (A_BLOCK_LINK)</li> <li>xTasksWaitingForBits (EventGroupDef_t)</li> <li>xSizeInBytes (HeapRegion)</li> <li>x (MpuVector, MpuVector32, OLED_VERTEX)</li> <li>xQueue (QueueDefinition)</li> <li>xSemaphore (QueueDefinition)</li> <li>xTasksWaitingToReceive (QueueDefinition)</li> <li>xTasksWaitingToSend (QueueDefinition)</li> <li>xMutexHolder (SemaphoreData)</li> <li>xHead (StreamBufferDef_t)</li> <li>xLength (StreamBufferDef_t)</li> <li>xTail (StreamBufferDef_t)</li> <li>xTaskWaitingToReceive (StreamBufferDef_t)</li> <li>xTaskWaitingToSend (StreamBufferDef_t)</li> <li>xTriggerLevelBytes (StreamBufferDef_t)</li> <li>XorShift (XorShift)</li> <li>xEventListItem (corCoRoutineControlBlock, tskTaskControlBlock)</li> <li>xGenericListItem (corCoRoutineControlBlock)</li> <li>xStateListItem (tskTaskControlBlock)</li> <li>xAvailableHeapSpaceInBytes (xHeapStats)</li> <li>xMinimumEverFreeBytesRemaining (xHeapStats)</li> <li>xNumberOfFreeBlocks (xHeapStats)</li> <li>xNumberOfSuccessfulAllocations (xHeapStats)</li> <li>xNumberOfSuccessfulFrees (xHeapStats)</li> <li>xSizeOfLargestFreeBlockInBytes (xHeapStats)</li> <li>xSizeOfSmallestFreeBlockInBytes (xHeapStats)</li> <li>xListEnd (xLIST)</li> <li>xItemValue (xLIST_ITEM, xMINI_LIST_ITEM)</li> <li>xDummy1 (xSTATIC_EVENT_GROUP)</li> <li>xDummy2 (xSTATIC_EVENT_GROUP, xSTATIC_LIST_ITEM, xSTATIC_MINI_LIST_ITEM, xSTATIC_TIMER)</li> <li>xDummy4 (xSTATIC_LIST)</li> <li>xDummy3 (xSTATIC_QUEUE, xSTATIC_TCB, xSTATIC_TIMER)</li> <li>xRegions (xTASK_PARAMETERS)</li> <li>xHandle (xTASK_STATUS)</li> <li>xTaskNumber (xTASK_STATUS)</li> <li>xOverflowCount (xTIME_OUT)</li> <li>xTimeOnEntering (xTIME_OUT)</li> </ul>"},{"location":"apiStm/class_members/#y","title":"y","text":"<ul> <li>y (MpuVector, MpuVector32, OLED_VERTEX)</li> </ul>"},{"location":"apiStm/class_members/#z","title":"z","text":"<ul> <li>z (MpuVector, MpuVector32)</li> </ul>"},{"location":"apiStm/class_members/#_1","title":"~","text":"<ul> <li>~BasePriorityRaiser (BasePriorityRaiser)</li> <li>~Esp32Manager (Esp32Manager)</li> <li>~MessageBufferWrapper (MessageBufferWrapper)</li> <li>~MutexWrapper (MutexWrapper)</li> <li>~QueueWrapper (QueueWrapper)</li> <li>~StreamBufferWrapper (StreamBufferWrapper)</li> <li>~TaskWrapper (TaskWrapper)</li> <li>~TickTimer (TickTimer)</li> </ul>"},{"location":"apiStm/class_member_functions/","title":"Class Member Functions","text":""},{"location":"apiStm/class_member_functions/#a","title":"a","text":"<ul> <li>adjust (ByteFifo)</li> <li>available (ByteFifo, StreamBufferWrapper)</li> <li>atStandstill (Motor)</li> <li>atTargetPosition (Motor)</li> </ul>"},{"location":"apiStm/class_member_functions/#b","title":"b","text":"<ul> <li>BasePriorityRaiser (BasePriorityRaiser)</li> <li>ByteFifo (ByteFifo)</li> </ul>"},{"location":"apiStm/class_member_functions/#c","title":"c","text":"<ul> <li>clear (ByteFifo, Regulator)</li> <li>create (MessageBufferWrapper, MutexWrapper, QueueWrapper, StreamBufferWrapper)</li> </ul>"},{"location":"apiStm/class_member_functions/#d","title":"d","text":"<ul> <li>data (ByteFifo)</li> <li>D (Regulator)</li> <li>de (Regulator)</li> </ul>"},{"location":"apiStm/class_member_functions/#e","title":"e","text":"<ul> <li>Esp32Manager (Esp32Manager)</li> <li>e (Regulator)</li> </ul>"},{"location":"apiStm/class_member_functions/#f","title":"f","text":"<ul> <li>freeSpace (StreamBufferWrapper)</li> </ul>"},{"location":"apiStm/class_member_functions/#h","title":"h","text":"<ul> <li>hasData (ByteFifo)</li> <li>handleSettings (Esp32Manager)</li> <li>holdReset (Esp32Manager)</li> <li>handle (MessageBufferWrapper, QueueWrapper, StreamBufferWrapper, TaskWrapper)</li> <li>homePosition (Motor)</li> </ul>"},{"location":"apiStm/class_member_functions/#i","title":"i","text":"<ul> <li>init (Esp32Manager)</li> <li>isInBootloader (Esp32Manager)</li> <li>I (Regulator)</li> <li>integrator (Regulator)</li> <li>isActive (TickTimer)</li> </ul>"},{"location":"apiStm/class_member_functions/#l","title":"l","text":"<ul> <li>lock (BasePriorityRaiser, MutexWrapper)</li> </ul>"},{"location":"apiStm/class_member_functions/#m","title":"m","text":"<ul> <li>MessageBufferWrapper (MessageBufferWrapper)</li> <li>Motor (Motor)</li> <li>mode (Motor)</li> <li>modeChange (Motor)</li> <li>MutexWrapper (MutexWrapper)</li> <li>maxOutput (Regulator)</li> </ul>"},{"location":"apiStm/class_member_functions/#n","title":"n","text":"<ul> <li>notifyRead (ByteFifo)</li> <li>notifyWritten (ByteFifo)</li> <li>native_handle (MutexWrapper)</li> <li>next (XorShift)</li> </ul>"},{"location":"apiStm/class_member_functions/#o","title":"o","text":"<ul> <li>onEnRisingInIrq (Esp32Manager)</li> <li>onSerialBreakInIrq (Esp32Manager)</li> <li>overwrite (QueueWrapper)</li> <li>operator= (Regulator)</li> <li>output (Regulator)</li> </ul>"},{"location":"apiStm/class_member_functions/#p","title":"p","text":"<ul> <li>peekSpan (ByteFifo)</li> <li>pop (ByteFifo)</li> <li>push (ByteFifo)</li> <li>poll (Esp32Manager, Motor, TickTimer)</li> <li>pop_front (MessageBufferWrapper, QueueWrapper)</li> <li>push_back (MessageBufferWrapper, QueueWrapper)</li> <li>push_front (QueueWrapper)</li> <li>P (Regulator)</li> <li>process (Regulator)</li> </ul>"},{"location":"apiStm/class_member_functions/#q","title":"q","text":"<ul> <li>queueReset (Esp32Manager)</li> <li>QueueWrapper (QueueWrapper)</li> </ul>"},{"location":"apiStm/class_member_functions/#r","title":"r","text":"<ul> <li>readableSpan (ByteFifo)</li> <li>releaseReset (Esp32Manager)</li> <li>resetWatchdog (Esp32Manager)</li> <li>reset (MessageBufferWrapper, Motor, QueueWrapper, StreamBufferWrapper)</li> <li>reportStat (Motor)</li> <li>Regulator (Regulator)</li> <li>read (StreamBufferWrapper)</li> <li>restart (TickTimer)</li> </ul>"},{"location":"apiStm/class_member_functions/#s","title":"s","text":"<ul> <li>setHead (ByteFifo)</li> <li>size (ByteFifo)</li> <li>setWatchdogInhibit (Esp32Manager)</li> <li>strapPins (Esp32Manager)</li> <li>setConfig (Motor)</li> <li>setPositionPid (Motor)</li> <li>setTargetBrakingPower (Motor)</li> <li>setTargetPosition (Motor)</li> <li>setTargetPower (Motor)</li> <li>setTargetVelocity (Motor)</li> <li>setVelocityPid (Motor)</li> <li>setD (Regulator)</li> <li>setI (Regulator)</li> <li>setMaxOutput (Regulator)</li> <li>setP (Regulator)</li> <li>stop (Regulator, TickTimer)</li> <li>StreamBufferWrapper (StreamBufferWrapper)</li> <li>start (TaskWrapper)</li> </ul>"},{"location":"apiStm/class_member_functions/#t","title":"t","text":"<ul> <li>TaskWrapper (TaskWrapper)</li> <li>trampoline (TaskWrapper)</li> <li>TickTimer (TickTimer)</li> </ul>"},{"location":"apiStm/class_member_functions/#u","title":"u","text":"<ul> <li>unlock (BasePriorityRaiser, MutexWrapper)</li> <li>unstrapPins (Esp32Manager)</li> </ul>"},{"location":"apiStm/class_member_functions/#w","title":"w","text":"<ul> <li>writeSpan (ByteFifo)</li> <li>writeableSpan (ByteFifo)</li> <li>write (StreamBufferWrapper)</li> </ul>"},{"location":"apiStm/class_member_functions/#x","title":"x","text":"<ul> <li>XorShift (XorShift)</li> </ul>"},{"location":"apiStm/class_member_functions/#_1","title":"~","text":"<ul> <li>~BasePriorityRaiser (BasePriorityRaiser)</li> <li>~Esp32Manager (Esp32Manager)</li> <li>~MessageBufferWrapper (MessageBufferWrapper)</li> <li>~MutexWrapper (MutexWrapper)</li> <li>~QueueWrapper (QueueWrapper)</li> <li>~StreamBufferWrapper (StreamBufferWrapper)</li> <li>~TaskWrapper (TaskWrapper)</li> <li>~TickTimer (TickTimer)</li> </ul>"},{"location":"apiStm/class_member_variables/","title":"Class Member Variables","text":""},{"location":"apiStm/class_member_variables/#a","title":"a","text":"<ul> <li>accel (MpuMotion32, MpuMotion6)</li> </ul>"},{"location":"apiStm/class_member_variables/#b","title":"b","text":"<ul> <li>batteryCoef (CalibrationData)</li> <li>batteryMidCoef (CalibrationData)</li> <li>buffer (MPU6050_t, mpu_t)</li> <li>bDescriptorSubType (usb_cdc_acm_desc, usb_cdc_call_mgmt_desc, usb_cdc_country_desc, usb_cdc_header_desc, usb_cdc_union_desc)</li> <li>bDescriptorType (usb_cdc_acm_desc, usb_cdc_call_mgmt_desc, usb_cdc_country_desc, usb_cdc_header_desc, usb_cdc_union_desc, usb_config_descriptor, usb_debug_descriptor, usb_device_descriptor, usb_endpoint_descriptor, usb_header_descriptor, usb_iad_descriptor, usb_interface_descriptor, usb_qualifier_descriptor, usb_string_descriptor)</li> <li>bFunctionLength (usb_cdc_acm_desc, usb_cdc_call_mgmt_desc, usb_cdc_country_desc, usb_cdc_header_desc, usb_cdc_union_desc)</li> <li>bmCapabilities (usb_cdc_acm_desc, usb_cdc_call_mgmt_desc)</li> <li>bDataInterface (usb_cdc_call_mgmt_desc)</li> <li>bcdCDC (usb_cdc_header_desc)</li> <li>bCharFormat (usb_cdc_line_coding)</li> <li>bDataBits (usb_cdc_line_coding)</li> <li>bParityType (usb_cdc_line_coding)</li> <li>bNotificationType (usb_cdc_notification)</li> <li>bmRequestType (usb_cdc_notification, usbd_ctlreq)</li> <li>bMasterInterface0 (usb_cdc_union_desc)</li> <li>bSlaveInterface0 (usb_cdc_union_desc)</li> <li>bConfigurationValue (usb_config_descriptor)</li> <li>bLength (usb_config_descriptor, usb_debug_descriptor, usb_device_descriptor, usb_endpoint_descriptor, usb_header_descriptor, usb_iad_descriptor, usb_interface_descriptor, usb_qualifier_descriptor, usb_string_descriptor)</li> <li>bMaxPower (usb_config_descriptor)</li> <li>bNumInterfaces (usb_config_descriptor)</li> <li>bmAttributes (usb_config_descriptor, usb_endpoint_descriptor)</li> <li>bDebugInEndpoint (usb_debug_descriptor)</li> <li>bDebugOutEndpoint (usb_debug_descriptor)</li> <li>bDeviceClass (usb_device_descriptor, usb_qualifier_descriptor)</li> <li>bDeviceProtocol (usb_device_descriptor, usb_qualifier_descriptor)</li> <li>bDeviceSubClass (usb_device_descriptor, usb_qualifier_descriptor)</li> <li>bMaxPacketSize0 (usb_device_descriptor, usb_qualifier_descriptor)</li> <li>bNumConfigurations (usb_device_descriptor, usb_qualifier_descriptor)</li> <li>bcdDevice (usb_device_descriptor)</li> <li>bcdUSB (usb_device_descriptor, usb_qualifier_descriptor)</li> <li>bEndpointAddress (usb_endpoint_descriptor)</li> <li>bInterval (usb_endpoint_descriptor)</li> <li>bFirstInterface (usb_iad_descriptor)</li> <li>bFunctionClass (usb_iad_descriptor)</li> <li>bFunctionProtocol (usb_iad_descriptor)</li> <li>bFunctionSubClass (usb_iad_descriptor)</li> <li>bInterfaceCount (usb_iad_descriptor)</li> <li>bAlternateSetting (usb_interface_descriptor)</li> <li>bInterfaceClass (usb_interface_descriptor)</li> <li>bInterfaceNumber (usb_interface_descriptor)</li> <li>bInterfaceProtocol (usb_interface_descriptor)</li> <li>bInterfaceSubClass (usb_interface_descriptor)</li> <li>bNumEndpoints (usb_interface_descriptor)</li> <li>bReserved (usb_qualifier_descriptor)</li> <li>bRequest (usbd_ctlreq)</li> </ul>"},{"location":"apiStm/class_member_variables/#c","title":"c","text":"<ul> <li>CurrentX (OLED_t)</li> <li>CurrentY (OLED_t)</li> <li>cRxLock (QueueDefinition)</li> <li>cTxLock (QueueDefinition)</li> <li>complete_callback (_usbd_device)</li> <li>config_callback (_usbd_device)</li> <li>control_callback (_usbd_device)</li> <li>config (cdc_config)</li> <li>connect (usbd_driver)</li> <li>control_state (usbd_status)</li> </ul>"},{"location":"apiStm/class_member_variables/#d","title":"d","text":"<ul> <li>data (FontDef, usbd_ctlreq)</li> <li>devAddr (MPU6050_t, mpu_t)</li> <li>DisplayOn (OLED_t)</li> <li>descriptor_callback (_usbd_device)</li> <li>driver (_usbd_device)</li> <li>dwDTERate (usb_cdc_line_coding)</li> <li>Data (usb_cdc_notification)</li> <li>data_buf (usbd_status)</li> <li>data_count (usbd_status)</li> <li>data_maxsize (usbd_status)</li> <li>data_ptr (usbd_status)</li> <li>device_cfg (usbd_status)</li> <li>device_state (usbd_status)</li> </ul>"},{"location":"apiStm/class_member_variables/#e","title":"e","text":"<ul> <li>endpoint (_usbd_device)</li> <li>events (_usbd_device)</li> <li>enable (usbd_driver)</li> <li>ep_config (usbd_driver)</li> <li>ep_deconfig (usbd_driver)</li> <li>ep_isstalled (usbd_driver)</li> <li>ep_read (usbd_driver)</li> <li>ep_setstall (usbd_driver)</li> <li>ep_write (usbd_driver)</li> <li>ep0size (usbd_status)</li> <li>eCurrentState (xTASK_STATUS)</li> </ul>"},{"location":"apiStm/class_member_variables/#f","title":"f","text":"<ul> <li>FontHeight (FontDef)</li> <li>FontWidth (FontDef)</li> <li>frame_no (usbd_driver)</li> </ul>"},{"location":"apiStm/class_member_variables/#g","title":"g","text":"<ul> <li>gyro (MpuMotion32, MpuMotion6)</li> <li>get_serialno_desc (usbd_driver)</li> <li>getinfo (usbd_driver)</li> </ul>"},{"location":"apiStm/class_member_variables/#i","title":"i","text":"<ul> <li>internalVrefMv (CalibrationData)</li> <li>Inverted (OLED_t)</li> <li>iCountryCodeRelDate (usb_cdc_country_desc)</li> <li>iConfiguration (usb_config_descriptor)</li> <li>iManufacturer (usb_device_descriptor)</li> <li>iProduct (usb_device_descriptor)</li> <li>iSerialNumber (usb_device_descriptor)</li> <li>idProduct (usb_device_descriptor)</li> <li>idVendor (usb_device_descriptor)</li> <li>iFunction (usb_iad_descriptor)</li> <li>iInterface (usb_interface_descriptor)</li> </ul>"},{"location":"apiStm/class_member_variables/#m","title":"m","text":"<ul> <li>m_fifo (ByteFifo)</li> <li>m_head (ByteFifo)</li> <li>m_tail (ByteFifo)</li> <li>magic (CalibrationData)</li> <li>m_checkBreakTimer (Esp32Manager)</li> <li>m_enPinHolders (Esp32Manager)</li> <li>m_inBootloader (Esp32Manager)</li> <li>m_lastDtr (Esp32Manager)</li> <li>m_lastRts (Esp32Manager)</li> <li>m_previousEnEdge (Esp32Manager)</li> <li>m_queuedReset (Esp32Manager)</li> <li>m_unstrapTimer (Esp32Manager)</li> <li>m_watchdogInhibit (Esp32Manager)</li> <li>m_watchdogTimer (Esp32Manager)</li> <li>m_buffer (MessageBufferWrapper, MutexWrapper, QueueWrapper, StreamBufferWrapper)</li> <li>m_bufferStruct (MessageBufferWrapper, StreamBufferWrapper)</li> <li>m_handle (MessageBufferWrapper, MutexWrapper, QueueWrapper, StreamBufferWrapper, TaskWrapper)</li> <li>m_actualPosition (Motor)</li> <li>m_actualPower (Motor)</li> <li>m_actualTicksPerLoop (Motor)</li> <li>m_dither (Motor)</li> <li>m_lastEncTicks (Motor)</li> <li>m_maxAccel (Motor)</li> <li>m_mode (Motor)</li> <li>m_posEpsilon (Motor)</li> <li>m_positionReg (Motor)</li> <li>m_targetPosition (Motor)</li> <li>m_targetVelocity (Motor)</li> <li>m_velEpsilon (Motor)</li> <li>m_velocityReg (Motor)</li> <li>m_queueStruct (QueueWrapper)</li> <li>m_d (Regulator)</li> <li>m_de (Regulator)</li> <li>m_e (Regulator)</li> <li>m_i (Regulator)</li> <li>m_integrator (Regulator)</li> <li>m_le (Regulator)</li> <li>m_max_output (Regulator)</li> <li>m_output (Regulator)</li> <li>m_p (Regulator)</li> <li>m_stop (Regulator)</li> <li>m_func (TaskWrapper)</li> <li>m_stack (TaskWrapper)</li> <li>m_taskStruct (TaskWrapper)</li> <li>MaxDelay (TickTimer)</li> <li>m_timeoutAt (TickTimer)</li> <li>m_state (XorShift)</li> </ul>"},{"location":"apiStm/class_member_variables/#p","title":"p","text":"<ul> <li>pxNextFreeBlock (A_BLOCK_LINK)</li> <li>pucStartAddress (HeapRegion)</li> <li>pcHead (QueueDefinition)</li> <li>pcWriteTo (QueueDefinition)</li> <li>pcReadFrom (QueuePointers)</li> <li>pcTail (QueuePointers)</li> <li>pucBuffer (StreamBufferDef_t)</li> <li>pxCoRoutineFunction (corCoRoutineControlBlock)</li> <li>pcTaskName (tskTaskControlBlock, xTASK_STATUS)</li> <li>pxStack (tskTaskControlBlock)</li> <li>pxTopOfStack (tskTaskControlBlock)</li> <li>poll (usbd_driver)</li> <li>pxIndex (xLIST)</li> <li>pvOwner (xLIST_ITEM)</li> <li>pxContainer (xLIST_ITEM)</li> <li>pxNext (xLIST_ITEM, xMINI_LIST_ITEM)</li> <li>pxPrevious (xLIST_ITEM, xMINI_LIST_ITEM)</li> <li>pvBaseAddress (xMEMORY_REGION)</li> <li>pvDummy3 (xSTATIC_LIST, xSTATIC_LIST_ITEM, xSTATIC_MINI_LIST_ITEM)</li> <li>pvDummy1 (xSTATIC_QUEUE, xSTATIC_TIMER)</li> <li>pvDummy2 (xSTATIC_QUEUE, xSTATIC_STREAM_BUFFER)</li> <li>pxDummy1 (xSTATIC_TCB)</li> <li>pxDummy6 (xSTATIC_TCB)</li> <li>pvDummy5 (xSTATIC_TIMER)</li> <li>pvDummy6 (xSTATIC_TIMER)</li> <li>pcName (xTASK_PARAMETERS)</li> <li>puxStackBuffer (xTASK_PARAMETERS)</li> <li>pvParameters (xTASK_PARAMETERS)</li> <li>pvTaskCode (xTASK_PARAMETERS)</li> <li>pxStackBase (xTASK_STATUS)</li> </ul>"},{"location":"apiStm/class_member_variables/#s","title":"s","text":"<ul> <li>status (_usbd_device)</li> <li>setaddr (usbd_driver)</li> </ul>"},{"location":"apiStm/class_member_variables/#t","title":"t","text":"<ul> <li>tempTypicalAtC (CalibrationData)</li> <li>tempTypicalMv (CalibrationData)</li> <li>tunnel_cdc_acm (cdc_config)</li> <li>tunnel_cdc_hdr (cdc_config)</li> <li>tunnel_cdc_mgmt (cdc_config)</li> <li>tunnel_cdc_union (cdc_config)</li> <li>tunnel_comm (cdc_config)</li> <li>tunnel_comm_ep (cdc_config)</li> <li>tunnel_comm_iad (cdc_config)</li> <li>tunnel_data (cdc_config)</li> <li>tunnel_data_eprx (cdc_config)</li> <li>tunnel_data_eptx (cdc_config)</li> </ul>"},{"location":"apiStm/class_member_variables/#u","title":"u","text":"<ul> <li>uxEventBits (EventGroupDef_t)</li> <li>u (QueueDefinition, xSTATIC_QUEUE)</li> <li>uxItemSize (QueueDefinition)</li> <li>uxLength (QueueDefinition)</li> <li>uxMessagesWaiting (QueueDefinition)</li> <li>uxRecursiveCallCount (SemaphoreData)</li> <li>ucFlags (StreamBufferDef_t)</li> <li>uxIndex (corCoRoutineControlBlock)</li> <li>uxPriority (corCoRoutineControlBlock, tskTaskControlBlock, xTASK_PARAMETERS)</li> <li>uxState (corCoRoutineControlBlock)</li> <li>uxNumberOfItems (xLIST)</li> <li>ulLengthInBytes (xMEMORY_REGION)</li> <li>ulParameters (xMEMORY_REGION)</li> <li>uxDummy2 (xSTATIC_LIST, xSTATIC_QUEUE)</li> <li>ucDummy5 (xSTATIC_QUEUE)</li> <li>uxDummy4 (xSTATIC_QUEUE)</li> <li>ucDummy3 (xSTATIC_STREAM_BUFFER)</li> <li>uxDummy1 (xSTATIC_STREAM_BUFFER)</li> <li>ucDummy19 (xSTATIC_TCB)</li> <li>ucDummy7 (xSTATIC_TCB)</li> <li>ulDummy18 (xSTATIC_TCB)</li> <li>uxDummy5 (xSTATIC_TCB)</li> <li>ucDummy8 (xSTATIC_TIMER)</li> <li>usStackDepth (xTASK_PARAMETERS)</li> <li>ulRunTimeCounter (xTASK_STATUS)</li> <li>usStackHighWaterMark (xTASK_STATUS)</li> <li>uxBasePriority (xTASK_STATUS)</li> <li>uxCurrentPriority (xTASK_STATUS)</li> </ul>"},{"location":"apiStm/class_member_variables/#w","title":"w","text":"<ul> <li>wCountyCode0 (usb_cdc_country_desc)</li> <li>wIndex (usb_cdc_notification, usbd_ctlreq)</li> <li>wLength (usb_cdc_notification, usbd_ctlreq)</li> <li>wValue (usb_cdc_notification, usbd_ctlreq)</li> <li>wTotalLength (usb_config_descriptor)</li> <li>wMaxPacketSize (usb_endpoint_descriptor)</li> <li>wString (usb_string_descriptor)</li> </ul>"},{"location":"apiStm/class_member_variables/#x","title":"x","text":"<ul> <li>xBlockSize (A_BLOCK_LINK)</li> <li>xTasksWaitingForBits (EventGroupDef_t)</li> <li>xSizeInBytes (HeapRegion)</li> <li>x (MpuVector, MpuVector32, OLED_VERTEX)</li> <li>xQueue (QueueDefinition)</li> <li>xSemaphore (QueueDefinition)</li> <li>xTasksWaitingToReceive (QueueDefinition)</li> <li>xTasksWaitingToSend (QueueDefinition)</li> <li>xMutexHolder (SemaphoreData)</li> <li>xHead (StreamBufferDef_t)</li> <li>xLength (StreamBufferDef_t)</li> <li>xTail (StreamBufferDef_t)</li> <li>xTaskWaitingToReceive (StreamBufferDef_t)</li> <li>xTaskWaitingToSend (StreamBufferDef_t)</li> <li>xTriggerLevelBytes (StreamBufferDef_t)</li> <li>xEventListItem (corCoRoutineControlBlock, tskTaskControlBlock)</li> <li>xGenericListItem (corCoRoutineControlBlock)</li> <li>xStateListItem (tskTaskControlBlock)</li> <li>xAvailableHeapSpaceInBytes (xHeapStats)</li> <li>xMinimumEverFreeBytesRemaining (xHeapStats)</li> <li>xNumberOfFreeBlocks (xHeapStats)</li> <li>xNumberOfSuccessfulAllocations (xHeapStats)</li> <li>xNumberOfSuccessfulFrees (xHeapStats)</li> <li>xSizeOfLargestFreeBlockInBytes (xHeapStats)</li> <li>xSizeOfSmallestFreeBlockInBytes (xHeapStats)</li> <li>xListEnd (xLIST)</li> <li>xItemValue (xLIST_ITEM, xMINI_LIST_ITEM)</li> <li>xDummy1 (xSTATIC_EVENT_GROUP)</li> <li>xDummy2 (xSTATIC_EVENT_GROUP, xSTATIC_LIST_ITEM, xSTATIC_MINI_LIST_ITEM, xSTATIC_TIMER)</li> <li>xDummy4 (xSTATIC_LIST)</li> <li>xDummy3 (xSTATIC_QUEUE, xSTATIC_TCB, xSTATIC_TIMER)</li> <li>xRegions (xTASK_PARAMETERS)</li> <li>xHandle (xTASK_STATUS)</li> <li>xTaskNumber (xTASK_STATUS)</li> <li>xOverflowCount (xTIME_OUT)</li> <li>xTimeOnEntering (xTIME_OUT)</li> </ul>"},{"location":"apiStm/class_member_variables/#y","title":"y","text":"<ul> <li>y (MpuVector, MpuVector32, OLED_VERTEX)</li> </ul>"},{"location":"apiStm/class_member_variables/#z","title":"z","text":"<ul> <li>z (MpuVector, MpuVector32)</li> </ul>"},{"location":"apiStm/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"apiStm/class_member_typedefs/#c","title":"c","text":"<ul> <li>coef_type (Regulator)</li> </ul>"},{"location":"apiStm/class_member_typedefs/#v","title":"v","text":"<ul> <li>value_type (Regulator)</li> </ul>"},{"location":"apiStm/class_member_enums/","title":"Class Member Enums","text":""},{"location":"apiStm/class_member_enums/#e","title":"e","text":"<ul> <li>EnHolderType (Esp32Manager)</li> </ul>"},{"location":"apiStm/class_member_enums/#q","title":"q","text":"<ul> <li>QueuedReset (Esp32Manager)</li> </ul>"},{"location":"apiStm/namespace_members/","title":"Namespace Members","text":""},{"location":"apiStm/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"apiStm/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"apiStm/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"apiStm/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"apiStm/functions/","title":"Functions","text":""},{"location":"apiStm/functions/#a","title":"a","text":"<ul> <li>Atomic_AND_u32 (atomic.h)</li> <li>Atomic_Add_u32 (atomic.h)</li> <li>Atomic_CompareAndSwapPointers_p32 (atomic.h)</li> <li>Atomic_CompareAndSwap_u32 (atomic.h)</li> <li>Atomic_Decrement_u32 (atomic.h)</li> <li>Atomic_Increment_u32 (atomic.h)</li> <li>Atomic_NAND_u32 (atomic.h)</li> <li>Atomic_OR_u32 (atomic.h)</li> <li>Atomic_Subtract_u32 (atomic.h)</li> <li>Atomic_SwapPointers_p32 (atomic.h)</li> <li>Atomic_XOR_u32 (atomic.h)</li> <li>AUXILIARY_AND_MOTOR_ADC_IRQ_HANDLER (Power.cpp)</li> <li>adcWait (Power.cpp)</li> </ul>"},{"location":"apiStm/functions/#b","title":"b","text":"<ul> <li>buttonControllerPoll (ButtonController.hpp, ButtonController.cpp)</li> <li>buttonControllerSetDebug (ButtonController.hpp, ButtonController.cpp)</li> <li>buzzerSetState (BuzzerController.hpp)</li> </ul>"},{"location":"apiStm/functions/#c","title":"c","text":"<ul> <li>clocksInit (Bsp.hpp)</li> <li>controlLinkReset (ControlLink.hpp, ControlLink.cpp)</li> <li>controlLinkRx (ControlLink.hpp, ControlLink.cpp)</li> <li>controlLinkTx (ControlLink.hpp, ControlLink.cpp)</li> <li>controlUartInit (ControlLink.hpp, ControlLink.cpp)</li> <li>cdcLinkInit (UsbCdcLink.h, UsbCdcLink.cpp)</li> <li>cdcLinkIsDebugEpEnabled (UsbCdcLink.h, UsbCdcLink.cpp)</li> <li>CONTROLUART_TX_DMA_HANDLER (ControlLink.cpp)</li> <li>controlLinkUpdateRxFifo (ControlLink.cpp)</li> <li>checkBatteryVoltage (Power.cpp)</li> <li>cdc_control (UsbCdcLink.cpp)</li> <li>cdc_control_debug (UsbCdcLink.cpp)</li> <li>cdc_control_tunnel (UsbCdcLink.cpp)</li> <li>cdc_getdesc (UsbCdcLink.cpp)</li> <li>cdc_setconf (UsbCdcLink.cpp)</li> </ul>"},{"location":"apiStm/functions/#d","title":"d","text":"<ul> <li>debugLinkPoll (DebugLink.hpp, DebugLink.cpp)</li> <li>debugLinkTx (DebugLink.hpp, DebugLink.cpp)</li> <li>debugUartInit (DebugLink.hpp, DebugLink.cpp)</li> <li>dispatcherEnqueueRequest (Dispatcher.hpp, Dispatcher.cpp)</li> <li>dispatcherEnqueueStatus (Dispatcher.hpp, Dispatcher.cpp)</li> <li>dispatcherInit (Dispatcher.hpp, Dispatcher.cpp)</li> <li>dispatcherPoll (Dispatcher.hpp, Dispatcher.cpp)</li> <li>dispatcherReset (Dispatcher.hpp, Dispatcher.cpp)</li> <li>DEBUG_HEX (Debug.hpp)</li> <li>DEBUGUART_HANDLER (DebugLink.cpp)</li> <li>DEBUGUART_TX_DMA_HANDLER (DebugLink.cpp)</li> <li>debugDownstreamHandler (DebugLink.cpp)</li> <li>debugLinkHandleCommand (DebugLink.cpp)</li> <li>debugUpstreamHandler (DebugLink.cpp)</li> <li>dispatcherProcessReq (Dispatcher.cpp)</li> </ul>"},{"location":"apiStm/functions/#e","title":"e","text":"<ul> <li>eTaskConfirmSleepModeStatus (task.h)</li> <li>eTaskGetState (task.h)</li> <li>EXTI4_IRQHandler (Bsp.cpp)</li> <li>EXTI9_5_IRQHandler (Bsp.cpp)</li> </ul>"},{"location":"apiStm/functions/#f","title":"f","text":"<ul> <li>flashWritePage (Flash.hpp)</li> </ul>"},{"location":"apiStm/functions/#g","title":"g","text":"<ul> <li>getButtons (Bsp.hpp)</li> <li>getExternalSensorDWord (Mpu6050.hpp, MpuController.hpp)</li> <li>getXFineGain (Mpu6050.hpp, MpuController.hpp)</li> <li>getXGyroOffsetTC (Mpu6050.hpp, MpuController.hpp)</li> <li>getYFineGain (Mpu6050.hpp, MpuController.hpp)</li> <li>getYGyroOffsetTC (Mpu6050.hpp, MpuController.hpp)</li> <li>getZFineGain (Mpu6050.hpp, MpuController.hpp)</li> <li>getZGyroOffsetTC (Mpu6050.hpp, MpuController.hpp)</li> </ul>"},{"location":"apiStm/functions/#h","title":"h","text":"<ul> <li>HAL_DMA_PollForTransfer_Really (HalDma.hpp)</li> <li>HAL_I2C_ErrorCallback (I2cController.cpp)</li> <li>HAL_I2C_MasterRxCpltCallback (I2cController.cpp)</li> <li>HAL_I2C_MasterTxCpltCallback (I2cController.cpp)</li> <li>HAL_I2C_MemRxCpltCallback (I2cController.cpp)</li> <li>HAL_I2C_MemTxCpltCallback (I2cController.cpp)</li> </ul>"},{"location":"apiStm/functions/#i","title":"i","text":"<ul> <li>isPressed (Bsp.hpp)</li> <li>I2Cdev_IsDeviceReady (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_Master_Receive (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_Master_Transmit (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_Mem_Read (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_Mem_Write (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_Slave_Receive (I2cController.hpp)</li> <li>I2Cdev_Slave_Transmit (I2cController.hpp)</li> <li>I2Cdev_init (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_readBit (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_readBitW (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_readBits (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_readBitsW (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_readByte (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_readBytes (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_readWord (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_readWords (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_scan (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_writeBit (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_writeBitW (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_writeBits (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_writeBitsW (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_writeByte (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_writeBytes (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_writeWord (I2cController.hpp, I2cController.cpp)</li> <li>I2Cdev_writeWords (I2cController.hpp, I2cController.cpp)</li> <li>i2cDispatch (I2cController.hpp, I2cController.cpp)</li> <li>i2cReset (I2cController.hpp, I2cController.cpp)</li> <li>isInInterrupt (Debug.hpp)</li> <li>I2C1_ER_IRQHandler (I2cController.cpp)</li> <li>I2C1_EV_IRQHandler (I2cController.cpp)</li> <li>i2cNotify (I2cController.cpp)</li> <li>i2cWait (I2cController.cpp)</li> <li>i2cWrap (I2cController.cpp)</li> </ul>"},{"location":"apiStm/functions/#l","title":"l","text":"<ul> <li>LL_ADC_SetChannelSamplingTimeFix (Bsp.hpp)</li> <li>LL_GPIO_AF_Remap (Bsp.hpp)</li> <li>loadCalibration (Power.cpp)</li> </ul>"},{"location":"apiStm/functions/#m","title":"m","text":"<ul> <li>motorDispatch (MotorController.hpp, MotorController.cpp)</li> <li>motorInit (MotorController.hpp, MotorController.cpp)</li> <li>motorReset (MotorController.hpp, MotorController.cpp)</li> <li>MPU6050 (Mpu6050.hpp)</li> <li>MPU6050_getAccelFIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_getAccelXSelfTest (Mpu6050.hpp)</li> <li>MPU6050_getAccelYSelfTest (Mpu6050.hpp)</li> <li>MPU6050_getAccelZSelfTest (Mpu6050.hpp)</li> <li>MPU6050_getAcceleration (Mpu6050.hpp)</li> <li>MPU6050_getAccelerationX (Mpu6050.hpp)</li> <li>MPU6050_getAccelerationY (Mpu6050.hpp)</li> <li>MPU6050_getAccelerationZ (Mpu6050.hpp)</li> <li>MPU6050_getAccelerometerPowerOnDelay (Mpu6050.hpp)</li> <li>MPU6050_getAuxVDDIOLevel (Mpu6050.hpp)</li> <li>MPU6050_getClockOutputEnabled (Mpu6050.hpp)</li> <li>MPU6050_getClockSource (Mpu6050.hpp)</li> <li>MPU6050_getDHPFMode (Mpu6050.hpp)</li> <li>MPU6050_getDLPFMode (Mpu6050.hpp)</li> <li>MPU6050_getDMPConfig1 (Mpu6050.hpp)</li> <li>MPU6050_getDMPConfig2 (Mpu6050.hpp)</li> <li>MPU6050_getDMPEnabled (Mpu6050.hpp)</li> <li>MPU6050_getDMPInt0Status (Mpu6050.hpp)</li> <li>MPU6050_getDMPInt1Status (Mpu6050.hpp)</li> <li>MPU6050_getDMPInt2Status (Mpu6050.hpp)</li> <li>MPU6050_getDMPInt3Status (Mpu6050.hpp)</li> <li>MPU6050_getDMPInt4Status (Mpu6050.hpp)</li> <li>MPU6050_getDMPInt5Status (Mpu6050.hpp)</li> <li>MPU6050_getDeviceID (Mpu6050.hpp)</li> <li>MPU6050_getExternalFrameSync (Mpu6050.hpp)</li> <li>MPU6050_getExternalSensorByte (Mpu6050.hpp)</li> <li>MPU6050_getExternalSensorWord (Mpu6050.hpp)</li> <li>MPU6050_getExternalShadowDelayEnabled (Mpu6050.hpp)</li> <li>MPU6050_getFIFOByte (Mpu6050.hpp)</li> <li>MPU6050_getFIFOBytes (Mpu6050.hpp)</li> <li>MPU6050_getFIFOCount (Mpu6050.hpp)</li> <li>MPU6050_getFIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_getFSyncInterruptEnabled (Mpu6050.hpp)</li> <li>MPU6050_getFSyncInterruptLevel (Mpu6050.hpp)</li> <li>MPU6050_getFreefallDetectionCounterDecrement (Mpu6050.hpp)</li> <li>MPU6050_getFreefallDetectionDuration (Mpu6050.hpp)</li> <li>MPU6050_getFreefallDetectionThreshold (Mpu6050.hpp)</li> <li>MPU6050_getFullScaleAccelRange (Mpu6050.hpp)</li> <li>MPU6050_getFullScaleGyroRange (Mpu6050.hpp)</li> <li>MPU6050_getI2CBypassEnabled (Mpu6050.hpp)</li> <li>MPU6050_getI2CMasterModeEnabled (Mpu6050.hpp)</li> <li>MPU6050_getIntDMPEnabled (Mpu6050.hpp)</li> <li>MPU6050_getIntDMPStatus (Mpu6050.hpp)</li> <li>MPU6050_getIntDataReadyEnabled (Mpu6050.hpp)</li> <li>MPU6050_getIntDataReadyStatus (Mpu6050.hpp)</li> <li>MPU6050_getIntEnabled (Mpu6050.hpp)</li> <li>MPU6050_getIntFIFOBufferOverflowEnabled (Mpu6050.hpp)</li> <li>MPU6050_getIntFIFOBufferOverflowStatus (Mpu6050.hpp)</li> <li>MPU6050_getIntFreefallEnabled (Mpu6050.hpp)</li> <li>MPU6050_getIntFreefallStatus (Mpu6050.hpp)</li> <li>MPU6050_getIntI2CMasterEnabled (Mpu6050.hpp)</li> <li>MPU6050_getIntI2CMasterStatus (Mpu6050.hpp)</li> <li>MPU6050_getIntMotionEnabled (Mpu6050.hpp)</li> <li>MPU6050_getIntMotionStatus (Mpu6050.hpp)</li> <li>MPU6050_getIntPLLReadyEnabled (Mpu6050.hpp)</li> <li>MPU6050_getIntPLLReadyStatus (Mpu6050.hpp)</li> <li>MPU6050_getIntStatus (Mpu6050.hpp)</li> <li>MPU6050_getIntZeroMotionEnabled (Mpu6050.hpp)</li> <li>MPU6050_getIntZeroMotionStatus (Mpu6050.hpp)</li> <li>MPU6050_getInterruptDrive (Mpu6050.hpp)</li> <li>MPU6050_getInterruptLatch (Mpu6050.hpp)</li> <li>MPU6050_getInterruptLatchClear (Mpu6050.hpp)</li> <li>MPU6050_getInterruptMode (Mpu6050.hpp)</li> <li>MPU6050_getLostArbitration (Mpu6050.hpp)</li> <li>MPU6050_getMasterClockSpeed (Mpu6050.hpp)</li> <li>MPU6050_getMotion6 (Mpu6050.hpp)</li> <li>MPU6050_getMotion9 (Mpu6050.hpp)</li> <li>MPU6050_getMotionDetectionCounterDecrement (Mpu6050.hpp)</li> <li>MPU6050_getMotionDetectionDuration (Mpu6050.hpp)</li> <li>MPU6050_getMotionDetectionThreshold (Mpu6050.hpp)</li> <li>MPU6050_getMultiMasterEnabled (Mpu6050.hpp)</li> <li>MPU6050_getOTPBankValid (Mpu6050.hpp)</li> <li>MPU6050_getPassthroughStatus (Mpu6050.hpp)</li> <li>MPU6050_getRate (Mpu6050.hpp)</li> <li>MPU6050_getRotation (Mpu6050.hpp)</li> <li>MPU6050_getRotationX (Mpu6050.hpp)</li> <li>MPU6050_getRotationY (Mpu6050.hpp)</li> <li>MPU6050_getRotationZ (Mpu6050.hpp)</li> <li>MPU6050_getSlate4InputByte (Mpu6050.hpp)</li> <li>MPU6050_getSlave0FIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_getSlave0Nack (Mpu6050.hpp)</li> <li>MPU6050_getSlave1FIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_getSlave1Nack (Mpu6050.hpp)</li> <li>MPU6050_getSlave2FIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_getSlave2Nack (Mpu6050.hpp)</li> <li>MPU6050_getSlave3FIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_getSlave3Nack (Mpu6050.hpp)</li> <li>MPU6050_getSlave4Address (Mpu6050.hpp)</li> <li>MPU6050_getSlave4Enabled (Mpu6050.hpp)</li> <li>MPU6050_getSlave4InterruptEnabled (Mpu6050.hpp)</li> <li>MPU6050_getSlave4IsDone (Mpu6050.hpp)</li> <li>MPU6050_getSlave4MasterDelay (Mpu6050.hpp)</li> <li>MPU6050_getSlave4Nack (Mpu6050.hpp)</li> <li>MPU6050_getSlave4Register (Mpu6050.hpp)</li> <li>MPU6050_getSlave4WriteMode (Mpu6050.hpp)</li> <li>MPU6050_getSlaveAddress (Mpu6050.hpp)</li> <li>MPU6050_getSlaveDataLength (Mpu6050.hpp)</li> <li>MPU6050_getSlaveDelayEnabled (Mpu6050.hpp)</li> <li>MPU6050_getSlaveEnabled (Mpu6050.hpp)</li> <li>MPU6050_getSlaveReadWriteTransitionEnabled (Mpu6050.hpp)</li> <li>MPU6050_getSlaveRegister (Mpu6050.hpp)</li> <li>MPU6050_getSlaveWordByteSwap (Mpu6050.hpp)</li> <li>MPU6050_getSlaveWordGroupOffset (Mpu6050.hpp)</li> <li>MPU6050_getSlaveWriteMode (Mpu6050.hpp)</li> <li>MPU6050_getSleepEnabled (Mpu6050.hpp)</li> <li>MPU6050_getStandbyXAccelEnabled (Mpu6050.hpp)</li> <li>MPU6050_getStandbyXGyroEnabled (Mpu6050.hpp)</li> <li>MPU6050_getStandbyYAccelEnabled (Mpu6050.hpp)</li> <li>MPU6050_getStandbyYGyroEnabled (Mpu6050.hpp)</li> <li>MPU6050_getStandbyZAccelEnabled (Mpu6050.hpp)</li> <li>MPU6050_getStandbyZGyroEnabled (Mpu6050.hpp)</li> <li>MPU6050_getTempFIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_getTempSensorEnabled (Mpu6050.hpp)</li> <li>MPU6050_getTemperature (Mpu6050.hpp)</li> <li>MPU6050_getWaitForExternalSensorEnabled (Mpu6050.hpp)</li> <li>MPU6050_getWakeCycleEnabled (Mpu6050.hpp)</li> <li>MPU6050_getWakeFrequency (Mpu6050.hpp)</li> <li>MPU6050_getXAccelOffset (Mpu6050.hpp)</li> <li>MPU6050_getXGyroFIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_getXGyroOffset (Mpu6050.hpp)</li> <li>MPU6050_getXNegMotionDetected (Mpu6050.hpp)</li> <li>MPU6050_getXPosMotionDetected (Mpu6050.hpp)</li> <li>MPU6050_getYAccelOffset (Mpu6050.hpp)</li> <li>MPU6050_getYGyroFIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_getYGyroOffset (Mpu6050.hpp)</li> <li>MPU6050_getYNegMotionDetected (Mpu6050.hpp)</li> <li>MPU6050_getYPosMotionDetected (Mpu6050.hpp)</li> <li>MPU6050_getZAccelOffset (Mpu6050.hpp)</li> <li>MPU6050_getZGyroFIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_getZGyroOffset (Mpu6050.hpp)</li> <li>MPU6050_getZNegMotionDetected (Mpu6050.hpp)</li> <li>MPU6050_getZPosMotionDetected (Mpu6050.hpp)</li> <li>MPU6050_getZeroMotionDetected (Mpu6050.hpp)</li> <li>MPU6050_getZeroMotionDetectionDuration (Mpu6050.hpp)</li> <li>MPU6050_getZeroMotionDetectionThreshold (Mpu6050.hpp)</li> <li>MPU6050_init (Mpu6050.hpp)</li> <li>MPU6050_initialize (Mpu6050.hpp)</li> <li>MPU6050_readMemoryBlock (Mpu6050.hpp)</li> <li>MPU6050_readMemoryByte (Mpu6050.hpp)</li> <li>MPU6050_reset (Mpu6050.hpp)</li> <li>MPU6050_resetAccelerometerPath (Mpu6050.hpp)</li> <li>MPU6050_resetDMP (Mpu6050.hpp)</li> <li>MPU6050_resetFIFO (Mpu6050.hpp)</li> <li>MPU6050_resetGyroscopePath (Mpu6050.hpp)</li> <li>MPU6050_resetI2CMaster (Mpu6050.hpp)</li> <li>MPU6050_resetSensors (Mpu6050.hpp)</li> <li>MPU6050_resetTemperaturePath (Mpu6050.hpp)</li> <li>MPU6050_setAccelFIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_setAccelXSelfTest (Mpu6050.hpp)</li> <li>MPU6050_setAccelYSelfTest (Mpu6050.hpp)</li> <li>MPU6050_setAccelZSelfTest (Mpu6050.hpp)</li> <li>MPU6050_setAccelerometerPowerOnDelay (Mpu6050.hpp)</li> <li>MPU6050_setAuxVDDIOLevel (Mpu6050.hpp)</li> <li>MPU6050_setClockOutputEnabled (Mpu6050.hpp)</li> <li>MPU6050_setClockSource (Mpu6050.hpp)</li> <li>MPU6050_setDHPFMode (Mpu6050.hpp)</li> <li>MPU6050_setDLPFMode (Mpu6050.hpp)</li> <li>MPU6050_setDMPConfig1 (Mpu6050.hpp)</li> <li>MPU6050_setDMPConfig2 (Mpu6050.hpp)</li> <li>MPU6050_setDMPEnabled (Mpu6050.hpp)</li> <li>MPU6050_setDeviceID (Mpu6050.hpp)</li> <li>MPU6050_setExternalFrameSync (Mpu6050.hpp)</li> <li>MPU6050_setExternalShadowDelayEnabled (Mpu6050.hpp)</li> <li>MPU6050_setFIFOByte (Mpu6050.hpp)</li> <li>MPU6050_setFIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_setFSyncInterruptEnabled (Mpu6050.hpp)</li> <li>MPU6050_setFSyncInterruptLevel (Mpu6050.hpp)</li> <li>MPU6050_setFreefallDetectionCounterDecrement (Mpu6050.hpp)</li> <li>MPU6050_setFreefallDetectionDuration (Mpu6050.hpp)</li> <li>MPU6050_setFreefallDetectionThreshold (Mpu6050.hpp)</li> <li>MPU6050_setFullScaleAccelRange (Mpu6050.hpp)</li> <li>MPU6050_setFullScaleGyroRange (Mpu6050.hpp)</li> <li>MPU6050_setI2CBypassEnabled (Mpu6050.hpp)</li> <li>MPU6050_setI2CMasterModeEnabled (Mpu6050.hpp)</li> <li>MPU6050_setIntDMPEnabled (Mpu6050.hpp)</li> <li>MPU6050_setIntDataReadyEnabled (Mpu6050.hpp)</li> <li>MPU6050_setIntEnabled (Mpu6050.hpp)</li> <li>MPU6050_setIntFIFOBufferOverflowEnabled (Mpu6050.hpp)</li> <li>MPU6050_setIntFreefallEnabled (Mpu6050.hpp)</li> <li>MPU6050_setIntI2CMasterEnabled (Mpu6050.hpp)</li> <li>MPU6050_setIntMotionEnabled (Mpu6050.hpp)</li> <li>MPU6050_setIntPLLReadyEnabled (Mpu6050.hpp)</li> <li>MPU6050_setIntZeroMotionEnabled (Mpu6050.hpp)</li> <li>MPU6050_setInterruptDrive (Mpu6050.hpp)</li> <li>MPU6050_setInterruptLatch (Mpu6050.hpp)</li> <li>MPU6050_setInterruptLatchClear (Mpu6050.hpp)</li> <li>MPU6050_setInterruptMode (Mpu6050.hpp)</li> <li>MPU6050_setMasterClockSpeed (Mpu6050.hpp)</li> <li>MPU6050_setMemoryBank (Mpu6050.hpp)</li> <li>MPU6050_setMemoryStartAddress (Mpu6050.hpp)</li> <li>MPU6050_setMotionDetectionCounterDecrement (Mpu6050.hpp)</li> <li>MPU6050_setMotionDetectionDuration (Mpu6050.hpp)</li> <li>MPU6050_setMotionDetectionThreshold (Mpu6050.hpp)</li> <li>MPU6050_setMultiMasterEnabled (Mpu6050.hpp)</li> <li>MPU6050_setOTPBankValid (Mpu6050.hpp)</li> <li>MPU6050_setRate (Mpu6050.hpp)</li> <li>MPU6050_setSlave0FIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_setSlave1FIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_setSlave2FIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_setSlave3FIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_setSlave4Address (Mpu6050.hpp)</li> <li>MPU6050_setSlave4Enabled (Mpu6050.hpp)</li> <li>MPU6050_setSlave4InterruptEnabled (Mpu6050.hpp)</li> <li>MPU6050_setSlave4MasterDelay (Mpu6050.hpp)</li> <li>MPU6050_setSlave4OutputByte (Mpu6050.hpp)</li> <li>MPU6050_setSlave4Register (Mpu6050.hpp)</li> <li>MPU6050_setSlave4WriteMode (Mpu6050.hpp)</li> <li>MPU6050_setSlaveAddress (Mpu6050.hpp)</li> <li>MPU6050_setSlaveDataLength (Mpu6050.hpp)</li> <li>MPU6050_setSlaveDelayEnabled (Mpu6050.hpp)</li> <li>MPU6050_setSlaveEnabled (Mpu6050.hpp)</li> <li>MPU6050_setSlaveOutputByte (Mpu6050.hpp)</li> <li>MPU6050_setSlaveReadWriteTransitionEnabled (Mpu6050.hpp)</li> <li>MPU6050_setSlaveRegister (Mpu6050.hpp)</li> <li>MPU6050_setSlaveWordByteSwap (Mpu6050.hpp)</li> <li>MPU6050_setSlaveWordGroupOffset (Mpu6050.hpp)</li> <li>MPU6050_setSlaveWriteMode (Mpu6050.hpp)</li> <li>MPU6050_setSleepEnabled (Mpu6050.hpp)</li> <li>MPU6050_setStandbyXAccelEnabled (Mpu6050.hpp)</li> <li>MPU6050_setStandbyXGyroEnabled (Mpu6050.hpp)</li> <li>MPU6050_setStandbyYAccelEnabled (Mpu6050.hpp)</li> <li>MPU6050_setStandbyYGyroEnabled (Mpu6050.hpp)</li> <li>MPU6050_setStandbyZAccelEnabled (Mpu6050.hpp)</li> <li>MPU6050_setStandbyZGyroEnabled (Mpu6050.hpp)</li> <li>MPU6050_setTempFIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_setTempSensorEnabled (Mpu6050.hpp)</li> <li>MPU6050_setWaitForExternalSensorEnabled (Mpu6050.hpp)</li> <li>MPU6050_setWakeCycleEnabled (Mpu6050.hpp)</li> <li>MPU6050_setWakeFrequency (Mpu6050.hpp)</li> <li>MPU6050_setXAccelOffset (Mpu6050.hpp)</li> <li>MPU6050_setXFineGain (Mpu6050.hpp)</li> <li>MPU6050_setXGyroFIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_setXGyroOffset (Mpu6050.hpp)</li> <li>MPU6050_setXGyroOffsetTC (Mpu6050.hpp)</li> <li>MPU6050_setYAccelOffset (Mpu6050.hpp)</li> <li>MPU6050_setYFineGain (Mpu6050.hpp)</li> <li>MPU6050_setYGyroFIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_setYGyroOffset (Mpu6050.hpp)</li> <li>MPU6050_setYGyroOffsetTC (Mpu6050.hpp)</li> <li>MPU6050_setZAccelOffset (Mpu6050.hpp)</li> <li>MPU6050_setZFineGain (Mpu6050.hpp)</li> <li>MPU6050_setZGyroFIFOEnabled (Mpu6050.hpp)</li> <li>MPU6050_setZGyroOffset (Mpu6050.hpp)</li> <li>MPU6050_setZGyroOffsetTC (Mpu6050.hpp)</li> <li>MPU6050_setZeroMotionDetectionDuration (Mpu6050.hpp)</li> <li>MPU6050_setZeroMotionDetectionThreshold (Mpu6050.hpp)</li> <li>MPU6050_switchSPIEnabled (Mpu6050.hpp)</li> <li>MPU6050_testConnection (Mpu6050.hpp)</li> <li>MPU6050_writeMemoryByte (Mpu6050.hpp)</li> <li>mpuCreate (MpuController.hpp, MpuController.cpp)</li> <li>mpuDispatch (MpuController.hpp, MpuController.cpp)</li> <li>mpuInitialize (MpuController.hpp, MpuController.cpp)</li> <li>mpuReset (MpuController.hpp, MpuController.cpp)</li> <li>mpuTick (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getAccelFIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getAccelXSelfTest (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getAccelYSelfTest (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getAccelZSelfTest (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getAcceleration (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getAccelerationX (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getAccelerationY (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getAccelerationZ (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getAccelerometerPowerOnDelay (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getAuxVDDIOLevel (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getClockOutputEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getClockSource (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getDHPFMode (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getDLPFMode (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getDMPConfig1 (MpuController.hpp)</li> <li>mpu_getDMPConfig2 (MpuController.hpp)</li> <li>mpu_getDMPEnabled (MpuController.hpp)</li> <li>mpu_getDMPInt0Status (MpuController.hpp)</li> <li>mpu_getDMPInt1Status (MpuController.hpp)</li> <li>mpu_getDMPInt2Status (MpuController.hpp)</li> <li>mpu_getDMPInt3Status (MpuController.hpp)</li> <li>mpu_getDMPInt4Status (MpuController.hpp)</li> <li>mpu_getDMPInt5Status (MpuController.hpp)</li> <li>mpu_getDeviceID (MpuController.hpp)</li> <li>mpu_getExternalFrameSync (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getExternalSensorByte (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getExternalSensorWord (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getExternalShadowDelayEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getFIFOByte (MpuController.hpp)</li> <li>mpu_getFIFOBytes (MpuController.hpp)</li> <li>mpu_getFIFOCount (MpuController.hpp)</li> <li>mpu_getFIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getFSyncInterruptEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getFSyncInterruptLevel (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getFreefallDetectionCounterDecrement (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getFreefallDetectionDuration (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getFreefallDetectionThreshold (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getFullScaleAccelRange (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getFullScaleGyroRange (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getI2CBypassEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getI2CMasterModeEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntDMPEnabled (MpuController.hpp)</li> <li>mpu_getIntDMPStatus (MpuController.hpp)</li> <li>mpu_getIntDataReadyEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntDataReadyStatus (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntFIFOBufferOverflowEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntFIFOBufferOverflowStatus (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntFreefallEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntFreefallStatus (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntI2CMasterEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntI2CMasterStatus (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntMotionEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntMotionStatus (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntPLLReadyEnabled (MpuController.hpp)</li> <li>mpu_getIntPLLReadyStatus (MpuController.hpp)</li> <li>mpu_getIntStatus (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntZeroMotionEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getIntZeroMotionStatus (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getInterruptDrive (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getInterruptLatch (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getInterruptLatchClear (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getInterruptMode (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getLostArbitration (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getMasterClockSpeed (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getMotion6 (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getMotion9 (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getMotionDetectionCounterDecrement (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getMotionDetectionDuration (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getMotionDetectionThreshold (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getMultiMasterEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getOTPBankValid (MpuController.hpp)</li> <li>mpu_getPassthroughStatus (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getRate (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getRotation (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getRotationX (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getRotationY (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getRotationZ (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlate4InputByte (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave0FIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave0Nack (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave1FIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave1Nack (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave2FIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave2Nack (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave3FIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave3Nack (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave4Address (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave4Enabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave4InterruptEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave4IsDone (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave4MasterDelay (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave4Nack (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave4Register (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlave4WriteMode (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlaveAddress (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlaveDataLength (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlaveDelayEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlaveEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlaveReadWriteTransitionEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlaveRegister (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlaveWordByteSwap (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlaveWordGroupOffset (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSlaveWriteMode (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getSleepEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getStandbyXAccelEnabled (MpuController.hpp)</li> <li>mpu_getStandbyXGyroEnabled (MpuController.hpp)</li> <li>mpu_getStandbyYAccelEnabled (MpuController.hpp)</li> <li>mpu_getStandbyYGyroEnabled (MpuController.hpp)</li> <li>mpu_getStandbyZAccelEnabled (MpuController.hpp)</li> <li>mpu_getStandbyZGyroEnabled (MpuController.hpp)</li> <li>mpu_getTempFIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getTempSensorEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getTemperature (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getWaitForExternalSensorEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getWakeCycleEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getWakeFrequency (MpuController.hpp)</li> <li>mpu_getXAccelOffset (MpuController.hpp)</li> <li>mpu_getXGyroFIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getXGyroOffset (MpuController.hpp)</li> <li>mpu_getXNegMotionDetected (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getXPosMotionDetected (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getYAccelOffset (MpuController.hpp)</li> <li>mpu_getYGyroFIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getYGyroOffset (MpuController.hpp)</li> <li>mpu_getYNegMotionDetected (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getYPosMotionDetected (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getZAccelOffset (MpuController.hpp)</li> <li>mpu_getZGyroFIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getZGyroOffset (MpuController.hpp)</li> <li>mpu_getZNegMotionDetected (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getZPosMotionDetected (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getZeroMotionDetected (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getZeroMotionDetectionDuration (MpuController.hpp, MpuController.cpp)</li> <li>mpu_getZeroMotionDetectionThreshold (MpuController.hpp, MpuController.cpp)</li> <li>mpu_readMemoryBlock (MpuController.hpp)</li> <li>mpu_readMemoryByte (MpuController.hpp)</li> <li>mpu_reset (MpuController.hpp, MpuController.cpp)</li> <li>mpu_resetAccelerometerPath (MpuController.hpp, MpuController.cpp)</li> <li>mpu_resetDMP (MpuController.hpp)</li> <li>mpu_resetFIFO (MpuController.hpp, MpuController.cpp)</li> <li>mpu_resetGyroscopePath (MpuController.hpp, MpuController.cpp)</li> <li>mpu_resetI2CMaster (MpuController.hpp, MpuController.cpp)</li> <li>mpu_resetSensors (MpuController.hpp, MpuController.cpp)</li> <li>mpu_resetTemperaturePath (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setAccelFIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setAccelXSelfTest (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setAccelYSelfTest (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setAccelZSelfTest (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setAccelerometerPowerOnDelay (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setAuxVDDIOLevel (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setClockOutputEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setClockSource (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setDHPFMode (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setDLPFMode (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setDMPConfig1 (MpuController.hpp)</li> <li>mpu_setDMPConfig2 (MpuController.hpp)</li> <li>mpu_setDMPEnabled (MpuController.hpp)</li> <li>mpu_setDeviceID (MpuController.hpp)</li> <li>mpu_setExternalFrameSync (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setExternalShadowDelayEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setFIFOByte (MpuController.hpp)</li> <li>mpu_setFIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setFSyncInterruptEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setFSyncInterruptLevel (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setFreefallDetectionCounterDecrement (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setFreefallDetectionDuration (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setFreefallDetectionThreshold (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setFullScaleAccelRange (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setFullScaleGyroRange (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setI2CBypassEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setI2CMasterModeEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setIntDMPEnabled (MpuController.hpp)</li> <li>mpu_setIntDataReadyEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setIntEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setIntFIFOBufferOverflowEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setIntFreefallEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setIntI2CMasterEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setIntMotionEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setIntPLLReadyEnabled (MpuController.hpp)</li> <li>mpu_setIntZeroMotionEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setInterruptDrive (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setInterruptLatch (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setInterruptLatchClear (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setInterruptMode (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setMasterClockSpeed (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setMemoryBank (MpuController.hpp)</li> <li>mpu_setMemoryStartAddress (MpuController.hpp)</li> <li>mpu_setMotionDetectionCounterDecrement (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setMotionDetectionDuration (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setMotionDetectionThreshold (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setMultiMasterEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setOTPBankValid (MpuController.hpp)</li> <li>mpu_setRate (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlave0FIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlave1FIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlave2FIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlave3FIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlave4Address (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlave4Enabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlave4InterruptEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlave4MasterDelay (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlave4OutputByte (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlave4Register (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlave4WriteMode (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlaveAddress (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlaveDataLength (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlaveDelayEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlaveEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlaveOutputByte (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlaveReadWriteTransitionEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlaveRegister (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlaveWordByteSwap (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlaveWordGroupOffset (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSlaveWriteMode (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setSleepEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setStandbyXAccelEnabled (MpuController.hpp)</li> <li>mpu_setStandbyXGyroEnabled (MpuController.hpp)</li> <li>mpu_setStandbyYAccelEnabled (MpuController.hpp)</li> <li>mpu_setStandbyYGyroEnabled (MpuController.hpp)</li> <li>mpu_setStandbyZAccelEnabled (MpuController.hpp)</li> <li>mpu_setStandbyZGyroEnabled (MpuController.hpp)</li> <li>mpu_setTempFIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setTempSensorEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setWaitForExternalSensorEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setWakeCycleEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setWakeFrequency (MpuController.hpp)</li> <li>mpu_setXAccelOffset (MpuController.hpp)</li> <li>mpu_setXFineGain (MpuController.hpp)</li> <li>mpu_setXGyroFIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setXGyroOffset (MpuController.hpp)</li> <li>mpu_setXGyroOffsetTC (MpuController.hpp)</li> <li>mpu_setYAccelOffset (MpuController.hpp)</li> <li>mpu_setYFineGain (MpuController.hpp)</li> <li>mpu_setYGyroFIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setYGyroOffset (MpuController.hpp)</li> <li>mpu_setYGyroOffsetTC (MpuController.hpp)</li> <li>mpu_setZAccelOffset (MpuController.hpp)</li> <li>mpu_setZFineGain (MpuController.hpp)</li> <li>mpu_setZGyroFIFOEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setZGyroOffset (MpuController.hpp)</li> <li>mpu_setZGyroOffsetTC (MpuController.hpp)</li> <li>mpu_setZeroMotionDetectionDuration (MpuController.hpp, MpuController.cpp)</li> <li>mpu_setZeroMotionDetectionThreshold (MpuController.hpp, MpuController.cpp)</li> <li>mpu_switchSPIEnabled (MpuController.hpp, MpuController.cpp)</li> <li>mpu_testConnection (MpuController.hpp, MpuController.cpp)</li> <li>mpu_writeMemoryByte (MpuController.hpp)</li> <li>MPU_eTaskGetState (mpu_prototypes.h)</li> <li>MPU_pcQueueGetName (mpu_prototypes.h)</li> <li>MPU_pcTaskGetName (mpu_prototypes.h)</li> <li>MPU_pcTimerGetName (mpu_prototypes.h)</li> <li>MPU_pvTaskGetThreadLocalStoragePointer (mpu_prototypes.h)</li> <li>MPU_pvTimerGetTimerID (mpu_prototypes.h)</li> <li>MPU_ucQueueGetQueueType (mpu_prototypes.h)</li> <li>MPU_ulTaskGetIdleRunTimeCounter (mpu_prototypes.h)</li> <li>MPU_ulTaskNotifyTake (mpu_prototypes.h)</li> <li>MPU_ulTaskNotifyValueClear (mpu_prototypes.h)</li> <li>MPU_uxEventGroupGetNumber (mpu_prototypes.h)</li> <li>MPU_uxQueueGetQueueNumber (mpu_prototypes.h)</li> <li>MPU_uxQueueMessagesWaiting (mpu_prototypes.h)</li> <li>MPU_uxQueueSpacesAvailable (mpu_prototypes.h)</li> <li>MPU_uxTaskGetNumberOfTasks (mpu_prototypes.h)</li> <li>MPU_uxTaskGetStackHighWaterMark (mpu_prototypes.h)</li> <li>MPU_uxTaskGetStackHighWaterMark2 (mpu_prototypes.h)</li> <li>MPU_uxTaskGetSystemState (mpu_prototypes.h)</li> <li>MPU_uxTaskPriorityGet (mpu_prototypes.h)</li> <li>MPU_uxTimerGetReloadMode (mpu_prototypes.h)</li> <li>MPU_vEventGroupDelete (mpu_prototypes.h)</li> <li>MPU_vQueueAddToRegistry (mpu_prototypes.h)</li> <li>MPU_vQueueDelete (mpu_prototypes.h)</li> <li>MPU_vQueueSetQueueNumber (mpu_prototypes.h)</li> <li>MPU_vQueueUnregisterQueue (mpu_prototypes.h)</li> <li>MPU_vStreamBufferDelete (mpu_prototypes.h)</li> <li>MPU_vTaskAllocateMPURegions (mpu_prototypes.h)</li> <li>MPU_vTaskDelay (mpu_prototypes.h)</li> <li>MPU_vTaskDelayUntil (mpu_prototypes.h)</li> <li>MPU_vTaskDelete (mpu_prototypes.h)</li> <li>MPU_vTaskGetInfo (mpu_prototypes.h)</li> <li>MPU_vTaskGetRunTimeStats (mpu_prototypes.h)</li> <li>MPU_vTaskList (mpu_prototypes.h)</li> <li>MPU_vTaskMissedYield (mpu_prototypes.h)</li> <li>MPU_vTaskPrioritySet (mpu_prototypes.h)</li> <li>MPU_vTaskResume (mpu_prototypes.h)</li> <li>MPU_vTaskSetApplicationTaskTag (mpu_prototypes.h)</li> <li>MPU_vTaskSetThreadLocalStoragePointer (mpu_prototypes.h)</li> <li>MPU_vTaskSetTimeOutState (mpu_prototypes.h)</li> <li>MPU_vTaskStartScheduler (mpu_prototypes.h)</li> <li>MPU_vTaskSuspend (mpu_prototypes.h)</li> <li>MPU_vTaskSuspendAll (mpu_prototypes.h)</li> <li>MPU_vTimerSetReloadMode (mpu_prototypes.h)</li> <li>MPU_vTimerSetTimerID (mpu_prototypes.h)</li> <li>MPU_xEventGroupClearBits (mpu_prototypes.h)</li> <li>MPU_xEventGroupCreate (mpu_prototypes.h)</li> <li>MPU_xEventGroupCreateStatic (mpu_prototypes.h)</li> <li>MPU_xEventGroupSetBits (mpu_prototypes.h)</li> <li>MPU_xEventGroupSync (mpu_prototypes.h)</li> <li>MPU_xEventGroupWaitBits (mpu_prototypes.h)</li> <li>MPU_xQueueAddToSet (mpu_prototypes.h)</li> <li>MPU_xQueueCreateCountingSemaphore (mpu_prototypes.h)</li> <li>MPU_xQueueCreateCountingSemaphoreStatic (mpu_prototypes.h)</li> <li>MPU_xQueueCreateMutex (mpu_prototypes.h)</li> <li>MPU_xQueueCreateMutexStatic (mpu_prototypes.h)</li> <li>MPU_xQueueCreateSet (mpu_prototypes.h)</li> <li>MPU_xQueueGenericCreate (mpu_prototypes.h)</li> <li>MPU_xQueueGenericCreateStatic (mpu_prototypes.h)</li> <li>MPU_xQueueGenericReset (mpu_prototypes.h)</li> <li>MPU_xQueueGenericSend (mpu_prototypes.h)</li> <li>MPU_xQueueGetMutexHolder (mpu_prototypes.h)</li> <li>MPU_xQueueGiveMutexRecursive (mpu_prototypes.h)</li> <li>MPU_xQueuePeek (mpu_prototypes.h)</li> <li>MPU_xQueueReceive (mpu_prototypes.h)</li> <li>MPU_xQueueRemoveFromSet (mpu_prototypes.h)</li> <li>MPU_xQueueSelectFromSet (mpu_prototypes.h)</li> <li>MPU_xQueueSemaphoreTake (mpu_prototypes.h)</li> <li>MPU_xQueueTakeMutexRecursive (mpu_prototypes.h)</li> <li>MPU_xStreamBufferBytesAvailable (mpu_prototypes.h)</li> <li>MPU_xStreamBufferGenericCreate (mpu_prototypes.h)</li> <li>MPU_xStreamBufferGenericCreateStatic (mpu_prototypes.h)</li> <li>MPU_xStreamBufferIsEmpty (mpu_prototypes.h)</li> <li>MPU_xStreamBufferIsFull (mpu_prototypes.h)</li> <li>MPU_xStreamBufferNextMessageLengthBytes (mpu_prototypes.h)</li> <li>MPU_xStreamBufferReceive (mpu_prototypes.h)</li> <li>MPU_xStreamBufferReset (mpu_prototypes.h)</li> <li>MPU_xStreamBufferSend (mpu_prototypes.h)</li> <li>MPU_xStreamBufferSetTriggerLevel (mpu_prototypes.h)</li> <li>MPU_xStreamBufferSpacesAvailable (mpu_prototypes.h)</li> <li>MPU_xTaskAbortDelay (mpu_prototypes.h)</li> <li>MPU_xTaskCallApplicationTaskHook (mpu_prototypes.h)</li> <li>MPU_xTaskCatchUpTicks (mpu_prototypes.h)</li> <li>MPU_xTaskCheckForTimeOut (mpu_prototypes.h)</li> <li>MPU_xTaskCreate (mpu_prototypes.h)</li> <li>MPU_xTaskCreateRestricted (mpu_prototypes.h)</li> <li>MPU_xTaskCreateRestrictedStatic (mpu_prototypes.h)</li> <li>MPU_xTaskCreateStatic (mpu_prototypes.h)</li> <li>MPU_xTaskGenericNotify (mpu_prototypes.h)</li> <li>MPU_xTaskGetApplicationTaskTag (mpu_prototypes.h)</li> <li>MPU_xTaskGetCurrentTaskHandle (mpu_prototypes.h)</li> <li>MPU_xTaskGetHandle (mpu_prototypes.h)</li> <li>MPU_xTaskGetIdleTaskHandle (mpu_prototypes.h)</li> <li>MPU_xTaskGetSchedulerState (mpu_prototypes.h)</li> <li>MPU_xTaskGetTickCount (mpu_prototypes.h)</li> <li>MPU_xTaskIncrementTick (mpu_prototypes.h)</li> <li>MPU_xTaskNotifyStateClear (mpu_prototypes.h)</li> <li>MPU_xTaskNotifyWait (mpu_prototypes.h)</li> <li>MPU_xTaskResumeAll (mpu_prototypes.h)</li> <li>MPU_xTimerCreate (mpu_prototypes.h)</li> <li>MPU_xTimerCreateStatic (mpu_prototypes.h)</li> <li>MPU_xTimerCreateTimerTask (mpu_prototypes.h)</li> <li>MPU_xTimerGenericCommand (mpu_prototypes.h)</li> <li>MPU_xTimerGetExpiryTime (mpu_prototypes.h)</li> <li>MPU_xTimerGetPeriod (mpu_prototypes.h)</li> <li>MPU_xTimerGetTimerDaemonTaskHandle (mpu_prototypes.h)</li> <li>MPU_xTimerIsTimerActive (mpu_prototypes.h)</li> <li>MPU_xTimerPendFunctionCall (mpu_prototypes.h)</li> <li>mpuRead (MpuController.cpp)</li> <li>mpuSend (MpuController.cpp)</li> <li>mpuTickCallback (MpuController.cpp)</li> <li>mpu_getExternalSensorDWord (MpuController.cpp)</li> <li>main (main.cpp)</li> </ul>"},{"location":"apiStm/functions/#o","title":"o","text":"<ul> <li>oledDispatch (OledController.hpp, OledController.cpp)</li> <li>oledDrawArc (OledController.hpp, OledController.cpp)</li> <li>oledDrawCircle (OledController.hpp, OledController.cpp)</li> <li>oledDrawLine (OledController.hpp, OledController.cpp)</li> <li>oledDrawPixel (OledController.hpp, OledController.cpp)</li> <li>oledDrawRectangle (OledController.hpp, OledController.cpp)</li> <li>oledFill (OledController.hpp, OledController.cpp)</li> <li>oledFillBuffer (OledController.hpp, OledController.cpp)</li> <li>oledGetDisplayOn (OledController.hpp, OledController.cpp)</li> <li>oledInit (OledController.hpp, OledController.cpp)</li> <li>oledInitOld (OledController.hpp)</li> <li>oledInitStm (OledController.hpp)</li> <li>oledPolyline (OledController.hpp, OledController.cpp)</li> <li>oledSetContrast (OledController.hpp, OledController.cpp)</li> <li>oledSetCursor (OledController.hpp, OledController.cpp)</li> <li>oledSetDisplayOn (OledController.hpp, OledController.cpp)</li> <li>oledTestConnection (OledController.hpp, OledController.cpp)</li> <li>oledUpdateScreen (OledController.hpp, OledController.cpp)</li> <li>oledWriteChar (OledController.hpp, OledController.cpp)</li> <li>oledWriteCommand (OledController.hpp, OledController.cpp)</li> <li>oledWriteData (OledController.hpp, OledController.cpp)</li> <li>oledWriteString (OledController.hpp, OledController.cpp)</li> <li>oledDegToRad (OledController.cpp)</li> <li>oledNormalizeTo0_360 (OledController.cpp)</li> </ul>"},{"location":"apiStm/functions/#p","title":"p","text":"<ul> <li>pinInit (Bsp.hpp)</li> <li>pinRead (Bsp.hpp)</li> <li>pinToggle (Bsp.hpp)</li> <li>pinWrite (Bsp.hpp)</li> <li>pinsInit (Bsp.hpp)</li> <li>powerBatteryMidMv (Power.hpp, Power.cpp)</li> <li>powerBatteryMv (Power.hpp, Power.cpp)</li> <li>powerCalibrate (Power.hpp, Power.cpp)</li> <li>powerInit (Power.hpp, Power.cpp)</li> <li>powerPoll (Power.hpp, Power.cpp)</li> <li>powerShutDown (Power.hpp, Power.cpp)</li> <li>powerTemperatureC (Power.hpp, Power.cpp)</li> <li>powerVrefMv (Power.hpp, Power.cpp)</li> <li>printTaskInfo (Debug.hpp)</li> <li>pvPortMalloc (portable.h, heap_4.c)</li> <li>pxPortInitialiseStack (portable.h)</li> <li>pcTaskGetName (task.h, tasks.c)</li> <li>pvTaskIncrementMutexHeldCount (task.h)</li> <li>pcTimerGetName (timers.h)</li> <li>pvTimerGetTimerID (timers.h)</li> <li>prvTestWaitCondition (event_groups.c)</li> <li>prvHeapInit (heap_4.c)</li> <li>prvInsertBlockIntoFreeList (heap_4.c)</li> <li>prvPortStartFirstTask (port.c)</li> <li>prvTaskExitError (port.c)</li> <li>prvCopyDataFromQueue (queue.c)</li> <li>prvCopyDataToQueue (queue.c)</li> <li>prvInitialiseNewQueue (queue.c)</li> <li>prvIsQueueEmpty (queue.c)</li> <li>prvIsQueueFull (queue.c)</li> <li>prvUnlockQueue (queue.c)</li> <li>prvBytesInBuffer (stream_buffer.c)</li> <li>prvInitialiseNewStreamBuffer (stream_buffer.c)</li> <li>prvReadBytesFromBuffer (stream_buffer.c)</li> <li>prvReadMessageFromBuffer (stream_buffer.c)</li> <li>prvWriteBytesToBuffer (stream_buffer.c)</li> <li>prvWriteMessageToBuffer (stream_buffer.c)</li> <li>portTASK_FUNCTION (tasks.c)</li> <li>prvAddCurrentTaskToDelayedList (tasks.c)</li> <li>prvAddNewTaskToReadyList (tasks.c)</li> <li>prvCheckTasksWaitingTermination (tasks.c)</li> <li>prvInitialiseTaskLists (tasks.c)</li> <li>prvResetNextTaskUnblockTime (tasks.c)</li> <li>parser (ControlLink.cpp)</li> <li>processRxBuf (DebugLink.cpp)</li> </ul>"},{"location":"apiStm/functions/#r","title":"r","text":"<ul> <li>reinitEspStrappingPins (Bsp.hpp)</li> <li>rebootToDfu (Debug.hpp, Debug.cpp)</li> </ul>"},{"location":"apiStm/functions/#s","title":"s","text":"<ul> <li>setLeds (Bsp.hpp)</li> <li>softReset (Bsp.hpp, Bsp.cpp)</li> <li>softResetInit (Bsp.hpp, Bsp.cpp)</li> <li>smartServoInit (SmartServoController.hpp, SmartServoController.cpp)</li> <li>smartServoPoll (SmartServoController.hpp, SmartServoController.cpp)</li> <li>smartServoSendRequest (SmartServoController.hpp, SmartServoController.cpp)</li> <li>stupidServoDispatch (StupidServoController.hpp, StupidServoController.cpp)</li> <li>stupidServoInit (StupidServoController.hpp, StupidServoController.cpp)</li> <li>stupidServoReset (StupidServoController.hpp, StupidServoController.cpp)</li> <li>sendButtonsStat (Dispatcher.cpp)</li> <li>sendVersionStat (Dispatcher.cpp)</li> <li>setMotorPower (MotorController.cpp)</li> <li>setPwmValue (MotorController.cpp)</li> <li>SERVOUART_HANDLER (SmartServoController.cpp)</li> <li>smartServoSetResponseReady (SmartServoController.cpp)</li> <li>smartServoStopRx (SmartServoController.cpp)</li> <li>stupidServoDisable (StupidServoController.cpp)</li> <li>stupidServoSetPosition (StupidServoController.cpp)</li> </ul>"},{"location":"apiStm/functions/#t","title":"t","text":"<ul> <li>tunnelOnSetLineCodingInIrq (CdcUartTunnel.hpp, CdcUartTunnel.cpp)</li> <li>tunnelPoll (CdcUartTunnel.hpp, CdcUartTunnel.cpp)</li> <li>tunnelUartInit (CdcUartTunnel.hpp, CdcUartTunnel.cpp)</li> <li>tunnelDownstreamHandler (CdcUartTunnel.cpp)</li> <li>tunnelUartRxPoll (CdcUartTunnel.cpp)</li> <li>tunnelUartTx (CdcUartTunnel.cpp)</li> <li>tunnelUartTxReady (CdcUartTunnel.cpp)</li> <li>tunnelUpstreamHandler (CdcUartTunnel.cpp)</li> <li>taskFunc (MotorController.cpp)</li> <li>tunnel_check_for_dfu_request (UsbCdcLink.cpp)</li> </ul>"},{"location":"apiStm/functions/#u","title":"u","text":"<ul> <li>ultrasoundDispatch (UltrasoundController.hpp, UltrasoundController.cpp)</li> <li>ultrasoundInit (UltrasoundController.hpp, UltrasoundController.cpp)</li> <li>ultrasoundOnEchoEdge (UltrasoundController.hpp, UltrasoundController.cpp)</li> <li>ultrasoundReset (UltrasoundController.hpp, UltrasoundController.cpp)</li> <li>uxListRemove (list.h, list.c)</li> <li>ucQueueGetQueueType (queue.h)</li> <li>uxQueueGetQueueNumber (queue.h)</li> <li>uxQueueMessagesWaiting (queue.h, queue.c)</li> <li>uxQueueMessagesWaitingFromISR (queue.h, queue.c)</li> <li>uxQueueSpacesAvailable (queue.h, queue.c)</li> <li>ulTaskGetIdleRunTimeCounter (task.h)</li> <li>ulTaskNotifyTake (task.h)</li> <li>ulTaskNotifyValueClear (task.h)</li> <li>uxTaskGetNumberOfTasks (task.h, tasks.c)</li> <li>uxTaskGetStackHighWaterMark (task.h)</li> <li>uxTaskGetStackHighWaterMark2 (task.h)</li> <li>uxTaskGetSystemState (task.h)</li> <li>uxTaskGetTaskNumber (task.h)</li> <li>uxTaskPriorityGet (task.h)</li> <li>uxTaskPriorityGetFromISR (task.h)</li> <li>uxTaskResetEventItemValue (task.h, tasks.c)</li> <li>uxTimerGetReloadMode (timers.h)</li> <li>ulPortRaiseBASEPRI (portmacro.h)</li> <li>usbd_connect (usbd_core.h)</li> <li>usbd_enable (usbd_core.h)</li> <li>usbd_ep_config (usbd_core.h)</li> <li>usbd_ep_deconfig (usbd_core.h)</li> <li>usbd_ep_read (usbd_core.h)</li> <li>usbd_ep_stall (usbd_core.h)</li> <li>usbd_ep_unstall (usbd_core.h)</li> <li>usbd_ep_write (usbd_core.h)</li> <li>usbd_getinfo (usbd_core.h)</li> <li>usbd_init (usbd_core.h)</li> <li>usbd_poll (usbd_core.h)</li> <li>usbd_reg_config (usbd_core.h)</li> <li>usbd_reg_control (usbd_core.h)</li> <li>usbd_reg_descr (usbd_core.h)</li> <li>usbd_reg_endpoint (usbd_core.h)</li> <li>usbd_reg_event (usbd_core.h)</li> <li>usbd_configure (usbd_core.c)</li> <li>usbd_process_callback (usbd_core.c)</li> <li>usbd_process_devrq (usbd_core.c)</li> <li>usbd_process_ep0 (usbd_core.c)</li> <li>usbd_process_eprx (usbd_core.c)</li> <li>usbd_process_eptrq (usbd_core.c)</li> <li>usbd_process_eptx (usbd_core.c)</li> <li>usbd_process_evt (usbd_core.c)</li> <li>usbd_process_intrq (usbd_core.c)</li> <li>usbd_process_request (usbd_core.c)</li> <li>usbd_process_reset (usbd_core.c)</li> <li>usbd_set_address (usbd_core.c)</li> <li>usbd_stall_pid (usbd_core.c)</li> <li>USB_LP_IRQ_HANDLER (UsbCdcLink.cpp)</li> </ul>"},{"location":"apiStm/functions/#v","title":"v","text":"<ul> <li>vCoRoutineAddToDelayedList (croutine.h)</li> <li>vCoRoutineSchedule (croutine.h)</li> <li>vEventGroupClearBitsCallback (event_groups.h, event_groups.c)</li> <li>vEventGroupDelete (event_groups.h, event_groups.c)</li> <li>vEventGroupSetBitsCallback (event_groups.h, event_groups.c)</li> <li>vListInitialise (list.h, list.c)</li> <li>vListInitialiseItem (list.h, list.c)</li> <li>vListInsert (list.h, list.c)</li> <li>vListInsertEnd (list.h, list.c)</li> <li>vPortDefineHeapRegions (portable.h)</li> <li>vPortEndScheduler (portable.h, port.c)</li> <li>vPortFree (portable.h, heap_4.c)</li> <li>vPortGetHeapStats (portable.h, heap_4.c)</li> <li>vPortInitialiseBlocks (portable.h, heap_4.c)</li> <li>vQueueDelete (queue.h, queue.c)</li> <li>vQueueSetQueueNumber (queue.h)</li> <li>vQueueWaitForMessageRestricted (queue.h)</li> <li>vStreamBufferDelete (stream_buffer.h, stream_buffer.c)</li> <li>vTaskAllocateMPURegions (task.h)</li> <li>vTaskDelay (task.h)</li> <li>vTaskDelayUntil (task.h)</li> <li>vTaskDelete (task.h)</li> <li>vTaskEndScheduler (task.h, tasks.c)</li> <li>vTaskGetInfo (task.h)</li> <li>vTaskGetRunTimeStats (task.h)</li> <li>vTaskInternalSetTimeOutState (task.h, tasks.c)</li> <li>vTaskList (task.h)</li> <li>vTaskMissedYield (task.h, tasks.c)</li> <li>vTaskNotifyGiveFromISR (task.h)</li> <li>vTaskPlaceOnEventList (task.h, tasks.c)</li> <li>vTaskPlaceOnEventListRestricted (task.h)</li> <li>vTaskPlaceOnUnorderedEventList (task.h, tasks.c)</li> <li>vTaskPriorityDisinheritAfterTimeout (task.h)</li> <li>vTaskPrioritySet (task.h)</li> <li>vTaskRemoveFromUnorderedEventList (task.h, tasks.c)</li> <li>vTaskResume (task.h)</li> <li>vTaskSetTaskNumber (task.h)</li> <li>vTaskSetTimeOutState (task.h, tasks.c)</li> <li>vTaskStartScheduler (task.h, tasks.c)</li> <li>vTaskStepTick (task.h)</li> <li>vTaskSuspend (task.h)</li> <li>vTaskSuspendAll (task.h, tasks.c)</li> <li>vTaskSwitchContext (task.h, tasks.c)</li> <li>vTimerSetReloadMode (timers.h)</li> <li>vTimerSetTimerID (timers.h)</li> <li>vPortEnterCritical (port.c, portmacro.h)</li> <li>vPortExitCritical (port.c, portmacro.h)</li> <li>vPortSVCHandler (port.c)</li> <li>vPortSetupTimerInterrupt (port.c)</li> <li>vPortRaiseBASEPRI (portmacro.h)</li> <li>vPortSetBASEPRI (portmacro.h)</li> <li>vPortSuppressTicksAndSleep (portmacro.h)</li> <li>vApplicationGetIdleTaskMemory (FreeRTOSCallbacks.cpp)</li> <li>vApplicationStackOverflowHook (FreeRTOSCallbacks.cpp)</li> <li>vApplicationTickHook (FreeRTOSCallbacks.cpp)</li> </ul>"},{"location":"apiStm/functions/#x","title":"x","text":"<ul> <li>xCoRoutineCreate (croutine.h)</li> <li>xCoRoutineRemoveFromEventList (croutine.h)</li> <li>xEventGroupClearBits (event_groups.h, event_groups.c)</li> <li>xEventGroupGetBitsFromISR (event_groups.h, event_groups.c)</li> <li>xEventGroupSetBits (event_groups.h, event_groups.c)</li> <li>xEventGroupSync (event_groups.h, event_groups.c)</li> <li>xEventGroupWaitBits (event_groups.h, event_groups.c)</li> <li>xPortGetFreeHeapSize (portable.h, heap_4.c)</li> <li>xPortGetMinimumEverFreeHeapSize (portable.h, heap_4.c)</li> <li>xPortStartScheduler (portable.h, port.c)</li> <li>xQueueAddToSet (queue.h)</li> <li>xQueueCRReceive (queue.h)</li> <li>xQueueCRReceiveFromISR (queue.h)</li> <li>xQueueCRSend (queue.h)</li> <li>xQueueCRSendFromISR (queue.h)</li> <li>xQueueCreateCountingSemaphore (queue.h)</li> <li>xQueueCreateCountingSemaphoreStatic (queue.h)</li> <li>xQueueCreateMutex (queue.h)</li> <li>xQueueCreateMutexStatic (queue.h)</li> <li>xQueueCreateSet (queue.h)</li> <li>xQueueGenericReset (queue.h, queue.c)</li> <li>xQueueGenericSend (queue.h, queue.c)</li> <li>xQueueGenericSendFromISR (queue.h, queue.c)</li> <li>xQueueGetMutexHolder (queue.h)</li> <li>xQueueGetMutexHolderFromISR (queue.h)</li> <li>xQueueGiveFromISR (queue.h, queue.c)</li> <li>xQueueGiveMutexRecursive (queue.h)</li> <li>xQueueIsQueueEmptyFromISR (queue.h, queue.c)</li> <li>xQueueIsQueueFullFromISR (queue.h, queue.c)</li> <li>xQueuePeek (queue.h, queue.c)</li> <li>xQueuePeekFromISR (queue.h, queue.c)</li> <li>xQueueReceive (queue.h, queue.c)</li> <li>xQueueReceiveFromISR (queue.h, queue.c)</li> <li>xQueueRemoveFromSet (queue.h)</li> <li>xQueueSelectFromSet (queue.h)</li> <li>xQueueSelectFromSetFromISR (queue.h)</li> <li>xQueueSemaphoreTake (queue.h, queue.c)</li> <li>xQueueTakeMutexRecursive (queue.h)</li> <li>xStreamBufferBytesAvailable (stream_buffer.h, stream_buffer.c)</li> <li>xStreamBufferGenericCreate (stream_buffer.h)</li> <li>xStreamBufferGenericCreateStatic (stream_buffer.h)</li> <li>xStreamBufferIsEmpty (stream_buffer.h, stream_buffer.c)</li> <li>xStreamBufferIsFull (stream_buffer.h, stream_buffer.c)</li> <li>xStreamBufferNextMessageLengthBytes (stream_buffer.h, stream_buffer.c)</li> <li>xStreamBufferReceive (stream_buffer.h, stream_buffer.c)</li> <li>xStreamBufferReceiveCompletedFromISR (stream_buffer.h, stream_buffer.c)</li> <li>xStreamBufferReceiveFromISR (stream_buffer.h, stream_buffer.c)</li> <li>xStreamBufferReset (stream_buffer.h, stream_buffer.c)</li> <li>xStreamBufferSend (stream_buffer.h, stream_buffer.c)</li> <li>xStreamBufferSendCompletedFromISR (stream_buffer.h, stream_buffer.c)</li> <li>xStreamBufferSendFromISR (stream_buffer.h, stream_buffer.c)</li> <li>xStreamBufferSetTriggerLevel (stream_buffer.h, stream_buffer.c)</li> <li>xStreamBufferSpacesAvailable (stream_buffer.h, stream_buffer.c)</li> <li>xTaskAbortDelay (task.h)</li> <li>xTaskCallApplicationTaskHook (task.h)</li> <li>xTaskCatchUpTicks (task.h, tasks.c)</li> <li>xTaskCheckForTimeOut (task.h, tasks.c)</li> <li>xTaskGenericNotify (task.h)</li> <li>xTaskGenericNotifyFromISR (task.h)</li> <li>xTaskGetCurrentTaskHandle (task.h)</li> <li>xTaskGetHandle (task.h)</li> <li>xTaskGetIdleTaskHandle (task.h)</li> <li>xTaskGetSchedulerState (task.h)</li> <li>xTaskGetTickCount (task.h, tasks.c)</li> <li>xTaskGetTickCountFromISR (task.h, tasks.c)</li> <li>xTaskIncrementTick (task.h, tasks.c)</li> <li>xTaskNotifyStateClear (task.h)</li> <li>xTaskNotifyWait (task.h)</li> <li>xTaskPriorityDisinherit (task.h)</li> <li>xTaskPriorityInherit (task.h)</li> <li>xTaskRemoveFromEventList (task.h, tasks.c)</li> <li>xTaskResumeAll (task.h, tasks.c)</li> <li>xTaskResumeFromISR (task.h)</li> <li>xTimerCreateTimerTask (timers.h)</li> <li>xTimerGenericCommand (timers.h)</li> <li>xTimerGetExpiryTime (timers.h)</li> <li>xTimerGetPeriod (timers.h)</li> <li>xTimerGetTimerDaemonTaskHandle (timers.h)</li> <li>xTimerIsTimerActive (timers.h)</li> <li>xTimerPendFunctionCall (timers.h)</li> <li>xTimerPendFunctionCallFromISR (timers.h)</li> <li>xPortPendSVHandler (port.c)</li> <li>xPortSysTickHandler (port.c)</li> <li>xPortIsInsideInterrupt (portmacro.h)</li> </ul>"},{"location":"apiStm/functions/#_","title":"_","text":"<ul> <li>__attribute__ (port.c, portmacro.h, usb_cdc.h, usb_std.h, usbd_core.c, UsbCdcLink.cpp)</li> <li>_write (DebugLink.cpp)</li> <li>_exit (FreeRTOSCallbacks.cpp)</li> </ul>"},{"location":"apiStm/macros/","title":"Macros","text":""},{"location":"apiStm/macros/#a","title":"a","text":"<ul> <li>AFIO_MAPR_RESERVED (Bsp.hpp)</li> <li>AUXILIARY_AND_MOTOR_ADC_IRQ_HANDLER (Bsp.hpp)</li> <li>ATOMIC_COMPARE_AND_SWAP_FAILURE (atomic.h)</li> <li>ATOMIC_COMPARE_AND_SWAP_SUCCESS (atomic.h)</li> <li>ATOMIC_ENTER_CRITICAL (atomic.h)</li> <li>ATOMIC_EXIT_CRITICAL (atomic.h)</li> </ul>"},{"location":"apiStm/macros/#c","title":"c","text":"<ul> <li>CONTROLUART_TX_DMA_HANDLER (Bsp.hpp)</li> <li>configASSERT (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>configCHECK_FOR_STACK_OVERFLOW (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>configCPU_CLOCK_HZ (FreeRTOSConfig.h)</li> <li>configGENERATE_RUN_TIME_STATS (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>configIDLE_SHOULD_YIELD (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>configKERNEL_INTERRUPT_PRIORITY (FreeRTOSConfig.h, port.c)</li> <li>configLIBRARY_LOWEST_INTERRUPT_PRIORITY (FreeRTOSConfig.h)</li> <li>configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY (FreeRTOSConfig.h)</li> <li>configMAX_CO_ROUTINE_PRIORITIES (FreeRTOSConfig.h)</li> <li>configMAX_PRIORITIES (FreeRTOSConfig.h)</li> <li>configMAX_SYSCALL_INTERRUPT_PRIORITY (FreeRTOSConfig.h)</li> <li>configMAX_TASK_NAME_LEN (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>configMINIMAL_STACK_SIZE (FreeRTOSConfig.h)</li> <li>configPRIO_BITS (FreeRTOSConfig.h)</li> <li>configQUEUE_REGISTRY_SIZE (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>configRECORD_STACK_HIGH_ADDRESS (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>configSUPPORT_DYNAMIC_ALLOCATION (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>configSUPPORT_STATIC_ALLOCATION (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>configTICK_RATE_HZ (FreeRTOSConfig.h)</li> <li>configTIMER_QUEUE_LENGTH (FreeRTOSConfig.h)</li> <li>configTIMER_TASK_PRIORITY (FreeRTOSConfig.h)</li> <li>configTIMER_TASK_STACK_DEPTH (FreeRTOSConfig.h)</li> <li>configTOTAL_HEAP_SIZE (FreeRTOSConfig.h)</li> <li>configUSE_16_BIT_TICKS (FreeRTOSConfig.h)</li> <li>configUSE_APPLICATION_TASK_TAG (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>configUSE_COUNTING_SEMAPHORES (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>configUSE_CO_ROUTINES (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>configUSE_IDLE_HOOK (FreeRTOSConfig.h)</li> <li>configUSE_MALLOC_FAILED_HOOK (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>configUSE_MUTEXES (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>configUSE_PORT_OPTIMISED_TASK_SELECTION (FreeRTOSConfig.h, FreeRTOS.h, portmacro.h)</li> <li>configUSE_PREEMPTION (FreeRTOSConfig.h)</li> <li>configUSE_RECURSIVE_MUTEXES (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>configUSE_TICK_HOOK (FreeRTOSConfig.h)</li> <li>configUSE_TIMERS (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>configUSE_TRACE_FACILITY (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>CDC_DATA_SZ (UsbCdcLink.h)</li> <li>CDC_DEBUG_NTF_EP (UsbCdcLink.h)</li> <li>CDC_DEBUG_RXD_EP (UsbCdcLink.h)</li> <li>CDC_DEBUG_TXD_EP (UsbCdcLink.h)</li> <li>CDC_EP0_SIZE (UsbCdcLink.h)</li> <li>CDC_NTF_SZ (UsbCdcLink.h)</li> <li>CDC_TUNNEL_NTF_EP (UsbCdcLink.h)</li> <li>CDC_TUNNEL_RXD_EP (UsbCdcLink.h)</li> <li>CDC_TUNNEL_TXD_EP (UsbCdcLink.h)</li> <li>configAPPLICATION_ALLOCATED_HEAP (FreeRTOS.h)</li> <li>configASSERT_DEFINED (FreeRTOS.h)</li> <li>configENABLE_BACKWARD_COMPATIBILITY (FreeRTOS.h)</li> <li>configENABLE_FPU (FreeRTOS.h)</li> <li>configENABLE_MPU (FreeRTOS.h)</li> <li>configENABLE_TRUSTZONE (FreeRTOS.h)</li> <li>configEXPECTED_IDLE_TIME_BEFORE_SLEEP (FreeRTOS.h)</li> <li>configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS (FreeRTOS.h)</li> <li>configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H (FreeRTOS.h)</li> <li>configINITIAL_TICK_COUNT (FreeRTOS.h)</li> <li>configMAX (FreeRTOS.h)</li> <li>configMESSAGE_BUFFER_LENGTH_TYPE (FreeRTOS.h)</li> <li>configMIN (FreeRTOS.h)</li> <li>configNUM_THREAD_LOCAL_STORAGE_POINTERS (FreeRTOS.h)</li> <li>configPOST_SLEEP_PROCESSING (FreeRTOS.h)</li> <li>configPRECONDITION (FreeRTOS.h)</li> <li>configPRECONDITION_DEFINED (FreeRTOS.h)</li> <li>configPRE_SLEEP_PROCESSING (FreeRTOS.h)</li> <li>configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING (FreeRTOS.h)</li> <li>configPRINTF (FreeRTOS.h)</li> <li>configRUN_FREERTOS_SECURE_ONLY (FreeRTOS.h)</li> <li>configSTACK_DEPTH_TYPE (FreeRTOS.h)</li> <li>configUSE_ALTERNATIVE_API (FreeRTOS.h)</li> <li>configUSE_DAEMON_TASK_STARTUP_HOOK (FreeRTOS.h)</li> <li>configUSE_NEWLIB_REENTRANT (FreeRTOS.h)</li> <li>configUSE_POSIX_ERRNO (FreeRTOS.h)</li> <li>configUSE_QUEUE_SETS (FreeRTOS.h)</li> <li>configUSE_STATS_FORMATTING_FUNCTIONS (FreeRTOS.h)</li> <li>configUSE_TASK_FPU_SUPPORT (FreeRTOS.h)</li> <li>configUSE_TASK_NOTIFICATIONS (FreeRTOS.h)</li> <li>configUSE_TICKLESS_IDLE (FreeRTOS.h)</li> <li>configUSE_TIME_SLICING (FreeRTOS.h)</li> <li>crDELAY (croutine.h)</li> <li>crEND (croutine.h)</li> <li>crQUEUE_RECEIVE (croutine.h)</li> <li>crQUEUE_RECEIVE_FROM_ISR (croutine.h)</li> <li>crQUEUE_SEND (croutine.h)</li> <li>crQUEUE_SEND_FROM_ISR (croutine.h)</li> <li>crSET_STATE0 (croutine.h)</li> <li>crSET_STATE1 (croutine.h)</li> <li>crSTART (croutine.h)</li> <li>configLIST_VOLATILE (list.h)</li> <li>configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES (projdefs.h)</li> <li>configSYSTICK_CLOCK_HZ (port.c)</li> <li>configIDLE_TASK_NAME (tasks.c)</li> <li>CAT (usb_std.h)</li> <li>COMMAND (DebugLink.cpp)</li> <li>CIRCLE_APPROXIMATION_SEGMENTS (OledController.cpp)</li> </ul>"},{"location":"apiStm/macros/#d","title":"d","text":"<ul> <li>DEBUGUART_HANDLER (Bsp.hpp)</li> <li>DEBUGUART_TX_DMA_HANDLER (Bsp.hpp)</li> <li>DEBUG (Debug.hpp)</li> <li>DEBUGLN (Debug.hpp)</li> <li>DEBUG_DESCRIPTORS (UsbCdcLink.cpp)</li> </ul>"},{"location":"apiStm/macros/#e","title":"e","text":"<ul> <li>eTaskStateGet (FreeRTOS.h)</li> <li>errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY (projdefs.h)</li> <li>errQUEUE_BLOCKED (projdefs.h)</li> <li>errQUEUE_EMPTY (projdefs.h)</li> <li>errQUEUE_FULL (projdefs.h)</li> <li>errQUEUE_YIELD (projdefs.h)</li> <li>eventCLEAR_EVENTS_ON_EXIT_BIT (event_groups.c)</li> <li>eventEVENT_BITS_CONTROL_BYTES (event_groups.c)</li> <li>eventUNBLOCKED_DUE_TO_BIT_SET (event_groups.c)</li> <li>eventWAIT_FOR_ALL_BITS (event_groups.c)</li> </ul>"},{"location":"apiStm/macros/#f","title":"f","text":"<ul> <li>FREERTOS_SYSTEM_CALL (mpu_wrappers.h)</li> </ul>"},{"location":"apiStm/macros/#h","title":"h","text":"<ul> <li>heapBITS_PER_BYTE (heap_4.c)</li> <li>heapMINIMUM_BLOCK_SIZE (heap_4.c)</li> </ul>"},{"location":"apiStm/macros/#i","title":"i","text":"<ul> <li>IN4AMASK (Bsp.hpp)</li> <li>IN4BMASK (Bsp.hpp)</li> <li>IN4PORT (Bsp.hpp)</li> <li>INCLUDE_eTaskGetState (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>INCLUDE_uxTaskGetStackHighWaterMark (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>INCLUDE_uxTaskPriorityGet (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>INCLUDE_vTaskDelay (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>INCLUDE_vTaskDelayUntil (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>INCLUDE_vTaskDelete (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>INCLUDE_vTaskPrioritySet (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>INCLUDE_vTaskSuspend (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>INCLUDE_xEventGroupSetBitFromISR (FreeRTOSConfig.h)</li> <li>INCLUDE_xResumeFromISR (FreeRTOSConfig.h)</li> <li>INCLUDE_xTaskAbortDelay (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>INCLUDE_xTaskGetCurrentTaskHandle (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>INCLUDE_xTaskGetHandle (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>INCLUDE_xTaskGetIdleTaskHandle (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>INCLUDE_xTaskGetSchedulerState (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>INCLUDE_xTaskResumeFromISR (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>INCLUDE_xTimerPendFunctionCall (FreeRTOSConfig.h, FreeRTOS.h)</li> <li>I2CDEV_DEFAULT_READ_TIMEOUT (I2cController.hpp)</li> <li>INCLUDE_uxTaskGetStackHighWaterMark2 (FreeRTOS.h)</li> <li>INCLUDE_xQueueGetMutexHolder (FreeRTOS.h)</li> <li>INCLUDE_xSemaphoreGetMutexHolder (FreeRTOS.h)</li> <li>INTSERIALNO_DESCRIPTOR (usb_std.h)</li> </ul>"},{"location":"apiStm/macros/#l","title":"l","text":"<ul> <li>listCURRENT_LIST_LENGTH (list.h)</li> <li>listFIRST_LIST_INTEGRITY_CHECK_VALUE (list.h)</li> <li>listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE (list.h)</li> <li>listGET_END_MARKER (list.h)</li> <li>listGET_HEAD_ENTRY (list.h)</li> <li>listGET_ITEM_VALUE_OF_HEAD_ENTRY (list.h)</li> <li>listGET_LIST_ITEM_OWNER (list.h)</li> <li>listGET_LIST_ITEM_VALUE (list.h)</li> <li>listGET_NEXT (list.h)</li> <li>listGET_OWNER_OF_HEAD_ENTRY (list.h)</li> <li>listGET_OWNER_OF_NEXT_ENTRY (list.h)</li> <li>listIS_CONTAINED_WITHIN (list.h)</li> <li>listLIST_IS_EMPTY (list.h)</li> <li>listLIST_IS_INITIALISED (list.h)</li> <li>listLIST_ITEM_CONTAINER (list.h)</li> <li>listSECOND_LIST_INTEGRITY_CHECK_VALUE (list.h)</li> <li>listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE (list.h)</li> <li>listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE (list.h)</li> <li>listSET_LIST_INTEGRITY_CHECK_1_VALUE (list.h)</li> <li>listSET_LIST_INTEGRITY_CHECK_2_VALUE (list.h)</li> <li>listSET_LIST_ITEM_OWNER (list.h)</li> <li>listSET_LIST_ITEM_VALUE (list.h)</li> <li>listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE (list.h)</li> <li>listTEST_LIST_INTEGRITY (list.h)</li> <li>listTEST_LIST_ITEM_INTEGRITY (list.h)</li> </ul>"},{"location":"apiStm/macros/#m","title":"m","text":"<ul> <li>MPU6050_ACCEL_FIFO_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_ACCEL_FS_16 (Mpu6050.hpp)</li> <li>MPU6050_ACCEL_FS_2 (Mpu6050.hpp)</li> <li>MPU6050_ACCEL_FS_4 (Mpu6050.hpp)</li> <li>MPU6050_ACCEL_FS_8 (Mpu6050.hpp)</li> <li>MPU6050_ACONFIG_ACCEL_HPF_BIT (Mpu6050.hpp)</li> <li>MPU6050_ACONFIG_ACCEL_HPF_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_ACONFIG_AFS_SEL_BIT (Mpu6050.hpp)</li> <li>MPU6050_ACONFIG_AFS_SEL_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_ACONFIG_XA_ST_BIT (Mpu6050.hpp)</li> <li>MPU6050_ACONFIG_YA_ST_BIT (Mpu6050.hpp)</li> <li>MPU6050_ACONFIG_ZA_ST_BIT (Mpu6050.hpp)</li> <li>MPU6050_ADDRESS_AD0_HIGH (Mpu6050.hpp)</li> <li>MPU6050_ADDRESS_AD0_LOW (Mpu6050.hpp)</li> <li>MPU6050_BANKSEL_CFG_USER_BANK_BIT (Mpu6050.hpp)</li> <li>MPU6050_BANKSEL_MEM_SEL_BIT (Mpu6050.hpp)</li> <li>MPU6050_BANKSEL_MEM_SEL_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_BANKSEL_PRFTCH_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_CFG_DLPF_CFG_BIT (Mpu6050.hpp)</li> <li>MPU6050_CFG_DLPF_CFG_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_CFG_EXT_SYNC_SET_BIT (Mpu6050.hpp)</li> <li>MPU6050_CFG_EXT_SYNC_SET_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_258 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_267 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_276 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_286 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_296 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_308 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_320 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_333 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_348 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_364 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_381 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_400 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_421 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_444 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_471 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_DIV_500 (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_INTERNAL (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_KEEP_RESET (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_PLL_EXT19M (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_PLL_EXT32K (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_PLL_XGYRO (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_PLL_YGYRO (Mpu6050.hpp)</li> <li>MPU6050_CLOCK_PLL_ZGYRO (Mpu6050.hpp)</li> <li>MPU6050_DEFAULT_ADDRESS (Mpu6050.hpp)</li> <li>MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT (Mpu6050.hpp)</li> <li>MPU6050_DELAYCTRL_I2C_SLV0_DLY_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_DELAYCTRL_I2C_SLV1_DLY_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_DELAYCTRL_I2C_SLV2_DLY_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_DELAYCTRL_I2C_SLV3_DLY_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_DELAYCTRL_I2C_SLV4_DLY_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_DETECT_ACCEL_ON_DELAY_BIT (Mpu6050.hpp)</li> <li>MPU6050_DETECT_ACCEL_ON_DELAY_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_DETECT_DECREMENT_1 (Mpu6050.hpp)</li> <li>MPU6050_DETECT_DECREMENT_2 (Mpu6050.hpp)</li> <li>MPU6050_DETECT_DECREMENT_4 (Mpu6050.hpp)</li> <li>MPU6050_DETECT_DECREMENT_RESET (Mpu6050.hpp)</li> <li>MPU6050_DETECT_FF_COUNT_BIT (Mpu6050.hpp)</li> <li>MPU6050_DETECT_FF_COUNT_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_DETECT_MOT_COUNT_BIT (Mpu6050.hpp)</li> <li>MPU6050_DETECT_MOT_COUNT_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_DHPF_0P63 (Mpu6050.hpp)</li> <li>MPU6050_DHPF_1P25 (Mpu6050.hpp)</li> <li>MPU6050_DHPF_2P5 (Mpu6050.hpp)</li> <li>MPU6050_DHPF_5 (Mpu6050.hpp)</li> <li>MPU6050_DHPF_HOLD (Mpu6050.hpp)</li> <li>MPU6050_DHPF_RESET (Mpu6050.hpp)</li> <li>MPU6050_DLPF_BW_10 (Mpu6050.hpp)</li> <li>MPU6050_DLPF_BW_188 (Mpu6050.hpp)</li> <li>MPU6050_DLPF_BW_20 (Mpu6050.hpp)</li> <li>MPU6050_DLPF_BW_256 (Mpu6050.hpp)</li> <li>MPU6050_DLPF_BW_42 (Mpu6050.hpp)</li> <li>MPU6050_DLPF_BW_5 (Mpu6050.hpp)</li> <li>MPU6050_DLPF_BW_98 (Mpu6050.hpp)</li> <li>MPU6050_DMPINT_0_BIT (Mpu6050.hpp)</li> <li>MPU6050_DMPINT_1_BIT (Mpu6050.hpp)</li> <li>MPU6050_DMPINT_2_BIT (Mpu6050.hpp)</li> <li>MPU6050_DMPINT_3_BIT (Mpu6050.hpp)</li> <li>MPU6050_DMPINT_4_BIT (Mpu6050.hpp)</li> <li>MPU6050_DMPINT_5_BIT (Mpu6050.hpp)</li> <li>MPU6050_DMP_MEMORY_BANKS (Mpu6050.hpp)</li> <li>MPU6050_DMP_MEMORY_BANK_SIZE (Mpu6050.hpp)</li> <li>MPU6050_DMP_MEMORY_CHUNK_SIZE (Mpu6050.hpp)</li> <li>MPU6050_EXT_SYNC_ACCEL_XOUT_L (Mpu6050.hpp)</li> <li>MPU6050_EXT_SYNC_ACCEL_YOUT_L (Mpu6050.hpp)</li> <li>MPU6050_EXT_SYNC_ACCEL_ZOUT_L (Mpu6050.hpp)</li> <li>MPU6050_EXT_SYNC_DISABLED (Mpu6050.hpp)</li> <li>MPU6050_EXT_SYNC_GYRO_XOUT_L (Mpu6050.hpp)</li> <li>MPU6050_EXT_SYNC_GYRO_YOUT_L (Mpu6050.hpp)</li> <li>MPU6050_EXT_SYNC_GYRO_ZOUT_L (Mpu6050.hpp)</li> <li>MPU6050_EXT_SYNC_TEMP_OUT_L (Mpu6050.hpp)</li> <li>MPU6050_GCONFIG_FS_SEL_BIT (Mpu6050.hpp)</li> <li>MPU6050_GCONFIG_FS_SEL_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_GYRO_FS_1000 (Mpu6050.hpp)</li> <li>MPU6050_GYRO_FS_2000 (Mpu6050.hpp)</li> <li>MPU6050_GYRO_FS_250 (Mpu6050.hpp)</li> <li>MPU6050_GYRO_FS_500 (Mpu6050.hpp)</li> <li>MPU6050_I2C_MST_CLK_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_MST_CLK_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_I2C_MST_P_NSR_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV4_ADDR_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV4_ADDR_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV4_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV4_INT_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV4_MST_DLY_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV4_MST_DLY_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV4_REG_DIS_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV4_RW_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV_ADDR_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV_ADDR_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV_BYTE_SW_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV_GRP_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV_LEN_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV_LEN_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV_REG_DIS_BIT (Mpu6050.hpp)</li> <li>MPU6050_I2C_SLV_RW_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTCFG_CLKOUT_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTCFG_FSYNC_INT_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTCFG_I2C_BYPASS_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTCFG_INT_LEVEL_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTCFG_INT_OPEN_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTCFG_INT_RD_CLEAR_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTCFG_LATCH_INT_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTCLEAR_ANYREAD (Mpu6050.hpp)</li> <li>MPU6050_INTCLEAR_STATUSREAD (Mpu6050.hpp)</li> <li>MPU6050_INTDRV_OPENDRAIN (Mpu6050.hpp)</li> <li>MPU6050_INTDRV_PUSHPULL (Mpu6050.hpp)</li> <li>MPU6050_INTERRUPT_DATA_RDY_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTERRUPT_DMP_INT_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTERRUPT_FF_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTERRUPT_FIFO_OFLOW_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTERRUPT_I2C_MST_INT_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTERRUPT_MOT_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTERRUPT_PLL_RDY_INT_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTERRUPT_ZMOT_BIT (Mpu6050.hpp)</li> <li>MPU6050_INTLATCH_50USPULSE (Mpu6050.hpp)</li> <li>MPU6050_INTLATCH_WAITCLEAR (Mpu6050.hpp)</li> <li>MPU6050_INTMODE_ACTIVEHIGH (Mpu6050.hpp)</li> <li>MPU6050_INTMODE_ACTIVELOW (Mpu6050.hpp)</li> <li>MPU6050_MOTION_MOT_XNEG_BIT (Mpu6050.hpp)</li> <li>MPU6050_MOTION_MOT_XPOS_BIT (Mpu6050.hpp)</li> <li>MPU6050_MOTION_MOT_YNEG_BIT (Mpu6050.hpp)</li> <li>MPU6050_MOTION_MOT_YPOS_BIT (Mpu6050.hpp)</li> <li>MPU6050_MOTION_MOT_ZNEG_BIT (Mpu6050.hpp)</li> <li>MPU6050_MOTION_MOT_ZPOS_BIT (Mpu6050.hpp)</li> <li>MPU6050_MOTION_MOT_ZRMOT_BIT (Mpu6050.hpp)</li> <li>MPU6050_MST_I2C_LOST_ARB_BIT (Mpu6050.hpp)</li> <li>MPU6050_MST_I2C_SLV0_NACK_BIT (Mpu6050.hpp)</li> <li>MPU6050_MST_I2C_SLV1_NACK_BIT (Mpu6050.hpp)</li> <li>MPU6050_MST_I2C_SLV2_NACK_BIT (Mpu6050.hpp)</li> <li>MPU6050_MST_I2C_SLV3_NACK_BIT (Mpu6050.hpp)</li> <li>MPU6050_MST_I2C_SLV4_DONE_BIT (Mpu6050.hpp)</li> <li>MPU6050_MST_I2C_SLV4_NACK_BIT (Mpu6050.hpp)</li> <li>MPU6050_MST_PASS_THROUGH_BIT (Mpu6050.hpp)</li> <li>MPU6050_MULT_MST_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_PATHRESET_ACCEL_RESET_BIT (Mpu6050.hpp)</li> <li>MPU6050_PATHRESET_GYRO_RESET_BIT (Mpu6050.hpp)</li> <li>MPU6050_PATHRESET_TEMP_RESET_BIT (Mpu6050.hpp)</li> <li>MPU6050_PWR1_CLKSEL_BIT (Mpu6050.hpp)</li> <li>MPU6050_PWR1_CLKSEL_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_PWR1_CYCLE_BIT (Mpu6050.hpp)</li> <li>MPU6050_PWR1_DEVICE_RESET_BIT (Mpu6050.hpp)</li> <li>MPU6050_PWR1_SLEEP_BIT (Mpu6050.hpp)</li> <li>MPU6050_PWR1_TEMP_DIS_BIT (Mpu6050.hpp)</li> <li>MPU6050_PWR2_LP_WAKE_CTRL_BIT (Mpu6050.hpp)</li> <li>MPU6050_PWR2_LP_WAKE_CTRL_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_PWR2_STBY_XA_BIT (Mpu6050.hpp)</li> <li>MPU6050_PWR2_STBY_XG_BIT (Mpu6050.hpp)</li> <li>MPU6050_PWR2_STBY_YA_BIT (Mpu6050.hpp)</li> <li>MPU6050_PWR2_STBY_YG_BIT (Mpu6050.hpp)</li> <li>MPU6050_PWR2_STBY_ZA_BIT (Mpu6050.hpp)</li> <li>MPU6050_PWR2_STBY_ZG_BIT (Mpu6050.hpp)</li> <li>MPU6050_RA_ACCEL_CONFIG (Mpu6050.hpp)</li> <li>MPU6050_RA_ACCEL_XOUT_H (Mpu6050.hpp)</li> <li>MPU6050_RA_ACCEL_XOUT_L (Mpu6050.hpp)</li> <li>MPU6050_RA_ACCEL_YOUT_H (Mpu6050.hpp)</li> <li>MPU6050_RA_ACCEL_YOUT_L (Mpu6050.hpp)</li> <li>MPU6050_RA_ACCEL_ZOUT_H (Mpu6050.hpp)</li> <li>MPU6050_RA_ACCEL_ZOUT_L (Mpu6050.hpp)</li> <li>MPU6050_RA_BANK_SEL (Mpu6050.hpp)</li> <li>MPU6050_RA_CONFIG (Mpu6050.hpp)</li> <li>MPU6050_RA_DMP_CFG_1 (Mpu6050.hpp)</li> <li>MPU6050_RA_DMP_CFG_2 (Mpu6050.hpp)</li> <li>MPU6050_RA_DMP_INT_STATUS (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_00 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_01 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_02 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_03 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_04 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_05 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_06 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_07 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_08 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_09 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_10 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_11 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_12 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_13 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_14 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_15 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_16 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_17 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_18 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_19 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_20 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_21 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_22 (Mpu6050.hpp)</li> <li>MPU6050_RA_EXT_SENS_DATA_23 (Mpu6050.hpp)</li> <li>MPU6050_RA_FF_DUR (Mpu6050.hpp)</li> <li>MPU6050_RA_FF_THR (Mpu6050.hpp)</li> <li>MPU6050_RA_FIFO_COUNTH (Mpu6050.hpp)</li> <li>MPU6050_RA_FIFO_COUNTL (Mpu6050.hpp)</li> <li>MPU6050_RA_FIFO_EN (Mpu6050.hpp)</li> <li>MPU6050_RA_FIFO_R_W (Mpu6050.hpp)</li> <li>MPU6050_RA_GYRO_CONFIG (Mpu6050.hpp)</li> <li>MPU6050_RA_GYRO_XOUT_H (Mpu6050.hpp)</li> <li>MPU6050_RA_GYRO_XOUT_L (Mpu6050.hpp)</li> <li>MPU6050_RA_GYRO_YOUT_H (Mpu6050.hpp)</li> <li>MPU6050_RA_GYRO_YOUT_L (Mpu6050.hpp)</li> <li>MPU6050_RA_GYRO_ZOUT_H (Mpu6050.hpp)</li> <li>MPU6050_RA_GYRO_ZOUT_L (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_MST_CTRL (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_MST_DELAY_CTRL (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_MST_STATUS (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV0_ADDR (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV0_CTRL (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV0_DO (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV0_REG (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV1_ADDR (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV1_CTRL (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV1_DO (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV1_REG (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV2_ADDR (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV2_CTRL (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV2_DO (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV2_REG (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV3_ADDR (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV3_CTRL (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV3_DO (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV3_REG (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV4_ADDR (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV4_CTRL (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV4_DI (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV4_DO (Mpu6050.hpp)</li> <li>MPU6050_RA_I2C_SLV4_REG (Mpu6050.hpp)</li> <li>MPU6050_RA_INT_ENABLE (Mpu6050.hpp)</li> <li>MPU6050_RA_INT_PIN_CFG (Mpu6050.hpp)</li> <li>MPU6050_RA_INT_STATUS (Mpu6050.hpp)</li> <li>MPU6050_RA_MEM_R_W (Mpu6050.hpp)</li> <li>MPU6050_RA_MEM_START_ADDR (Mpu6050.hpp)</li> <li>MPU6050_RA_MOT_DETECT_CTRL (Mpu6050.hpp)</li> <li>MPU6050_RA_MOT_DETECT_STATUS (Mpu6050.hpp)</li> <li>MPU6050_RA_MOT_DUR (Mpu6050.hpp)</li> <li>MPU6050_RA_MOT_THR (Mpu6050.hpp)</li> <li>MPU6050_RA_PWR_MGMT_1 (Mpu6050.hpp)</li> <li>MPU6050_RA_PWR_MGMT_2 (Mpu6050.hpp)</li> <li>MPU6050_RA_SIGNAL_PATH_RESET (Mpu6050.hpp)</li> <li>MPU6050_RA_SMPLRT_DIV (Mpu6050.hpp)</li> <li>MPU6050_RA_TEMP_OUT_H (Mpu6050.hpp)</li> <li>MPU6050_RA_TEMP_OUT_L (Mpu6050.hpp)</li> <li>MPU6050_RA_USER_CTRL (Mpu6050.hpp)</li> <li>MPU6050_RA_WHO_AM_I (Mpu6050.hpp)</li> <li>MPU6050_RA_XA_OFFS_H (Mpu6050.hpp)</li> <li>MPU6050_RA_XA_OFFS_L_TC (Mpu6050.hpp)</li> <li>MPU6050_RA_XG_OFFS_TC (Mpu6050.hpp)</li> <li>MPU6050_RA_XG_OFFS_USRH (Mpu6050.hpp)</li> <li>MPU6050_RA_XG_OFFS_USRL (Mpu6050.hpp)</li> <li>MPU6050_RA_X_FINE_GAIN (Mpu6050.hpp)</li> <li>MPU6050_RA_YA_OFFS_H (Mpu6050.hpp)</li> <li>MPU6050_RA_YA_OFFS_L_TC (Mpu6050.hpp)</li> <li>MPU6050_RA_YG_OFFS_TC (Mpu6050.hpp)</li> <li>MPU6050_RA_YG_OFFS_USRH (Mpu6050.hpp)</li> <li>MPU6050_RA_YG_OFFS_USRL (Mpu6050.hpp)</li> <li>MPU6050_RA_Y_FINE_GAIN (Mpu6050.hpp)</li> <li>MPU6050_RA_ZA_OFFS_H (Mpu6050.hpp)</li> <li>MPU6050_RA_ZA_OFFS_L_TC (Mpu6050.hpp)</li> <li>MPU6050_RA_ZG_OFFS_TC (Mpu6050.hpp)</li> <li>MPU6050_RA_ZG_OFFS_USRH (Mpu6050.hpp)</li> <li>MPU6050_RA_ZG_OFFS_USRL (Mpu6050.hpp)</li> <li>MPU6050_RA_ZRMOT_DUR (Mpu6050.hpp)</li> <li>MPU6050_RA_ZRMOT_THR (Mpu6050.hpp)</li> <li>MPU6050_RA_Z_FINE_GAIN (Mpu6050.hpp)</li> <li>MPU6050_SLV0_FIFO_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_SLV1_FIFO_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_SLV2_FIFO_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_SLV_3_FIFO_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_TC_OFFSET_BIT (Mpu6050.hpp)</li> <li>MPU6050_TC_OFFSET_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_TC_OTP_BNK_VLD_BIT (Mpu6050.hpp)</li> <li>MPU6050_TC_PWR_MODE_BIT (Mpu6050.hpp)</li> <li>MPU6050_TEMP_FIFO_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_USERCTRL_DMP_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_USERCTRL_DMP_RESET_BIT (Mpu6050.hpp)</li> <li>MPU6050_USERCTRL_FIFO_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_USERCTRL_FIFO_RESET_BIT (Mpu6050.hpp)</li> <li>MPU6050_USERCTRL_I2C_IF_DIS_BIT (Mpu6050.hpp)</li> <li>MPU6050_USERCTRL_I2C_MST_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_USERCTRL_I2C_MST_RESET_BIT (Mpu6050.hpp)</li> <li>MPU6050_USERCTRL_SIG_COND_RESET_BIT (Mpu6050.hpp)</li> <li>MPU6050_VDDIO_LEVEL_VDD (Mpu6050.hpp)</li> <li>MPU6050_VDDIO_LEVEL_VLOGIC (Mpu6050.hpp)</li> <li>MPU6050_WAIT_FOR_ES_BIT (Mpu6050.hpp)</li> <li>MPU6050_WAKE_FREQ_10 (Mpu6050.hpp)</li> <li>MPU6050_WAKE_FREQ_1P25 (Mpu6050.hpp)</li> <li>MPU6050_WAKE_FREQ_2P5 (Mpu6050.hpp)</li> <li>MPU6050_WAKE_FREQ_5 (Mpu6050.hpp)</li> <li>MPU6050_WHO_AM_I_BIT (Mpu6050.hpp)</li> <li>MPU6050_WHO_AM_I_LENGTH (Mpu6050.hpp)</li> <li>MPU6050_XG_FIFO_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_YG_FIFO_EN_BIT (Mpu6050.hpp)</li> <li>MPU6050_ZG_FIFO_EN_BIT (Mpu6050.hpp)</li> <li>mpu_ACCEL_FIFO_EN_BIT (MpuController.hpp)</li> <li>mpu_ACCEL_FS_16 (MpuController.hpp)</li> <li>mpu_ACCEL_FS_2 (MpuController.hpp)</li> <li>mpu_ACCEL_FS_4 (MpuController.hpp)</li> <li>mpu_ACCEL_FS_8 (MpuController.hpp)</li> <li>mpu_ACONFIG_ACCEL_HPF_BIT (MpuController.hpp)</li> <li>mpu_ACONFIG_ACCEL_HPF_LENGTH (MpuController.hpp)</li> <li>mpu_ACONFIG_AFS_SEL_BIT (MpuController.hpp)</li> <li>mpu_ACONFIG_AFS_SEL_LENGTH (MpuController.hpp)</li> <li>mpu_ACONFIG_XA_ST_BIT (MpuController.hpp)</li> <li>mpu_ACONFIG_YA_ST_BIT (MpuController.hpp)</li> <li>mpu_ACONFIG_ZA_ST_BIT (MpuController.hpp)</li> <li>mpu_ADDRESS_AD0_HIGH (MpuController.hpp)</li> <li>mpu_ADDRESS_AD0_LOW (MpuController.hpp)</li> <li>mpu_BANKSEL_CFG_USER_BANK_BIT (MpuController.hpp)</li> <li>mpu_BANKSEL_MEM_SEL_BIT (MpuController.hpp)</li> <li>mpu_BANKSEL_MEM_SEL_LENGTH (MpuController.hpp)</li> <li>mpu_BANKSEL_PRFTCH_EN_BIT (MpuController.hpp)</li> <li>mpu_CFG_DLPF_CFG_BIT (MpuController.hpp)</li> <li>mpu_CFG_DLPF_CFG_LENGTH (MpuController.hpp)</li> <li>mpu_CFG_EXT_SYNC_SET_BIT (MpuController.hpp)</li> <li>mpu_CFG_EXT_SYNC_SET_LENGTH (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_258 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_267 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_276 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_286 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_296 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_308 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_320 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_333 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_348 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_364 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_381 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_400 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_421 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_444 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_471 (MpuController.hpp)</li> <li>mpu_CLOCK_DIV_500 (MpuController.hpp)</li> <li>mpu_CLOCK_INTERNAL (MpuController.hpp)</li> <li>mpu_CLOCK_KEEP_RESET (MpuController.hpp)</li> <li>mpu_CLOCK_PLL_EXT19M (MpuController.hpp)</li> <li>mpu_CLOCK_PLL_EXT32K (MpuController.hpp)</li> <li>mpu_CLOCK_PLL_XGYRO (MpuController.hpp)</li> <li>mpu_CLOCK_PLL_YGYRO (MpuController.hpp)</li> <li>mpu_CLOCK_PLL_ZGYRO (MpuController.hpp)</li> <li>mpu_DEFAULT_ADDRESS (MpuController.hpp)</li> <li>mpu_DELAYCTRL_DELAY_ES_SHADOW_BIT (MpuController.hpp)</li> <li>mpu_DELAYCTRL_I2C_SLV0_DLY_EN_BIT (MpuController.hpp)</li> <li>mpu_DELAYCTRL_I2C_SLV1_DLY_EN_BIT (MpuController.hpp)</li> <li>mpu_DELAYCTRL_I2C_SLV2_DLY_EN_BIT (MpuController.hpp)</li> <li>mpu_DELAYCTRL_I2C_SLV3_DLY_EN_BIT (MpuController.hpp)</li> <li>mpu_DELAYCTRL_I2C_SLV4_DLY_EN_BIT (MpuController.hpp)</li> <li>mpu_DETECT_ACCEL_ON_DELAY_BIT (MpuController.hpp)</li> <li>mpu_DETECT_ACCEL_ON_DELAY_LENGTH (MpuController.hpp)</li> <li>mpu_DETECT_DECREMENT_1 (MpuController.hpp)</li> <li>mpu_DETECT_DECREMENT_2 (MpuController.hpp)</li> <li>mpu_DETECT_DECREMENT_4 (MpuController.hpp)</li> <li>mpu_DETECT_DECREMENT_RESET (MpuController.hpp)</li> <li>mpu_DETECT_FF_COUNT_BIT (MpuController.hpp)</li> <li>mpu_DETECT_FF_COUNT_LENGTH (MpuController.hpp)</li> <li>mpu_DETECT_MOT_COUNT_BIT (MpuController.hpp)</li> <li>mpu_DETECT_MOT_COUNT_LENGTH (MpuController.hpp)</li> <li>mpu_DHPF_0P63 (MpuController.hpp)</li> <li>mpu_DHPF_1P25 (MpuController.hpp)</li> <li>mpu_DHPF_2P5 (MpuController.hpp)</li> <li>mpu_DHPF_5 (MpuController.hpp)</li> <li>mpu_DHPF_HOLD (MpuController.hpp)</li> <li>mpu_DHPF_RESET (MpuController.hpp)</li> <li>mpu_DLPF_BW_10 (MpuController.hpp)</li> <li>mpu_DLPF_BW_188 (MpuController.hpp)</li> <li>mpu_DLPF_BW_20 (MpuController.hpp)</li> <li>mpu_DLPF_BW_256 (MpuController.hpp)</li> <li>mpu_DLPF_BW_42 (MpuController.hpp)</li> <li>mpu_DLPF_BW_5 (MpuController.hpp)</li> <li>mpu_DLPF_BW_98 (MpuController.hpp)</li> <li>mpu_DMPINT_0_BIT (MpuController.hpp)</li> <li>mpu_DMPINT_1_BIT (MpuController.hpp)</li> <li>mpu_DMPINT_2_BIT (MpuController.hpp)</li> <li>mpu_DMPINT_3_BIT (MpuController.hpp)</li> <li>mpu_DMPINT_4_BIT (MpuController.hpp)</li> <li>mpu_DMPINT_5_BIT (MpuController.hpp)</li> <li>mpu_DMP_MEMORY_BANKS (MpuController.hpp)</li> <li>mpu_DMP_MEMORY_BANK_SIZE (MpuController.hpp)</li> <li>mpu_DMP_MEMORY_CHUNK_SIZE (MpuController.hpp)</li> <li>mpu_EXT_SYNC_ACCEL_XOUT_L (MpuController.hpp)</li> <li>mpu_EXT_SYNC_ACCEL_YOUT_L (MpuController.hpp)</li> <li>mpu_EXT_SYNC_ACCEL_ZOUT_L (MpuController.hpp)</li> <li>mpu_EXT_SYNC_DISABLED (MpuController.hpp)</li> <li>mpu_EXT_SYNC_GYRO_XOUT_L (MpuController.hpp)</li> <li>mpu_EXT_SYNC_GYRO_YOUT_L (MpuController.hpp)</li> <li>mpu_EXT_SYNC_GYRO_ZOUT_L (MpuController.hpp)</li> <li>mpu_EXT_SYNC_TEMP_OUT_L (MpuController.hpp)</li> <li>mpu_GCONFIG_FS_SEL_BIT (MpuController.hpp)</li> <li>mpu_GCONFIG_FS_SEL_LENGTH (MpuController.hpp)</li> <li>mpu_GYRO_FS_1000 (MpuController.hpp)</li> <li>mpu_GYRO_FS_2000 (MpuController.hpp)</li> <li>mpu_GYRO_FS_250 (MpuController.hpp)</li> <li>mpu_GYRO_FS_500 (MpuController.hpp)</li> <li>mpu_I2C_MST_CLK_BIT (MpuController.hpp)</li> <li>mpu_I2C_MST_CLK_LENGTH (MpuController.hpp)</li> <li>mpu_I2C_MST_P_NSR_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV4_ADDR_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV4_ADDR_LENGTH (MpuController.hpp)</li> <li>mpu_I2C_SLV4_EN_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV4_INT_EN_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV4_MST_DLY_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV4_MST_DLY_LENGTH (MpuController.hpp)</li> <li>mpu_I2C_SLV4_REG_DIS_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV4_RW_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV_ADDR_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV_ADDR_LENGTH (MpuController.hpp)</li> <li>mpu_I2C_SLV_BYTE_SW_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV_EN_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV_GRP_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV_LEN_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV_LEN_LENGTH (MpuController.hpp)</li> <li>mpu_I2C_SLV_REG_DIS_BIT (MpuController.hpp)</li> <li>mpu_I2C_SLV_RW_BIT (MpuController.hpp)</li> <li>mpu_INTCFG_CLKOUT_EN_BIT (MpuController.hpp)</li> <li>mpu_INTCFG_FSYNC_INT_EN_BIT (MpuController.hpp)</li> <li>mpu_INTCFG_FSYNC_INT_LEVEL_BIT (MpuController.hpp)</li> <li>mpu_INTCFG_I2C_BYPASS_EN_BIT (MpuController.hpp)</li> <li>mpu_INTCFG_INT_LEVEL_BIT (MpuController.hpp)</li> <li>mpu_INTCFG_INT_OPEN_BIT (MpuController.hpp)</li> <li>mpu_INTCFG_INT_RD_CLEAR_BIT (MpuController.hpp)</li> <li>mpu_INTCFG_LATCH_INT_EN_BIT (MpuController.hpp)</li> <li>mpu_INTCLEAR_ANYREAD (MpuController.hpp)</li> <li>mpu_INTCLEAR_STATUSREAD (MpuController.hpp)</li> <li>mpu_INTDRV_OPENDRAIN (MpuController.hpp)</li> <li>mpu_INTDRV_PUSHPULL (MpuController.hpp)</li> <li>mpu_INTERRUPT_DATA_RDY_BIT (MpuController.hpp)</li> <li>mpu_INTERRUPT_DMP_INT_BIT (MpuController.hpp)</li> <li>mpu_INTERRUPT_FF_BIT (MpuController.hpp)</li> <li>mpu_INTERRUPT_FIFO_OFLOW_BIT (MpuController.hpp)</li> <li>mpu_INTERRUPT_I2C_MST_INT_BIT (MpuController.hpp)</li> <li>mpu_INTERRUPT_MOT_BIT (MpuController.hpp)</li> <li>mpu_INTERRUPT_PLL_RDY_INT_BIT (MpuController.hpp)</li> <li>mpu_INTERRUPT_ZMOT_BIT (MpuController.hpp)</li> <li>mpu_INTLATCH_50USPULSE (MpuController.hpp)</li> <li>mpu_INTLATCH_WAITCLEAR (MpuController.hpp)</li> <li>mpu_INTMODE_ACTIVEHIGH (MpuController.hpp)</li> <li>mpu_INTMODE_ACTIVELOW (MpuController.hpp)</li> <li>mpu_MOTION_MOT_XNEG_BIT (MpuController.hpp)</li> <li>mpu_MOTION_MOT_XPOS_BIT (MpuController.hpp)</li> <li>mpu_MOTION_MOT_YNEG_BIT (MpuController.hpp)</li> <li>mpu_MOTION_MOT_YPOS_BIT (MpuController.hpp)</li> <li>mpu_MOTION_MOT_ZNEG_BIT (MpuController.hpp)</li> <li>mpu_MOTION_MOT_ZPOS_BIT (MpuController.hpp)</li> <li>mpu_MOTION_MOT_ZRMOT_BIT (MpuController.hpp)</li> <li>mpu_MST_I2C_LOST_ARB_BIT (MpuController.hpp)</li> <li>mpu_MST_I2C_SLV0_NACK_BIT (MpuController.hpp)</li> <li>mpu_MST_I2C_SLV1_NACK_BIT (MpuController.hpp)</li> <li>mpu_MST_I2C_SLV2_NACK_BIT (MpuController.hpp)</li> <li>mpu_MST_I2C_SLV3_NACK_BIT (MpuController.hpp)</li> <li>mpu_MST_I2C_SLV4_DONE_BIT (MpuController.hpp)</li> <li>mpu_MST_I2C_SLV4_NACK_BIT (MpuController.hpp)</li> <li>mpu_MST_PASS_THROUGH_BIT (MpuController.hpp)</li> <li>mpu_MULT_MST_EN_BIT (MpuController.hpp)</li> <li>mpu_PATHRESET_ACCEL_RESET_BIT (MpuController.hpp)</li> <li>mpu_PATHRESET_GYRO_RESET_BIT (MpuController.hpp)</li> <li>mpu_PATHRESET_TEMP_RESET_BIT (MpuController.hpp)</li> <li>mpu_PWR1_CLKSEL_BIT (MpuController.hpp)</li> <li>mpu_PWR1_CLKSEL_LENGTH (MpuController.hpp)</li> <li>mpu_PWR1_CYCLE_BIT (MpuController.hpp)</li> <li>mpu_PWR1_DEVICE_RESET_BIT (MpuController.hpp)</li> <li>mpu_PWR1_SLEEP_BIT (MpuController.hpp)</li> <li>mpu_PWR1_TEMP_DIS_BIT (MpuController.hpp)</li> <li>mpu_PWR2_LP_WAKE_CTRL_BIT (MpuController.hpp)</li> <li>mpu_PWR2_LP_WAKE_CTRL_LENGTH (MpuController.hpp)</li> <li>mpu_PWR2_STBY_XA_BIT (MpuController.hpp)</li> <li>mpu_PWR2_STBY_XG_BIT (MpuController.hpp)</li> <li>mpu_PWR2_STBY_YA_BIT (MpuController.hpp)</li> <li>mpu_PWR2_STBY_YG_BIT (MpuController.hpp)</li> <li>mpu_PWR2_STBY_ZA_BIT (MpuController.hpp)</li> <li>mpu_PWR2_STBY_ZG_BIT (MpuController.hpp)</li> <li>mpu_RA_ACCEL_CONFIG (MpuController.hpp)</li> <li>mpu_RA_ACCEL_XOUT_H (MpuController.hpp)</li> <li>mpu_RA_ACCEL_XOUT_L (MpuController.hpp)</li> <li>mpu_RA_ACCEL_YOUT_H (MpuController.hpp)</li> <li>mpu_RA_ACCEL_YOUT_L (MpuController.hpp)</li> <li>mpu_RA_ACCEL_ZOUT_H (MpuController.hpp)</li> <li>mpu_RA_ACCEL_ZOUT_L (MpuController.hpp)</li> <li>mpu_RA_BANK_SEL (MpuController.hpp)</li> <li>mpu_RA_CONFIG (MpuController.hpp)</li> <li>mpu_RA_DMP_CFG_1 (MpuController.hpp)</li> <li>mpu_RA_DMP_CFG_2 (MpuController.hpp)</li> <li>mpu_RA_DMP_INT_STATUS (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_00 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_01 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_02 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_03 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_04 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_05 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_06 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_07 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_08 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_09 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_10 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_11 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_12 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_13 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_14 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_15 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_16 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_17 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_18 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_19 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_20 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_21 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_22 (MpuController.hpp)</li> <li>mpu_RA_EXT_SENS_DATA_23 (MpuController.hpp)</li> <li>mpu_RA_FF_DUR (MpuController.hpp)</li> <li>mpu_RA_FF_THR (MpuController.hpp)</li> <li>mpu_RA_FIFO_COUNTH (MpuController.hpp)</li> <li>mpu_RA_FIFO_COUNTL (MpuController.hpp)</li> <li>mpu_RA_FIFO_EN (MpuController.hpp)</li> <li>mpu_RA_FIFO_R_W (MpuController.hpp)</li> <li>mpu_RA_GYRO_CONFIG (MpuController.hpp)</li> <li>mpu_RA_GYRO_XOUT_H (MpuController.hpp)</li> <li>mpu_RA_GYRO_XOUT_L (MpuController.hpp)</li> <li>mpu_RA_GYRO_YOUT_H (MpuController.hpp)</li> <li>mpu_RA_GYRO_YOUT_L (MpuController.hpp)</li> <li>mpu_RA_GYRO_ZOUT_H (MpuController.hpp)</li> <li>mpu_RA_GYRO_ZOUT_L (MpuController.hpp)</li> <li>mpu_RA_I2C_MST_CTRL (MpuController.hpp)</li> <li>mpu_RA_I2C_MST_DELAY_CTRL (MpuController.hpp)</li> <li>mpu_RA_I2C_MST_STATUS (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV0_ADDR (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV0_CTRL (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV0_DO (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV0_REG (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV1_ADDR (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV1_CTRL (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV1_DO (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV1_REG (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV2_ADDR (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV2_CTRL (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV2_DO (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV2_REG (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV3_ADDR (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV3_CTRL (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV3_DO (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV3_REG (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV4_ADDR (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV4_CTRL (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV4_DI (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV4_DO (MpuController.hpp)</li> <li>mpu_RA_I2C_SLV4_REG (MpuController.hpp)</li> <li>mpu_RA_INT_ENABLE (MpuController.hpp)</li> <li>mpu_RA_INT_PIN_CFG (MpuController.hpp)</li> <li>mpu_RA_INT_STATUS (MpuController.hpp)</li> <li>mpu_RA_MEM_R_W (MpuController.hpp)</li> <li>mpu_RA_MEM_START_ADDR (MpuController.hpp)</li> <li>mpu_RA_MOT_DETECT_CTRL (MpuController.hpp)</li> <li>mpu_RA_MOT_DETECT_STATUS (MpuController.hpp)</li> <li>mpu_RA_MOT_DUR (MpuController.hpp)</li> <li>mpu_RA_MOT_THR (MpuController.hpp)</li> <li>mpu_RA_PWR_MGMT_1 (MpuController.hpp)</li> <li>mpu_RA_PWR_MGMT_2 (MpuController.hpp)</li> <li>mpu_RA_SIGNAL_PATH_RESET (MpuController.hpp)</li> <li>mpu_RA_SMPLRT_DIV (MpuController.hpp)</li> <li>mpu_RA_TEMP_OUT_H (MpuController.hpp)</li> <li>mpu_RA_TEMP_OUT_L (MpuController.hpp)</li> <li>mpu_RA_USER_CTRL (MpuController.hpp)</li> <li>mpu_RA_WHO_AM_I (MpuController.hpp)</li> <li>mpu_RA_XA_OFFS_H (MpuController.hpp)</li> <li>mpu_RA_XA_OFFS_L_TC (MpuController.hpp)</li> <li>mpu_RA_XG_OFFS_TC (MpuController.hpp)</li> <li>mpu_RA_XG_OFFS_USRH (MpuController.hpp)</li> <li>mpu_RA_XG_OFFS_USRL (MpuController.hpp)</li> <li>mpu_RA_X_FINE_GAIN (MpuController.hpp)</li> <li>mpu_RA_YA_OFFS_H (MpuController.hpp)</li> <li>mpu_RA_YA_OFFS_L_TC (MpuController.hpp)</li> <li>mpu_RA_YG_OFFS_TC (MpuController.hpp)</li> <li>mpu_RA_YG_OFFS_USRH (MpuController.hpp)</li> <li>mpu_RA_YG_OFFS_USRL (MpuController.hpp)</li> <li>mpu_RA_Y_FINE_GAIN (MpuController.hpp)</li> <li>mpu_RA_ZA_OFFS_H (MpuController.hpp)</li> <li>mpu_RA_ZA_OFFS_L_TC (MpuController.hpp)</li> <li>mpu_RA_ZG_OFFS_TC (MpuController.hpp)</li> <li>mpu_RA_ZG_OFFS_USRH (MpuController.hpp)</li> <li>mpu_RA_ZG_OFFS_USRL (MpuController.hpp)</li> <li>mpu_RA_ZRMOT_DUR (MpuController.hpp)</li> <li>mpu_RA_ZRMOT_THR (MpuController.hpp)</li> <li>mpu_RA_Z_FINE_GAIN (MpuController.hpp)</li> <li>mpu_SLV0_FIFO_EN_BIT (MpuController.hpp)</li> <li>mpu_SLV1_FIFO_EN_BIT (MpuController.hpp)</li> <li>mpu_SLV2_FIFO_EN_BIT (MpuController.hpp)</li> <li>mpu_SLV_3_FIFO_EN_BIT (MpuController.hpp)</li> <li>mpu_TC_OFFSET_BIT (MpuController.hpp)</li> <li>mpu_TC_OFFSET_LENGTH (MpuController.hpp)</li> <li>mpu_TC_OTP_BNK_VLD_BIT (MpuController.hpp)</li> <li>mpu_TC_PWR_MODE_BIT (MpuController.hpp)</li> <li>mpu_TEMP_FIFO_EN_BIT (MpuController.hpp)</li> <li>mpu_USERCTRL_DMP_EN_BIT (MpuController.hpp)</li> <li>mpu_USERCTRL_DMP_RESET_BIT (MpuController.hpp)</li> <li>mpu_USERCTRL_FIFO_EN_BIT (MpuController.hpp)</li> <li>mpu_USERCTRL_FIFO_RESET_BIT (MpuController.hpp)</li> <li>mpu_USERCTRL_I2C_IF_DIS_BIT (MpuController.hpp)</li> <li>mpu_USERCTRL_I2C_MST_EN_BIT (MpuController.hpp)</li> <li>mpu_USERCTRL_I2C_MST_RESET_BIT (MpuController.hpp)</li> <li>mpu_USERCTRL_SIG_COND_RESET_BIT (MpuController.hpp)</li> <li>mpu_VDDIO_LEVEL_VDD (MpuController.hpp)</li> <li>mpu_VDDIO_LEVEL_VLOGIC (MpuController.hpp)</li> <li>mpu_WAIT_FOR_ES_BIT (MpuController.hpp)</li> <li>mpu_WAKE_FREQ_10 (MpuController.hpp)</li> <li>mpu_WAKE_FREQ_1P25 (MpuController.hpp)</li> <li>mpu_WAKE_FREQ_2P5 (MpuController.hpp)</li> <li>mpu_WAKE_FREQ_5 (MpuController.hpp)</li> <li>mpu_WHO_AM_I_BIT (MpuController.hpp)</li> <li>mpu_WHO_AM_I_LENGTH (MpuController.hpp)</li> <li>mpu_XG_FIFO_EN_BIT (MpuController.hpp)</li> <li>mpu_YG_FIFO_EN_BIT (MpuController.hpp)</li> <li>mpu_ZG_FIFO_EN_BIT (MpuController.hpp)</li> <li>mtCOVERAGE_TEST_DELAY (FreeRTOS.h)</li> <li>mtCOVERAGE_TEST_MARKER (FreeRTOS.h)</li> <li>MPU_WRAPPERS_INCLUDED_FROM_API_FILE (event_groups.c, heap_4.c, queue.c, stream_buffer.c, tasks.c, timers.c)</li> </ul>"},{"location":"apiStm/macros/#n","title":"n","text":"<ul> <li>NO_DESCRIPTOR (usb_std.h)</li> </ul>"},{"location":"apiStm/macros/#o","title":"o","text":"<ul> <li>OLED_BUFFER_SIZE (OledController.hpp)</li> <li>OLED_I2C_ADDR (OledController.hpp)</li> </ul>"},{"location":"apiStm/macros/#p","title":"p","text":"<ul> <li>pcQueueGetName (FreeRTOS.h)</li> <li>pcQueueGetQueueName (FreeRTOS.h)</li> <li>pcTaskGetTaskName (FreeRTOS.h)</li> <li>pcTimerGetTimerName (FreeRTOS.h)</li> <li>pdTASK_CODE (FreeRTOS.h)</li> <li>pdTASK_HOOK_CODE (FreeRTOS.h)</li> <li>portALLOCATE_SECURE_CONTEXT (FreeRTOS.h)</li> <li>portASSERT_IF_INTERRUPT_PRIORITY_INVALID (FreeRTOS.h)</li> <li>portASSERT_IF_IN_ISR (FreeRTOS.h)</li> <li>portCLEAN_UP_TCB (FreeRTOS.h)</li> <li>portCLEAR_INTERRUPT_MASK_FROM_ISR (FreeRTOS.h, portmacro.h)</li> <li>portCONFIGURE_TIMER_FOR_RUN_TIME_STATS (FreeRTOS.h)</li> <li>portCRITICAL_NESTING_IN_TCB (FreeRTOS.h)</li> <li>portDONT_DISCARD (FreeRTOS.h)</li> <li>portMEMORY_BARRIER (FreeRTOS.h, portmacro.h)</li> <li>portPOINTER_SIZE_TYPE (FreeRTOS.h)</li> <li>portPRE_TASK_DELETE_HOOK (FreeRTOS.h)</li> <li>portPRIVILEGE_BIT (FreeRTOS.h)</li> <li>portSETUP_TCB (FreeRTOS.h)</li> <li>portSET_INTERRUPT_MASK_FROM_ISR (FreeRTOS.h, portmacro.h)</li> <li>portSOFTWARE_BARRIER (FreeRTOS.h)</li> <li>portSUPPRESS_TICKS_AND_SLEEP (FreeRTOS.h, portmacro.h)</li> <li>portTASK_USES_FLOATING_POINT (FreeRTOS.h)</li> <li>portTICK_RATE_MS (FreeRTOS.h)</li> <li>portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR (FreeRTOS.h)</li> <li>portTICK_TYPE_ENTER_CRITICAL (FreeRTOS.h)</li> <li>portTICK_TYPE_EXIT_CRITICAL (FreeRTOS.h)</li> <li>portTICK_TYPE_IS_ATOMIC (FreeRTOS.h, portmacro.h)</li> <li>portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR (FreeRTOS.h)</li> <li>portTickType (FreeRTOS.h)</li> <li>portYIELD_WITHIN_API (FreeRTOS.h)</li> <li>pxContainer (FreeRTOS.h)</li> <li>portFORCE_INLINE (atomic.h, portmacro.h)</li> <li>PRIVILEGED_DATA (mpu_wrappers.h)</li> <li>PRIVILEGED_FUNCTION (mpu_wrappers.h)</li> <li>portUSING_MPU_WRAPPERS (mpu_wrappers.h)</li> <li>portARCH_NAME (portable.h)</li> <li>portHAS_STACK_OVERFLOW_CHECKING (portable.h)</li> <li>portNUM_CONFIGURABLE_REGIONS (portable.h)</li> <li>pdBIG_ENDIAN (projdefs.h)</li> <li>pdFAIL (projdefs.h)</li> <li>pdFALSE (projdefs.h)</li> <li>pdFREERTOS_BIG_ENDIAN (projdefs.h)</li> <li>pdFREERTOS_ERRNO_EACCES (projdefs.h)</li> <li>pdFREERTOS_ERRNO_EADDRINUSE (projdefs.h)</li> <li>pdFREERTOS_ERRNO_EADDRNOTAVAIL (projdefs.h)</li> <li>pdFREERTOS_ERRNO_EAGAIN (projdefs.h)</li> <li>pdFREERTOS_ERRNO_EALREADY (projdefs.h)</li> <li>pdFREERTOS_ERRNO_EBADE (projdefs.h)</li> <li>pdFREERTOS_ERRNO_EBADF (projdefs.h)</li> <li>pdFREERTOS_ERRNO_EBUSY (projdefs.h)</li> <li>pdFREERTOS_ERRNO_ECANCELED (projdefs.h)</li> <li>pdFREERTOS_ERRNO_EEXIST (projdefs.h)</li> <li>pdFREERTOS_ERRNO_EFAULT (projdefs.h)</li> <li>pdFREERTOS_ERRNO_EFTYPE (projdefs.h)</li> <li>pdFREERTOS_ERRNO_EILSEQ (projdefs.h)</li> <li>pdFREERTOS_ERRNO_EINPROGRESS (projdefs.h)</li> <li>pdFREERTOS_ERRNO_EINTR (projdefs.h)</li> <li>pdFREERTOS_ERRNO_EINVAL (projdefs.h)</li> <li>pdFREERTOS_ERRNO_EIO (projdefs.h)</li> <li>pdFREERTOS_ERRNO_EISCONN (projdefs.h)</li> <li>pdFREERTOS_ERRNO_EISDIR (projdefs.h)</li> <li>pdFREERTOS_ERRNO_ENAMETOOLONG (projdefs.h)</li> <li>pdFREERTOS_ERRNO_ENMFILE (projdefs.h)</li> <li>pdFREERTOS_ERRNO_ENOBUFS (projdefs.h)</li> <li>pdFREERTOS_ERRNO_ENODEV (projdefs.h)</li> <li>pdFREERTOS_ERRNO_ENOENT (projdefs.h)</li> <li>pdFREERTOS_ERRNO_ENOMEDIUM (projdefs.h)</li> <li>pdFREERTOS_ERRNO_ENOMEM (projdefs.h)</li> <li>pdFREERTOS_ERRNO_ENOPROTOOPT (projdefs.h)</li> <li>pdFREERTOS_ERRNO_ENOSPC (projdefs.h)</li> <li>pdFREERTOS_ERRNO_ENOTCONN (projdefs.h)</li> <li>pdFREERTOS_ERRNO_ENOTDIR (projdefs.h)</li> <li>pdFREERTOS_ERRNO_ENOTEMPTY (projdefs.h)</li> <li>pdFREERTOS_ERRNO_ENXIO (projdefs.h)</li> <li>pdFREERTOS_ERRNO_EOPNOTSUPP (projdefs.h)</li> <li>pdFREERTOS_ERRNO_EROFS (projdefs.h)</li> <li>pdFREERTOS_ERRNO_ESPIPE (projdefs.h)</li> <li>pdFREERTOS_ERRNO_ETIMEDOUT (projdefs.h)</li> <li>pdFREERTOS_ERRNO_EUNATCH (projdefs.h)</li> <li>pdFREERTOS_ERRNO_EWOULDBLOCK (projdefs.h)</li> <li>pdFREERTOS_ERRNO_EXDEV (projdefs.h)</li> <li>pdFREERTOS_ERRNO_NONE (projdefs.h)</li> <li>pdFREERTOS_LITTLE_ENDIAN (projdefs.h)</li> <li>pdINTEGRITY_CHECK_VALUE (projdefs.h)</li> <li>pdLITTLE_ENDIAN (projdefs.h)</li> <li>pdMS_TO_TICKS (projdefs.h)</li> <li>pdPASS (projdefs.h)</li> <li>pdTRUE (projdefs.h)</li> <li>portAIRCR_REG (port.c)</li> <li>portFIRST_USER_INTERRUPT_NUMBER (port.c)</li> <li>portINITIAL_XPSR (port.c)</li> <li>portMAX_24_BIT_NUMBER (port.c)</li> <li>portMAX_8_BIT_VALUE (port.c)</li> <li>portMAX_PRIGROUP_BITS (port.c)</li> <li>portMISSED_COUNTS_FACTOR (port.c)</li> <li>portNVIC_IP_REGISTERS_OFFSET_16 (port.c)</li> <li>portNVIC_PENDSVCLEAR_BIT (port.c)</li> <li>portNVIC_PENDSV_PRI (port.c)</li> <li>portNVIC_PEND_SYSTICK_CLEAR_BIT (port.c)</li> <li>portNVIC_SYSPRI2_REG (port.c)</li> <li>portNVIC_SYSTICK_CLK_BIT (port.c)</li> <li>portNVIC_SYSTICK_COUNT_FLAG_BIT (port.c)</li> <li>portNVIC_SYSTICK_CTRL_REG (port.c)</li> <li>portNVIC_SYSTICK_CURRENT_VALUE_REG (port.c)</li> <li>portNVIC_SYSTICK_ENABLE_BIT (port.c)</li> <li>portNVIC_SYSTICK_INT_BIT (port.c)</li> <li>portNVIC_SYSTICK_LOAD_REG (port.c)</li> <li>portNVIC_SYSTICK_PRI (port.c)</li> <li>portPRIGROUP_SHIFT (port.c)</li> <li>portPRIORITY_GROUP_MASK (port.c)</li> <li>portSTART_ADDRESS_MASK (port.c)</li> <li>portTASK_RETURN_ADDRESS (port.c)</li> <li>portTOP_BIT_OF_BYTE (port.c)</li> <li>portVECTACTIVE_MASK (port.c)</li> <li>portBASE_TYPE (portmacro.h)</li> <li>portBYTE_ALIGNMENT (portmacro.h)</li> <li>portCHAR (portmacro.h)</li> <li>portDISABLE_INTERRUPTS (portmacro.h)</li> <li>portDOUBLE (portmacro.h)</li> <li>portENABLE_INTERRUPTS (portmacro.h)</li> <li>portEND_SWITCHING_ISR (portmacro.h)</li> <li>portENTER_CRITICAL (portmacro.h)</li> <li>portEXIT_CRITICAL (portmacro.h)</li> <li>portFLOAT (portmacro.h)</li> <li>portGET_HIGHEST_PRIORITY (portmacro.h)</li> <li>portINLINE (portmacro.h)</li> <li>portLONG (portmacro.h)</li> <li>portMAX_DELAY (portmacro.h)</li> <li>portNOP (portmacro.h)</li> <li>portNVIC_INT_CTRL_REG (portmacro.h)</li> <li>portNVIC_PENDSVSET_BIT (portmacro.h)</li> <li>portRECORD_READY_PRIORITY (portmacro.h)</li> <li>portRESET_READY_PRIORITY (portmacro.h, tasks.c)</li> <li>portSHORT (portmacro.h)</li> <li>portSTACK_GROWTH (portmacro.h)</li> <li>portSTACK_TYPE (portmacro.h)</li> <li>portTASK_FUNCTION (portmacro.h)</li> <li>portTASK_FUNCTION_PROTO (portmacro.h)</li> <li>portTICK_PERIOD_MS (portmacro.h)</li> <li>portYIELD (portmacro.h)</li> <li>portYIELD_FROM_ISR (portmacro.h)</li> <li>prvLockQueue (queue.c)</li> <li>prvAddTaskToReadyList (tasks.c)</li> <li>prvGetTCBFromHandle (tasks.c)</li> </ul>"},{"location":"apiStm/macros/#q","title":"q","text":"<ul> <li>queueOVERWRITE (queue.h)</li> <li>queueQUEUE_TYPE_BASE (queue.h)</li> <li>queueQUEUE_TYPE_BINARY_SEMAPHORE (queue.h)</li> <li>queueQUEUE_TYPE_COUNTING_SEMAPHORE (queue.h)</li> <li>queueQUEUE_TYPE_MUTEX (queue.h)</li> <li>queueQUEUE_TYPE_RECURSIVE_MUTEX (queue.h)</li> <li>queueQUEUE_TYPE_SET (queue.h)</li> <li>queueSEND_TO_BACK (queue.h)</li> <li>queueSEND_TO_FRONT (queue.h)</li> <li>queueLOCKED_UNMODIFIED (queue.c)</li> <li>queueMUTEX_GIVE_BLOCK_TIME (queue.c)</li> <li>queueQUEUE_IS_MUTEX (queue.c)</li> <li>queueSEMAPHORE_QUEUE_ITEM_LENGTH (queue.c)</li> <li>queueUNLOCKED (queue.c)</li> <li>queueYIELD_IF_USING_PREEMPTION (queue.c)</li> </ul>"},{"location":"apiStm/macros/#s","title":"s","text":"<ul> <li>SERVOUART_HANDLER (Bsp.hpp)</li> <li>STRINGIFY (Debug.hpp)</li> <li>semBINARY_SEMAPHORE_QUEUE_LENGTH (semphr.h)</li> <li>semGIVE_BLOCK_TIME (semphr.h)</li> <li>semSEMAPHORE_QUEUE_ITEM_LENGTH (semphr.h)</li> <li>sbBYTES_TO_STORE_MESSAGE_LENGTH (stream_buffer.c)</li> <li>sbFLAGS_IS_MESSAGE_BUFFER (stream_buffer.c)</li> <li>sbFLAGS_IS_STATICALLY_ALLOCATED (stream_buffer.c)</li> <li>sbRECEIVE_COMPLETED (stream_buffer.c)</li> <li>sbRECEIVE_COMPLETED_FROM_ISR (stream_buffer.c)</li> <li>sbSEND_COMPLETED (stream_buffer.c)</li> <li>sbSEND_COMPLETE_FROM_ISR (stream_buffer.c)</li> </ul>"},{"location":"apiStm/macros/#t","title":"t","text":"<ul> <li>TOSTRING (Debug.hpp)</li> <li>tmrTIMER_CALLBACK (FreeRTOS.h)</li> <li>traceBLOCKING_ON_QUEUE_PEEK (FreeRTOS.h)</li> <li>traceBLOCKING_ON_QUEUE_RECEIVE (FreeRTOS.h)</li> <li>traceBLOCKING_ON_QUEUE_SEND (FreeRTOS.h)</li> <li>traceBLOCKING_ON_STREAM_BUFFER_RECEIVE (FreeRTOS.h)</li> <li>traceBLOCKING_ON_STREAM_BUFFER_SEND (FreeRTOS.h)</li> <li>traceCREATE_COUNTING_SEMAPHORE (FreeRTOS.h)</li> <li>traceCREATE_COUNTING_SEMAPHORE_FAILED (FreeRTOS.h)</li> <li>traceCREATE_MUTEX (FreeRTOS.h)</li> <li>traceCREATE_MUTEX_FAILED (FreeRTOS.h)</li> <li>traceEND (FreeRTOS.h)</li> <li>traceEVENT_GROUP_CLEAR_BITS (FreeRTOS.h)</li> <li>traceEVENT_GROUP_CLEAR_BITS_FROM_ISR (FreeRTOS.h)</li> <li>traceEVENT_GROUP_CREATE (FreeRTOS.h)</li> <li>traceEVENT_GROUP_CREATE_FAILED (FreeRTOS.h)</li> <li>traceEVENT_GROUP_DELETE (FreeRTOS.h)</li> <li>traceEVENT_GROUP_SET_BITS (FreeRTOS.h)</li> <li>traceEVENT_GROUP_SET_BITS_FROM_ISR (FreeRTOS.h)</li> <li>traceEVENT_GROUP_SYNC_BLOCK (FreeRTOS.h)</li> <li>traceEVENT_GROUP_SYNC_END (FreeRTOS.h)</li> <li>traceEVENT_GROUP_WAIT_BITS_BLOCK (FreeRTOS.h)</li> <li>traceEVENT_GROUP_WAIT_BITS_END (FreeRTOS.h)</li> <li>traceFREE (FreeRTOS.h)</li> <li>traceGIVE_MUTEX_RECURSIVE (FreeRTOS.h)</li> <li>traceGIVE_MUTEX_RECURSIVE_FAILED (FreeRTOS.h)</li> <li>traceINCREASE_TICK_COUNT (FreeRTOS.h)</li> <li>traceLOW_POWER_IDLE_BEGIN (FreeRTOS.h)</li> <li>traceLOW_POWER_IDLE_END (FreeRTOS.h)</li> <li>traceMALLOC (FreeRTOS.h)</li> <li>traceMOVED_TASK_TO_READY_STATE (FreeRTOS.h)</li> <li>tracePEND_FUNC_CALL (FreeRTOS.h)</li> <li>tracePEND_FUNC_CALL_FROM_ISR (FreeRTOS.h)</li> <li>tracePOST_MOVED_TASK_TO_READY_STATE (FreeRTOS.h)</li> <li>traceQUEUE_CREATE (FreeRTOS.h)</li> <li>traceQUEUE_CREATE_FAILED (FreeRTOS.h)</li> <li>traceQUEUE_DELETE (FreeRTOS.h)</li> <li>traceQUEUE_PEEK (FreeRTOS.h)</li> <li>traceQUEUE_PEEK_FAILED (FreeRTOS.h)</li> <li>traceQUEUE_PEEK_FROM_ISR (FreeRTOS.h)</li> <li>traceQUEUE_PEEK_FROM_ISR_FAILED (FreeRTOS.h)</li> <li>traceQUEUE_RECEIVE (FreeRTOS.h)</li> <li>traceQUEUE_RECEIVE_FAILED (FreeRTOS.h)</li> <li>traceQUEUE_RECEIVE_FROM_ISR (FreeRTOS.h)</li> <li>traceQUEUE_RECEIVE_FROM_ISR_FAILED (FreeRTOS.h)</li> <li>traceQUEUE_REGISTRY_ADD (FreeRTOS.h)</li> <li>traceQUEUE_SEND (FreeRTOS.h)</li> <li>traceQUEUE_SEND_FAILED (FreeRTOS.h)</li> <li>traceQUEUE_SEND_FROM_ISR (FreeRTOS.h)</li> <li>traceQUEUE_SEND_FROM_ISR_FAILED (FreeRTOS.h)</li> <li>traceSTART (FreeRTOS.h)</li> <li>traceSTREAM_BUFFER_CREATE (FreeRTOS.h)</li> <li>traceSTREAM_BUFFER_CREATE_FAILED (FreeRTOS.h)</li> <li>traceSTREAM_BUFFER_CREATE_STATIC_FAILED (FreeRTOS.h)</li> <li>traceSTREAM_BUFFER_DELETE (FreeRTOS.h)</li> <li>traceSTREAM_BUFFER_RECEIVE (FreeRTOS.h)</li> <li>traceSTREAM_BUFFER_RECEIVE_FAILED (FreeRTOS.h)</li> <li>traceSTREAM_BUFFER_RECEIVE_FROM_ISR (FreeRTOS.h)</li> <li>traceSTREAM_BUFFER_RESET (FreeRTOS.h)</li> <li>traceSTREAM_BUFFER_SEND (FreeRTOS.h)</li> <li>traceSTREAM_BUFFER_SEND_FAILED (FreeRTOS.h)</li> <li>traceSTREAM_BUFFER_SEND_FROM_ISR (FreeRTOS.h)</li> <li>traceTAKE_MUTEX_RECURSIVE (FreeRTOS.h)</li> <li>traceTAKE_MUTEX_RECURSIVE_FAILED (FreeRTOS.h)</li> <li>traceTASK_CREATE (FreeRTOS.h)</li> <li>traceTASK_CREATE_FAILED (FreeRTOS.h)</li> <li>traceTASK_DELAY (FreeRTOS.h)</li> <li>traceTASK_DELAY_UNTIL (FreeRTOS.h)</li> <li>traceTASK_DELETE (FreeRTOS.h)</li> <li>traceTASK_INCREMENT_TICK (FreeRTOS.h)</li> <li>traceTASK_NOTIFY (FreeRTOS.h)</li> <li>traceTASK_NOTIFY_FROM_ISR (FreeRTOS.h)</li> <li>traceTASK_NOTIFY_GIVE_FROM_ISR (FreeRTOS.h)</li> <li>traceTASK_NOTIFY_TAKE (FreeRTOS.h)</li> <li>traceTASK_NOTIFY_TAKE_BLOCK (FreeRTOS.h)</li> <li>traceTASK_NOTIFY_WAIT (FreeRTOS.h)</li> <li>traceTASK_NOTIFY_WAIT_BLOCK (FreeRTOS.h)</li> <li>traceTASK_PRIORITY_DISINHERIT (FreeRTOS.h)</li> <li>traceTASK_PRIORITY_INHERIT (FreeRTOS.h)</li> <li>traceTASK_PRIORITY_SET (FreeRTOS.h)</li> <li>traceTASK_RESUME (FreeRTOS.h)</li> <li>traceTASK_RESUME_FROM_ISR (FreeRTOS.h)</li> <li>traceTASK_SUSPEND (FreeRTOS.h)</li> <li>traceTASK_SWITCHED_IN (FreeRTOS.h)</li> <li>traceTASK_SWITCHED_OUT (FreeRTOS.h)</li> <li>traceTIMER_COMMAND_RECEIVED (FreeRTOS.h)</li> <li>traceTIMER_COMMAND_SEND (FreeRTOS.h)</li> <li>traceTIMER_CREATE (FreeRTOS.h)</li> <li>traceTIMER_CREATE_FAILED (FreeRTOS.h)</li> <li>traceTIMER_EXPIRED (FreeRTOS.h)</li> <li>tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE (FreeRTOS.h)</li> <li>taskCHECK_FOR_STACK_OVERFLOW (stack_macros.h)</li> <li>taskDISABLE_INTERRUPTS (task.h)</li> <li>taskENABLE_INTERRUPTS (task.h)</li> <li>taskENTER_CRITICAL (task.h)</li> <li>taskENTER_CRITICAL_FROM_ISR (task.h)</li> <li>taskEXIT_CRITICAL (task.h)</li> <li>taskEXIT_CRITICAL_FROM_ISR (task.h)</li> <li>taskSCHEDULER_NOT_STARTED (task.h)</li> <li>taskSCHEDULER_RUNNING (task.h)</li> <li>taskSCHEDULER_SUSPENDED (task.h)</li> <li>taskYIELD (task.h)</li> <li>tskIDLE_PRIORITY (task.h)</li> <li>tskKERNEL_VERSION_BUILD (task.h)</li> <li>tskKERNEL_VERSION_MAJOR (task.h)</li> <li>tskKERNEL_VERSION_MINOR (task.h)</li> <li>tskKERNEL_VERSION_NUMBER (task.h)</li> <li>tskMPU_REGION_DEVICE_MEMORY (task.h)</li> <li>tskMPU_REGION_EXECUTE_NEVER (task.h)</li> <li>tskMPU_REGION_NORMAL_MEMORY (task.h)</li> <li>tskMPU_REGION_READ_ONLY (task.h)</li> <li>tskMPU_REGION_READ_WRITE (task.h)</li> <li>tmrCOMMAND_CHANGE_PERIOD (timers.h)</li> <li>tmrCOMMAND_CHANGE_PERIOD_FROM_ISR (timers.h)</li> <li>tmrCOMMAND_DELETE (timers.h)</li> <li>tmrCOMMAND_EXECUTE_CALLBACK (timers.h)</li> <li>tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR (timers.h)</li> <li>tmrCOMMAND_RESET (timers.h)</li> <li>tmrCOMMAND_RESET_FROM_ISR (timers.h)</li> <li>tmrCOMMAND_START (timers.h)</li> <li>tmrCOMMAND_START_DONT_TRACE (timers.h)</li> <li>tmrCOMMAND_START_FROM_ISR (timers.h)</li> <li>tmrCOMMAND_STOP (timers.h)</li> <li>tmrCOMMAND_STOP_FROM_ISR (timers.h)</li> <li>tmrFIRST_FROM_ISR_COMMAND (timers.h)</li> <li>taskEVENT_LIST_ITEM_VALUE_IN_USE (tasks.c)</li> <li>taskNOTIFICATION_RECEIVED (tasks.c)</li> <li>taskNOT_WAITING_NOTIFICATION (tasks.c)</li> <li>taskRECORD_READY_PRIORITY (tasks.c)</li> <li>taskRESET_READY_PRIORITY (tasks.c)</li> <li>taskSELECT_HIGHEST_PRIORITY_TASK (tasks.c)</li> <li>taskSWITCH_DELAYED_LISTS (tasks.c)</li> <li>taskWAITING_NOTIFICATION (tasks.c)</li> <li>taskYIELD_IF_USING_PREEMPTION (tasks.c)</li> <li>tskBLOCKED_CHAR (tasks.c)</li> <li>tskDELETED_CHAR (tasks.c)</li> <li>tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB (tasks.c)</li> <li>tskREADY_CHAR (tasks.c)</li> <li>tskRUNNING_CHAR (tasks.c)</li> <li>tskSET_NEW_STACKS_TO_KNOWN_VALUE (tasks.c)</li> <li>tskSTACK_FILL_BYTE (tasks.c)</li> <li>tskSTATICALLY_ALLOCATED_STACK_AND_TCB (tasks.c)</li> <li>tskSTATICALLY_ALLOCATED_STACK_ONLY (tasks.c)</li> <li>tskSUSPENDED_CHAR (tasks.c)</li> </ul>"},{"location":"apiStm/macros/#u","title":"u","text":"<ul> <li>USB_LP_IRQ_HANDLER (Bsp.hpp)</li> <li>USE_FreeRTOS_HEAP_4 (FreeRTOSConfig.h)</li> <li>uxSemaphoreGetCount (semphr.h)</li> <li>uxQueueType (queue.c)</li> <li>USB_CDC_1_5_STOP_BITS (usb_cdc.h)</li> <li>USB_CDC_1_STOP_BITS (usb_cdc.h)</li> <li>USB_CDC_2_STOP_BITS (usb_cdc.h)</li> <li>USB_CDC_CALL_MGMT_CAP_CALL_MGMT (usb_cdc.h)</li> <li>USB_CDC_CALL_MGMT_CAP_DATA_INTF (usb_cdc.h)</li> <li>USB_CDC_CAP_BRK (usb_cdc.h)</li> <li>USB_CDC_CAP_LINE (usb_cdc.h)</li> <li>USB_CDC_CAP_NOTIFY (usb_cdc.h)</li> <li>USB_CDC_CLEAR_COMM_FEATURE (usb_cdc.h)</li> <li>USB_CDC_COMM_FEATURE (usb_cdc.h)</li> <li>USB_CDC_EVEN_PARITY (usb_cdc.h)</li> <li>USB_CDC_GET_COMM_FEATURE (usb_cdc.h)</li> <li>USB_CDC_GET_ENCAPSULATED_RESP (usb_cdc.h)</li> <li>USB_CDC_GET_LINE_CODING (usb_cdc.h)</li> <li>USB_CDC_MARK_PARITY (usb_cdc.h)</li> <li>USB_CDC_NO_PARITY (usb_cdc.h)</li> <li>USB_CDC_NTF_NETWORK_CONNECTION (usb_cdc.h)</li> <li>USB_CDC_NTF_RESPONSE_AVAILABLE (usb_cdc.h)</li> <li>USB_CDC_NTF_SERIAL_STATE (usb_cdc.h)</li> <li>USB_CDC_NTF_SPEED_CHANGE (usb_cdc.h)</li> <li>USB_CDC_ODD_PARITY (usb_cdc.h)</li> <li>USB_CDC_PROTO_CDCSPEC (usb_cdc.h)</li> <li>USB_CDC_PROTO_HOST (usb_cdc.h)</li> <li>USB_CDC_PROTO_NONE (usb_cdc.h)</li> <li>USB_CDC_PROTO_NTB (usb_cdc.h)</li> <li>USB_CDC_PROTO_V25TER (usb_cdc.h)</li> <li>USB_CDC_SEND_BREAK (usb_cdc.h)</li> <li>USB_CDC_SEND_ENCAPSULATED_CMD (usb_cdc.h)</li> <li>USB_CDC_SET_COMM_FEATURE (usb_cdc.h)</li> <li>USB_CDC_SET_CONTROL_LINE_STATE (usb_cdc.h)</li> <li>USB_CDC_SET_LINE_CODING (usb_cdc.h)</li> <li>USB_CDC_SPACE_PARITY (usb_cdc.h)</li> <li>USB_CDC_STATE_BREAK (usb_cdc.h)</li> <li>USB_CDC_STATE_FRAMING (usb_cdc.h)</li> <li>USB_CDC_STATE_OVERRUN (usb_cdc.h)</li> <li>USB_CDC_STATE_PARITY (usb_cdc.h)</li> <li>USB_CDC_STATE_RING (usb_cdc.h)</li> <li>USB_CDC_STATE_RX_CARRIER (usb_cdc.h)</li> <li>USB_CDC_STATE_TX_CARRIER (usb_cdc.h)</li> <li>USB_CDC_SUBCLASS_ACM (usb_cdc.h)</li> <li>USB_CLASS_CDC (usb_cdc.h)</li> <li>USB_CLASS_CDC_DATA (usb_cdc.h)</li> <li>USB_DTYPE_CDC_ACM (usb_cdc.h)</li> <li>USB_DTYPE_CDC_CALL_MANAGEMENT (usb_cdc.h)</li> <li>USB_DTYPE_CDC_COUNTRY (usb_cdc.h)</li> <li>USB_DTYPE_CDC_HEADER (usb_cdc.h)</li> <li>USB_DTYPE_CDC_UNION (usb_cdc.h)</li> <li>USB_ARRAY_DESC (usb_std.h)</li> <li>USB_CFG_ATTR_RESERVED (usb_std.h)</li> <li>USB_CFG_ATTR_SELFPOWERED (usb_std.h)</li> <li>USB_CFG_POWER_MA (usb_std.h)</li> <li>USB_CLASS_APP_SPEC (usb_std.h)</li> <li>USB_CLASS_AUDIO (usb_std.h)</li> <li>USB_CLASS_AV (usb_std.h)</li> <li>USB_CLASS_BILLBOARD (usb_std.h)</li> <li>USB_CLASS_CBRIDGE (usb_std.h)</li> <li>USB_CLASS_CONTENT_SEC (usb_std.h)</li> <li>USB_CLASS_CSCID (usb_std.h)</li> <li>USB_CLASS_DIAGNOSTIC (usb_std.h)</li> <li>USB_CLASS_HEALTHCARE (usb_std.h)</li> <li>USB_CLASS_HUB (usb_std.h)</li> <li>USB_CLASS_IAD (usb_std.h)</li> <li>USB_CLASS_MASS_STORAGE (usb_std.h)</li> <li>USB_CLASS_MISC (usb_std.h)</li> <li>USB_CLASS_PER_INTERFACE (usb_std.h)</li> <li>USB_CLASS_PHYSICAL (usb_std.h)</li> <li>USB_CLASS_PRINTER (usb_std.h)</li> <li>USB_CLASS_STILL_IMAGE (usb_std.h)</li> <li>USB_CLASS_VENDOR (usb_std.h)</li> <li>USB_CLASS_VIDEO (usb_std.h)</li> <li>USB_CLASS_WIRELESS (usb_std.h)</li> <li>USB_DTYPE_CONFIGURATION (usb_std.h)</li> <li>USB_DTYPE_CS_ENDPOINT (usb_std.h)</li> <li>USB_DTYPE_CS_INTERFACE (usb_std.h)</li> <li>USB_DTYPE_DEBUG (usb_std.h)</li> <li>USB_DTYPE_DEVICE (usb_std.h)</li> <li>USB_DTYPE_ENDPOINT (usb_std.h)</li> <li>USB_DTYPE_INTERFACE (usb_std.h)</li> <li>USB_DTYPE_INTERFACEPOWER (usb_std.h)</li> <li>USB_DTYPE_INTERFASEASSOC (usb_std.h)</li> <li>USB_DTYPE_OTG (usb_std.h)</li> <li>USB_DTYPE_OTHER (usb_std.h)</li> <li>USB_DTYPE_QUALIFIER (usb_std.h)</li> <li>USB_DTYPE_STRING (usb_std.h)</li> <li>USB_EPATTR_ADAPTIVE (usb_std.h)</li> <li>USB_EPATTR_ASYNC (usb_std.h)</li> <li>USB_EPATTR_NO_SYNC (usb_std.h)</li> <li>USB_EPATTR_SYNC (usb_std.h)</li> <li>USB_EPDIR_IN (usb_std.h)</li> <li>USB_EPDIR_OUT (usb_std.h)</li> <li>USB_EPTYPE_BULK (usb_std.h)</li> <li>USB_EPTYPE_CONTROL (usb_std.h)</li> <li>USB_EPTYPE_INTERRUPT (usb_std.h)</li> <li>USB_EPTYPE_ISOCHRONUS (usb_std.h)</li> <li>USB_EPUSAGE_DATA (usb_std.h)</li> <li>USB_EPUSAGE_FEEDBACK (usb_std.h)</li> <li>USB_EPUSAGE_IMP_FEEDBACK (usb_std.h)</li> <li>USB_FEAT_DEBUG_MODE (usb_std.h)</li> <li>USB_FEAT_ENDPOINT_HALT (usb_std.h)</li> <li>USB_FEAT_REMOTE_WKUP (usb_std.h)</li> <li>USB_FEAT_TEST_MODE (usb_std.h)</li> <li>USB_LANGID_AFR (usb_std.h)</li> <li>USB_LANGID_ARA_AE (usb_std.h)</li> <li>USB_LANGID_ARA_BH (usb_std.h)</li> <li>USB_LANGID_ARA_DZ (usb_std.h)</li> <li>USB_LANGID_ARA_EG (usb_std.h)</li> <li>USB_LANGID_ARA_IQ (usb_std.h)</li> <li>USB_LANGID_ARA_JO (usb_std.h)</li> <li>USB_LANGID_ARA_KW (usb_std.h)</li> <li>USB_LANGID_ARA_LB (usb_std.h)</li> <li>USB_LANGID_ARA_LY (usb_std.h)</li> <li>USB_LANGID_ARA_MA (usb_std.h)</li> <li>USB_LANGID_ARA_OM (usb_std.h)</li> <li>USB_LANGID_ARA_QA (usb_std.h)</li> <li>USB_LANGID_ARA_SA (usb_std.h)</li> <li>USB_LANGID_ARA_SY (usb_std.h)</li> <li>USB_LANGID_ARA_TN (usb_std.h)</li> <li>USB_LANGID_ARA_YE (usb_std.h)</li> <li>USB_LANGID_ASM (usb_std.h)</li> <li>USB_LANGID_AZE_CYR (usb_std.h)</li> <li>USB_LANGID_AZE_LAT (usb_std.h)</li> <li>USB_LANGID_BEL (usb_std.h)</li> <li>USB_LANGID_BEN (usb_std.h)</li> <li>USB_LANGID_BUL (usb_std.h)</li> <li>USB_LANGID_CAT (usb_std.h)</li> <li>USB_LANGID_CZE (usb_std.h)</li> <li>USB_LANGID_DAN (usb_std.h)</li> <li>USB_LANGID_DEU (usb_std.h)</li> <li>USB_LANGID_DEU_AT (usb_std.h)</li> <li>USB_LANGID_DEU_LI (usb_std.h)</li> <li>USB_LANGID_DEU_LU (usb_std.h)</li> <li>USB_LANGID_DEU_SZ (usb_std.h)</li> <li>USB_LANGID_ELL (usb_std.h)</li> <li>USB_LANGID_ENG_AU (usb_std.h)</li> <li>USB_LANGID_ENG_BZ (usb_std.h)</li> <li>USB_LANGID_ENG_CA (usb_std.h)</li> <li>USB_LANGID_ENG_CAR (usb_std.h)</li> <li>USB_LANGID_ENG_IE (usb_std.h)</li> <li>USB_LANGID_ENG_JM (usb_std.h)</li> <li>USB_LANGID_ENG_NZ (usb_std.h)</li> <li>USB_LANGID_ENG_PH (usb_std.h)</li> <li>USB_LANGID_ENG_TH (usb_std.h)</li> <li>USB_LANGID_ENG_UK (usb_std.h)</li> <li>USB_LANGID_ENG_US (usb_std.h)</li> <li>USB_LANGID_ENG_ZA (usb_std.h)</li> <li>USB_LANGID_ENG_ZW (usb_std.h)</li> <li>USB_LANGID_EST (usb_std.h)</li> <li>USB_LANGID_EUS (usb_std.h)</li> <li>USB_LANGID_FAO (usb_std.h)</li> <li>USB_LANGID_FAS (usb_std.h)</li> <li>USB_LANGID_FIN (usb_std.h)</li> <li>USB_LANGID_FRA (usb_std.h)</li> <li>USB_LANGID_FRA_BE (usb_std.h)</li> <li>USB_LANGID_FRA_CA (usb_std.h)</li> <li>USB_LANGID_FRA_LU (usb_std.h)</li> <li>USB_LANGID_FRA_MC (usb_std.h)</li> <li>USB_LANGID_FRA_SZ (usb_std.h)</li> <li>USB_LANGID_GUJ (usb_std.h)</li> <li>USB_LANGID_HEB (usb_std.h)</li> <li>USB_LANGID_HIN (usb_std.h)</li> <li>USB_LANGID_HRV (usb_std.h)</li> <li>USB_LANGID_HUN (usb_std.h)</li> <li>USB_LANGID_HYE (usb_std.h)</li> <li>USB_LANGID_IND (usb_std.h)</li> <li>USB_LANGID_ISL (usb_std.h)</li> <li>USB_LANGID_ITA (usb_std.h)</li> <li>USB_LANGID_ITA_SZ (usb_std.h)</li> <li>USB_LANGID_JPN (usb_std.h)</li> <li>USB_LANGID_KAN (usb_std.h)</li> <li>USB_LANGID_KAS (usb_std.h)</li> <li>USB_LANGID_KAT (usb_std.h)</li> <li>USB_LANGID_KAZ (usb_std.h)</li> <li>USB_LANGID_KOK (usb_std.h)</li> <li>USB_LANGID_KOR (usb_std.h)</li> <li>USB_LANGID_KOR_JOH (usb_std.h)</li> <li>USB_LANGID_LAV (usb_std.h)</li> <li>USB_LANGID_LIT (usb_std.h)</li> <li>USB_LANGID_LIT_CLS (usb_std.h)</li> <li>USB_LANGID_MAL (usb_std.h)</li> <li>USB_LANGID_MAR (usb_std.h)</li> <li>USB_LANGID_MKD (usb_std.h)</li> <li>USB_LANGID_MNI (usb_std.h)</li> <li>USB_LANGID_MSA (usb_std.h)</li> <li>USB_LANGID_MSA_BN (usb_std.h)</li> <li>USB_LANGID_MYA (usb_std.h)</li> <li>USB_LANGID_NEP (usb_std.h)</li> <li>USB_LANGID_NLD_BE (usb_std.h)</li> <li>USB_LANGID_NLD_NL (usb_std.h)</li> <li>USB_LANGID_NNO (usb_std.h)</li> <li>USB_LANGID_NOB (usb_std.h)</li> <li>USB_LANGID_NSO (usb_std.h)</li> <li>USB_LANGID_ORI (usb_std.h)</li> <li>USB_LANGID_PAN (usb_std.h)</li> <li>USB_LANGID_POL (usb_std.h)</li> <li>USB_LANGID_POR (usb_std.h)</li> <li>USB_LANGID_POR_BR (usb_std.h)</li> <li>USB_LANGID_RON (usb_std.h)</li> <li>USB_LANGID_RUS (usb_std.h)</li> <li>USB_LANGID_SAN (usb_std.h)</li> <li>USB_LANGID_SLK (usb_std.h)</li> <li>USB_LANGID_SLV (usb_std.h)</li> <li>USB_LANGID_SND (usb_std.h)</li> <li>USB_LANGID_SPA (usb_std.h)</li> <li>USB_LANGID_SPA_AR (usb_std.h)</li> <li>USB_LANGID_SPA_BO (usb_std.h)</li> <li>USB_LANGID_SPA_CL (usb_std.h)</li> <li>USB_LANGID_SPA_CO (usb_std.h)</li> <li>USB_LANGID_SPA_CR (usb_std.h)</li> <li>USB_LANGID_SPA_DO (usb_std.h)</li> <li>USB_LANGID_SPA_EC (usb_std.h)</li> <li>USB_LANGID_SPA_GT (usb_std.h)</li> <li>USB_LANGID_SPA_HN (usb_std.h)</li> <li>USB_LANGID_SPA_MDN (usb_std.h)</li> <li>USB_LANGID_SPA_MX (usb_std.h)</li> <li>USB_LANGID_SPA_NI (usb_std.h)</li> <li>USB_LANGID_SPA_PA (usb_std.h)</li> <li>USB_LANGID_SPA_PE (usb_std.h)</li> <li>USB_LANGID_SPA_PR (usb_std.h)</li> <li>USB_LANGID_SPA_PY (usb_std.h)</li> <li>USB_LANGID_SPA_SV (usb_std.h)</li> <li>USB_LANGID_SPA_UY (usb_std.h)</li> <li>USB_LANGID_SPA_VE (usb_std.h)</li> <li>USB_LANGID_SQI (usb_std.h)</li> <li>USB_LANGID_SRB_CYR (usb_std.h)</li> <li>USB_LANGID_SRB_LAT (usb_std.h)</li> <li>USB_LANGID_SWA (usb_std.h)</li> <li>USB_LANGID_SWE (usb_std.h)</li> <li>USB_LANGID_SWE_FI (usb_std.h)</li> <li>USB_LANGID_TAM (usb_std.h)</li> <li>USB_LANGID_TAT (usb_std.h)</li> <li>USB_LANGID_TEL (usb_std.h)</li> <li>USB_LANGID_THA (usb_std.h)</li> <li>USB_LANGID_TUR (usb_std.h)</li> <li>USB_LANGID_URD_IN (usb_std.h)</li> <li>USB_LANGID_URD_PK (usb_std.h)</li> <li>USB_LANGID_UZB_CYR (usb_std.h)</li> <li>USB_LANGID_UZB_LAT (usb_std.h)</li> <li>USB_LANGID_VIE (usb_std.h)</li> <li>USB_LANGID_ZHO_CN (usb_std.h)</li> <li>USB_LANGID_ZHO_HK (usb_std.h)</li> <li>USB_LANGID_ZHO_MO (usb_std.h)</li> <li>USB_LANGID_ZHO_SG (usb_std.h)</li> <li>USB_LANGID_ZHO_TW (usb_std.h)</li> <li>USB_LANGIG_UKR (usb_std.h)</li> <li>USB_PROTO_IAD (usb_std.h)</li> <li>USB_PROTO_NONE (usb_std.h)</li> <li>USB_PROTO_VENDOR (usb_std.h)</li> <li>USB_STD_CLEAR_FEATURE (usb_std.h)</li> <li>USB_STD_GET_CONFIG (usb_std.h)</li> <li>USB_STD_GET_DESCRIPTOR (usb_std.h)</li> <li>USB_STD_GET_INTERFACE (usb_std.h)</li> <li>USB_STD_GET_STATUS (usb_std.h)</li> <li>USB_STD_SET_ADDRESS (usb_std.h)</li> <li>USB_STD_SET_CONFIG (usb_std.h)</li> <li>USB_STD_SET_DESCRIPTOR (usb_std.h)</li> <li>USB_STD_SET_FEATURE (usb_std.h)</li> <li>USB_STD_SET_INTERFACE (usb_std.h)</li> <li>USB_STD_SYNCH_FRAME (usb_std.h)</li> <li>USB_STRING_DESC (usb_std.h)</li> <li>USB_SUBCLASS_IAD (usb_std.h)</li> <li>USB_SUBCLASS_NONE (usb_std.h)</li> <li>USB_SUBCLASS_VENDOR (usb_std.h)</li> <li>USB_TEST_FORCE_ENABLE (usb_std.h)</li> <li>USB_TEST_J (usb_std.h)</li> <li>USB_TEST_K (usb_std.h)</li> <li>USB_TEST_PACKET (usb_std.h)</li> <li>USB_TEST_SE0_NAK (usb_std.h)</li> <li>USBD_HW_ADDRFST (usbd_core.h)</li> <li>USBD_HW_BC (usbd_core.h)</li> <li>USBD_HW_ENABLED (usbd_core.h)</li> <li>USBD_HW_ENUMSPEED (usbd_core.h)</li> <li>USBD_HW_SPEED_FS (usbd_core.h)</li> <li>USBD_HW_SPEED_HS (usbd_core.h)</li> <li>USBD_HW_SPEED_LS (usbd_core.h)</li> <li>USBD_HW_SPEED_NC (usbd_core.h)</li> <li>USB_EPTYPE_DBLBUF (usbd_core.h)</li> <li>USB_REQ_CLASS (usbd_core.h)</li> <li>USB_REQ_DEVICE (usbd_core.h)</li> <li>USB_REQ_DEVTOHOST (usbd_core.h)</li> <li>USB_REQ_DIRECTION (usbd_core.h)</li> <li>USB_REQ_ENDPOINT (usbd_core.h)</li> <li>USB_REQ_HOSTTODEV (usbd_core.h)</li> <li>USB_REQ_INTERFACE (usbd_core.h)</li> <li>USB_REQ_OTHER (usbd_core.h)</li> <li>USB_REQ_RECIPIENT (usbd_core.h)</li> <li>USB_REQ_STANDARD (usbd_core.h)</li> <li>USB_REQ_TYPE (usbd_core.h)</li> <li>USB_REQ_VENDOR (usbd_core.h)</li> <li>USND_HW_HS (usbd_core.h)</li> <li>usbd_evt_count (usbd_core.h)</li> <li>usbd_evt_eprx (usbd_core.h)</li> <li>usbd_evt_epsetup (usbd_core.h)</li> <li>usbd_evt_eptx (usbd_core.h)</li> <li>usbd_evt_error (usbd_core.h)</li> <li>usbd_evt_reset (usbd_core.h)</li> <li>usbd_evt_sof (usbd_core.h)</li> <li>usbd_evt_susp (usbd_core.h)</li> <li>usbd_evt_wkup (usbd_core.h)</li> <li>usbd_lane_cdp (usbd_core.h)</li> <li>usbd_lane_dcp (usbd_core.h)</li> <li>usbd_lane_dsc (usbd_core.h)</li> <li>usbd_lane_sdp (usbd_core.h)</li> <li>usbd_lane_unk (usbd_core.h)</li> </ul>"},{"location":"apiStm/macros/#v","title":"v","text":"<ul> <li>vPortSVCHandler (FreeRTOSConfig.h)</li> <li>vQueueAddToRegistry (FreeRTOS.h)</li> <li>vQueueUnregisterQueue (FreeRTOS.h)</li> <li>vTaskGetTaskInfo (FreeRTOS.h)</li> <li>vMessageBufferDelete (message_buffer.h)</li> <li>vSemaphoreDelete (semphr.h)</li> <li>VERSION_BCD (usb_std.h)</li> </ul>"},{"location":"apiStm/macros/#x","title":"x","text":"<ul> <li>xPortPendSVHandler (FreeRTOSConfig.h)</li> <li>xPortSysTickHandler (FreeRTOSConfig.h)</li> <li>xCoRoutineHandle (FreeRTOS.h)</li> <li>xList (FreeRTOS.h)</li> <li>xListItem (FreeRTOS.h)</li> <li>xMemoryRegion (FreeRTOS.h)</li> <li>xQueueHandle (FreeRTOS.h)</li> <li>xQueueSetHandle (FreeRTOS.h)</li> <li>xQueueSetMemberHandle (FreeRTOS.h)</li> <li>xSemaphoreHandle (FreeRTOS.h)</li> <li>xTaskGetIdleRunTimeCounter (FreeRTOS.h)</li> <li>xTaskHandle (FreeRTOS.h)</li> <li>xTaskParameters (FreeRTOS.h)</li> <li>xTaskStatusType (FreeRTOS.h)</li> <li>xTimeOutType (FreeRTOS.h)</li> <li>xTimerHandle (FreeRTOS.h)</li> <li>xEventGroupClearBitsFromISR (event_groups.h)</li> <li>xEventGroupGetBits (event_groups.h)</li> <li>xEventGroupSetBitsFromISR (event_groups.h)</li> <li>xMessageBufferCreate (message_buffer.h)</li> <li>xMessageBufferCreateStatic (message_buffer.h)</li> <li>xMessageBufferIsEmpty (message_buffer.h)</li> <li>xMessageBufferIsFull (message_buffer.h)</li> <li>xMessageBufferNextLengthBytes (message_buffer.h)</li> <li>xMessageBufferReceive (message_buffer.h)</li> <li>xMessageBufferReceiveCompletedFromISR (message_buffer.h)</li> <li>xMessageBufferReceiveFromISR (message_buffer.h)</li> <li>xMessageBufferReset (message_buffer.h)</li> <li>xMessageBufferSend (message_buffer.h)</li> <li>xMessageBufferSendCompletedFromISR (message_buffer.h)</li> <li>xMessageBufferSendFromISR (message_buffer.h)</li> <li>xMessageBufferSpaceAvailable (message_buffer.h)</li> <li>xMessageBufferSpacesAvailable (message_buffer.h)</li> <li>xQueueOverwrite (queue.h)</li> <li>xQueueOverwriteFromISR (queue.h)</li> <li>xQueueReset (queue.h)</li> <li>xQueueSend (queue.h)</li> <li>xQueueSendFromISR (queue.h)</li> <li>xQueueSendToBack (queue.h)</li> <li>xQueueSendToBackFromISR (queue.h)</li> <li>xQueueSendToFront (queue.h)</li> <li>xQueueSendToFrontFromISR (queue.h)</li> <li>xSemaphoreGetMutexHolder (semphr.h)</li> <li>xSemaphoreGetMutexHolderFromISR (semphr.h)</li> <li>xSemaphoreGive (semphr.h)</li> <li>xSemaphoreGiveFromISR (semphr.h)</li> <li>xSemaphoreTake (semphr.h)</li> <li>xSemaphoreTakeFromISR (semphr.h)</li> <li>xStreamBufferCreate (stream_buffer.h)</li> <li>xStreamBufferCreateStatic (stream_buffer.h)</li> <li>xTaskNotify (task.h)</li> <li>xTaskNotifyAndQuery (task.h)</li> <li>xTaskNotifyAndQueryFromISR (task.h)</li> <li>xTaskNotifyFromISR (task.h)</li> <li>xTaskNotifyGive (task.h)</li> <li>xTimerChangePeriod (timers.h)</li> <li>xTimerChangePeriodFromISR (timers.h)</li> <li>xTimerDelete (timers.h)</li> <li>xTimerReset (timers.h)</li> <li>xTimerResetFromISR (timers.h)</li> <li>xTimerStart (timers.h)</li> <li>xTimerStartFromISR (timers.h)</li> <li>xTimerStop (timers.h)</li> <li>xTimerStopFromISR (timers.h)</li> </ul>"},{"location":"apiStm/macros/#_","title":"_","text":"<ul> <li>_BCL (stm32.h)</li> <li>_BMD (stm32.h)</li> <li>_BST (stm32.h)</li> <li>_BV (stm32.h)</li> <li>_WBC (stm32.h)</li> <li>_WBS (stm32.h)</li> <li>_WVL (stm32.h)</li> <li>__CAT (usb_std.h)</li> <li>_MIN (usbd_core.c)</li> </ul>"},{"location":"apiStm/variables/","title":"Variables","text":""},{"location":"apiStm/variables/#a","title":"a","text":"<ul> <li>ADC_channel_t (Bsp.hpp)</li> <li>ADC_rank_t (Bsp.hpp)</li> <li>auxiliaryAdc (Bsp.hpp)</li> <li>auxiliaryAndMotorAdcIRQn (Bsp.hpp)</li> <li>auxiliaryAndMotorAdcIrqPrio (Bsp.hpp)</li> </ul>"},{"location":"apiStm/variables/#b","title":"b","text":"<ul> <li>batteryMiddleVoltageAdcChannel (Bsp.hpp)</li> <li>batteryMiddleVoltageAdcRank (Bsp.hpp)</li> <li>batteryMiddleVoltagePin (Bsp.hpp)</li> <li>batteryVoltageAdcChannel (Bsp.hpp)</li> <li>batteryVoltageAdcRank (Bsp.hpp)</li> <li>batteryVoltagePin (Bsp.hpp)</li> <li>button1Pin (Bsp.hpp)</li> <li>button2Pin (Bsp.hpp)</li> <li>button3Pin (Bsp.hpp)</li> <li>button4Pin (Bsp.hpp)</li> <li>buttonOffPin (Bsp.hpp)</li> <li>buttonOnPin (Bsp.hpp)</li> <li>buttonPin (Bsp.hpp)</li> <li>buzzerPin (Bsp.hpp)</li> <li>BlockLink_t (heap_4.c)</li> <li>BaseType_t (portmacro.h)</li> <li>bCharFormat (usb_cdc.h)</li> <li>bDataBits (usb_cdc.h)</li> <li>bDataInterface (usb_cdc.h)</li> <li>bDescriptorSubType (usb_cdc.h)</li> <li>bDescriptorType (usb_cdc.h, usb_std.h)</li> <li>bFunctionLength (usb_cdc.h)</li> <li>bMasterInterface0 (usb_cdc.h)</li> <li>bNotificationType (usb_cdc.h)</li> <li>bParityType (usb_cdc.h)</li> <li>bSlaveInterface0 (usb_cdc.h)</li> <li>bcdCDC (usb_cdc.h)</li> <li>bmCapabilities (usb_cdc.h)</li> <li>bmRequestType (usb_cdc.h)</li> <li>bAlternateSetting (usb_std.h)</li> <li>bConfigurationValue (usb_std.h)</li> <li>bDebugInEndpoint (usb_std.h)</li> <li>bDebugOutEndpoint (usb_std.h)</li> <li>bDeviceClass (usb_std.h)</li> <li>bDeviceProtocol (usb_std.h)</li> <li>bDeviceSubClass (usb_std.h)</li> <li>bEndpointAddress (usb_std.h)</li> <li>bFirstInterface (usb_std.h)</li> <li>bFunctionClass (usb_std.h)</li> <li>bFunctionProtocol (usb_std.h)</li> <li>bFunctionSubClass (usb_std.h)</li> <li>bInterfaceClass (usb_std.h)</li> <li>bInterfaceCount (usb_std.h)</li> <li>bInterfaceNumber (usb_std.h)</li> <li>bInterfaceProtocol (usb_std.h)</li> <li>bInterfaceSubClass (usb_std.h)</li> <li>bInterval (usb_std.h)</li> <li>bLength (usb_std.h)</li> <li>bMaxPacketSize0 (usb_std.h)</li> <li>bMaxPower (usb_std.h)</li> <li>bNumConfigurations (usb_std.h)</li> <li>bNumEndpoints (usb_std.h)</li> <li>bNumInterfaces (usb_std.h)</li> <li>bReserved (usb_std.h)</li> <li>bcdDevice (usb_std.h)</li> <li>bcdUSB (usb_std.h)</li> <li>bmAttributes (usb_std.h)</li> <li>buttonState (ButtonController.cpp)</li> </ul>"},{"location":"apiStm/variables/#c","title":"c","text":"<ul> <li>controlUart (Bsp.hpp)</li> <li>controlUartRxDmaChannel (Bsp.hpp)</li> <li>controlUartRxPin (Bsp.hpp)</li> <li>controlUartTxDmaChannel (Bsp.hpp)</li> <li>controlUartTxDmaIRQn (Bsp.hpp)</li> <li>controlUartTxDmaIRQnPrio (Bsp.hpp)</li> <li>controlUartTxPin (Bsp.hpp)</li> <li>CRCB_t (croutine.h)</li> <li>CoRoutineHandle_t (croutine.h)</li> <li>crCOROUTINE_CODE (croutine.h)</li> <li>codec (ControlLink.cpp)</li> <li>compressCoef (MpuController.cpp)</li> <li>calib (Power.cpp)</li> <li>calibrationDataMagic (Power.cpp)</li> <li>calibrationDefaults (Power.cpp)</li> <li>cdc_iface_desc_en (UsbCdcDescriptors.c, UsbCdcLink.cpp)</li> <li>cdc_line_debug (UsbCdcLink.cpp)</li> <li>cdc_line_tunnel (UsbCdcLink.cpp)</li> <li>config (UsbCdcLink.cpp)</li> <li>config_desc (UsbCdcLink.cpp)</li> </ul>"},{"location":"apiStm/variables/#d","title":"d","text":"<ul> <li>DMA_channel_t (Bsp.hpp)</li> <li>debugUart (Bsp.hpp)</li> <li>debugUartIRQn (Bsp.hpp)</li> <li>debugUartIrqPrio (Bsp.hpp)</li> <li>debugUartRxDmaChannel (Bsp.hpp)</li> <li>debugUartRxPin (Bsp.hpp)</li> <li>debugUartTxDmaChannel (Bsp.hpp)</li> <li>debugUartTxDmaIRQn (Bsp.hpp)</li> <li>debugUartTxDmaIrqPrio (Bsp.hpp)</li> <li>debugUartTxPin (Bsp.hpp)</li> <li>Data (usb_cdc.h)</li> <li>dwDTERate (usb_cdc.h)</li> <li>debugStateChanges (ButtonController.cpp)</li> <li>dmaRxHandle (CdcUartTunnel.cpp, ControlLink.cpp, DebugLink.cpp)</li> <li>dmaTxHandle (CdcUartTunnel.cpp, ControlLink.cpp, DebugLink.cpp)</li> <li>dispatchStatPeriodMs (Power.cpp)</li> <li>dispatchStatTimer (Power.cpp)</li> <li>debug_iface_desc_en (UsbCdcDescriptors.c, UsbCdcLink.cpp)</li> <li>DebugDescriptorsSize (UsbCdcLink.cpp)</li> <li>device_desc (UsbCdcLink.cpp)</li> <li>dtable (UsbCdcLink.cpp)</li> </ul>"},{"location":"apiStm/variables/#e","title":"e","text":"<ul> <li>encoder1aPin (Bsp.hpp)</li> <li>encoder1bPin (Bsp.hpp)</li> <li>encoder2aPin (Bsp.hpp)</li> <li>encoder2bPin (Bsp.hpp)</li> <li>encoder3aPin (Bsp.hpp)</li> <li>encoder3bPin (Bsp.hpp)</li> <li>encoder4aPin (Bsp.hpp)</li> <li>encoder4bPin (Bsp.hpp)</li> <li>encoderTimer (Bsp.hpp)</li> <li>esp0Pin (Bsp.hpp)</li> <li>esp12Pin (Bsp.hpp)</li> <li>esp15Pin (Bsp.hpp)</li> <li>esp2Pin (Bsp.hpp)</li> <li>espEnPin (Bsp.hpp)</li> <li>EventBits_t (event_groups.h)</li> <li>EventGroupHandle_t (event_groups.h)</li> <li>eNotifyAction (task.h)</li> <li>eSleepModeStatus (task.h)</li> <li>eTaskState (task.h)</li> <li>EventGroup_t (event_groups.c)</li> <li>Esp32WatchdogTimeoutMs (Esp32Manager.cpp)</li> <li>encoderFilter (MotorController.cpp)</li> <li>echoRestoreTimeoutMs (UltrasoundController.cpp)</li> <li>enableDebugEp (UsbCdcLink.cpp)</li> </ul>"},{"location":"apiStm/variables/#f","title":"f","text":"<ul> <li>Font_11x18 (OledController_fonts.hpp, OledController_fonts.cpp)</li> <li>Font_16x26 (OledController_fonts.hpp, OledController_fonts.cpp)</li> <li>Font_6x8 (OledController_fonts.hpp, OledController_fonts.cpp)</li> <li>Font_7x10 (OledController_fonts.hpp, OledController_fonts.cpp)</li> <li>FLASH_PAGE_POWER_CALIBRATION (Flash.hpp)</li> <li>Font11x18 (OledController_fonts.cpp)</li> <li>Font16x26 (OledController_fonts.cpp)</li> <li>Font6x8 (OledController_fonts.cpp)</li> <li>Font7x10 (OledController_fonts.cpp)</li> </ul>"},{"location":"apiStm/variables/#g","title":"g","text":"<ul> <li>gBuff (SmartServoController.cpp)</li> <li>gBuffIndex (SmartServoController.cpp)</li> <li>gBuffSize (SmartServoController.cpp)</li> <li>gExpectResponse (SmartServoController.cpp)</li> <li>gResponseReady (SmartServoController.cpp)</li> <li>gResponseTimeout (SmartServoController.cpp)</li> <li>gState (SmartServoController.cpp)</li> <li>gStateTimeout (SmartServoController.cpp)</li> </ul>"},{"location":"apiStm/variables/#h","title":"h","text":"<ul> <li>HeapRegion_t (portable.h)</li> <li>HeapStats_t (portable.h)</li> </ul>"},{"location":"apiStm/variables/#i","title":"i","text":"<ul> <li>i2cErIRQn (Bsp.hpp)</li> <li>i2cEvIRQn (Bsp.hpp)</li> <li>i2cIRQnPrio (Bsp.hpp)</li> <li>i2cPrio (Bsp.hpp)</li> <li>i2cScl (Bsp.hpp)</li> <li>i2cSda (Bsp.hpp)</li> <li>in4aPin (Bsp.hpp)</li> <li>in4bPin (Bsp.hpp)</li> <li>internalReferenceVoltageAdcRank (Bsp.hpp)</li> <li>I2cEvents (I2cController.hpp)</li> <li>i2cEventGroup (I2cController.hpp, I2cController.cpp)</li> <li>i2cTaskHandle (I2cController.hpp, I2cController.cpp)</li> <li>iCountryCodeRelDate (usb_cdc.h)</li> <li>iConfiguration (usb_std.h)</li> <li>iFunction (usb_std.h)</li> <li>iInterface (usb_std.h)</li> <li>iManufacturer (usb_std.h)</li> <li>iProduct (usb_std.h)</li> <li>iSerialNumber (usb_std.h)</li> <li>idProduct (usb_std.h)</li> <li>idVendor (usb_std.h)</li> <li>idleTaskStack (FreeRTOSCallbacks.cpp)</li> <li>idleTaskStruct (FreeRTOSCallbacks.cpp)</li> <li>I2Cdev_hi2c (I2cController.cpp)</li> <li>I2Cdev_readTimeout (I2cController.cpp)</li> <li>i2cCallingTask (I2cController.cpp)</li> <li>i2cEventBuffer (I2cController.cpp)</li> <li>i2cMutex (I2cController.cpp)</li> <li>i2cQueue (I2cController.cpp)</li> <li>i2cTask (I2cController.cpp)</li> </ul>"},{"location":"apiStm/variables/#l","title":"l","text":"<ul> <li>led1Pin (Bsp.hpp)</li> <li>led2Pin (Bsp.hpp)</li> <li>led3Pin (Bsp.hpp)</li> <li>led4Pin (Bsp.hpp)</li> <li>ledPin (Bsp.hpp)</li> <li>ledPins (Bsp.hpp)</li> <li>ListItem_t (list.h)</li> <li>List_t (list.h)</li> <li>lang_desc (UsbCdcDescriptors.c, UsbCdcLink.cpp)</li> </ul>"},{"location":"apiStm/variables/#m","title":"m","text":"<ul> <li>mainTaskPrio (Bsp.hpp)</li> <li>motorTaskPrio (Bsp.hpp)</li> <li>motorLoopFreq (Motor.hpp)</li> <li>MPU6050_t (Mpu6050.hpp)</li> <li>mpu_t (MpuController.hpp)</li> <li>MiniListItem_t (list.h)</li> <li>MessageBufferHandle_t (message_buffer.h)</li> <li>MemoryRegion_t (task.h)</li> <li>MaxLineLength (DebugLink.cpp)</li> <li>maxPwm (MotorController.cpp)</li> <li>motor (MotorController.cpp)</li> <li>motorMut (MotorController.cpp)</li> <li>motorTask (MotorController.cpp)</li> <li>MpuMotion32 (MpuController.cpp)</li> <li>MpuMotion6 (MpuController.cpp)</li> <li>MpuVector (MpuController.cpp)</li> <li>MpuVector32 (MpuController.cpp)</li> <li>mpu6050 (MpuController.cpp)</li> <li>mpuAggrCounter (MpuController.cpp)</li> <li>mpuAggrData (MpuController.cpp)</li> <li>mpuTickPeriodMs (MpuController.cpp)</li> <li>mpuTimerBuffer (MpuController.cpp)</li> <li>mpuTimerHandle (MpuController.cpp)</li> <li>manuf_desc_en (UsbCdcDescriptors.c, UsbCdcLink.cpp)</li> <li>mainTask (main.cpp)</li> </ul>"},{"location":"apiStm/variables/#o","title":"o","text":"<ul> <li>OLED_COLOR (OledController.hpp)</li> <li>OLED_Error_t (OledController.hpp)</li> <li>OLED (OledController.cpp)</li> <li>OLED_Buffer (OledController.cpp)</li> <li>oled_height (OledController.cpp)</li> <li>oled_width (OledController.cpp)</li> </ul>"},{"location":"apiStm/variables/#p","title":"p","text":"<ul> <li>PinDef (Bsp.hpp)</li> <li>powerPin (Bsp.hpp)</li> <li>pwm1aPin (Bsp.hpp)</li> <li>pwm1bPin (Bsp.hpp)</li> <li>pwm2aPin (Bsp.hpp)</li> <li>pwm2bPin (Bsp.hpp)</li> <li>pwm3aPin (Bsp.hpp)</li> <li>pwm3bPin (Bsp.hpp)</li> <li>pwm4Pin (Bsp.hpp)</li> <li>pwmTimer (Bsp.hpp)</li> <li>POWER_CALIBRATE_DEFAULT (Power.hpp)</li> <li>POWER_CALIBRATE_NO_CHANGE (Power.hpp)</li> <li>PendedFunction_t (timers.h)</li> <li>pxEnd (heap_4.c)</li> <li>pxCurrentTCB (tasks.c)</li> <li>pxDelayedTaskList (tasks.c)</li> <li>pxOverflowDelayedTaskList (tasks.c)</li> <li>pxReadyTasksLists (tasks.c)</li> <li>powerOffAt (ButtonController.cpp)</li> <li>pwmCenterValue (StupidServoController.cpp)</li> <li>pwmCoef (StupidServoController.cpp)</li> <li>pingTimeoutMs (UltrasoundController.cpp)</li> <li>prod_desc_en (UsbCdcDescriptors.c, UsbCdcLink.cpp)</li> </ul>"},{"location":"apiStm/variables/#q","title":"q","text":"<ul> <li>QueueHandle_t (queue.h)</li> <li>QueueSetHandle_t (queue.h)</li> <li>QueueSetMemberHandle_t (queue.h)</li> <li>QueuePointers_t (queue.c)</li> <li>Queue_t (queue.c)</li> </ul>"},{"location":"apiStm/variables/#r","title":"r","text":"<ul> <li>rxFifo (CdcUartTunnel.cpp, ControlLink.cpp)</li> <li>rxLineBuffer (DebugLink.cpp)</li> <li>requestQueue (Dispatcher.cpp)</li> <li>rawBattery (Power.cpp)</li> <li>rawInternalRef (Power.cpp)</li> <li>rawMidBattery (Power.cpp)</li> <li>rawTemperature (Power.cpp)</li> <li>risingMicros (UltrasoundController.cpp)</li> </ul>"},{"location":"apiStm/variables/#s","title":"s","text":"<ul> <li>servo1Pin (Bsp.hpp)</li> <li>servo2Pin (Bsp.hpp)</li> <li>servo3Pin (Bsp.hpp)</li> <li>servo4Pin (Bsp.hpp)</li> <li>servoPins (Bsp.hpp)</li> <li>servoTimer (Bsp.hpp)</li> <li>servoUart (Bsp.hpp)</li> <li>servoUartIRQn (Bsp.hpp)</li> <li>servoUartIrqPrio (Bsp.hpp)</li> <li>servoUartTxRxPin (Bsp.hpp)</li> <li>softResetTaskPrio (Bsp.hpp)</li> <li>sEsp32Manager (Esp32Manager.hpp, Esp32Manager.cpp)</li> <li>StaticEventGroup_t (FreeRTOS.h)</li> <li>StaticListItem_t (FreeRTOS.h)</li> <li>StaticList_t (FreeRTOS.h)</li> <li>StaticMessageBuffer_t (FreeRTOS.h)</li> <li>StaticMiniListItem_t (FreeRTOS.h)</li> <li>StaticQueue_t (FreeRTOS.h)</li> <li>StaticSemaphore_t (FreeRTOS.h)</li> <li>StaticStreamBuffer_t (FreeRTOS.h)</li> <li>StaticTask_t (FreeRTOS.h)</li> <li>StaticTimer_t (FreeRTOS.h)</li> <li>SemaphoreHandle_t (semphr.h)</li> <li>StreamBufferHandle_t (stream_buffer.h)</li> <li>StackType_t (portmacro.h)</li> <li>SemaphoreData_t (queue.c)</li> <li>StreamBuffer_t (stream_buffer.c)</li> <li>softResetTask (Bsp.cpp)</li> <li>statusQueue (Dispatcher.cpp)</li> <li>SmartServoState (SmartServoController.cpp)</li> <li>status (UltrasoundController.cpp)</li> <li>serial_number_desc_en (UsbCdcDescriptors.c, UsbCdcLink.cpp)</li> </ul>"},{"location":"apiStm/variables/#t","title":"t","text":"<ul> <li>temperatureAdcRank (Bsp.hpp)</li> <li>tunnelUart (Bsp.hpp)</li> <li>tunnelUartRxDmaChannel (Bsp.hpp)</li> <li>tunnelUartRxPin (Bsp.hpp)</li> <li>tunnelUartTxDmaChannel (Bsp.hpp)</li> <li>tunnelUartTxPin (Bsp.hpp)</li> <li>TaskFunction_t (projdefs.h)</li> <li>TaskHandle_t (task.h)</li> <li>TaskHookFunction_t (task.h)</li> <li>TaskParameters_t (task.h)</li> <li>TaskStatus_t (task.h)</li> <li>TimeOut_t (task.h)</li> <li>TimerCallbackFunction_t (timers.h)</li> <li>TimerHandle_t (timers.h)</li> <li>TickType_t (portmacro.h)</li> <li>TCB_t (tasks.c)</li> <li>tskTCB (tasks.c)</li> <li>txBuf (CdcUartTunnel.cpp)</li> <li>txDmaBuf (ControlLink.cpp, DebugLink.cpp)</li> <li>txEncodeBuf (ControlLink.cpp)</li> <li>txMessageBuf (ControlLink.cpp)</li> <li>txUartStreamBuf (DebugLink.cpp)</li> <li>ThresholdNoBatteryMv (Power.cpp)</li> <li>ThresholdPowerOffMv (Power.cpp)</li> <li>tempAvgSlope (Power.cpp)</li> <li>trigQueue (UltrasoundController.cpp)</li> <li>tunnel_cdc_acm (UsbCdcLink.cpp)</li> <li>tunnel_cdc_hdr (UsbCdcLink.cpp)</li> <li>tunnel_cdc_mgmt (UsbCdcLink.cpp)</li> <li>tunnel_cdc_union (UsbCdcLink.cpp)</li> <li>tunnel_comm (UsbCdcLink.cpp)</li> <li>tunnel_comm_ep (UsbCdcLink.cpp)</li> <li>tunnel_comm_iad (UsbCdcLink.cpp)</li> <li>tunnel_data (UsbCdcLink.cpp)</li> <li>tunnel_data_eprx (UsbCdcLink.cpp)</li> <li>tunnel_data_eptx (UsbCdcLink.cpp)</li> </ul>"},{"location":"apiStm/variables/#u","title":"u","text":"<ul> <li>ultrasoundTaskPrio (Bsp.hpp)</li> <li>usbBusDetectionPin (Bsp.hpp)</li> <li>usbDnPin (Bsp.hpp)</li> <li>usbDpPin (Bsp.hpp)</li> <li>usbDpPullUpPin (Bsp.hpp)</li> <li>usbLpIRQn (Bsp.hpp)</li> <li>usbLpIRQnPrio (Bsp.hpp)</li> <li>userUart (Bsp.hpp)</li> <li>userUartRxPin (Bsp.hpp)</li> <li>userUartTxPin (Bsp.hpp)</li> <li>uts1EchoPin (Bsp.hpp)</li> <li>uts1TrigPin (Bsp.hpp)</li> <li>uts2EchoPin (Bsp.hpp)</li> <li>uts2TrigPin (Bsp.hpp)</li> <li>uts3EchoPin (Bsp.hpp)</li> <li>uts3TrigPin (Bsp.hpp)</li> <li>uts4EchoPin (Bsp.hpp)</li> <li>uts4TrigPin (Bsp.hpp)</li> <li>utsEchoPin (Bsp.hpp)</li> <li>utsIRQPrio (Bsp.hpp)</li> <li>utsTimer (Bsp.hpp)</li> <li>utsTrigPin (Bsp.hpp)</li> <li>udev (UsbCdcLink.h, UsbCdcLink.cpp)</li> <li>ucHeap (heap_4.c)</li> <li>UBaseType_t (portmacro.h)</li> <li>uxCurrentNumberOfTasks (tasks.c)</li> <li>uxSchedulerSuspended (tasks.c)</li> <li>uxTaskNumber (tasks.c)</li> <li>uxTopReadyPriority (tasks.c)</li> <li>usbd_cfg_callback (usbd_core.h)</li> <li>usbd_ctl_callback (usbd_core.h)</li> <li>usbd_ctl_state (usbd_core.h)</li> <li>usbd_device (usbd_core.h)</li> <li>usbd_dsc_callback (usbd_core.h)</li> <li>usbd_evt_callback (usbd_core.h)</li> <li>usbd_hw_connect (usbd_core.h)</li> <li>usbd_hw_enable (usbd_core.h)</li> <li>usbd_hw_ep_config (usbd_core.h)</li> <li>usbd_hw_ep_deconfig (usbd_core.h)</li> <li>usbd_hw_ep_isstalled (usbd_core.h)</li> <li>usbd_hw_ep_read (usbd_core.h)</li> <li>usbd_hw_ep_setstall (usbd_core.h)</li> <li>usbd_hw_ep_write (usbd_core.h)</li> <li>usbd_hw_get_frameno (usbd_core.h)</li> <li>usbd_hw_get_serialno (usbd_core.h)</li> <li>usbd_hw_getinfo (usbd_core.h)</li> <li>usbd_hw_poll (usbd_core.h)</li> <li>usbd_hw_setaddr (usbd_core.h)</li> <li>usbd_machine_state (usbd_core.h)</li> <li>usbd_respond (usbd_core.h)</li> <li>usbd_rqc_callback (usbd_core.h)</li> <li>usbIrqPrioRaise (CdcUartTunnel.cpp, DebugLink.cpp)</li> <li>uartRxFifo (DebugLink.cpp)</li> <li>usbFrameBuf (DebugLink.cpp)</li> <li>usbRxFifo (DebugLink.cpp)</li> <li>usbTxFifo (DebugLink.cpp)</li> <li>undervoltageCounter (Power.cpp)</li> <li>undervoltageShutdownThreshold (Power.cpp)</li> <li>undervoltageWarningOn (Power.cpp)</li> <li>utsActiveIndex (UltrasoundController.cpp)</li> <li>utsTask (UltrasoundController.cpp)</li> <li>ubuf (UsbCdcLink.cpp)</li> </ul>"},{"location":"apiStm/variables/#v","title":"v","text":"<ul> <li>vrefMv (Power.cpp)</li> </ul>"},{"location":"apiStm/variables/#w","title":"w","text":"<ul> <li>wCountyCode0 (usb_cdc.h)</li> <li>wIndex (usb_cdc.h)</li> <li>wLength (usb_cdc.h)</li> <li>wValue (usb_cdc.h)</li> <li>wMaxPacketSize (usb_std.h)</li> <li>wString (usb_std.h)</li> <li>wTotalLength (usb_std.h)</li> </ul>"},{"location":"apiStm/variables/#x","title":"x","text":"<ul> <li>xBlockAllocatedBit (heap_4.c)</li> <li>xFreeBytesRemaining (heap_4.c)</li> <li>xHeapStructSize (heap_4.c)</li> <li>xMinimumEverFreeBytesRemaining (heap_4.c)</li> <li>xNumberOfSuccessfulAllocations (heap_4.c)</li> <li>xNumberOfSuccessfulFrees (heap_4.c)</li> <li>xStart (heap_4.c)</li> <li>xQUEUE (queue.c)</li> <li>xDelayedTaskList1 (tasks.c)</li> <li>xDelayedTaskList2 (tasks.c)</li> <li>xIdleTaskHandle (tasks.c)</li> <li>xNextTaskUnblockTime (tasks.c)</li> <li>xNumOfOverflows (tasks.c)</li> <li>xPendedTicks (tasks.c)</li> <li>xPendingReadyList (tasks.c)</li> <li>xSchedulerRunning (tasks.c)</li> <li>xTickCount (tasks.c)</li> <li>xYieldPending (tasks.c)</li> </ul>"},{"location":"apiStm/variables/#_","title":"_","text":"<ul> <li>_usbd_respond (usbd_core.h)</li> </ul>"},{"location":"apiStm/variables/#_1","title":"@","text":"<ul> <li>@2 (UsbCdcLink.cpp)</li> <li>@3 (UsbCdcLink.cpp)</li> </ul>"},{"location":"apiStm/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules<ul> <li>EventGroup</li> <li>EventGroupHandle_t</li> <li>xEventGroupClearBits</li> <li>xEventGroupClearBitsFromISR</li> <li>xEventGroupCreate</li> <li>xEventGroupGetBits</li> <li>xEventGroupGetBitsFromISR</li> <li>xEventGroupSetBits</li> <li>xEventGroupSetBitsFromISR</li> <li>xEventGroupSync</li> <li>xEventGroupWaitBits</li> <li>TaskHandle_t</li> <li>USB Device HW driver and core API</li> <li>USB device core</li> <li>USB hardware driver</li> <li>USB CDC class</li> <li>USB Standard</li> <li>USB standard LANGID codes</li> <li>crDELAY</li> <li>crQUEUE_RECEIVE</li> <li>crQUEUE_RECEIVE_FROM_ISR</li> <li>crQUEUE_SEND</li> <li>crQUEUE_SEND_FROM_ISR</li> <li>crSTART</li> <li>pcTaskGetHandle</li> <li>pcTaskGetName</li> <li>taskDISABLE_INTERRUPTS</li> <li>taskENABLE_INTERRUPTS</li> <li>taskENTER_CRITICAL</li> <li>taskEXIT_CRITICAL</li> <li>taskYIELD</li> <li>ulTaskGetIdleRunTimeCounter</li> <li>ulTaskNotifyTake</li> <li>ulTaskNotifyValueClear</li> <li>uxQueueMessagesWaiting</li> <li>uxTaskGetNumberOfTasks</li> <li>uxTaskPriorityGet</li> <li>vCoRoutineSchedule</li> <li>vQueueDelete</li> <li>vSemaphoreCreateBinary</li> <li>vSemaphoreDelete</li> <li>vStreamBufferDelete</li> <li>vTaskDelay</li> <li>vTaskDelayUntil</li> <li>vTaskDelete</li> <li>vTaskEndScheduler</li> <li>vTaskGetInfo</li> <li>vTaskGetRunTimeStats</li> <li>vTaskList</li> <li>vTaskPrioritySet</li> <li>vTaskResume</li> <li>vTaskResumeFromISR</li> <li>vTaskSetTimeOutState</li> <li>vTaskStartScheduler</li> <li>vTaskSuspend</li> <li>vTaskSuspendAll</li> <li>xCoRoutineCreate</li> <li>xMessageBufferCreate</li> <li>xMessageBufferCreateStatic</li> <li>xMessageBufferNextLengthBytes</li> <li>xMessageBufferReceive</li> <li>xMessageBufferReceiveCompletedFromISR</li> <li>xMessageBufferReceiveFromISR</li> <li>xMessageBufferReset</li> <li>xMessageBufferSend</li> <li>xMessageBufferSendCompletedFromISR</li> <li>xMessageBufferSendFromISR</li> <li>xMessageBufferSpaceAvailable</li> <li>xQueueCreate</li> <li>xQueueCreateStatic</li> <li>xQueueOverwrite</li> <li>xQueueOverwriteFromISR</li> <li>xQueuePeek</li> <li>xQueuePeekFromISR</li> <li>xQueueReceive</li> <li>xQueueReceiveFromISR</li> <li>xQueueSend</li> <li>xQueueSendFromISR</li> <li>xSemaphoreCreateBinary</li> <li>xSemaphoreCreateBinaryStatic</li> <li>xSemaphoreCreateCounting</li> <li>xSemaphoreCreateCountingStatic</li> <li>xSemaphoreCreateMutex</li> <li>xSemaphoreCreateMutexStatic</li> <li>xSemaphoreCreateRecursiveMutex</li> <li>xSemaphoreCreateRecursiveMutexStatic</li> <li>xSemaphoreGive</li> <li>xSemaphoreGiveFromISR</li> <li>xSemaphoreGiveRecursive</li> <li>xSemaphoreTake</li> <li>xSemaphoreTakeRecursive</li> <li>xStreamBufferBytesAvailable</li> <li>xStreamBufferCreate</li> <li>xStreamBufferCreateStatic</li> <li>xStreamBufferIsEmpty</li> <li>xStreamBufferIsFull</li> <li>xStreamBufferReceive</li> <li>xStreamBufferReceiveCompletedFromISR</li> <li>xStreamBufferReceiveFromISR</li> <li>xStreamBufferReset</li> <li>xStreamBufferSend</li> <li>xStreamBufferSendCompletedFromISR</li> <li>xStreamBufferSendFromISR</li> <li>xStreamBufferSetTriggerLevel</li> <li>xStreamBufferSpacesAvailable</li> <li>xTaskAbortDelay</li> <li>xTaskCheckForTimeOut</li> <li>xTaskCreate</li> <li>xTaskCreateRestricted</li> <li>xTaskCreateRestrictedStatic</li> <li>xTaskCreateStatic</li> <li>xTaskGetTickCount</li> <li>xTaskGetTickCountFromISR</li> <li>xTaskNotify</li> <li>xTaskNotifyGive</li> <li>xTaskNotifyStateClear</li> <li>xTaskNotifyWait</li> <li>xTaskResumeAll</li> </ul> </li> <li>Class List<ul> <li>struct A_BLOCK_LINK</li> <li>class BasePriorityRaiser</li> <li>class ByteFifo</li> <li>struct CalibrationData</li> <li>class Esp32Manager</li> <li>struct EventGroupDef_t</li> <li>struct FontDef</li> <li>struct HeapRegion</li> <li>struct MPU6050_t</li> <li>class MessageBufferWrapper</li> <li>class Motor</li> <li>struct MpuMotion32</li> <li>struct MpuMotion6</li> <li>struct MpuVector</li> <li>struct MpuVector32</li> <li>class MutexWrapper</li> <li>struct OLED_VERTEX</li> <li>struct OLED_t</li> <li>struct QueueDefinition</li> <li>struct QueuePointers</li> <li>class QueueWrapper</li> <li>struct Regulator</li> <li>struct SemaphoreData</li> <li>struct StreamBufferDef_t</li> <li>class StreamBufferWrapper</li> <li>class TaskWrapper</li> <li>class TickTimer</li> <li>class XorShift</li> <li>struct __debug_descriptors</li> <li>struct _usbd_device</li> <li>struct cdc_config</li> <li>struct corCoRoutineControlBlock</li> <li>struct mpu_t</li> <li>struct tskTaskControlBlock</li> <li>struct usb_cdc_acm_desc</li> <li>struct usb_cdc_call_mgmt_desc</li> <li>struct usb_cdc_country_desc</li> <li>struct usb_cdc_header_desc</li> <li>struct usb_cdc_line_coding</li> <li>struct usb_cdc_notification</li> <li>struct usb_cdc_union_desc</li> <li>struct usb_config_descriptor</li> <li>struct usb_debug_descriptor</li> <li>struct usb_device_descriptor</li> <li>struct usb_endpoint_descriptor</li> <li>struct usb_header_descriptor</li> <li>struct usb_iad_descriptor</li> <li>struct usb_interface_descriptor</li> <li>struct usb_qualifier_descriptor</li> <li>struct usb_string_descriptor</li> <li>struct usbd_ctlreq</li> <li>struct usbd_driver</li> <li>struct usbd_status</li> <li>struct xHeapStats</li> <li>struct xLIST</li> <li>struct xLIST_ITEM</li> <li>struct xMEMORY_REGION</li> <li>struct xMINI_LIST_ITEM</li> <li>struct xSTATIC_EVENT_GROUP</li> <li>struct xSTATIC_LIST</li> <li>struct xSTATIC_LIST_ITEM</li> <li>struct xSTATIC_MINI_LIST_ITEM</li> <li>struct xSTATIC_QUEUE</li> <li>struct xSTATIC_STREAM_BUFFER</li> <li>struct xSTATIC_TCB</li> <li>struct xSTATIC_TIMER</li> <li>struct xTASK_PARAMETERS</li> <li>struct xTASK_STATUS</li> <li>struct xTIME_OUT</li> </ul> </li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files<ul> <li>fw</li> <li>fw/rbcx-coprocessor<ul> <li>.clang-format</li> <li>.clang-format source</li> <li>fw/rbcx-coprocessor/include</li> <li>Bsp.hpp</li> <li>Bsp.hpp source</li> <li>ButtonController.hpp</li> <li>ButtonController.hpp source</li> <li>BuzzerController.hpp</li> <li>BuzzerController.hpp source</li> <li>CdcUartTunnel.hpp</li> <li>CdcUartTunnel.hpp source</li> <li>ControlLink.hpp</li> <li>ControlLink.hpp source</li> <li>DebugLink.hpp</li> <li>DebugLink.hpp source</li> <li>Dispatcher.hpp</li> <li>Dispatcher.hpp source</li> <li>Esp32Manager.hpp</li> <li>Esp32Manager.hpp source</li> <li>FreeRTOSConfig.h</li> <li>FreeRTOSConfig.h source</li> <li>I2cController.hpp</li> <li>I2cController.hpp source</li> <li>Motor.hpp</li> <li>Motor.hpp source</li> <li>MotorController.hpp</li> <li>MotorController.hpp source</li> <li>Mpu6050.hpp</li> <li>Mpu6050.hpp source</li> <li>MpuController.hpp</li> <li>MpuController.hpp source</li> <li>OledController.hpp</li> <li>OledController.hpp source</li> <li>OledController_fonts.hpp</li> <li>OledController_fonts.hpp source</li> <li>Power.hpp</li> <li>Power.hpp source</li> <li>SmartServoController.hpp</li> <li>SmartServoController.hpp source</li> <li>StupidServoController.hpp</li> <li>StupidServoController.hpp source</li> <li>UltrasoundController.hpp</li> <li>UltrasoundController.hpp source</li> <li>UsbCdcLink.h</li> <li>UsbCdcLink.h source</li> <li>fw/rbcx-coprocessor/include/utils<ul> <li>BasePriorityRaiser.hpp</li> <li>BasePriorityRaiser.hpp source</li> <li>ByteFifo.hpp</li> <li>ByteFifo.hpp source</li> <li>Debug.hpp</li> <li>Debug.hpp source</li> <li>Flash.hpp</li> <li>Flash.hpp source</li> <li>HalDma.hpp</li> <li>HalDma.hpp source</li> <li>MessageBufferWrapper.hpp</li> <li>MessageBufferWrapper.hpp source</li> <li>MutexWrapper.hpp</li> <li>MutexWrapper.hpp source</li> <li>QueueWrapper.hpp</li> <li>QueueWrapper.hpp source</li> <li>Regulator.hpp</li> <li>Regulator.hpp source</li> <li>StreamBufferWrapper.hpp</li> <li>StreamBufferWrapper.hpp source</li> <li>TaskWrapper.hpp</li> <li>TaskWrapper.hpp source</li> <li>TickTimer.hpp</li> <li>TickTimer.hpp source</li> <li>XorShift.hpp</li> <li>XorShift.hpp source</li> </ul> </li> <li>fw/rbcx-coprocessor/lib</li> <li>fw/rbcx-coprocessor/lib/FreeRTOS<ul> <li>fw/rbcx-coprocessor/lib/FreeRTOS/include</li> <li>FreeRTOS.h</li> <li>FreeRTOS.h source</li> <li>atomic.h</li> <li>atomic.h source</li> <li>croutine.h</li> <li>croutine.h source</li> <li>deprecated_definitions.h</li> <li>deprecated_definitions.h source</li> <li>event_groups.h</li> <li>event_groups.h source</li> <li>list.h</li> <li>list.h source</li> <li>message_buffer.h</li> <li>message_buffer.h source</li> <li>mpu_prototypes.h</li> <li>mpu_prototypes.h source</li> <li>mpu_wrappers.h</li> <li>mpu_wrappers.h source</li> <li>portable.h</li> <li>portable.h source</li> <li>projdefs.h</li> <li>projdefs.h source</li> <li>queue.h</li> <li>queue.h source</li> <li>semphr.h</li> <li>semphr.h source</li> <li>stack_macros.h</li> <li>stack_macros.h source</li> <li>stream_buffer.h</li> <li>stream_buffer.h source</li> <li>task.h</li> <li>task.h source</li> <li>timers.h</li> <li>timers.h source</li> <li>fw/rbcx-coprocessor/lib/FreeRTOS/src</li> <li>croutine.c</li> <li>croutine.c source</li> <li>event_groups.c</li> <li>event_groups.c source</li> <li>heap_4.c</li> <li>heap_4.c source</li> <li>list.c</li> <li>list.c source</li> <li>mpu_wrappers.c</li> <li>mpu_wrappers.c source</li> <li>port.c</li> <li>port.c source</li> <li>portmacro.h</li> <li>portmacro.h source</li> <li>queue.c</li> <li>queue.c source</li> <li>stream_buffer.c</li> <li>stream_buffer.c source</li> <li>tasks.c</li> <li>tasks.c source</li> <li>timers.c</li> <li>timers.c source</li> </ul> </li> <li>fw/rbcx-coprocessor/lib/libusb_stm32<ul> <li>fw/rbcx-coprocessor/lib/libusb_stm32/include</li> <li>stm32.h</li> <li>stm32.h source</li> <li>usb.h</li> <li>usb.h source</li> <li>usb_cdc.h</li> <li>usb_cdc.h source</li> <li>usb_std.h</li> <li>usb_std.h source</li> <li>usbd_core.h</li> <li>usbd_core.h source</li> <li>fw/rbcx-coprocessor/lib/libusb_stm32/src</li> <li>usbd_core.c</li> <li>usbd_core.c source</li> <li>usbd_stm32f103_devfs.c</li> <li>usbd_stm32f103_devfs.c source</li> </ul> </li> <li>fw/rbcx-coprocessor/src</li> <li>Bsp.cpp</li> <li>Bsp.cpp source</li> <li>ButtonController.cpp</li> <li>ButtonController.cpp source</li> <li>CdcUartTunnel.cpp</li> <li>CdcUartTunnel.cpp source</li> <li>ControlLink.cpp</li> <li>ControlLink.cpp source</li> <li>DebugLink.cpp</li> <li>DebugLink.cpp source</li> <li>Dispatcher.cpp</li> <li>Dispatcher.cpp source</li> <li>Esp32Manager.cpp</li> <li>Esp32Manager.cpp source</li> <li>FreeRTOSCallbacks.cpp</li> <li>FreeRTOSCallbacks.cpp source</li> <li>I2cController.cpp</li> <li>I2cController.cpp source</li> <li>MotorController.cpp</li> <li>MotorController.cpp source</li> <li>MpuController.cpp</li> <li>MpuController.cpp source</li> <li>OledController.cpp</li> <li>OledController.cpp source</li> <li>OledController_fonts.cpp</li> <li>OledController_fonts.cpp source</li> <li>Power.cpp</li> <li>Power.cpp source</li> <li>SmartServoController.cpp</li> <li>SmartServoController.cpp source</li> <li>StupidServoController.cpp</li> <li>StupidServoController.cpp source</li> <li>UltrasoundController.cpp</li> <li>UltrasoundController.cpp source</li> <li>UsbCdcDescriptors.c</li> <li>UsbCdcDescriptors.c source</li> <li>UsbCdcLink.cpp</li> <li>UsbCdcLink.cpp source</li> <li>fw/rbcx-coprocessor/src/utils<ul> <li>Debug.cpp</li> <li>Debug.cpp source</li> </ul> </li> <li>main.cpp</li> <li>main.cpp source</li> </ul> </li> </ul> </li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"apiEsp32/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p>"},{"location":"apiEsp32/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p>"},{"location":"apiEsp32/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"apiEsp32/classes/","title":"Class Index","text":""},{"location":"apiEsp32/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p>"},{"location":"apiEsp32/modules/","title":"Modules","text":"<p>Here is a list of all modules:</p>"},{"location":"apiEsp32/pages/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p>"},{"location":"apiEsp32/class_members/","title":"Class Members","text":""},{"location":"apiEsp32/class_member_functions/","title":"Class Member Functions","text":""},{"location":"apiEsp32/class_member_variables/","title":"Class Member Variables","text":""},{"location":"apiEsp32/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"apiEsp32/class_member_enums/","title":"Class Member Enums","text":""},{"location":"apiEsp32/namespace_members/","title":"Namespace Members","text":""},{"location":"apiEsp32/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"apiEsp32/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"apiEsp32/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"apiEsp32/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"apiEsp32/functions/","title":"Functions","text":""},{"location":"apiEsp32/macros/","title":"Macros","text":""},{"location":"apiEsp32/variables/","title":"Variables","text":""},{"location":"apiEsp32/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}