
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Documentation for the RBCX robot controller board designed by the RoboticsBrno team. It is based on the STM32F446RE microcontroller and ESP32 microcontroller. Features: 4 motors with encoders, 4 servos, buttons with the gamepad, LEDs, ultra-sonic sensor, ...">
      
      
        <meta name="author" content="RoboticsBrno">
      
      
        <link rel="canonical" href="https://rbcx.robotikabrno.cz/apiStm/tasks_8c_source/">
      
      
      
      <link rel="icon" href="../../assets/logo.png">
      <meta name="generator" content="mkdocs-1.4.3, mkdocs-material-9.1.15">
    
    
      
        <title>File tasks.c - RB3204-RBCX</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.26e3688c.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.ecc896b0.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
        html.glightbox-open { overflow: initial; height: 100%; }
        .gslide-title { margin-top: 0px; user-select: text; }
        .gslide-desc { color: #666; user-select: text; }
        .gslide-image img { background: white; }
        
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}
            </style> <script src="../../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="green" data-md-color-accent="green">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#file-tasksc" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="RB3204-RBCX" class="md-header__button md-logo" aria-label="RB3204-RBCX" data-md-component="logo">
      
  <img src="../../assets/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            RB3204-RBCX
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              File tasks.c
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
          
            
            
            
            <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="green" data-md-color-accent="green"  aria-hidden="true"  type="radio" name="__palette" id="__palette_1">
            
          
        </form>
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/RoboticsBrno/RB3204-RBCX" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    RoboticsBrno/RB3204-RBCX
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  


  <li class="md-tabs__item">
    <a href="../.." class="md-tabs__link">
      Home
    </a>
  </li>

      
        
  
  


  <li class="md-tabs__item">
    <a href="../../SW-development/" class="md-tabs__link">
      Software development
    </a>
  </li>

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../api/" class="md-tabs__link">
        API Reference
      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="RB3204-RBCX" class="md-nav__button md-logo" aria-label="RB3204-RBCX" data-md-component="logo">
      
  <img src="../../assets/logo.png" alt="logo">

    </a>
    RB3204-RBCX
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/RoboticsBrno/RB3204-RBCX" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    RoboticsBrno/RB3204-RBCX
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../SW-development/" class="md-nav__link">
        Software development
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
      
      
        
          
            
          
        
          
        
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../../api/">API Reference</a>
          
            <label for="__nav_3">
              <span class="md-nav__icon md-icon"></span>
            </label>
          
        </div>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          API Reference
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2" >
      
      
        
          
            
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../">API STM Coprocessor</a>
          
            <label for="__nav_3_2">
              <span class="md-nav__icon md-icon"></span>
            </label>
          
        </div>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_2_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_2">
          <span class="md-nav__icon md-icon"></span>
          API STM Coprocessor
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../links/" class="md-nav__link">
        Links
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2_3" >
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_3_2_3" id="__nav_3_2_3_label" tabindex="0">
          Classes
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_2_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_2_3">
          <span class="md-nav__icon md-icon"></span>
          Classes
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../annotated/" class="md-nav__link">
        Class List
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../classes/" class="md-nav__link">
        Class Index
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../hierarchy/" class="md-nav__link">
        Class Hierarchy
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../class_members/" class="md-nav__link">
        Class Members
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../class_member_functions/" class="md-nav__link">
        Class Member Functions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../class_member_variables/" class="md-nav__link">
        Class Member Variables
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../class_member_typedefs/" class="md-nav__link">
        Class Member Typedefs
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../class_member_enums/" class="md-nav__link">
        Class Member Enumerations
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2_4" >
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_3_2_4" id="__nav_3_2_4_label" tabindex="0">
          Namespaces
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_2_4_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_2_4">
          <span class="md-nav__icon md-icon"></span>
          Namespaces
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../namespaces/" class="md-nav__link">
        Namespace List
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../namespace_members/" class="md-nav__link">
        Namespace Members
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../namespace_member_functions/" class="md-nav__link">
        Namespace Member Functions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../namespace_member_variables/" class="md-nav__link">
        Namespace Member Variables
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../namespace_member_typedefs/" class="md-nav__link">
        Namespace Member Typedefs
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../namespace_member_enums/" class="md-nav__link">
        Namespace Member Enumerations
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../functions/" class="md-nav__link">
        Functions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../variables/" class="md-nav__link">
        Variables
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../macros/" class="md-nav__link">
        Macros
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../files/" class="md-nav__link">
        Files
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3" >
      
      
        
          
            
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../../apiEsp32/">API ESP32 library</a>
          
            <label for="__nav_3_3">
              <span class="md-nav__icon md-icon"></span>
            </label>
          
        </div>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_3">
          <span class="md-nav__icon md-icon"></span>
          API ESP32 library
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/links/" class="md-nav__link">
        Links
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3_3" >
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_3_3_3" id="__nav_3_3_3_label" tabindex="0">
          Classes
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_3_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_3_3">
          <span class="md-nav__icon md-icon"></span>
          Classes
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/annotated/" class="md-nav__link">
        Class List
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/classes/" class="md-nav__link">
        Class Index
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/hierarchy/" class="md-nav__link">
        Class Hierarchy
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/class_members/" class="md-nav__link">
        Class Members
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/class_member_functions/" class="md-nav__link">
        Class Member Functions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/class_member_variables/" class="md-nav__link">
        Class Member Variables
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/class_member_typedefs/" class="md-nav__link">
        Class Member Typedefs
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/class_member_enums/" class="md-nav__link">
        Class Member Enumerations
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3_4" >
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_3_3_4" id="__nav_3_3_4_label" tabindex="0">
          Namespaces
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_3_4_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_3_4">
          <span class="md-nav__icon md-icon"></span>
          Namespaces
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/namespaces/" class="md-nav__link">
        Namespace List
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/namespace_members/" class="md-nav__link">
        Namespace Members
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/namespace_member_functions/" class="md-nav__link">
        Namespace Member Functions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/namespace_member_variables/" class="md-nav__link">
        Namespace Member Variables
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/namespace_member_typedefs/" class="md-nav__link">
        Namespace Member Typedefs
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/namespace_member_enums/" class="md-nav__link">
        Namespace Member Enumerations
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/functions/" class="md-nav__link">
        Functions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/variables/" class="md-nav__link">
        Variables
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/macros/" class="md-nav__link">
        Macros
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/files/" class="md-nav__link">
        Files
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="file-tasksc">File tasks.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_6728f3a9088eeb382ccd8bff3a2a4804/"><strong>FreeRTOS</strong></a> <strong>&gt;</strong> <a href="../dir_3e946fa640f7764a34038834221bbde8/"><strong>src</strong></a> <strong>&gt;</strong> <a href="../tasks_8c/"><strong>tasks.c</strong></a></p>
<p><a href="../tasks_8c/">Go to the documentation of this file.</a> </p>
<div class="highlight"><pre><span></span><code><span class="cm">/*</span>
<span class="cm"> * FreeRTOS Kernel V10.3.1</span>
<span class="cm"> * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining a copy of</span>
<span class="cm"> * this software and associated documentation files (the &quot;Software&quot;), to deal in</span>
<span class="cm"> * the Software without restriction, including without limitation the rights to</span>
<span class="cm"> * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of</span>
<span class="cm"> * the Software, and to permit persons to whom the Software is furnished to do so,</span>
<span class="cm"> * subject to the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice shall be included in all</span>
<span class="cm"> * copies or substantial portions of the Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="cm"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS</span>
<span class="cm"> * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR</span>
<span class="cm"> * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER</span>
<span class="cm"> * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<span class="cm"> * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="cm"> *</span>
<span class="cm"> * http://www.FreeRTOS.org</span>
<span class="cm"> * http://aws.amazon.com/freertos</span>
<span class="cm"> *</span>
<span class="cm"> * 1 tab == 4 spaces!</span>
<span class="cm"> */</span>

<span class="cm">/* Standard includes. */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>

<span class="cm">/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining</span>
<span class="cm">all the API functions to use the MPU wrappers.  That should only be done when</span>
<span class="cm">task.h is included from an application file. */</span>
<span class="cp">#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE</span>

<span class="cm">/* FreeRTOS includes. */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;FreeRTOS.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;task.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;timers.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;stack_macros.h&quot;</span>

<span class="cm">/* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified</span>
<span class="cm">because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined</span>
<span class="cm">for the header files above, but not in this file, in order to generate the</span>
<span class="cm">correct privileged Vs unprivileged linkage and placement. */</span>
<span class="cp">#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE </span><span class="cm">/*lint !e961 !e750 !e9021. */</span>

<span class="cm">/* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting</span>
<span class="cm">functions but without including stdio.h here. */</span>
<span class="cp">#if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )</span>
<span class="w">    </span><span class="cm">/* At the bottom of this file are two optional functions that can be used</span>
<span class="cm">    to generate human readable text from the raw data generated by the</span>
<span class="cm">    uxTaskGetSystemState() function.  Note the formatting functions are provided</span>
<span class="cm">    for convenience only, and are NOT considered part of the kernel. */</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#endif </span><span class="cm">/* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */</span>

<span class="cp">#if( configUSE_PREEMPTION == 0 )</span>
<span class="w">    </span><span class="cm">/* If the cooperative scheduler is being used then a yield should not be</span>
<span class="cm">    performed just because a higher priority task has been woken. */</span>
<span class="w">    </span><span class="cp">#define taskYIELD_IF_USING_PREEMPTION()</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="cp">#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()</span>
<span class="cp">#endif</span>

<span class="cm">/* Values that can be assigned to the ucNotifyState member of the TCB. */</span>
<span class="cp">#define taskNOT_WAITING_NOTIFICATION    ( ( uint8_t ) 0 )</span>
<span class="cp">#define taskWAITING_NOTIFICATION        ( ( uint8_t ) 1 )</span>
<span class="cp">#define taskNOTIFICATION_RECEIVED       ( ( uint8_t ) 2 )</span>

<span class="cm">/*</span>
<span class="cm"> * The value used to fill the stack of a task when the task is created.  This</span>
<span class="cm"> * is used purely for checking the high water mark for tasks.</span>
<span class="cm"> */</span>
<span class="cp">#define tskSTACK_FILL_BYTE  ( 0xa5U )</span>

<span class="cm">/* Bits used to recored how a task&#39;s stack and TCB were allocated. */</span>
<span class="cp">#define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB      ( ( uint8_t ) 0 )</span>
<span class="cp">#define tskSTATICALLY_ALLOCATED_STACK_ONLY          ( ( uint8_t ) 1 )</span>
<span class="cp">#define tskSTATICALLY_ALLOCATED_STACK_AND_TCB       ( ( uint8_t ) 2 )</span>

<span class="cm">/* If any of the following are set then task stacks are filled with a known</span>
<span class="cm">value so the high water mark can be determined.  If none of the following are</span>
<span class="cm">set then don&#39;t fill the stack so there is no unnecessary dependency on memset. */</span>
<span class="cp">#if( ( configCHECK_FOR_STACK_OVERFLOW &gt; 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )</span>
<span class="w">    </span><span class="cp">#define tskSET_NEW_STACKS_TO_KNOWN_VALUE    1</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="cp">#define tskSET_NEW_STACKS_TO_KNOWN_VALUE    0</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Macros used by vListTask to indicate which state a task is in.</span>
<span class="cm"> */</span>
<span class="cp">#define tskRUNNING_CHAR     ( &#39;X&#39; )</span>
<span class="cp">#define tskBLOCKED_CHAR     ( &#39;B&#39; )</span>
<span class="cp">#define tskREADY_CHAR       ( &#39;R&#39; )</span>
<span class="cp">#define tskDELETED_CHAR     ( &#39;D&#39; )</span>
<span class="cp">#define tskSUSPENDED_CHAR   ( &#39;S&#39; )</span>

<span class="cm">/*</span>
<span class="cm"> * Some kernel aware debuggers require the data the debugger needs access to be</span>
<span class="cm"> * global, rather than file scope.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef portREMOVE_STATIC_QUALIFIER</span>
<span class="w">    </span><span class="cp">#define static</span>
<span class="cp">#endif</span>

<span class="cm">/* The name allocated to the Idle task.  This can be overridden by defining</span>
<span class="cm">configIDLE_TASK_NAME in FreeRTOSConfig.h. */</span>
<span class="cp">#ifndef configIDLE_TASK_NAME</span>
<span class="w">    </span><span class="cp">#define configIDLE_TASK_NAME &quot;IDLE&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )</span>

<span class="w">    </span><span class="cm">/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is</span>
<span class="cm">    performed in a generic way that is not optimised to any particular</span>
<span class="cm">    microcontroller architecture. */</span>

<span class="w">    </span><span class="cm">/* uxTopReadyPriority holds the priority of the highest priority ready</span>
<span class="cm">    state task. */</span>
<span class="w">    </span><span class="cp">#define taskRECORD_READY_PRIORITY( uxPriority )                                                     \</span>
<span class="cp">    {                                                                                                   \</span>
<span class="cp">        if( ( uxPriority ) &gt; uxTopReadyPriority )                                                       \</span>
<span class="cp">        {                                                                                               \</span>
<span class="cp">            uxTopReadyPriority = ( uxPriority );                                                        \</span>
<span class="cp">        }                                                                                               \</span>
<span class="cp">    } </span><span class="cm">/* taskRECORD_READY_PRIORITY */</span>

<span class="w">    </span><span class="cm">/*-----------------------------------------------------------*/</span>

<span class="w">    </span><span class="cp">#define taskSELECT_HIGHEST_PRIORITY_TASK()                                                          \</span>
<span class="cp">    {                                                                                                   \</span>
<span class="cp">    UBaseType_t uxTopPriority = uxTopReadyPriority;                                                     \</span>
<span class="cp">                                                                                                        \</span>
<span class="cp">        </span><span class="cm">/* Find the highest priority queue that contains ready tasks. */</span><span class="cp">                                \</span>
<span class="cp">        while( listLIST_IS_EMPTY( &amp;( pxReadyTasksLists[ uxTopPriority ] ) ) )                           \</span>
<span class="cp">        {                                                                                               \</span>
<span class="cp">            configASSERT( uxTopPriority );                                                              \</span>
<span class="cp">            --uxTopPriority;                                                                            \</span>
<span class="cp">        }                                                                                               \</span>
<span class="cp">                                                                                                        \</span>
<span class="cp">        </span><span class="cm">/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of                        \</span>
<span class="cm">        the same priority get an equal share of the processor time. */</span><span class="cp">                                  \</span>
<span class="cp">        listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &amp;( pxReadyTasksLists[ uxTopPriority ] ) );           \</span>
<span class="cp">        uxTopReadyPriority = uxTopPriority;                                                             \</span>
<span class="cp">    } </span><span class="cm">/* taskSELECT_HIGHEST_PRIORITY_TASK */</span>

<span class="w">    </span><span class="cm">/*-----------------------------------------------------------*/</span>

<span class="w">    </span><span class="cm">/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as</span>
<span class="cm">    they are only required when a port optimised method of task selection is</span>
<span class="cm">    being used. */</span>
<span class="w">    </span><span class="cp">#define taskRESET_READY_PRIORITY( uxPriority )</span>
<span class="w">    </span><span class="cp">#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )</span>

<span class="cp">#else </span><span class="cm">/* configUSE_PORT_OPTIMISED_TASK_SELECTION */</span>

<span class="w">    </span><span class="cm">/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is</span>
<span class="cm">    performed in a way that is tailored to the particular microcontroller</span>
<span class="cm">    architecture being used. */</span>

<span class="w">    </span><span class="cm">/* A port optimised version is provided.  Call the port defined macros. */</span>
<span class="w">    </span><span class="cp">#define taskRECORD_READY_PRIORITY( uxPriority ) portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )</span>

<span class="w">    </span><span class="cm">/*-----------------------------------------------------------*/</span>

<span class="w">    </span><span class="cp">#define taskSELECT_HIGHEST_PRIORITY_TASK()                                                      \</span>
<span class="cp">    {                                                                                               \</span>
<span class="cp">    UBaseType_t uxTopPriority;                                                                      \</span>
<span class="cp">                                                                                                    \</span>
<span class="cp">        </span><span class="cm">/* Find the highest priority list that contains ready tasks. */</span><span class="cp">                             \</span>
<span class="cp">        portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );                              \</span>
<span class="cp">        configASSERT( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ uxTopPriority ] ) ) &gt; 0 );     \</span>
<span class="cp">        listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &amp;( pxReadyTasksLists[ uxTopPriority ] ) );       \</span>
<span class="cp">    } </span><span class="cm">/* taskSELECT_HIGHEST_PRIORITY_TASK() */</span>

<span class="w">    </span><span class="cm">/*-----------------------------------------------------------*/</span>

<span class="w">    </span><span class="cm">/* A port optimised version is provided, call it only if the TCB being reset</span>
<span class="cm">    is being referenced from a ready list.  If it is referenced from a delayed</span>
<span class="cm">    or suspended list then it won&#39;t be in a ready list. */</span>
<span class="w">    </span><span class="cp">#define taskRESET_READY_PRIORITY( uxPriority )                                                      \</span>
<span class="cp">    {                                                                                                   \</span>
<span class="cp">        if( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )  \</span>
<span class="cp">        {                                                                                               \</span>
<span class="cp">            portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );                         \</span>
<span class="cp">        }                                                                                               \</span>
<span class="cp">    }</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_PORT_OPTIMISED_TASK_SELECTION */</span>

<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cm">/* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick</span>
<span class="cm">count overflows. */</span>
<span class="cp">#define taskSWITCH_DELAYED_LISTS()                                                                  \</span>
<span class="cp">{                                                                                                   \</span>
<span class="cp">    List_t *pxTemp;                                                                                 \</span>
<span class="cp">                                                                                                    \</span>
<span class="cp">    </span><span class="cm">/* The delayed tasks list should be empty when the lists are switched. */</span><span class="cp">                       \</span>
<span class="cp">    configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );                                     \</span>
<span class="cp">                                                                                                    \</span>
<span class="cp">    pxTemp = pxDelayedTaskList;                                                                     \</span>
<span class="cp">    pxDelayedTaskList = pxOverflowDelayedTaskList;                                                  \</span>
<span class="cp">    pxOverflowDelayedTaskList = pxTemp;                                                             \</span>
<span class="cp">    xNumOfOverflows++;                                                                              \</span>
<span class="cp">    prvResetNextTaskUnblockTime();                                                                  \</span>
<span class="cp">}</span>

<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * Place the task represented by pxTCB into the appropriate ready list for</span>
<span class="cm"> * the task.  It is inserted at the end of the list.</span>
<span class="cm"> */</span>
<span class="cp">#define prvAddTaskToReadyList( pxTCB )                                                              \</span>
<span class="cp">    traceMOVED_TASK_TO_READY_STATE( pxTCB );                                                        \</span>
<span class="cp">    taskRECORD_READY_PRIORITY( ( pxTCB )-&gt;uxPriority );                                             \</span>
<span class="cp">    vListInsertEnd( &amp;( pxReadyTasksLists[ ( pxTCB )-&gt;uxPriority ] ), &amp;( ( pxTCB )-&gt;xStateListItem ) ); \</span>
<span class="cp">    tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * Several functions take an TaskHandle_t parameter that can optionally be NULL,</span>
<span class="cm"> * where NULL is used to indicate that the handle of the currently executing</span>
<span class="cm"> * task should be used in place of the parameter.  This macro simply checks to</span>
<span class="cm"> * see if the parameter is NULL and returns a pointer to the appropriate TCB.</span>
<span class="cm"> */</span>
<span class="cp">#define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )</span>

<span class="cm">/* The item value of the event list item is normally used to hold the priority</span>
<span class="cm">of the task to which it belongs (coded to allow it to be held in reverse</span>
<span class="cm">priority order).  However, it is occasionally borrowed for other purposes.  It</span>
<span class="cm">is important its value is not updated due to a task priority change while it is</span>
<span class="cm">being used for another purpose.  The following bit definition is used to inform</span>
<span class="cm">the scheduler that the value should not be changed - in which case it is the</span>
<span class="cm">responsibility of whichever module is using the value to ensure it gets set back</span>
<span class="cm">to its original value when it is released. */</span>
<span class="cp">#if( configUSE_16_BIT_TICKS == 1 )</span>
<span class="w">    </span><span class="cp">#define taskEVENT_LIST_ITEM_VALUE_IN_USE    0x8000U</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="cp">#define taskEVENT_LIST_ITEM_VALUE_IN_USE    0x80000000UL</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Task control block.  A task control block (TCB) is allocated for each task,</span>
<span class="cm"> * and stores task state information, including a pointer to the task&#39;s context</span>
<span class="cm"> * (the task&#39;s run time environment, including register values)</span>
<span class="cm"> */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">tskTaskControlBlock</span><span class="w">          </span><span class="cm">/* The old naming convention is used to prevent breaking kernel aware debuggers. */</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="n">StackType_t</span><span class="w">    </span><span class="o">*</span><span class="n">pxTopOfStack</span><span class="p">;</span><span class="w">  </span><span class="cm">/*&lt; Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */</span>

<span class="w">    </span><span class="cp">#if ( portUSING_MPU_WRAPPERS == 1 )</span>
<span class="w">        </span><span class="n">xMPU_SETTINGS</span><span class="w">   </span><span class="n">xMPUSettings</span><span class="p">;</span><span class="w">       </span><span class="cm">/*&lt; The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="w">    </span><span class="n">ListItem_t</span><span class="w">          </span><span class="n">xStateListItem</span><span class="p">;</span><span class="w"> </span><span class="cm">/*&lt; The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */</span>
<span class="w">    </span><span class="n">ListItem_t</span><span class="w">          </span><span class="n">xEventListItem</span><span class="p">;</span><span class="w">     </span><span class="cm">/*&lt; Used to reference a task from an event list. */</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w">         </span><span class="n">uxPriority</span><span class="p">;</span><span class="w">         </span><span class="cm">/*&lt; The priority of the task.  0 is the lowest priority. */</span>
<span class="w">    </span><span class="n">StackType_t</span><span class="w">         </span><span class="o">*</span><span class="n">pxStack</span><span class="p">;</span><span class="w">           </span><span class="cm">/*&lt; Points to the start of the stack. */</span>
<span class="w">    </span><span class="kt">char</span><span class="w">                </span><span class="n">pcTaskName</span><span class="p">[</span><span class="w"> </span><span class="n">configMAX_TASK_NAME_LEN</span><span class="w"> </span><span class="p">];</span><span class="cm">/*&lt; Descriptive name given to the task when created.  Facilitates debugging only. */</span><span class="w"> </span><span class="cm">/*lint !e971 Unqualified char types are allowed for strings and single characters only. */</span>

<span class="w">    </span><span class="cp">#if ( ( portSTACK_GROWTH &gt; 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )</span>
<span class="w">        </span><span class="n">StackType_t</span><span class="w">     </span><span class="o">*</span><span class="n">pxEndOfStack</span><span class="p">;</span><span class="w">      </span><span class="cm">/*&lt; Points to the highest valid address for the stack. */</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="w">    </span><span class="cp">#if ( portCRITICAL_NESTING_IN_TCB == 1 )</span>
<span class="w">        </span><span class="n">UBaseType_t</span><span class="w">     </span><span class="n">uxCriticalNesting</span><span class="p">;</span><span class="w">  </span><span class="cm">/*&lt; Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="w">    </span><span class="cp">#if ( configUSE_TRACE_FACILITY == 1 )</span>
<span class="w">        </span><span class="n">UBaseType_t</span><span class="w">     </span><span class="n">uxTCBNumber</span><span class="p">;</span><span class="w">        </span><span class="cm">/*&lt; Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */</span>
<span class="w">        </span><span class="n">UBaseType_t</span><span class="w">     </span><span class="n">uxTaskNumber</span><span class="p">;</span><span class="w">       </span><span class="cm">/*&lt; Stores a number specifically for use by third party trace code. */</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="w">    </span><span class="cp">#if ( configUSE_MUTEXES == 1 )</span>
<span class="w">        </span><span class="n">UBaseType_t</span><span class="w">     </span><span class="n">uxBasePriority</span><span class="p">;</span><span class="w">     </span><span class="cm">/*&lt; The priority last assigned to the task - used by the priority inheritance mechanism. */</span>
<span class="w">        </span><span class="n">UBaseType_t</span><span class="w">     </span><span class="n">uxMutexesHeld</span><span class="p">;</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="w">    </span><span class="cp">#if ( configUSE_APPLICATION_TASK_TAG == 1 )</span>
<span class="w">        </span><span class="n">TaskHookFunction_t</span><span class="w"> </span><span class="n">pxTaskTag</span><span class="p">;</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="w">    </span><span class="cp">#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 )</span>
<span class="w">        </span><span class="kt">void</span><span class="w">            </span><span class="o">*</span><span class="n">pvThreadLocalStoragePointers</span><span class="p">[</span><span class="w"> </span><span class="n">configNUM_THREAD_LOCAL_STORAGE_POINTERS</span><span class="w"> </span><span class="p">];</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="w">    </span><span class="cp">#if( configGENERATE_RUN_TIME_STATS == 1 )</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w">        </span><span class="n">ulRunTimeCounter</span><span class="p">;</span><span class="w">   </span><span class="cm">/*&lt; Stores the amount of time the task has spent in the Running state. */</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="w">    </span><span class="cp">#if ( configUSE_NEWLIB_REENTRANT == 1 )</span>
<span class="w">        </span><span class="cm">/* Allocate a Newlib reent structure that is specific to this task.</span>
<span class="cm">        Note Newlib support has been included by popular demand, but is not</span>
<span class="cm">        used by the FreeRTOS maintainers themselves.  FreeRTOS is not</span>
<span class="cm">        responsible for resulting newlib operation.  User must be familiar with</span>
<span class="cm">        newlib and must provide system-wide implementations of the necessary</span>
<span class="cm">        stubs. Be warned that (at the time of writing) the current newlib design</span>
<span class="cm">        implements a system-wide malloc() that must be provided with locks.</span>

<span class="cm">        See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html</span>
<span class="cm">        for additional information. */</span>
<span class="w">        </span><span class="k">struct</span><span class="w">  </span><span class="nc">_reent</span><span class="w"> </span><span class="n">xNewLib_reent</span><span class="p">;</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="w">    </span><span class="cp">#if( configUSE_TASK_NOTIFICATIONS == 1 )</span>
<span class="w">        </span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ulNotifiedValue</span><span class="p">;</span>
<span class="w">        </span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ucNotifyState</span><span class="p">;</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="w">    </span><span class="cm">/* See the comments in FreeRTOS.h with the definition of</span>
<span class="cm">    tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */</span>
<span class="w">    </span><span class="cp">#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) </span><span class="cm">/*lint !e731 !e9029 Macro has been consolidated for readability reasons. */</span>
<span class="w">        </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ucStaticallyAllocated</span><span class="p">;</span><span class="w">      </span><span class="cm">/*&lt; Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="w">    </span><span class="cp">#if( INCLUDE_xTaskAbortDelay == 1 )</span>
<span class="w">        </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ucDelayAborted</span><span class="p">;</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="w">    </span><span class="cp">#if( configUSE_POSIX_ERRNO == 1 )</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">iTaskErrno</span><span class="p">;</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="p">}</span><span class="w"> </span><span class="n">tskTCB</span><span class="p">;</span>

<span class="cm">/* The old tskTCB name is maintained above then typedefed to the new TCB_t name</span>
<span class="cm">below to enable the use of older kernel aware debuggers. */</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">tskTCB</span><span class="w"> </span><span class="n">TCB_t</span><span class="p">;</span>

<span class="cm">/*lint -save -e956 A manual analysis and inspection has been used to determine</span>
<span class="cm">which static variables must be declared volatile. */</span>
<span class="n">PRIVILEGED_DATA</span><span class="w"> </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="cm">/* Lists for ready and blocked tasks. --------------------</span>
<span class="cm">xDelayedTaskList1 and xDelayedTaskList2 could be move to function scople but</span>
<span class="cm">doing so breaks some kernel aware debuggers and debuggers that rely on removing</span>
<span class="cm">the static qualifier. */</span>
<span class="n">PRIVILEGED_DATA</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">List_t</span><span class="w"> </span><span class="n">pxReadyTasksLists</span><span class="p">[</span><span class="w"> </span><span class="n">configMAX_PRIORITIES</span><span class="w"> </span><span class="p">];</span><span class="cm">/*&lt; Prioritised ready tasks. */</span>
<span class="n">PRIVILEGED_DATA</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">List_t</span><span class="w"> </span><span class="n">xDelayedTaskList1</span><span class="p">;</span><span class="w">                        </span><span class="cm">/*&lt; Delayed tasks. */</span>
<span class="n">PRIVILEGED_DATA</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">List_t</span><span class="w"> </span><span class="n">xDelayedTaskList2</span><span class="p">;</span><span class="w">                        </span><span class="cm">/*&lt; Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */</span>
<span class="n">PRIVILEGED_DATA</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">List_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">pxDelayedTaskList</span><span class="p">;</span><span class="w">             </span><span class="cm">/*&lt; Points to the delayed task list currently being used. */</span>
<span class="n">PRIVILEGED_DATA</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">List_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">pxOverflowDelayedTaskList</span><span class="p">;</span><span class="w">     </span><span class="cm">/*&lt; Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */</span>
<span class="n">PRIVILEGED_DATA</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">List_t</span><span class="w"> </span><span class="n">xPendingReadyList</span><span class="p">;</span><span class="w">                        </span><span class="cm">/*&lt; Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */</span>

<span class="cp">#if( INCLUDE_vTaskDelete == 1 )</span>

<span class="w">    </span><span class="n">PRIVILEGED_DATA</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">List_t</span><span class="w"> </span><span class="n">xTasksWaitingTermination</span><span class="p">;</span><span class="w">             </span><span class="cm">/*&lt; Tasks that have been deleted - but their memory not yet freed. */</span>
<span class="w">    </span><span class="n">PRIVILEGED_DATA</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxDeletedTasksWaitingCleanUp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0U</span><span class="p">;</span>

<span class="cp">#endif</span>

<span class="cp">#if ( INCLUDE_vTaskSuspend == 1 )</span>

<span class="w">    </span><span class="n">PRIVILEGED_DATA</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">List_t</span><span class="w"> </span><span class="n">xSuspendedTaskList</span><span class="p">;</span><span class="w">                   </span><span class="cm">/*&lt; Tasks that are currently suspended. */</span>

<span class="cp">#endif</span>

<span class="cm">/* Global POSIX errno. Its value is changed upon context switching to match</span>
<span class="cm">the errno of the currently running task. */</span>
<span class="cp">#if ( configUSE_POSIX_ERRNO == 1 )</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">FreeRTOS_errno</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/* Other file private variables. --------------------------------*/</span>
<span class="n">PRIVILEGED_DATA</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxCurrentNumberOfTasks</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0U</span><span class="p">;</span>
<span class="n">PRIVILEGED_DATA</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xTickCount</span><span class="w">               </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">configINITIAL_TICK_COUNT</span><span class="p">;</span>
<span class="n">PRIVILEGED_DATA</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxTopReadyPriority</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">tskIDLE_PRIORITY</span><span class="p">;</span>
<span class="n">PRIVILEGED_DATA</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xSchedulerRunning</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="n">PRIVILEGED_DATA</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xPendedTicks</span><span class="w">             </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0U</span><span class="p">;</span>
<span class="n">PRIVILEGED_DATA</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xYieldPending</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="n">PRIVILEGED_DATA</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xNumOfOverflows</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">PRIVILEGED_DATA</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxTaskNumber</span><span class="w">                     </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0U</span><span class="p">;</span>
<span class="n">PRIVILEGED_DATA</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xNextTaskUnblockTime</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0U</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Initialised to portMAX_DELAY before the scheduler starts. */</span>
<span class="n">PRIVILEGED_DATA</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xIdleTaskHandle</span><span class="w">                 </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w">         </span><span class="cm">/*&lt; Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */</span>

<span class="cm">/* Context switches are held pending while the scheduler is suspended.  Also,</span>
<span class="cm">interrupts must not manipulate the xStateListItem of a TCB, or any of the</span>
<span class="cm">lists the xStateListItem can be referenced from, if the scheduler is suspended.</span>
<span class="cm">If an interrupt needs to unblock a task while the scheduler is suspended then it</span>
<span class="cm">moves the task&#39;s event list item into the xPendingReadyList, ready for the</span>
<span class="cm">kernel to move the task from the pending ready list into the real ready list</span>
<span class="cm">when the scheduler is unsuspended.  The pending ready list itself can only be</span>
<span class="cm">accessed from a critical section. */</span>
<span class="n">PRIVILEGED_DATA</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxSchedulerSuspended</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>

<span class="cp">#if ( configGENERATE_RUN_TIME_STATS == 1 )</span>

<span class="w">    </span><span class="cm">/* Do not move these variables to function scope as doing so prevents the</span>
<span class="cm">    code working with debuggers that need to remove the static qualifier. */</span>
<span class="w">    </span><span class="n">PRIVILEGED_DATA</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ulTaskSwitchedInTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0UL</span><span class="p">;</span><span class="w"> </span><span class="cm">/*&lt; Holds the value of a timer/counter the last time a task was switched in. */</span>
<span class="w">    </span><span class="n">PRIVILEGED_DATA</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ulTotalRunTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0UL</span><span class="p">;</span><span class="w">       </span><span class="cm">/*&lt; Holds the total amount of execution time as defined by the run time counter clock. */</span>

<span class="cp">#endif</span>

<span class="cm">/*lint -restore */</span>

<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cm">/* Callback function prototypes. --------------------------*/</span>
<span class="cp">#if(  configCHECK_FOR_STACK_OVERFLOW &gt; 0 )</span>

<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">vApplicationStackOverflowHook</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTask</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">pcTaskName</span><span class="w"> </span><span class="p">);</span>

<span class="cp">#endif</span>

<span class="cp">#if( configUSE_TICK_HOOK &gt; 0 )</span>

<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">vApplicationTickHook</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e526 Symbol not defined as it is an application callback. */</span>

<span class="cp">#endif</span>

<span class="cp">#if( configSUPPORT_STATIC_ALLOCATION == 1 )</span>

<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">vApplicationGetIdleTaskMemory</span><span class="p">(</span><span class="w"> </span><span class="n">StaticTask_t</span><span class="w"> </span><span class="o">**</span><span class="n">ppxIdleTaskTCBBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">StackType_t</span><span class="w"> </span><span class="o">**</span><span class="n">ppxIdleTaskStackBuffer</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">pulIdleTaskStackSize</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e526 Symbol not defined as it is an application callback. */</span>

<span class="cp">#endif</span>

<span class="cm">/* File private functions. --------------------------------*/</span>

<span class="cp">#if ( INCLUDE_vTaskSuspend == 1 )</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="nf">prvTaskIsTaskSuspended</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">PRIVILEGED_FUNCTION</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* INCLUDE_vTaskSuspend */</span>

<span class="cm">/*</span>
<span class="cm"> * Utility to ready all the lists used by the scheduler.  This is called</span>
<span class="cm"> * automatically upon the creation of the first task.</span>
<span class="cm"> */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">prvInitialiseTaskLists</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">PRIVILEGED_FUNCTION</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The idle task, which as all tasks is implemented as a never ending loop.</span>
<span class="cm"> * The idle task is automatically created and added to the ready lists upon</span>
<span class="cm"> * creation of the first user task.</span>
<span class="cm"> *</span>
<span class="cm"> * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific</span>
<span class="cm"> * language extensions.  The equivalent prototype for this function is:</span>
<span class="cm"> *</span>
<span class="cm"> * void prvIdleTask( void *pvParameters );</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span><span class="w"> </span><span class="n">portTASK_FUNCTION_PROTO</span><span class="p">(</span><span class="w"> </span><span class="n">prvIdleTask</span><span class="p">,</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Utility to free all memory allocated by the scheduler to hold a TCB,</span>
<span class="cm"> * including the stack pointed to by the TCB.</span>
<span class="cm"> *</span>
<span class="cm"> * This does not free memory allocated by the task itself (i.e. memory</span>
<span class="cm"> * allocated by calls to pvPortMalloc from within the tasks application code).</span>
<span class="cm"> */</span>
<span class="cp">#if ( INCLUDE_vTaskDelete == 1 )</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">prvDeleteTCB</span><span class="p">(</span><span class="w"> </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTCB</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">PRIVILEGED_FUNCTION</span><span class="p">;</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Used only by the idle task.  This checks to see if anything has been placed</span>
<span class="cm"> * in the list of tasks waiting to be deleted.  If so the task is cleaned up</span>
<span class="cm"> * and its TCB deleted.</span>
<span class="cm"> */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">prvCheckTasksWaitingTermination</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">PRIVILEGED_FUNCTION</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The currently executing task is entering the Blocked state.  Add the task to</span>
<span class="cm"> * either the current or the overflow delayed task list.</span>
<span class="cm"> */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">prvAddCurrentTaskToDelayedList</span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xCanBlockIndefinitely</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">PRIVILEGED_FUNCTION</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Fills an TaskStatus_t structure with information on each task that is</span>
<span class="cm"> * referenced from the pxList list (which may be a ready list, a delayed list,</span>
<span class="cm"> * a suspended list, etc.).</span>
<span class="cm"> *</span>
<span class="cm"> * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM</span>
<span class="cm"> * NORMAL APPLICATION CODE.</span>
<span class="cm"> */</span>
<span class="cp">#if ( configUSE_TRACE_FACILITY == 1 )</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="nf">prvListTasksWithinSingleList</span><span class="p">(</span><span class="w"> </span><span class="n">TaskStatus_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTaskStatusArray</span><span class="p">,</span><span class="w"> </span><span class="n">List_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxList</span><span class="p">,</span><span class="w"> </span><span class="n">eTaskState</span><span class="w"> </span><span class="n">eState</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">PRIVILEGED_FUNCTION</span><span class="p">;</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Searches pxList for a task with name pcNameToQuery - returning a handle to</span>
<span class="cm"> * the task if it is found, or NULL if the task is not found.</span>
<span class="cm"> */</span>
<span class="cp">#if ( INCLUDE_xTaskGetHandle == 1 )</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="nf">prvSearchForNameWithinSingleList</span><span class="p">(</span><span class="w"> </span><span class="n">List_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxList</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">pcNameToQuery</span><span class="p">[]</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">PRIVILEGED_FUNCTION</span><span class="p">;</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * When a task is created, the stack of the task is filled with a known value.</span>
<span class="cm"> * This function determines the &#39;high water mark&#39; of the task stack by</span>
<span class="cm"> * determining how much of the stack remains at the original preset value.</span>
<span class="cm"> */</span>
<span class="cp">#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">configSTACK_DEPTH_TYPE</span><span class="w"> </span><span class="nf">prvTaskCheckFreeStackSpace</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pucStackByte</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">PRIVILEGED_FUNCTION</span><span class="p">;</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Return the amount of time, in ticks, that will pass before the kernel will</span>
<span class="cm"> * next move a task from the Blocked state to the Running state.</span>
<span class="cm"> *</span>
<span class="cm"> * This conditional compilation should use inequality to 0, not equality to 1.</span>
<span class="cm"> * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user</span>
<span class="cm"> * defined low power mode implementations require configUSE_TICKLESS_IDLE to be</span>
<span class="cm"> * set to a value other than 1.</span>
<span class="cm"> */</span>
<span class="cp">#if ( configUSE_TICKLESS_IDLE != 0 )</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="nf">prvGetExpectedIdleTime</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">PRIVILEGED_FUNCTION</span><span class="p">;</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Set xNextTaskUnblockTime to the time at which the next Blocked state task</span>
<span class="cm"> * will exit the Blocked state.</span>
<span class="cm"> */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">prvResetNextTaskUnblockTime</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">);</span>

<span class="cp">#if ( ( configUSE_TRACE_FACILITY == 1 ) &amp;&amp; ( configUSE_STATS_FORMATTING_FUNCTIONS &gt; 0 ) )</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Helper function used to pad task names with spaces when printing out</span>
<span class="cm">     * human readable tables of task information.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">prvWriteNameToBuffer</span><span class="p">(</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">pcBuffer</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">pcTaskName</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">PRIVILEGED_FUNCTION</span><span class="p">;</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Called after a Task_t structure has been allocated either statically or</span>
<span class="cm"> * dynamically to fill in the structure&#39;s members.</span>
<span class="cm"> */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">prvInitialiseNewTask</span><span class="p">(</span><span class="w">   </span><span class="n">TaskFunction_t</span><span class="w"> </span><span class="n">pxTaskCode</span><span class="p">,</span>
<span class="w">                                    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pcName</span><span class="p">,</span><span class="w">      </span><span class="cm">/*lint !e971 Unqualified char types are allowed for strings and single characters only. */</span>
<span class="w">                                    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ulStackDepth</span><span class="p">,</span>
<span class="w">                                    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pvParameters</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxPriority</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxCreatedTask</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxNewTCB</span><span class="p">,</span>
<span class="w">                                    </span><span class="k">const</span><span class="w"> </span><span class="n">MemoryRegion_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">xRegions</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">PRIVILEGED_FUNCTION</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Called after a new task has been created and initialised to place the task</span>
<span class="cm"> * under the control of the scheduler.</span>
<span class="cm"> */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">prvAddNewTaskToReadyList</span><span class="p">(</span><span class="w"> </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxNewTCB</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">PRIVILEGED_FUNCTION</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * freertos_tasks_c_additions_init() should only be called if the user definable</span>
<span class="cm"> * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro</span>
<span class="cm"> * called by the function.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">freertos_tasks_c_additions_init</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">PRIVILEGED_FUNCTION</span><span class="p">;</span>

<span class="cp">#endif</span>

<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if( configSUPPORT_STATIC_ALLOCATION == 1 )</span>

<span class="w">    </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="nf">xTaskCreateStatic</span><span class="p">(</span><span class="w"> </span><span class="n">TaskFunction_t</span><span class="w"> </span><span class="n">pxTaskCode</span><span class="p">,</span>
<span class="w">                                    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pcName</span><span class="p">,</span><span class="w">      </span><span class="cm">/*lint !e971 Unqualified char types are allowed for strings and single characters only. */</span>
<span class="w">                                    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ulStackDepth</span><span class="p">,</span>
<span class="w">                                    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pvParameters</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxPriority</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">StackType_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">puxStackBuffer</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">StaticTask_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxTaskBuffer</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxNewTCB</span><span class="p">;</span>
<span class="w">    </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>

<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">puxStackBuffer</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskBuffer</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cp">#if( configASSERT_DEFINED == 1 )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Sanity check that the size of the structure used to declare a</span>
<span class="cm">            variable of type StaticTask_t equals the size of the real task</span>
<span class="cm">            structure. */</span>
<span class="w">            </span><span class="k">volatile</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">xSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">StaticTask_t</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">xSize</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">TCB_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xSize</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Prevent lint warning when configASSERT() is not used. */</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif </span><span class="cm">/* configASSERT_DEFINED */</span>


<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskBuffer</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">puxStackBuffer</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* The memory used for the task&#39;s TCB and stack are passed into this</span>
<span class="cm">            function - use them. */</span>
<span class="w">            </span><span class="n">pxNewTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxTaskBuffer</span><span class="p">;</span><span class="w"> </span><span class="cm">/*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */</span>
<span class="w">            </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pxStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">StackType_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">puxStackBuffer</span><span class="p">;</span>

<span class="w">            </span><span class="cp">#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) </span><span class="cm">/*lint !e731 !e9029 Macro has been consolidated for readability reasons. */</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Tasks can be created statically or dynamically, so note this</span>
<span class="cm">                task was created statically in case the task is later deleted. */</span>
<span class="w">                </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">ucStaticallyAllocated</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tskSTATICALLY_ALLOCATED_STACK_AND_TCB</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="cp">#endif </span><span class="cm">/* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */</span>

<span class="w">            </span><span class="n">prvInitialiseNewTask</span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskCode</span><span class="p">,</span><span class="w"> </span><span class="n">pcName</span><span class="p">,</span><span class="w"> </span><span class="n">ulStackDepth</span><span class="p">,</span><span class="w"> </span><span class="n">pvParameters</span><span class="p">,</span><span class="w"> </span><span class="n">uxPriority</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xReturn</span><span class="p">,</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="n">prvAddNewTaskToReadyList</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* SUPPORT_STATIC_ALLOCATION */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if( ( portUSING_MPU_WRAPPERS == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) )</span>

<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xTaskCreateRestrictedStatic</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TaskParameters_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxTaskDefinition</span><span class="p">,</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxCreatedTask</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxNewTCB</span><span class="p">;</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY</span><span class="p">;</span>

<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskDefinition</span><span class="o">-&gt;</span><span class="n">puxStackBuffer</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskDefinition</span><span class="o">-&gt;</span><span class="n">pxTaskBuffer</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskDefinition</span><span class="o">-&gt;</span><span class="n">puxStackBuffer</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskDefinition</span><span class="o">-&gt;</span><span class="n">pxTaskBuffer</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Allocate space for the TCB.  Where the memory comes from depends</span>
<span class="cm">            on the implementation of the port malloc function and whether or</span>
<span class="cm">            not static allocation is being used. */</span>
<span class="w">            </span><span class="n">pxNewTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxTaskDefinition</span><span class="o">-&gt;</span><span class="n">pxTaskBuffer</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/* Store the stack location in the TCB. */</span>
<span class="w">            </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pxStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTaskDefinition</span><span class="o">-&gt;</span><span class="n">puxStackBuffer</span><span class="p">;</span>

<span class="w">            </span><span class="cp">#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Tasks can be created statically or dynamically, so note this</span>
<span class="cm">                task was created statically in case the task is later deleted. */</span>
<span class="w">                </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">ucStaticallyAllocated</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tskSTATICALLY_ALLOCATED_STACK_AND_TCB</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="cp">#endif </span><span class="cm">/* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */</span>

<span class="w">            </span><span class="n">prvInitialiseNewTask</span><span class="p">(</span><span class="w">   </span><span class="n">pxTaskDefinition</span><span class="o">-&gt;</span><span class="n">pvTaskCode</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">pxTaskDefinition</span><span class="o">-&gt;</span><span class="n">pcName</span><span class="p">,</span>
<span class="w">                                    </span><span class="p">(</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxTaskDefinition</span><span class="o">-&gt;</span><span class="n">usStackDepth</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">pxTaskDefinition</span><span class="o">-&gt;</span><span class="n">pvParameters</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">pxTaskDefinition</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">pxCreatedTask</span><span class="p">,</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">pxTaskDefinition</span><span class="o">-&gt;</span><span class="n">xRegions</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="n">prvAddNewTaskToReadyList</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdPASS</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* ( portUSING_MPU_WRAPPERS == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if( ( portUSING_MPU_WRAPPERS == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )</span>

<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xTaskCreateRestricted</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TaskParameters_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxTaskDefinition</span><span class="p">,</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxCreatedTask</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxNewTCB</span><span class="p">;</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY</span><span class="p">;</span>

<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskDefinition</span><span class="o">-&gt;</span><span class="n">puxStackBuffer</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskDefinition</span><span class="o">-&gt;</span><span class="n">puxStackBuffer</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Allocate space for the TCB.  Where the memory comes from depends</span>
<span class="cm">            on the implementation of the port malloc function and whether or</span>
<span class="cm">            not static allocation is being used. */</span>
<span class="w">            </span><span class="n">pxNewTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pvPortMalloc</span><span class="p">(</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">TCB_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Store the stack location in the TCB. */</span>
<span class="w">                </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pxStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTaskDefinition</span><span class="o">-&gt;</span><span class="n">puxStackBuffer</span><span class="p">;</span>

<span class="w">                </span><span class="cp">#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* Tasks can be created statically or dynamically, so note</span>
<span class="cm">                    this task had a statically allocated stack in case it is</span>
<span class="cm">                    later deleted.  The TCB was allocated dynamically. */</span>
<span class="w">                    </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">ucStaticallyAllocated</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tskSTATICALLY_ALLOCATED_STACK_ONLY</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="cp">#endif </span><span class="cm">/* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */</span>

<span class="w">                </span><span class="n">prvInitialiseNewTask</span><span class="p">(</span><span class="w">   </span><span class="n">pxTaskDefinition</span><span class="o">-&gt;</span><span class="n">pvTaskCode</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">pxTaskDefinition</span><span class="o">-&gt;</span><span class="n">pcName</span><span class="p">,</span>
<span class="w">                                        </span><span class="p">(</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxTaskDefinition</span><span class="o">-&gt;</span><span class="n">usStackDepth</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">pxTaskDefinition</span><span class="o">-&gt;</span><span class="n">pvParameters</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">pxTaskDefinition</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">pxCreatedTask</span><span class="p">,</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">pxTaskDefinition</span><span class="o">-&gt;</span><span class="n">xRegions</span><span class="w"> </span><span class="p">);</span>

<span class="w">                </span><span class="n">prvAddNewTaskToReadyList</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdPASS</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* portUSING_MPU_WRAPPERS */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )</span>

<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xTaskCreate</span><span class="p">(</span><span class="w"> </span><span class="n">TaskFunction_t</span><span class="w"> </span><span class="n">pxTaskCode</span><span class="p">,</span>
<span class="w">                            </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pcName</span><span class="p">,</span><span class="w">      </span><span class="cm">/*lint !e971 Unqualified char types are allowed for strings and single characters only. */</span>
<span class="w">                            </span><span class="k">const</span><span class="w"> </span><span class="n">configSTACK_DEPTH_TYPE</span><span class="w"> </span><span class="n">usStackDepth</span><span class="p">,</span>
<span class="w">                            </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pvParameters</span><span class="p">,</span>
<span class="w">                            </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxPriority</span><span class="p">,</span>
<span class="w">                            </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxCreatedTask</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxNewTCB</span><span class="p">;</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* If the stack grows down then allocate the stack then the TCB so the stack</span>
<span class="cm">        does not grow into the TCB.  Likewise if the stack grows up then allocate</span>
<span class="cm">        the TCB then the stack. */</span>
<span class="w">        </span><span class="cp">#if( portSTACK_GROWTH &gt; 0 )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Allocate space for the TCB.  Where the memory comes from depends on</span>
<span class="cm">            the implementation of the port malloc function and whether or not static</span>
<span class="cm">            allocation is being used. */</span>
<span class="w">            </span><span class="n">pxNewTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pvPortMalloc</span><span class="p">(</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">TCB_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Allocate space for the stack used by the task being created.</span>
<span class="cm">                The base of the stack memory stored in the TCB so the task can</span>
<span class="cm">                be deleted later if required. */</span>
<span class="w">                </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pxStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">StackType_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pvPortMalloc</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">usStackDepth</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">StackType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e961 MISRA exception as the casts are only redundant for some ports. */</span>

<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pxStack</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* Could not allocate the stack.  Delete the allocated TCB. */</span>
<span class="w">                    </span><span class="n">vPortFree</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="n">pxNewTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#else </span><span class="cm">/* portSTACK_GROWTH */</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">        </span><span class="n">StackType_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxStack</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/* Allocate space for the stack used by the task being created. */</span>
<span class="w">            </span><span class="n">pxStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pvPortMalloc</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">usStackDepth</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">StackType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU&#39;s stack and this allocation is the stack. */</span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxStack</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Allocate space for the TCB. */</span>
<span class="w">                </span><span class="n">pxNewTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pvPortMalloc</span><span class="p">(</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">TCB_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU&#39;s stack, and the first member of TCB_t is always a pointer to the task&#39;s stack. */</span>

<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* Store the stack location in the TCB. */</span>
<span class="w">                    </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pxStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxStack</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* The stack cannot be used as the TCB was not created.  Free</span>
<span class="cm">                    it again. */</span>
<span class="w">                    </span><span class="n">vPortFree</span><span class="p">(</span><span class="w"> </span><span class="n">pxStack</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">pxNewTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif </span><span class="cm">/* portSTACK_GROWTH */</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cp">#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) </span><span class="cm">/*lint !e9029 !e731 Macro has been consolidated for readability reasons. */</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Tasks can be created statically or dynamically, so note this</span>
<span class="cm">                task was created dynamically in case it is later deleted. */</span>
<span class="w">                </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">ucStaticallyAllocated</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="cp">#endif </span><span class="cm">/* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */</span>

<span class="w">            </span><span class="n">prvInitialiseNewTask</span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskCode</span><span class="p">,</span><span class="w"> </span><span class="n">pcName</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">usStackDepth</span><span class="p">,</span><span class="w"> </span><span class="n">pvParameters</span><span class="p">,</span><span class="w"> </span><span class="n">uxPriority</span><span class="p">,</span><span class="w"> </span><span class="n">pxCreatedTask</span><span class="p">,</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="n">prvAddNewTaskToReadyList</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdPASS</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configSUPPORT_DYNAMIC_ALLOCATION */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">prvInitialiseNewTask</span><span class="p">(</span><span class="w">   </span><span class="n">TaskFunction_t</span><span class="w"> </span><span class="n">pxTaskCode</span><span class="p">,</span>
<span class="w">                                    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pcName</span><span class="p">,</span><span class="w">      </span><span class="cm">/*lint !e971 Unqualified char types are allowed for strings and single characters only. */</span>
<span class="w">                                    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ulStackDepth</span><span class="p">,</span>
<span class="w">                                    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pvParameters</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxPriority</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxCreatedTask</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxNewTCB</span><span class="p">,</span>
<span class="w">                                    </span><span class="k">const</span><span class="w"> </span><span class="n">MemoryRegion_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">xRegions</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">StackType_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTopOfStack</span><span class="p">;</span>
<span class="n">UBaseType_t</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">    </span><span class="cp">#if( portUSING_MPU_WRAPPERS == 1 )</span>
<span class="w">        </span><span class="cm">/* Should the task be created in privileged mode? */</span>
<span class="w">        </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xRunPrivileged</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">uxPriority</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">portPRIVILEGE_BIT</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0U</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xRunPrivileged</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xRunPrivileged</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">uxPriority</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">portPRIVILEGE_BIT</span><span class="p">;</span>
<span class="w">    </span><span class="cp">#endif </span><span class="cm">/* portUSING_MPU_WRAPPERS == 1 */</span>

<span class="w">    </span><span class="cm">/* Avoid dependency on memset() if it is not required. */</span>
<span class="w">    </span><span class="cp">#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Fill the stack with a known value to assist debugging. */</span>
<span class="w">        </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">memset</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pxStack</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">tskSTACK_FILL_BYTE</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">ulStackDepth</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">StackType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif </span><span class="cm">/* tskSET_NEW_STACKS_TO_KNOWN_VALUE */</span>

<span class="w">    </span><span class="cm">/* Calculate the top of stack address.  This depends on whether the stack</span>
<span class="cm">    grows from high memory to low (as per the 80x86) or vice versa.</span>
<span class="cm">    portSTACK_GROWTH is used to make the result positive or negative as required</span>
<span class="cm">    by the port. */</span>
<span class="w">    </span><span class="cp">#if( portSTACK_GROWTH &lt; 0 )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">pxTopOfStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pxStack</span><span class="p">[</span><span class="w"> </span><span class="n">ulStackDepth</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="n">pxTopOfStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">StackType_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">portPOINTER_SIZE_TYPE</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxTopOfStack</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">portPOINTER_SIZE_TYPE</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">portBYTE_ALIGNMENT_MASK</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */</span>

<span class="w">        </span><span class="cm">/* Check the alignment of the calculated top of stack is correct. */</span>
<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">portPOINTER_SIZE_TYPE</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxTopOfStack</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">portPOINTER_SIZE_TYPE</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">portBYTE_ALIGNMENT_MASK</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0UL</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cp">#if( configRECORD_STACK_HIGH_ADDRESS == 1 )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Also record the stack&#39;s high address, which may assist</span>
<span class="cm">            debugging. */</span>
<span class="w">            </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pxEndOfStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTopOfStack</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif </span><span class="cm">/* configRECORD_STACK_HIGH_ADDRESS */</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#else </span><span class="cm">/* portSTACK_GROWTH */</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">pxTopOfStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pxStack</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* Check the alignment of the stack buffer is correct. */</span>
<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">portPOINTER_SIZE_TYPE</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pxStack</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">portPOINTER_SIZE_TYPE</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">portBYTE_ALIGNMENT_MASK</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0UL</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* The other extreme of the stack space is required if stack checking is</span>
<span class="cm">        performed. */</span>
<span class="w">        </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pxEndOfStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pxStack</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">ulStackDepth</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif </span><span class="cm">/* portSTACK_GROWTH */</span>

<span class="w">    </span><span class="cm">/* Store the task name in the TCB. */</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pcName</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">configMAX_TASK_NAME_LEN</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pcTaskName</span><span class="p">[</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pcName</span><span class="p">[</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">];</span>

<span class="w">            </span><span class="cm">/* Don&#39;t copy all configMAX_TASK_NAME_LEN if the string is shorter than</span>
<span class="cm">            configMAX_TASK_NAME_LEN characters just in case the memory after the</span>
<span class="cm">            string is not accessible (extremely unlikely). */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pcName</span><span class="p">[</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mh">0x00</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/* Ensure the name string is terminated in the case that the string length</span>
<span class="cm">        was greater or equal to configMAX_TASK_NAME_LEN. */</span>
<span class="w">        </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pcTaskName</span><span class="p">[</span><span class="w"> </span><span class="n">configMAX_TASK_NAME_LEN</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* The task has not been given a name, so just ensure there is a NULL</span>
<span class="cm">        terminator when it is read out. */</span>
<span class="w">        </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pcTaskName</span><span class="p">[</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* This is used as an array index so must ensure it&#39;s not too large.  First</span>
<span class="cm">    remove the privilege bit if one is present. */</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxPriority</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">configMAX_PRIORITIES</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">uxPriority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">configMAX_PRIORITIES</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">1U</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uxPriority</span><span class="p">;</span>
<span class="w">    </span><span class="cp">#if ( configUSE_MUTEXES == 1 )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">uxBasePriority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uxPriority</span><span class="p">;</span>
<span class="w">        </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">uxMutexesHeld</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif </span><span class="cm">/* configUSE_MUTEXES */</span>

<span class="w">    </span><span class="n">vListInitialiseItem</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">vListInitialiseItem</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get</span>
<span class="cm">    back to the containing TCB from a generic item in a list. */</span>
<span class="w">    </span><span class="n">listSET_LIST_ITEM_OWNER</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Event lists are always in priority order. */</span>
<span class="w">    </span><span class="n">listSET_LIST_ITEM_VALUE</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">configMAX_PRIORITIES</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">uxPriority</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e961 MISRA exception as the casts are only redundant for some ports. */</span>
<span class="w">    </span><span class="n">listSET_LIST_ITEM_OWNER</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cp">#if ( portCRITICAL_NESTING_IN_TCB == 1 )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">uxCriticalNesting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0U</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif </span><span class="cm">/* portCRITICAL_NESTING_IN_TCB */</span>

<span class="w">    </span><span class="cp">#if ( configUSE_APPLICATION_TASK_TAG == 1 )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pxTaskTag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif </span><span class="cm">/* configUSE_APPLICATION_TASK_TAG */</span>

<span class="w">    </span><span class="cp">#if ( configGENERATE_RUN_TIME_STATS == 1 )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">ulRunTimeCounter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0UL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif </span><span class="cm">/* configGENERATE_RUN_TIME_STATS */</span>

<span class="w">    </span><span class="cp">#if ( portUSING_MPU_WRAPPERS == 1 )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">vPortStoreTaskMPUSettings</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">xMPUSettings</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="n">xRegions</span><span class="p">,</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pxStack</span><span class="p">,</span><span class="w"> </span><span class="n">ulStackDepth</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Avoid compiler warning about unreferenced parameter. */</span>
<span class="w">        </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xRegions</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="w">    </span><span class="cp">#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">configNUM_THREAD_LOCAL_STORAGE_POINTERS</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pvThreadLocalStoragePointers</span><span class="p">[</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="w">    </span><span class="cp">#if ( configUSE_TASK_NOTIFICATIONS == 1 )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">ulNotifiedValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">ucNotifyState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskNOT_WAITING_NOTIFICATION</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="w">    </span><span class="cp">#if ( configUSE_NEWLIB_REENTRANT == 1 )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Initialise this task&#39;s Newlib reent structure.</span>
<span class="cm">        See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html</span>
<span class="cm">        for additional information. */</span>
<span class="w">        </span><span class="n">_REENT_INIT_PTR</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">xNewLib_reent</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="w">    </span><span class="cp">#if( INCLUDE_xTaskAbortDelay == 1 )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">ucDelayAborted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="w">    </span><span class="cm">/* Initialize the TCB stack to look as if the task was already running,</span>
<span class="cm">    but had been interrupted by the scheduler.  The return address is set</span>
<span class="cm">    to the start of the task function. Once the stack has been initialised</span>
<span class="cm">    the top of stack variable is updated. */</span>
<span class="w">    </span><span class="cp">#if( portUSING_MPU_WRAPPERS == 1 )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* If the port has capability to detect stack overflow,</span>
<span class="cm">        pass the stack end address to the stack initialization</span>
<span class="cm">        function as well. */</span>
<span class="w">        </span><span class="cp">#if( portHAS_STACK_OVERFLOW_CHECKING == 1 )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cp">#if( portSTACK_GROWTH &lt; 0 )</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pxTopOfStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxPortInitialiseStack</span><span class="p">(</span><span class="w"> </span><span class="n">pxTopOfStack</span><span class="p">,</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pxStack</span><span class="p">,</span><span class="w"> </span><span class="n">pxTaskCode</span><span class="p">,</span><span class="w"> </span><span class="n">pvParameters</span><span class="p">,</span><span class="w"> </span><span class="n">xRunPrivileged</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="cp">#else </span><span class="cm">/* portSTACK_GROWTH */</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pxTopOfStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxPortInitialiseStack</span><span class="p">(</span><span class="w"> </span><span class="n">pxTopOfStack</span><span class="p">,</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pxEndOfStack</span><span class="p">,</span><span class="w"> </span><span class="n">pxTaskCode</span><span class="p">,</span><span class="w"> </span><span class="n">pvParameters</span><span class="p">,</span><span class="w"> </span><span class="n">xRunPrivileged</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="cp">#endif </span><span class="cm">/* portSTACK_GROWTH */</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#else </span><span class="cm">/* portHAS_STACK_OVERFLOW_CHECKING */</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pxTopOfStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxPortInitialiseStack</span><span class="p">(</span><span class="w"> </span><span class="n">pxTopOfStack</span><span class="p">,</span><span class="w"> </span><span class="n">pxTaskCode</span><span class="p">,</span><span class="w"> </span><span class="n">pvParameters</span><span class="p">,</span><span class="w"> </span><span class="n">xRunPrivileged</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif </span><span class="cm">/* portHAS_STACK_OVERFLOW_CHECKING */</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#else </span><span class="cm">/* portUSING_MPU_WRAPPERS */</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* If the port has capability to detect stack overflow,</span>
<span class="cm">        pass the stack end address to the stack initialization</span>
<span class="cm">        function as well. */</span>
<span class="w">        </span><span class="cp">#if( portHAS_STACK_OVERFLOW_CHECKING == 1 )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cp">#if( portSTACK_GROWTH &lt; 0 )</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pxTopOfStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxPortInitialiseStack</span><span class="p">(</span><span class="w"> </span><span class="n">pxTopOfStack</span><span class="p">,</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pxStack</span><span class="p">,</span><span class="w"> </span><span class="n">pxTaskCode</span><span class="p">,</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="cp">#else </span><span class="cm">/* portSTACK_GROWTH */</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pxTopOfStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxPortInitialiseStack</span><span class="p">(</span><span class="w"> </span><span class="n">pxTopOfStack</span><span class="p">,</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pxEndOfStack</span><span class="p">,</span><span class="w"> </span><span class="n">pxTaskCode</span><span class="p">,</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="cp">#endif </span><span class="cm">/* portSTACK_GROWTH */</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#else </span><span class="cm">/* portHAS_STACK_OVERFLOW_CHECKING */</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">pxTopOfStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxPortInitialiseStack</span><span class="p">(</span><span class="w"> </span><span class="n">pxTopOfStack</span><span class="p">,</span><span class="w"> </span><span class="n">pxTaskCode</span><span class="p">,</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif </span><span class="cm">/* portHAS_STACK_OVERFLOW_CHECKING */</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif </span><span class="cm">/* portUSING_MPU_WRAPPERS */</span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxCreatedTask</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Pass the handle out in an anonymous way.  The handle can be used to</span>
<span class="cm">        change the created task&#39;s priority, delete the created task, etc.*/</span>
<span class="w">        </span><span class="o">*</span><span class="n">pxCreatedTask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">prvAddNewTaskToReadyList</span><span class="p">(</span><span class="w"> </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxNewTCB</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* Ensure interrupts don&#39;t access the task lists while the lists are being</span>
<span class="cm">    updated. */</span>
<span class="w">    </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">uxCurrentNumberOfTasks</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* There are no other tasks, or all the other tasks are in</span>
<span class="cm">            the suspended state - make this the current task. */</span>
<span class="w">            </span><span class="n">pxCurrentTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="p">;</span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxCurrentNumberOfTasks</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* This is the first task to be created so do the preliminary</span>
<span class="cm">                initialisation required.  We will not recover if this call</span>
<span class="cm">                fails, but we will report the failure. */</span>
<span class="w">                </span><span class="n">prvInitialiseTaskLists</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* If the scheduler is not already running, make this task the</span>
<span class="cm">            current task if it is the highest priority task to be created</span>
<span class="cm">            so far. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xSchedulerRunning</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">pxCurrentTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">uxTaskNumber</span><span class="o">++</span><span class="p">;</span>

<span class="w">        </span><span class="cp">#if ( configUSE_TRACE_FACILITY == 1 )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Add a counter into the TCB for tracing only. */</span>
<span class="w">            </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">uxTCBNumber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uxTaskNumber</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif </span><span class="cm">/* configUSE_TRACE_FACILITY */</span>
<span class="w">        </span><span class="n">traceTASK_CREATE</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="n">prvAddTaskToReadyList</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="n">portSETUP_TCB</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xSchedulerRunning</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* If the created task is of a higher priority than the current task</span>
<span class="cm">        then it should run now. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">pxNewTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">taskYIELD_IF_USING_PREEMPTION</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( INCLUDE_vTaskDelete == 1 )</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">vTaskDelete</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTaskToDelete</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTCB</span><span class="p">;</span>

<span class="w">        </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* If null is passed in here then it is the calling task that is</span>
<span class="cm">            being deleted. */</span>
<span class="w">            </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvGetTCBFromHandle</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskToDelete</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="cm">/* Remove task from the ready/delayed list. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxListRemove</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">taskRESET_READY_PRIORITY</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="cm">/* Is the task waiting on an event also? */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_ITEM_CONTAINER</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">uxListRemove</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="cm">/* Increment the uxTaskNumber also so kernel aware debuggers can</span>
<span class="cm">            detect that the task lists need re-generating.  This is done before</span>
<span class="cm">            portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will</span>
<span class="cm">            not return. */</span>
<span class="w">            </span><span class="n">uxTaskNumber</span><span class="o">++</span><span class="p">;</span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* A task is deleting itself.  This cannot complete within the</span>
<span class="cm">                task itself, as a context switch to another task is required.</span>
<span class="cm">                Place the task in the termination list.  The idle task will</span>
<span class="cm">                check the termination list and free up any memory allocated by</span>
<span class="cm">                the scheduler for the TCB and stack of the deleted task. */</span>
<span class="w">                </span><span class="n">vListInsertEnd</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xTasksWaitingTermination</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">                </span><span class="cm">/* Increment the ucTasksDeleted variable so the idle task knows</span>
<span class="cm">                there is a task that has been deleted and that it should therefore</span>
<span class="cm">                check the xTasksWaitingTermination list. */</span>
<span class="w">                </span><span class="o">++</span><span class="n">uxDeletedTasksWaitingCleanUp</span><span class="p">;</span>

<span class="w">                </span><span class="cm">/* Call the delete hook before portPRE_TASK_DELETE_HOOK() as</span>
<span class="cm">                portPRE_TASK_DELETE_HOOK() does not return in the Win32 port. */</span>
<span class="w">                </span><span class="n">traceTASK_DELETE</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>

<span class="w">                </span><span class="cm">/* The pre-delete hook is primarily for the Windows simulator,</span>
<span class="cm">                in which Windows specific clean up operations are performed,</span>
<span class="cm">                after which it is not possible to yield away from this task -</span>
<span class="cm">                hence xYieldPending is used to latch that a context switch is</span>
<span class="cm">                required. */</span>
<span class="w">                </span><span class="n">portPRE_TASK_DELETE_HOOK</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xYieldPending</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="o">--</span><span class="n">uxCurrentNumberOfTasks</span><span class="p">;</span>
<span class="w">                </span><span class="n">traceTASK_DELETE</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="n">prvDeleteTCB</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>

<span class="w">                </span><span class="cm">/* Reset the next expected unblock time in case it referred to</span>
<span class="cm">                the task that has just been deleted. */</span>
<span class="w">                </span><span class="n">prvResetNextTaskUnblockTime</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">        </span><span class="cm">/* Force a reschedule if it is the currently running task that has just</span>
<span class="cm">        been deleted. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xSchedulerRunning</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">uxSchedulerSuspended</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="n">portYIELD_WITHIN_API</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* INCLUDE_vTaskDelete */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( INCLUDE_vTaskDelayUntil == 1 )</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">vTaskDelayUntil</span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxPreviousWakeTime</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xTimeIncrement</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xTimeToWake</span><span class="p">;</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xAlreadyYielded</span><span class="p">,</span><span class="w"> </span><span class="n">xShouldDelay</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>

<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxPreviousWakeTime</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xTimeIncrement</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0U</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">uxSchedulerSuspended</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="n">vTaskSuspendAll</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Minor optimisation.  The tick count cannot change in this</span>
<span class="cm">            block. */</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xConstTickCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTickCount</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/* Generate the tick time at which the task wants to wake. */</span>
<span class="w">            </span><span class="n">xTimeToWake</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">pxPreviousWakeTime</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">xTimeIncrement</span><span class="p">;</span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xConstTickCount</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">pxPreviousWakeTime</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* The tick count has overflowed since this function was</span>
<span class="cm">                lasted called.  In this case the only time we should ever</span>
<span class="cm">                actually delay is if the wake time has also overflowed,</span>
<span class="cm">                and the wake time is greater than the tick time.  When this</span>
<span class="cm">                is the case it is as if neither time had overflowed. */</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xTimeToWake</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">pxPreviousWakeTime</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xTimeToWake</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">xConstTickCount</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">xShouldDelay</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* The tick time has not overflowed.  In this case we will</span>
<span class="cm">                delay if either the wake time has overflowed, and/or the</span>
<span class="cm">                tick time is less than the wake time. */</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xTimeToWake</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">pxPreviousWakeTime</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xTimeToWake</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">xConstTickCount</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">xShouldDelay</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="cm">/* Update the wake time ready for the next call. */</span>
<span class="w">            </span><span class="o">*</span><span class="n">pxPreviousWakeTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTimeToWake</span><span class="p">;</span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xShouldDelay</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">traceTASK_DELAY_UNTIL</span><span class="p">(</span><span class="w"> </span><span class="n">xTimeToWake</span><span class="w"> </span><span class="p">);</span>

<span class="w">                </span><span class="cm">/* prvAddCurrentTaskToDelayedList() needs the block time, not</span>
<span class="cm">                the time to wake, so subtract the current tick count. */</span>
<span class="w">                </span><span class="n">prvAddCurrentTaskToDelayedList</span><span class="p">(</span><span class="w"> </span><span class="n">xTimeToWake</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xConstTickCount</span><span class="p">,</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">xAlreadyYielded</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTaskResumeAll</span><span class="p">();</span>

<span class="w">        </span><span class="cm">/* Force a reschedule if xTaskResumeAll has not already done so, we may</span>
<span class="cm">        have put ourselves to sleep. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xAlreadyYielded</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">portYIELD_WITHIN_API</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* INCLUDE_vTaskDelayUntil */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( INCLUDE_vTaskDelay == 1 )</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">vTaskDelay</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xTicksToDelay</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xAlreadyYielded</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* A delay time of zero just forces a reschedule. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTicksToDelay</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0U</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">uxSchedulerSuspended</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="n">vTaskSuspendAll</span><span class="p">();</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">traceTASK_DELAY</span><span class="p">();</span>

<span class="w">                </span><span class="cm">/* A task that is removed from the event list while the</span>
<span class="cm">                scheduler is suspended will not get placed in the ready</span>
<span class="cm">                list or removed from the blocked list until the scheduler</span>
<span class="cm">                is resumed.</span>

<span class="cm">                This task cannot be in an event list as it is the currently</span>
<span class="cm">                executing task. */</span>
<span class="w">                </span><span class="n">prvAddCurrentTaskToDelayedList</span><span class="p">(</span><span class="w"> </span><span class="n">xTicksToDelay</span><span class="p">,</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">xAlreadyYielded</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTaskResumeAll</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/* Force a reschedule if xTaskResumeAll has not already done so, we may</span>
<span class="cm">        have put ourselves to sleep. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xAlreadyYielded</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">portYIELD_WITHIN_API</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* INCLUDE_vTaskDelay */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_xTaskAbortDelay == 1 ) )</span>

<span class="w">    </span><span class="n">eTaskState</span><span class="w"> </span><span class="nf">eTaskGetState</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">eTaskState</span><span class="w"> </span><span class="n">eReturn</span><span class="p">;</span>
<span class="w">    </span><span class="n">List_t</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pxStateList</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">pxDelayedList</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">pxOverflowedDelayedList</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTask</span><span class="p">;</span>

<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* The task calling this function is querying its own state. */</span>
<span class="w">            </span><span class="n">eReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eRunning</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">pxStateList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">listLIST_ITEM_CONTAINER</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="n">pxDelayedList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxDelayedTaskList</span><span class="p">;</span>
<span class="w">                </span><span class="n">pxOverflowedDelayedList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxOverflowDelayedTaskList</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxStateList</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pxDelayedList</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxStateList</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pxOverflowedDelayedList</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* The task being queried is referenced from one of the Blocked</span>
<span class="cm">                lists. */</span>
<span class="w">                </span><span class="n">eReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eBlocked</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="cp">#if ( INCLUDE_vTaskSuspend == 1 )</span>
<span class="w">                </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxStateList</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xSuspendedTaskList</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* The task being queried is referenced from the suspended</span>
<span class="cm">                    list.  Is it genuinely suspended or is it blocked</span>
<span class="cm">                    indefinitely? */</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_ITEM_CONTAINER</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="cp">#if( configUSE_TASK_NOTIFICATIONS == 1 )</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="cm">/* The task does not appear on the event list item of</span>
<span class="cm">                            and of the RTOS objects, but could still be in the</span>
<span class="cm">                            blocked state if it is waiting on its notification</span>
<span class="cm">                            rather than waiting on an object. */</span>
<span class="w">                            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ucNotifyState</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">taskWAITING_NOTIFICATION</span><span class="w"> </span><span class="p">)</span>
<span class="w">                            </span><span class="p">{</span>
<span class="w">                                </span><span class="n">eReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eBlocked</span><span class="p">;</span>
<span class="w">                            </span><span class="p">}</span>
<span class="w">                            </span><span class="k">else</span>
<span class="w">                            </span><span class="p">{</span>
<span class="w">                                </span><span class="n">eReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eSuspended</span><span class="p">;</span>
<span class="w">                            </span><span class="p">}</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="cp">#else</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="n">eReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eSuspended</span><span class="p">;</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="cp">#endif</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">eReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eBlocked</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="cp">#endif</span>

<span class="w">            </span><span class="cp">#if ( INCLUDE_vTaskDelete == 1 )</span>
<span class="w">                </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxStateList</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xTasksWaitingTermination</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxStateList</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* The task being queried is referenced from the deleted</span>
<span class="cm">                    tasks list, or it is not referenced from any lists at</span>
<span class="cm">                    all. */</span>
<span class="w">                    </span><span class="n">eReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eDeleted</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="cp">#endif</span>

<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="cm">/*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* If the task is not in any other state, it must be in the</span>
<span class="cm">                Ready (including pending ready) state. */</span>
<span class="w">                </span><span class="n">eReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eReady</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">eReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="cm">/*lint !e818 xTask cannot be a pointer to const because it is a typedef. */</span>

<span class="cp">#endif </span><span class="cm">/* INCLUDE_eTaskGetState */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( INCLUDE_uxTaskPriorityGet == 1 )</span>

<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="nf">uxTaskPriorityGet</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="n">pxTCB</span><span class="p">;</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxReturn</span><span class="p">;</span>

<span class="w">        </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* If null is passed in here then it is the priority of the task</span>
<span class="cm">            that called uxTaskPriorityGet() that is being queried. */</span>
<span class="w">            </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvGetTCBFromHandle</span><span class="p">(</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="n">uxReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">uxReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* INCLUDE_uxTaskPriorityGet */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( INCLUDE_uxTaskPriorityGet == 1 )</span>

<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="nf">uxTaskPriorityGetFromISR</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="n">pxTCB</span><span class="p">;</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxReturn</span><span class="p">,</span><span class="w"> </span><span class="n">uxSavedInterruptState</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* RTOS ports that support interrupt nesting have the concept of a</span>
<span class="cm">        maximum system call (or maximum API call) interrupt priority.</span>
<span class="cm">        Interrupts that are above the maximum system call priority are keep</span>
<span class="cm">        permanently enabled, even when the RTOS kernel is in a critical section,</span>
<span class="cm">        but cannot make any calls to FreeRTOS API functions.  If configASSERT()</span>
<span class="cm">        is defined in FreeRTOSConfig.h then</span>
<span class="cm">        portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion</span>
<span class="cm">        failure if a FreeRTOS API function is called from an interrupt that has</span>
<span class="cm">        been assigned a priority above the configured maximum system call</span>
<span class="cm">        priority.  Only FreeRTOS functions that end in FromISR can be called</span>
<span class="cm">        from interrupts that have been assigned a priority at or (logically)</span>
<span class="cm">        below the maximum system call interrupt priority.  FreeRTOS maintains a</span>
<span class="cm">        separate interrupt safe API to ensure interrupt entry is as fast and as</span>
<span class="cm">        simple as possible.  More information (albeit Cortex-M specific) is</span>
<span class="cm">        provided on the following link:</span>
<span class="cm">        https://www.freertos.org/RTOS-Cortex-M3-M4.html */</span>
<span class="w">        </span><span class="n">portASSERT_IF_INTERRUPT_PRIORITY_INVALID</span><span class="p">();</span>

<span class="w">        </span><span class="n">uxSavedInterruptState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">portSET_INTERRUPT_MASK_FROM_ISR</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* If null is passed in here then it is the priority of the calling</span>
<span class="cm">            task that is being queried. */</span>
<span class="w">            </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvGetTCBFromHandle</span><span class="p">(</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="n">uxReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">portCLEAR_INTERRUPT_MASK_FROM_ISR</span><span class="p">(</span><span class="w"> </span><span class="n">uxSavedInterruptState</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">uxReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* INCLUDE_uxTaskPriorityGet */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( INCLUDE_vTaskPrioritySet == 1 )</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">vTaskPrioritySet</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTask</span><span class="p">,</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxNewPriority</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTCB</span><span class="p">;</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxCurrentBasePriority</span><span class="p">,</span><span class="w"> </span><span class="n">uxPriorityUsedOnEntry</span><span class="p">;</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xYieldRequired</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>

<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">uxNewPriority</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">configMAX_PRIORITIES</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* Ensure the new priority is valid. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxNewPriority</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">configMAX_PRIORITIES</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">uxNewPriority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">configMAX_PRIORITIES</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">1U</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* If null is passed in here then it is the priority of the calling</span>
<span class="cm">            task that is being changed. */</span>
<span class="w">            </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvGetTCBFromHandle</span><span class="p">(</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="n">traceTASK_PRIORITY_SET</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="p">,</span><span class="w"> </span><span class="n">uxNewPriority</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="cp">#if ( configUSE_MUTEXES == 1 )</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">uxCurrentBasePriority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxBasePriority</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="cp">#else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">uxCurrentBasePriority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="cp">#endif</span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxCurrentBasePriority</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">uxNewPriority</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* The priority change may have readied a task of higher</span>
<span class="cm">                priority than the calling task. */</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxNewPriority</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">uxCurrentBasePriority</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="cm">/* The priority of a task other than the currently</span>
<span class="cm">                        running task is being raised.  Is the priority being</span>
<span class="cm">                        raised above that of the running task? */</span>
<span class="w">                        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxNewPriority</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="p">)</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="n">xYieldRequired</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="k">else</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="cm">/* The priority of the running task is being raised,</span>
<span class="cm">                        but the running task must already be the highest</span>
<span class="cm">                        priority task able to run so no yield is required. */</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* Setting the priority of the running task down means</span>
<span class="cm">                    there may now be another task of higher priority that</span>
<span class="cm">                    is ready to execute. */</span>
<span class="w">                    </span><span class="n">xYieldRequired</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* Setting the priority of any other task down does not</span>
<span class="cm">                    require a yield as the running task must be above the</span>
<span class="cm">                    new priority of the task being modified. */</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="cm">/* Remember the ready list the task might be referenced from</span>
<span class="cm">                before its uxPriority member is changed so the</span>
<span class="cm">                taskRESET_READY_PRIORITY() macro can function correctly. */</span>
<span class="w">                </span><span class="n">uxPriorityUsedOnEntry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="p">;</span>

<span class="w">                </span><span class="cp">#if ( configUSE_MUTEXES == 1 )</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* Only change the priority being used if the task is not</span>
<span class="cm">                    currently using an inherited priority. */</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxBasePriority</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uxNewPriority</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>

<span class="w">                    </span><span class="cm">/* The base priority gets set whatever. */</span>
<span class="w">                    </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxBasePriority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uxNewPriority</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="cp">#else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uxNewPriority</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="cp">#endif</span>

<span class="w">                </span><span class="cm">/* Only reset the event list item value if the value is not</span>
<span class="cm">                being used for anything else. */</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">listGET_LIST_ITEM_VALUE</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">taskEVENT_LIST_ITEM_VALUE_IN_USE</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0UL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">listSET_LIST_ITEM_VALUE</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">configMAX_PRIORITIES</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">uxNewPriority</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e961 MISRA exception as the casts are only redundant for some ports. */</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="cm">/* If the task is in the blocked or suspended list we need do</span>
<span class="cm">                nothing more than change its priority variable. However, if</span>
<span class="cm">                the task is in a ready list it needs to be removed and placed</span>
<span class="cm">                in the list appropriate to its new priority. */</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listIS_CONTAINED_WITHIN</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxReadyTasksLists</span><span class="p">[</span><span class="w"> </span><span class="n">uxPriorityUsedOnEntry</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* The task is currently in its ready list - remove before</span>
<span class="cm">                    adding it to it&#39;s new ready list.  As we are in a critical</span>
<span class="cm">                    section we can do this even if the scheduler is suspended. */</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxListRemove</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="cm">/* It is known that the task is in its ready list so</span>
<span class="cm">                        there is no need to check again and the port level</span>
<span class="cm">                        reset macro can be called directly. */</span>
<span class="w">                        </span><span class="n">portRESET_READY_PRIORITY</span><span class="p">(</span><span class="w"> </span><span class="n">uxPriorityUsedOnEntry</span><span class="p">,</span><span class="w"> </span><span class="n">uxTopReadyPriority</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="n">prvAddTaskToReadyList</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xYieldRequired</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">taskYIELD_IF_USING_PREEMPTION</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="cm">/* Remove compiler warning about unused variables when the port</span>
<span class="cm">                optimised task selection is not being used. */</span>
<span class="w">                </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">uxPriorityUsedOnEntry</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* INCLUDE_vTaskPrioritySet */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( INCLUDE_vTaskSuspend == 1 )</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">vTaskSuspend</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTaskToSuspend</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTCB</span><span class="p">;</span>

<span class="w">        </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* If null is passed in here then it is the running task that is</span>
<span class="cm">            being suspended. */</span>
<span class="w">            </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvGetTCBFromHandle</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskToSuspend</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="n">traceTASK_SUSPEND</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="cm">/* Remove task from the ready/delayed list and place in the</span>
<span class="cm">            suspended list. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxListRemove</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">taskRESET_READY_PRIORITY</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="cm">/* Is the task waiting on an event also? */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_ITEM_CONTAINER</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">uxListRemove</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="n">vListInsertEnd</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xSuspendedTaskList</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="cp">#if( configUSE_TASK_NOTIFICATIONS == 1 )</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ucNotifyState</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">taskWAITING_NOTIFICATION</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* The task was blocked to wait for a notification, but is</span>
<span class="cm">                    now suspended, so no notification was received. */</span>
<span class="w">                    </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ucNotifyState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskNOT_WAITING_NOTIFICATION</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="cp">#endif</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xSchedulerRunning</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Reset the next expected unblock time in case it referred to the</span>
<span class="cm">            task that is now in the Suspended state. */</span>
<span class="w">            </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">prvResetNextTaskUnblockTime</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xSchedulerRunning</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* The current task has just been suspended. */</span>
<span class="w">                </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">uxSchedulerSuspended</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="n">portYIELD_WITHIN_API</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* The scheduler is not running, but the task that was pointed</span>
<span class="cm">                to by pxCurrentTCB has just been suspended and pxCurrentTCB</span>
<span class="cm">                must be adjusted to point to a different task. */</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listCURRENT_LIST_LENGTH</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xSuspendedTaskList</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">uxCurrentNumberOfTasks</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="cm">/*lint !e931 Right has no side effect, just volatile. */</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* No other tasks are ready, so set pxCurrentTCB back to</span>
<span class="cm">                    NULL so when the next task is created pxCurrentTCB will</span>
<span class="cm">                    be set to point to it no matter what its relative priority</span>
<span class="cm">                    is. */</span>
<span class="w">                    </span><span class="n">pxCurrentTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">vTaskSwitchContext</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* INCLUDE_vTaskSuspend */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( INCLUDE_vTaskSuspend == 1 )</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="nf">prvTaskIsTaskSuspended</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTask</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* Accesses xPendingReadyList so must be called from a critical</span>
<span class="cm">        section. */</span>

<span class="w">        </span><span class="cm">/* It does not make sense to check if the calling task is suspended. */</span>
<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* Is the task being resumed actually in the suspended list? */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listIS_CONTAINED_WITHIN</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xSuspendedTaskList</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Has the task already been resumed from within an ISR? */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listIS_CONTAINED_WITHIN</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xPendingReadyList</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Is it in the suspended list because it is in the Suspended</span>
<span class="cm">                state, or because is is blocked with no timeout? */</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listIS_CONTAINED_WITHIN</span><span class="p">(</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="cm">/*lint !e961.  The cast is only redundant when NULL is used. */</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="cm">/*lint !e818 xTask cannot be a pointer to const because it is a typedef. */</span>

<span class="cp">#endif </span><span class="cm">/* INCLUDE_vTaskSuspend */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( INCLUDE_vTaskSuspend == 1 )</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">vTaskResume</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTaskToResume</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTaskToResume</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* It does not make sense to resume the calling task. */</span>
<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskToResume</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* The parameter cannot be NULL as it is impossible to resume the</span>
<span class="cm">        currently executing task. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">prvTaskIsTaskSuspended</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">traceTASK_RESUME</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>

<span class="w">                    </span><span class="cm">/* The ready list can be accessed even if the scheduler is</span>
<span class="cm">                    suspended because this is inside a critical section. */</span>
<span class="w">                    </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">uxListRemove</span><span class="p">(</span><span class="w">  </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="n">prvAddTaskToReadyList</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>

<span class="w">                    </span><span class="cm">/* A higher priority task may have just been resumed. */</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="cm">/* This yield may not cause the task just resumed to run,</span>
<span class="cm">                        but will leave the lists in the correct state for the</span>
<span class="cm">                        next yield. */</span>
<span class="w">                        </span><span class="n">taskYIELD_IF_USING_PREEMPTION</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* INCLUDE_vTaskSuspend */</span>

<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) &amp;&amp; ( INCLUDE_vTaskSuspend == 1 ) )</span>

<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xTaskResumeFromISR</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTaskToResume</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xYieldRequired</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTaskToResume</span><span class="p">;</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxSavedInterruptStatus</span><span class="p">;</span>

<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskToResume</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* RTOS ports that support interrupt nesting have the concept of a</span>
<span class="cm">        maximum system call (or maximum API call) interrupt priority.</span>
<span class="cm">        Interrupts that are above the maximum system call priority are keep</span>
<span class="cm">        permanently enabled, even when the RTOS kernel is in a critical section,</span>
<span class="cm">        but cannot make any calls to FreeRTOS API functions.  If configASSERT()</span>
<span class="cm">        is defined in FreeRTOSConfig.h then</span>
<span class="cm">        portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion</span>
<span class="cm">        failure if a FreeRTOS API function is called from an interrupt that has</span>
<span class="cm">        been assigned a priority above the configured maximum system call</span>
<span class="cm">        priority.  Only FreeRTOS functions that end in FromISR can be called</span>
<span class="cm">        from interrupts that have been assigned a priority at or (logically)</span>
<span class="cm">        below the maximum system call interrupt priority.  FreeRTOS maintains a</span>
<span class="cm">        separate interrupt safe API to ensure interrupt entry is as fast and as</span>
<span class="cm">        simple as possible.  More information (albeit Cortex-M specific) is</span>
<span class="cm">        provided on the following link:</span>
<span class="cm">        https://www.freertos.org/RTOS-Cortex-M3-M4.html */</span>
<span class="w">        </span><span class="n">portASSERT_IF_INTERRUPT_PRIORITY_INVALID</span><span class="p">();</span>

<span class="w">        </span><span class="n">uxSavedInterruptStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">portSET_INTERRUPT_MASK_FROM_ISR</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">prvTaskIsTaskSuspended</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">traceTASK_RESUME_FROM_ISR</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>

<span class="w">                </span><span class="cm">/* Check the ready lists can be accessed. */</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxSchedulerSuspended</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* Ready lists can be accessed so move the task from the</span>
<span class="cm">                    suspended list to the ready list directly. */</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">xYieldRequired</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>

<span class="w">                    </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">uxListRemove</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="n">prvAddTaskToReadyList</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* The delayed or ready lists cannot be accessed so the task</span>
<span class="cm">                    is held in the pending ready list until the scheduler is</span>
<span class="cm">                    unsuspended. */</span>
<span class="w">                    </span><span class="n">vListInsertEnd</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">xPendingReadyList</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">portCLEAR_INTERRUPT_MASK_FROM_ISR</span><span class="p">(</span><span class="w"> </span><span class="n">uxSavedInterruptStatus</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xYieldRequired</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* ( ( INCLUDE_xTaskResumeFromISR == 1 ) &amp;&amp; ( INCLUDE_vTaskSuspend == 1 ) ) */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vTaskStartScheduler</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Add the idle task at the lowest priority. */</span>
<span class="w">    </span><span class="cp">#if( configSUPPORT_STATIC_ALLOCATION == 1 )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">StaticTask_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxIdleTaskTCBBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">        </span><span class="n">StackType_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxIdleTaskStackBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ulIdleTaskStackSize</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* The Idle task is created using user provided RAM - obtain the</span>
<span class="cm">        address of the RAM then create the idle task. */</span>
<span class="w">        </span><span class="n">vApplicationGetIdleTaskMemory</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pxIdleTaskTCBBuffer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pxIdleTaskStackBuffer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ulIdleTaskStackSize</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="n">xIdleTaskHandle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTaskCreateStatic</span><span class="p">(</span><span class="w">    </span><span class="n">prvIdleTask</span><span class="p">,</span>
<span class="w">                                                </span><span class="n">configIDLE_TASK_NAME</span><span class="p">,</span>
<span class="w">                                                </span><span class="n">ulIdleTaskStackSize</span><span class="p">,</span>
<span class="w">                                                </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="cm">/*lint !e961.  The cast is not redundant for all compilers. */</span>
<span class="w">                                                </span><span class="n">portPRIVILEGE_BIT</span><span class="p">,</span><span class="w"> </span><span class="cm">/* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */</span>
<span class="w">                                                </span><span class="n">pxIdleTaskStackBuffer</span><span class="p">,</span>
<span class="w">                                                </span><span class="n">pxIdleTaskTCBBuffer</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xIdleTaskHandle</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdPASS</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFAIL</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* The Idle task is being created using dynamically allocated RAM. */</span>
<span class="w">        </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTaskCreate</span><span class="p">(</span><span class="w">  </span><span class="n">prvIdleTask</span><span class="p">,</span>
<span class="w">                                </span><span class="n">configIDLE_TASK_NAME</span><span class="p">,</span>
<span class="w">                                </span><span class="n">configMINIMAL_STACK_SIZE</span><span class="p">,</span>
<span class="w">                                </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">                                </span><span class="n">portPRIVILEGE_BIT</span><span class="p">,</span><span class="w"> </span><span class="cm">/* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */</span>
<span class="w">                                </span><span class="o">&amp;</span><span class="n">xIdleTaskHandle</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif </span><span class="cm">/* configSUPPORT_STATIC_ALLOCATION */</span>

<span class="w">    </span><span class="cp">#if ( configUSE_TIMERS == 1 )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xReturn</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdPASS</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTimerCreateTimerTask</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif </span><span class="cm">/* configUSE_TIMERS */</span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xReturn</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdPASS</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* freertos_tasks_c_additions_init() should only be called if the user</span>
<span class="cm">        definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is</span>
<span class="cm">        the only macro called by the function. */</span>
<span class="w">        </span><span class="cp">#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">freertos_tasks_c_additions_init</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif</span>

<span class="w">        </span><span class="cm">/* Interrupts are turned off here, to ensure a tick does not occur</span>
<span class="cm">        before or during the call to xPortStartScheduler().  The stacks of</span>
<span class="cm">        the created tasks contain a status word with interrupts switched on</span>
<span class="cm">        so interrupts will automatically get re-enabled when the first task</span>
<span class="cm">        starts to run. */</span>
<span class="w">        </span><span class="n">portDISABLE_INTERRUPTS</span><span class="p">();</span>

<span class="w">        </span><span class="cp">#if ( configUSE_NEWLIB_REENTRANT == 1 )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Switch Newlib&#39;s _impure_ptr variable to point to the _reent</span>
<span class="cm">            structure specific to the task that will run first.</span>
<span class="cm">            See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html</span>
<span class="cm">            for additional information. */</span>
<span class="w">            </span><span class="n">_impure_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">xNewLib_reent</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif </span><span class="cm">/* configUSE_NEWLIB_REENTRANT */</span>

<span class="w">        </span><span class="n">xNextTaskUnblockTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">portMAX_DELAY</span><span class="p">;</span>
<span class="w">        </span><span class="n">xSchedulerRunning</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">        </span><span class="n">xTickCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">configINITIAL_TICK_COUNT</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* If configGENERATE_RUN_TIME_STATS is defined then the following</span>
<span class="cm">        macro must be defined to configure the timer/counter used to generate</span>
<span class="cm">        the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS</span>
<span class="cm">        is set to 0 and the following line fails to build then ensure you do not</span>
<span class="cm">        have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your</span>
<span class="cm">        FreeRTOSConfig.h file. */</span>
<span class="w">        </span><span class="n">portCONFIGURE_TIMER_FOR_RUN_TIME_STATS</span><span class="p">();</span>

<span class="w">        </span><span class="n">traceTASK_SWITCHED_IN</span><span class="p">();</span>

<span class="w">        </span><span class="cm">/* Setting up the timer tick is hardware specific and thus in the</span>
<span class="cm">        portable interface. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xPortStartScheduler</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Should not reach here as if the scheduler is running the</span>
<span class="cm">            function will not return. */</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Should only reach here if a task calls xTaskEndScheduler(). */</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* This line will only be reached if the kernel could not be started,</span>
<span class="cm">        because there was not enough FreeRTOS heap to create the idle task</span>
<span class="cm">        or the timer task. */</span>
<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">xReturn</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,</span>
<span class="cm">    meaning xIdleTaskHandle is not used anywhere else. */</span>
<span class="w">    </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xIdleTaskHandle</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vTaskEndScheduler</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* Stop the scheduler interrupts and call the portable scheduler end</span>
<span class="cm">    routine so the original ISRs can be restored if necessary.  The port</span>
<span class="cm">    layer must ensure interrupts enable bit is left in the correct state. */</span>
<span class="w">    </span><span class="n">portDISABLE_INTERRUPTS</span><span class="p">();</span>
<span class="w">    </span><span class="n">xSchedulerRunning</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="w">    </span><span class="n">vPortEndScheduler</span><span class="p">();</span>
<span class="p">}</span>
<span class="cm">/*----------------------------------------------------------*/</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vTaskSuspendAll</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* A critical section is not required as the variable is of type</span>
<span class="cm">    BaseType_t.  Please read Richard Barry&#39;s reply in the following link to a</span>
<span class="cm">    post in the FreeRTOS support forum before reporting this as a bug! -</span>
<span class="cm">    http://goo.gl/wu4acr */</span>

<span class="w">    </span><span class="cm">/* portSOFRWARE_BARRIER() is only implemented for emulated/simulated ports that</span>
<span class="cm">    do not otherwise exhibit real time behaviour. */</span>
<span class="w">    </span><span class="n">portSOFTWARE_BARRIER</span><span class="p">();</span>

<span class="w">    </span><span class="cm">/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment</span>
<span class="cm">    is used to allow calls to vTaskSuspendAll() to nest. */</span>
<span class="w">    </span><span class="o">++</span><span class="n">uxSchedulerSuspended</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Enforces ordering for ports and optimised compilers that may otherwise place</span>
<span class="cm">    the above increment elsewhere. */</span>
<span class="w">    </span><span class="n">portMEMORY_BARRIER</span><span class="p">();</span>
<span class="p">}</span>
<span class="cm">/*----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_TICKLESS_IDLE != 0 )</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="nf">prvGetExpectedIdleTime</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxHigherPriorityReadyTasks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* uxHigherPriorityReadyTasks takes care of the case where</span>
<span class="cm">        configUSE_PREEMPTION is 0, so there may be tasks above the idle priority</span>
<span class="cm">        task that are in the Ready state, even though the idle task is</span>
<span class="cm">        running. */</span>
<span class="w">        </span><span class="cp">#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxTopReadyPriority</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">tskIDLE_PRIORITY</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">uxHigherPriorityReadyTasks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxLeastSignificantBit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mh">0x01</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/* When port optimised task selection is used the uxTopReadyPriority</span>
<span class="cm">            variable is used as a bit map.  If bits other than the least</span>
<span class="cm">            significant bit are set then there are tasks that have a priority</span>
<span class="cm">            above the idle priority that are in the Ready state.  This takes</span>
<span class="cm">            care of the case where the co-operative scheduler is in use. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxTopReadyPriority</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">uxLeastSignificantBit</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">uxHigherPriorityReadyTasks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">tskIDLE_PRIORITY</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listCURRENT_LIST_LENGTH</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxReadyTasksLists</span><span class="p">[</span><span class="w"> </span><span class="n">tskIDLE_PRIORITY</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* There are other idle priority tasks in the ready state.  If</span>
<span class="cm">            time slicing is used then the very next tick interrupt must be</span>
<span class="cm">            processed. */</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxHigherPriorityReadyTasks</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* There are tasks in the Ready state that have a priority above the</span>
<span class="cm">            idle priority.  This path can only be reached if</span>
<span class="cm">            configUSE_PREEMPTION is 0. */</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xNextTaskUnblockTime</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xTickCount</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_TICKLESS_IDLE */</span>
<span class="cm">/*----------------------------------------------------------*/</span>

<span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xTaskResumeAll</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xAlreadyYielded</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* If uxSchedulerSuspended is zero then this function does not match a</span>
<span class="cm">    previous call to vTaskSuspendAll(). */</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">uxSchedulerSuspended</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* It is possible that an ISR caused a task to be removed from an event</span>
<span class="cm">    list while the scheduler was suspended.  If this was the case then the</span>
<span class="cm">    removed task will have been added to the xPendingReadyList.  Once the</span>
<span class="cm">    scheduler has been resumed it is safe to move all the pending ready</span>
<span class="cm">    tasks from this list into their appropriate ready list. */</span>
<span class="w">    </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="o">--</span><span class="n">uxSchedulerSuspended</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxSchedulerSuspended</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxCurrentNumberOfTasks</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0U</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Move any readied tasks from the pending list into the</span>
<span class="cm">                appropriate ready list. */</span>
<span class="w">                </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_IS_EMPTY</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xPendingReadyList</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">listGET_OWNER_OF_HEAD_ENTRY</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xPendingReadyList</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */</span>
<span class="w">                    </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">uxListRemove</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">uxListRemove</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="n">prvAddTaskToReadyList</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>

<span class="w">                    </span><span class="cm">/* If the moved task has a priority higher than the current</span>
<span class="cm">                    task then a yield must be performed. */</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">xYieldPending</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* A task was unblocked while the scheduler was suspended,</span>
<span class="cm">                    which may have prevented the next unblock time from being</span>
<span class="cm">                    re-calculated, in which case re-calculate it now.  Mainly</span>
<span class="cm">                    important for low power tickless implementations, where</span>
<span class="cm">                    this can prevent an unnecessary exit from low power</span>
<span class="cm">                    state. */</span>
<span class="w">                    </span><span class="n">prvResetNextTaskUnblockTime</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="cm">/* If any ticks occurred while the scheduler was suspended then</span>
<span class="cm">                they should be processed now.  This ensures the tick count does</span>
<span class="cm">                not slip, and that any delayed tasks are resumed at the correct</span>
<span class="cm">                time. */</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xPendedCounts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xPendedTicks</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Non-volatile copy. */</span>

<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xPendedCounts</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0U</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="k">do</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskIncrementTick</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                            </span><span class="p">{</span>
<span class="w">                                </span><span class="n">xYieldPending</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                            </span><span class="p">}</span>
<span class="w">                            </span><span class="k">else</span>
<span class="w">                            </span><span class="p">{</span>
<span class="w">                                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                            </span><span class="p">}</span>
<span class="w">                            </span><span class="o">--</span><span class="n">xPendedCounts</span><span class="p">;</span>
<span class="w">                        </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="n">xPendedCounts</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0U</span><span class="w"> </span><span class="p">);</span>

<span class="w">                        </span><span class="n">xPendedTicks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xYieldPending</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cp">#if( configUSE_PREEMPTION != 0 )</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">xAlreadyYielded</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="cp">#endif</span>
<span class="w">                    </span><span class="n">taskYIELD_IF_USING_PREEMPTION</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">xAlreadyYielded</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="n">TickType_t</span><span class="w"> </span><span class="nf">xTaskGetTickCount</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">TickType_t</span><span class="w"> </span><span class="n">xTicks</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Critical section required if running on a 16 bit processor. */</span>
<span class="w">    </span><span class="n">portTICK_TYPE_ENTER_CRITICAL</span><span class="p">();</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">xTicks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTickCount</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">portTICK_TYPE_EXIT_CRITICAL</span><span class="p">();</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">xTicks</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="n">TickType_t</span><span class="w"> </span><span class="nf">xTaskGetTickCountFromISR</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">TickType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxSavedInterruptStatus</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* RTOS ports that support interrupt nesting have the concept of a maximum</span>
<span class="cm">    system call (or maximum API call) interrupt priority.  Interrupts that are</span>
<span class="cm">    above the maximum system call priority are kept permanently enabled, even</span>
<span class="cm">    when the RTOS kernel is in a critical section, but cannot make any calls to</span>
<span class="cm">    FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h</span>
<span class="cm">    then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion</span>
<span class="cm">    failure if a FreeRTOS API function is called from an interrupt that has been</span>
<span class="cm">    assigned a priority above the configured maximum system call priority.</span>
<span class="cm">    Only FreeRTOS functions that end in FromISR can be called from interrupts</span>
<span class="cm">    that have been assigned a priority at or (logically) below the maximum</span>
<span class="cm">    system call interrupt priority.  FreeRTOS maintains a separate interrupt</span>
<span class="cm">    safe API to ensure interrupt entry is as fast and as simple as possible.</span>
<span class="cm">    More information (albeit Cortex-M specific) is provided on the following</span>
<span class="cm">    link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */</span>
<span class="w">    </span><span class="n">portASSERT_IF_INTERRUPT_PRIORITY_INVALID</span><span class="p">();</span>

<span class="w">    </span><span class="n">uxSavedInterruptStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR</span><span class="p">();</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTickCount</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR</span><span class="p">(</span><span class="w"> </span><span class="n">uxSavedInterruptStatus</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="n">UBaseType_t</span><span class="w"> </span><span class="nf">uxTaskGetNumberOfTasks</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* A critical section is not required because the variables are of type</span>
<span class="cm">    BaseType_t. */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">uxCurrentNumberOfTasks</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">pcTaskGetName</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTaskToQuery</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="cm">/*lint !e971 Unqualified char types are allowed for strings and single characters only. */</span>
<span class="p">{</span>
<span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTCB</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* If null is passed in here then the name of the calling task is being</span>
<span class="cm">    queried. */</span>
<span class="w">    </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvGetTCBFromHandle</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskToQuery</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">pcTaskName</span><span class="p">[</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( INCLUDE_xTaskGetHandle == 1 )</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="nf">prvSearchForNameWithinSingleList</span><span class="p">(</span><span class="w"> </span><span class="n">List_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxList</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">pcNameToQuery</span><span class="p">[]</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxNextTCB</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">pxFirstTCB</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">pxReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">cNextChar</span><span class="p">;</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xBreakLoop</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* This function is called with the scheduler suspended. */</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listCURRENT_LIST_LENGTH</span><span class="p">(</span><span class="w"> </span><span class="n">pxList</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">listGET_OWNER_OF_NEXT_ENTRY</span><span class="p">(</span><span class="w"> </span><span class="n">pxFirstTCB</span><span class="p">,</span><span class="w"> </span><span class="n">pxList</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="cm">/*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */</span>

<span class="w">            </span><span class="k">do</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">listGET_OWNER_OF_NEXT_ENTRY</span><span class="p">(</span><span class="w"> </span><span class="n">pxNextTCB</span><span class="p">,</span><span class="w"> </span><span class="n">pxList</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */</span>

<span class="w">                </span><span class="cm">/* Check each character in the name looking for a match or</span>
<span class="cm">                mismatch. */</span>
<span class="w">                </span><span class="n">xBreakLoop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="w">                </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">configMAX_TASK_NAME_LEN</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">cNextChar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxNextTCB</span><span class="o">-&gt;</span><span class="n">pcTaskName</span><span class="p">[</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">];</span>

<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">cNextChar</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pcNameToQuery</span><span class="p">[</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="cm">/* Characters didn&#39;t match. */</span>
<span class="w">                        </span><span class="n">xBreakLoop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">cNextChar</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mh">0x00</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="cm">/* Both strings terminated, a match must have been</span>
<span class="cm">                        found. */</span>
<span class="w">                        </span><span class="n">pxReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxNextTCB</span><span class="p">;</span>
<span class="w">                        </span><span class="n">xBreakLoop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>

<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xBreakLoop</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="k">break</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxReturn</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* The handle has been found. */</span>
<span class="w">                    </span><span class="k">break</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="n">pxNextTCB</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pxFirstTCB</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">pxReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* INCLUDE_xTaskGetHandle */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( INCLUDE_xTaskGetHandle == 1 )</span>

<span class="w">    </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="nf">xTaskGetHandle</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">pcNameToQuery</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="cm">/*lint !e971 Unqualified char types are allowed for strings and single characters only. */</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">configMAX_PRIORITIES</span><span class="p">;</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="o">*</span><span class="w"> </span><span class="n">pxTCB</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */</span>
<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="w"> </span><span class="n">pcNameToQuery</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">configMAX_TASK_NAME_LEN</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="n">vTaskSuspendAll</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Search the ready lists. */</span>
<span class="w">            </span><span class="k">do</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">uxQueue</span><span class="o">--</span><span class="p">;</span>
<span class="w">                </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvSearchForNameWithinSingleList</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">List_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxReadyTasksLists</span><span class="p">[</span><span class="w"> </span><span class="n">uxQueue</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="n">pcNameToQuery</span><span class="w"> </span><span class="p">);</span>

<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* Found the handle. */</span>
<span class="w">                    </span><span class="k">break</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="n">uxQueue</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">tskIDLE_PRIORITY</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e961 MISRA exception as the casts are only redundant for some ports. */</span>

<span class="w">            </span><span class="cm">/* Search the delayed lists. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvSearchForNameWithinSingleList</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">List_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxDelayedTaskList</span><span class="p">,</span><span class="w"> </span><span class="n">pcNameToQuery</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvSearchForNameWithinSingleList</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">List_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxOverflowDelayedTaskList</span><span class="p">,</span><span class="w"> </span><span class="n">pcNameToQuery</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="cp">#if ( INCLUDE_vTaskSuspend == 1 )</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* Search the suspended list. */</span>
<span class="w">                    </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvSearchForNameWithinSingleList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xSuspendedTaskList</span><span class="p">,</span><span class="w"> </span><span class="n">pcNameToQuery</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="cp">#endif</span>

<span class="w">            </span><span class="cp">#if( INCLUDE_vTaskDelete == 1 )</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* Search the deleted list. */</span>
<span class="w">                    </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvSearchForNameWithinSingleList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xTasksWaitingTermination</span><span class="p">,</span><span class="w"> </span><span class="n">pcNameToQuery</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="cp">#endif</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xTaskResumeAll</span><span class="p">();</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">pxTCB</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* INCLUDE_xTaskGetHandle */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_TRACE_FACILITY == 1 )</span>

<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="nf">uxTaskGetSystemState</span><span class="p">(</span><span class="w"> </span><span class="n">TaskStatus_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxArraySize</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pulTotalRunTime</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxTask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">uxQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">configMAX_PRIORITIES</span><span class="p">;</span>

<span class="w">        </span><span class="n">vTaskSuspendAll</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Is there a space in the array for each task in the system? */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxArraySize</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">uxCurrentNumberOfTasks</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Fill in an TaskStatus_t structure with information on each</span>
<span class="cm">                task in the Ready state. */</span>
<span class="w">                </span><span class="k">do</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">uxQueue</span><span class="o">--</span><span class="p">;</span>
<span class="w">                    </span><span class="n">uxTask</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">prvListTasksWithinSingleList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">[</span><span class="w"> </span><span class="n">uxTask</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxReadyTasksLists</span><span class="p">[</span><span class="w"> </span><span class="n">uxQueue</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="n">eReady</span><span class="w"> </span><span class="p">);</span>

<span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="n">uxQueue</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">tskIDLE_PRIORITY</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e961 MISRA exception as the casts are only redundant for some ports. */</span>

<span class="w">                </span><span class="cm">/* Fill in an TaskStatus_t structure with information on each</span>
<span class="cm">                task in the Blocked state. */</span>
<span class="w">                </span><span class="n">uxTask</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">prvListTasksWithinSingleList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">[</span><span class="w"> </span><span class="n">uxTask</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">List_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxDelayedTaskList</span><span class="p">,</span><span class="w"> </span><span class="n">eBlocked</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="n">uxTask</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">prvListTasksWithinSingleList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">[</span><span class="w"> </span><span class="n">uxTask</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">List_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxOverflowDelayedTaskList</span><span class="p">,</span><span class="w"> </span><span class="n">eBlocked</span><span class="w"> </span><span class="p">);</span>

<span class="w">                </span><span class="cp">#if( INCLUDE_vTaskDelete == 1 )</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* Fill in an TaskStatus_t structure with information on</span>
<span class="cm">                    each task that has been deleted but not yet cleaned up. */</span>
<span class="w">                    </span><span class="n">uxTask</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">prvListTasksWithinSingleList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">[</span><span class="w"> </span><span class="n">uxTask</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xTasksWaitingTermination</span><span class="p">,</span><span class="w"> </span><span class="n">eDeleted</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="cp">#endif</span>

<span class="w">                </span><span class="cp">#if ( INCLUDE_vTaskSuspend == 1 )</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* Fill in an TaskStatus_t structure with information on</span>
<span class="cm">                    each task in the Suspended state. */</span>
<span class="w">                    </span><span class="n">uxTask</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">prvListTasksWithinSingleList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">[</span><span class="w"> </span><span class="n">uxTask</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xSuspendedTaskList</span><span class="p">,</span><span class="w"> </span><span class="n">eSuspended</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="cp">#endif</span>

<span class="w">                </span><span class="cp">#if ( configGENERATE_RUN_TIME_STATS == 1)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pulTotalRunTime</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="cp">#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE</span>
<span class="w">                            </span><span class="n">portALT_GET_RUN_TIME_COUNTER_VALUE</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="o">*</span><span class="n">pulTotalRunTime</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">                        </span><span class="cp">#else</span>
<span class="w">                            </span><span class="o">*</span><span class="n">pulTotalRunTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">portGET_RUN_TIME_COUNTER_VALUE</span><span class="p">();</span>
<span class="w">                        </span><span class="cp">#endif</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="cp">#else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pulTotalRunTime</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="o">*</span><span class="n">pulTotalRunTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="cp">#endif</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xTaskResumeAll</span><span class="p">();</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">uxTask</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_TRACE_FACILITY */</span>
<span class="cm">/*----------------------------------------------------------*/</span>

<span class="cp">#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )</span>

<span class="w">    </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="nf">xTaskGetIdleTaskHandle</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* If xTaskGetIdleTaskHandle() is called before the scheduler has been</span>
<span class="cm">        started, then xIdleTaskHandle will be NULL. */</span>
<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xIdleTaskHandle</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xIdleTaskHandle</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* INCLUDE_xTaskGetIdleTaskHandle */</span>
<span class="cm">/*----------------------------------------------------------*/</span>

<span class="cm">/* This conditional compilation should use inequality to 0, not equality to 1.</span>
<span class="cm">This is to ensure vTaskStepTick() is available when user defined low power mode</span>
<span class="cm">implementations require configUSE_TICKLESS_IDLE to be set to a value other than</span>
<span class="cm">1. */</span>
<span class="cp">#if ( configUSE_TICKLESS_IDLE != 0 )</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">vTaskStepTick</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xTicksToJump</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Correct the tick count value after a period during which the tick</span>
<span class="cm">        was suppressed.  Note this does *not* call the tick hook function for</span>
<span class="cm">        each stepped tick. */</span>
<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xTickCount</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">xTicksToJump</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">xNextTaskUnblockTime</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="n">xTickCount</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">xTicksToJump</span><span class="p">;</span>
<span class="w">        </span><span class="n">traceINCREASE_TICK_COUNT</span><span class="p">(</span><span class="w"> </span><span class="n">xTicksToJump</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_TICKLESS_IDLE */</span>
<span class="cm">/*----------------------------------------------------------*/</span>

<span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xTaskCatchUpTicks</span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xTicksToCatchUp</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xYieldRequired</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Must not be called with the scheduler suspended as the implementation</span>
<span class="cm">    relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">uxSchedulerSuspended</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when</span>
<span class="cm">    the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */</span>
<span class="w">    </span><span class="n">vTaskSuspendAll</span><span class="p">();</span>
<span class="w">    </span><span class="n">xPendedTicks</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">xTicksToCatchUp</span><span class="p">;</span>
<span class="w">    </span><span class="n">xYieldRequired</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTaskResumeAll</span><span class="p">();</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">xYieldRequired</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*----------------------------------------------------------*/</span>

<span class="cp">#if ( INCLUDE_xTaskAbortDelay == 1 )</span>

<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xTaskAbortDelay</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTask</span><span class="p">;</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>

<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="n">vTaskSuspendAll</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* A task can only be prematurely removed from the Blocked state if</span>
<span class="cm">            it is actually in the Blocked state. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">eTaskGetState</span><span class="p">(</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">eBlocked</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdPASS</span><span class="p">;</span>

<span class="w">                </span><span class="cm">/* Remove the reference to the task from the blocked list.  An</span>
<span class="cm">                interrupt won&#39;t touch the xStateListItem because the</span>
<span class="cm">                scheduler is suspended. */</span>
<span class="w">                </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">uxListRemove</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">                </span><span class="cm">/* Is the task waiting on an event also?  If so remove it from</span>
<span class="cm">                the event list too.  Interrupts can touch the event list item,</span>
<span class="cm">                even though the scheduler is suspended, so a critical section</span>
<span class="cm">                is used. */</span>
<span class="w">                </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_ITEM_CONTAINER</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">uxListRemove</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">                        </span><span class="cm">/* This lets the task know it was forcibly removed from the</span>
<span class="cm">                        blocked state so it should not re-evaluate its block time and</span>
<span class="cm">                        then block again. */</span>
<span class="w">                        </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ucDelayAborted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">                </span><span class="cm">/* Place the unblocked task into the appropriate ready list. */</span>
<span class="w">                </span><span class="n">prvAddTaskToReadyList</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>

<span class="w">                </span><span class="cm">/* A task being unblocked cannot cause an immediate context</span>
<span class="cm">                switch if preemption is turned off. */</span>
<span class="w">                </span><span class="cp">#if (  configUSE_PREEMPTION == 1 )</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* Preemption is on, but a context switch should only be</span>
<span class="cm">                    performed if the unblocked task has a priority that is</span>
<span class="cm">                    equal to or higher than the currently executing task. */</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="cm">/* Pend the yield to be performed when the scheduler</span>
<span class="cm">                        is unsuspended. */</span>
<span class="w">                        </span><span class="n">xYieldPending</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="cp">#endif </span><span class="cm">/* configUSE_PREEMPTION */</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFAIL</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xTaskResumeAll</span><span class="p">();</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* INCLUDE_xTaskAbortDelay */</span>
<span class="cm">/*----------------------------------------------------------*/</span>

<span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xTaskIncrementTick</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pxTCB</span><span class="p">;</span>
<span class="n">TickType_t</span><span class="w"> </span><span class="n">xItemValue</span><span class="p">;</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xSwitchRequired</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Called by the portable layer each time a tick interrupt occurs.</span>
<span class="cm">    Increments the tick then checks to see if the new tick value will cause any</span>
<span class="cm">    tasks to be unblocked. */</span>
<span class="w">    </span><span class="n">traceTASK_INCREMENT_TICK</span><span class="p">(</span><span class="w"> </span><span class="n">xTickCount</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxSchedulerSuspended</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Minor optimisation.  The tick count cannot change in this</span>
<span class="cm">        block. */</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xConstTickCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTickCount</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* Increment the RTOS tick, switching the delayed and overflowed</span>
<span class="cm">        delayed lists if it wraps to 0. */</span>
<span class="w">        </span><span class="n">xTickCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xConstTickCount</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xConstTickCount</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0U</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="cm">/*lint !e774 &#39;if&#39; does not always evaluate to false as it is looking for an overflow. */</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">taskSWITCH_DELAYED_LISTS</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/* See if this tick has made a timeout expire.  Tasks are stored in</span>
<span class="cm">        the queue in the order of their wake time - meaning once one task</span>
<span class="cm">        has been found whose block time has not expired there is no need to</span>
<span class="cm">        look any further down the list. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xConstTickCount</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">xNextTaskUnblockTime</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="p">;;</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_IS_EMPTY</span><span class="p">(</span><span class="w"> </span><span class="n">pxDelayedTaskList</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* The delayed list is empty.  Set xNextTaskUnblockTime</span>
<span class="cm">                    to the maximum possible value so it is extremely</span>
<span class="cm">                    unlikely that the</span>
<span class="cm">                    if( xTickCount &gt;= xNextTaskUnblockTime ) test will pass</span>
<span class="cm">                    next time through. */</span>
<span class="w">                    </span><span class="n">xNextTaskUnblockTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">portMAX_DELAY</span><span class="p">;</span><span class="w"> </span><span class="cm">/*lint !e961 MISRA exception as the casts are only redundant for some ports. */</span>
<span class="w">                    </span><span class="k">break</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* The delayed list is not empty, get the value of the</span>
<span class="cm">                    item at the head of the delayed list.  This is the time</span>
<span class="cm">                    at which the task at the head of the delayed list must</span>
<span class="cm">                    be removed from the Blocked state. */</span>
<span class="w">                    </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">listGET_OWNER_OF_HEAD_ENTRY</span><span class="p">(</span><span class="w"> </span><span class="n">pxDelayedTaskList</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */</span>
<span class="w">                    </span><span class="n">xItemValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">listGET_LIST_ITEM_VALUE</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xConstTickCount</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">xItemValue</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="cm">/* It is not time to unblock this item yet, but the</span>
<span class="cm">                        item value is the time at which the task at the head</span>
<span class="cm">                        of the blocked list must be removed from the Blocked</span>
<span class="cm">                        state - so record the item value in</span>
<span class="cm">                        xNextTaskUnblockTime. */</span>
<span class="w">                        </span><span class="n">xNextTaskUnblockTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xItemValue</span><span class="p">;</span>
<span class="w">                        </span><span class="k">break</span><span class="p">;</span><span class="w"> </span><span class="cm">/*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>

<span class="w">                    </span><span class="cm">/* It is time to remove the item from the Blocked state. */</span>
<span class="w">                    </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">uxListRemove</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">                    </span><span class="cm">/* Is the task waiting on an event also?  If so remove</span>
<span class="cm">                    it from the event list. */</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_ITEM_CONTAINER</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">uxListRemove</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>

<span class="w">                    </span><span class="cm">/* Place the unblocked task into the appropriate ready</span>
<span class="cm">                    list. */</span>
<span class="w">                    </span><span class="n">prvAddTaskToReadyList</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>

<span class="w">                    </span><span class="cm">/* A task being unblocked cannot cause an immediate</span>
<span class="cm">                    context switch if preemption is turned off. */</span>
<span class="w">                    </span><span class="cp">#if (  configUSE_PREEMPTION == 1 )</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="cm">/* Preemption is on, but a context switch should</span>
<span class="cm">                        only be performed if the unblocked task has a</span>
<span class="cm">                        priority that is equal to or higher than the</span>
<span class="cm">                        currently executing task. */</span>
<span class="w">                        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="p">)</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="n">xSwitchRequired</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="k">else</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="cp">#endif </span><span class="cm">/* configUSE_PREEMPTION */</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/* Tasks of equal priority to the currently running task will share</span>
<span class="cm">        processing time (time slice) if preemption is on, and the application</span>
<span class="cm">        writer has not explicitly turned time slicing off. */</span>
<span class="w">        </span><span class="cp">#if ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configUSE_TIME_SLICING == 1 ) )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listCURRENT_LIST_LENGTH</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxReadyTasksLists</span><span class="p">[</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">xSwitchRequired</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif </span><span class="cm">/* ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configUSE_TIME_SLICING == 1 ) ) */</span>

<span class="w">        </span><span class="cp">#if ( configUSE_TICK_HOOK == 1 )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Guard against the tick hook being called when the pended tick</span>
<span class="cm">            count is being unwound (when the scheduler is being unlocked). */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xPendedTicks</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">vApplicationTickHook</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif </span><span class="cm">/* configUSE_TICK_HOOK */</span>

<span class="w">        </span><span class="cp">#if ( configUSE_PREEMPTION == 1 )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xYieldPending</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">xSwitchRequired</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif </span><span class="cm">/* configUSE_PREEMPTION */</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="o">++</span><span class="n">xPendedTicks</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* The tick hook gets called at regular intervals, even if the</span>
<span class="cm">        scheduler is locked. */</span>
<span class="w">        </span><span class="cp">#if ( configUSE_TICK_HOOK == 1 )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">vApplicationTickHook</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">xSwitchRequired</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_APPLICATION_TASK_TAG == 1 )</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">vTaskSetApplicationTaskTag</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTask</span><span class="p">,</span><span class="w"> </span><span class="n">TaskHookFunction_t</span><span class="w"> </span><span class="n">pxHookFunction</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">xTCB</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* If xTask is NULL then it is the task hook of the calling task that is</span>
<span class="cm">        getting set. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTask</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/* Save the hook function in the TCB.  A critical section is required as</span>
<span class="cm">        the value can be accessed from an interrupt. */</span>
<span class="w">        </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xTCB</span><span class="o">-&gt;</span><span class="n">pxTaskTag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxHookFunction</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_APPLICATION_TASK_TAG */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_APPLICATION_TASK_TAG == 1 )</span>

<span class="w">    </span><span class="n">TaskHookFunction_t</span><span class="w"> </span><span class="nf">xTaskGetApplicationTaskTag</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTCB</span><span class="p">;</span>
<span class="w">    </span><span class="n">TaskHookFunction_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* If xTask is NULL then set the calling task&#39;s hook. */</span>
<span class="w">        </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvGetTCBFromHandle</span><span class="p">(</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* Save the hook function in the TCB.  A critical section is required as</span>
<span class="cm">        the value can be accessed from an interrupt. */</span>
<span class="w">        </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">pxTaskTag</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_APPLICATION_TASK_TAG */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_APPLICATION_TASK_TAG == 1 )</span>

<span class="w">    </span><span class="n">TaskHookFunction_t</span><span class="w"> </span><span class="nf">xTaskGetApplicationTaskTagFromISR</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTCB</span><span class="p">;</span>
<span class="w">    </span><span class="n">TaskHookFunction_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxSavedInterruptStatus</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* If xTask is NULL then set the calling task&#39;s hook. */</span>
<span class="w">        </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvGetTCBFromHandle</span><span class="p">(</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* Save the hook function in the TCB.  A critical section is required as</span>
<span class="cm">        the value can be accessed from an interrupt. */</span>
<span class="w">        </span><span class="n">uxSavedInterruptStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">portSET_INTERRUPT_MASK_FROM_ISR</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">pxTaskTag</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">portCLEAR_INTERRUPT_MASK_FROM_ISR</span><span class="p">(</span><span class="w"> </span><span class="n">uxSavedInterruptStatus</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_APPLICATION_TASK_TAG */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_APPLICATION_TASK_TAG == 1 )</span>

<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xTaskCallApplicationTaskHook</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTask</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvParameter</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">xTCB</span><span class="p">;</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* If xTask is NULL then we are calling our own task hook. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTask</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTCB</span><span class="o">-&gt;</span><span class="n">pxTaskTag</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTCB</span><span class="o">-&gt;</span><span class="n">pxTaskTag</span><span class="p">(</span><span class="w"> </span><span class="n">pvParameter</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFAIL</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_APPLICATION_TASK_TAG */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vTaskSwitchContext</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxSchedulerSuspended</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* The scheduler is currently suspended - do not allow a context</span>
<span class="cm">        switch. */</span>
<span class="w">        </span><span class="n">xYieldPending</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">xYieldPending</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="w">        </span><span class="n">traceTASK_SWITCHED_OUT</span><span class="p">();</span>

<span class="w">        </span><span class="cp">#if ( configGENERATE_RUN_TIME_STATS == 1 )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cp">#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE</span>
<span class="w">                </span><span class="n">portALT_GET_RUN_TIME_COUNTER_VALUE</span><span class="p">(</span><span class="w"> </span><span class="n">ulTotalRunTime</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="cp">#else</span>
<span class="w">                </span><span class="n">ulTotalRunTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">portGET_RUN_TIME_COUNTER_VALUE</span><span class="p">();</span>
<span class="w">            </span><span class="cp">#endif</span>

<span class="w">            </span><span class="cm">/* Add the amount of time the task has been running to the</span>
<span class="cm">            accumulated time so far.  The time the task started running was</span>
<span class="cm">            stored in ulTaskSwitchedInTime.  Note that there is no overflow</span>
<span class="cm">            protection here so count values are only valid until the timer</span>
<span class="cm">            overflows.  The guard against negative values is to protect</span>
<span class="cm">            against suspect run time stat counter implementations - which</span>
<span class="cm">            are provided by the application, not the kernel. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">ulTotalRunTime</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">ulTaskSwitchedInTime</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">ulRunTimeCounter</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">ulTotalRunTime</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ulTaskSwitchedInTime</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">ulTaskSwitchedInTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ulTotalRunTime</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif </span><span class="cm">/* configGENERATE_RUN_TIME_STATS */</span>

<span class="w">        </span><span class="cm">/* Check for stack overflow, if configured. */</span>
<span class="w">        </span><span class="n">taskCHECK_FOR_STACK_OVERFLOW</span><span class="p">();</span>

<span class="w">        </span><span class="cm">/* Before the currently running task is switched out, save its errno. */</span>
<span class="w">        </span><span class="cp">#if( configUSE_POSIX_ERRNO == 1 )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">iTaskErrno</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FreeRTOS_errno</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif</span>

<span class="w">        </span><span class="cm">/* Select a new task to run using either the generic C or port</span>
<span class="cm">        optimised asm code. */</span>
<span class="w">        </span><span class="n">taskSELECT_HIGHEST_PRIORITY_TASK</span><span class="p">();</span><span class="w"> </span><span class="cm">/*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */</span>
<span class="w">        </span><span class="n">traceTASK_SWITCHED_IN</span><span class="p">();</span>

<span class="w">        </span><span class="cm">/* After the new task is switched in, update the global errno. */</span>
<span class="w">        </span><span class="cp">#if( configUSE_POSIX_ERRNO == 1 )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">FreeRTOS_errno</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">iTaskErrno</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif</span>

<span class="w">        </span><span class="cp">#if ( configUSE_NEWLIB_REENTRANT == 1 )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Switch Newlib&#39;s _impure_ptr variable to point to the _reent</span>
<span class="cm">            structure specific to this task.</span>
<span class="cm">            See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html</span>
<span class="cm">            for additional information. */</span>
<span class="w">            </span><span class="n">_impure_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">xNewLib_reent</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif </span><span class="cm">/* configUSE_NEWLIB_REENTRANT */</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vTaskPlaceOnEventList</span><span class="p">(</span><span class="w"> </span><span class="n">List_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxEventList</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxEventList</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE</span>
<span class="cm">    SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */</span>

<span class="w">    </span><span class="cm">/* Place the event list item of the TCB in the appropriate event list.</span>
<span class="cm">    This is placed in the list in priority order so the highest priority task</span>
<span class="cm">    is the first to be woken by the event.  The queue that contains the event</span>
<span class="cm">    list is locked, preventing simultaneous access from interrupts. */</span>
<span class="w">    </span><span class="n">vListInsert</span><span class="p">(</span><span class="w"> </span><span class="n">pxEventList</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="n">prvAddCurrentTaskToDelayedList</span><span class="p">(</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="p">,</span><span class="w"> </span><span class="n">pdTRUE</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vTaskPlaceOnUnorderedEventList</span><span class="p">(</span><span class="w"> </span><span class="n">List_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pxEventList</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xItemValue</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxEventList</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by</span>
<span class="cm">    the event groups implementation. */</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">uxSchedulerSuspended</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Store the item value in the event list item.  It is safe to access the</span>
<span class="cm">    event list item here as interrupts won&#39;t access the event list item of a</span>
<span class="cm">    task that is not in the Blocked state. */</span>
<span class="w">    </span><span class="n">listSET_LIST_ITEM_VALUE</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="n">xItemValue</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">taskEVENT_LIST_ITEM_VALUE_IN_USE</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Place the event list item of the TCB at the end of the appropriate event</span>
<span class="cm">    list.  It is safe to access the event list here because it is part of an</span>
<span class="cm">    event group implementation - and interrupts don&#39;t access event groups</span>
<span class="cm">    directly (instead they access them indirectly by pending function calls to</span>
<span class="cm">    the task level). */</span>
<span class="w">    </span><span class="n">vListInsertEnd</span><span class="p">(</span><span class="w"> </span><span class="n">pxEventList</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="n">prvAddCurrentTaskToDelayedList</span><span class="p">(</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="p">,</span><span class="w"> </span><span class="n">pdTRUE</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if( configUSE_TIMERS == 1 )</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">vTaskPlaceOnEventListRestricted</span><span class="p">(</span><span class="w"> </span><span class="n">List_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxEventList</span><span class="p">,</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xWaitIndefinitely</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxEventList</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* This function should not be called by application code hence the</span>
<span class="cm">        &#39;Restricted&#39; in its name.  It is not part of the public API.  It is</span>
<span class="cm">        designed for use by kernel code, and has special calling requirements -</span>
<span class="cm">        it should be called with the scheduler suspended. */</span>


<span class="w">        </span><span class="cm">/* Place the event list item of the TCB in the appropriate event list.</span>
<span class="cm">        In this case it is assume that this is the only task that is going to</span>
<span class="cm">        be waiting on this event list, so the faster vListInsertEnd() function</span>
<span class="cm">        can be used in place of vListInsert. */</span>
<span class="w">        </span><span class="n">vListInsertEnd</span><span class="p">(</span><span class="w"> </span><span class="n">pxEventList</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* If the task should block indefinitely then set the block time to a</span>
<span class="cm">        value that will be recognised as an indefinite delay inside the</span>
<span class="cm">        prvAddCurrentTaskToDelayedList() function. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xWaitIndefinitely</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">portMAX_DELAY</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">traceTASK_DELAY_UNTIL</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xTickCount</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="n">prvAddCurrentTaskToDelayedList</span><span class="p">(</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="p">,</span><span class="w"> </span><span class="n">xWaitIndefinitely</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_TIMERS */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xTaskRemoveFromEventList</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">List_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxEventList</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxUnblockedTCB</span><span class="p">;</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be</span>
<span class="cm">    called from a critical section within an ISR. */</span>

<span class="w">    </span><span class="cm">/* The event list is sorted in priority order, so the first in the list can</span>
<span class="cm">    be removed as it is known to be the highest priority.  Remove the TCB from</span>
<span class="cm">    the delayed list, and add it to the ready list.</span>

<span class="cm">    If an event is for a queue that is locked then this function will never</span>
<span class="cm">    get called - the lock count on the queue will get modified instead.  This</span>
<span class="cm">    means exclusive access to the event list is guaranteed here.</span>

<span class="cm">    This function assumes that a check has already been made to ensure that</span>
<span class="cm">    pxEventList is not empty. */</span>
<span class="w">    </span><span class="n">pxUnblockedTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">listGET_OWNER_OF_HEAD_ENTRY</span><span class="p">(</span><span class="w"> </span><span class="n">pxEventList</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxUnblockedTCB</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">uxListRemove</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxUnblockedTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxSchedulerSuspended</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">uxListRemove</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxUnblockedTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="n">prvAddTaskToReadyList</span><span class="p">(</span><span class="w"> </span><span class="n">pxUnblockedTCB</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cp">#if( configUSE_TICKLESS_IDLE != 0 )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* If a task is blocked on a kernel object then xNextTaskUnblockTime</span>
<span class="cm">            might be set to the blocked task&#39;s time out time.  If the task is</span>
<span class="cm">            unblocked for a reason other than a timeout xNextTaskUnblockTime is</span>
<span class="cm">            normally left unchanged, because it is automatically reset to a new</span>
<span class="cm">            value when the tick count equals xNextTaskUnblockTime.  However if</span>
<span class="cm">            tickless idling is used it might be more important to enter sleep mode</span>
<span class="cm">            at the earliest possible time - so reset xNextTaskUnblockTime here to</span>
<span class="cm">            ensure it is updated at the earliest possible time. */</span>
<span class="w">            </span><span class="n">prvResetNextTaskUnblockTime</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* The delayed and ready lists cannot be accessed, so hold this task</span>
<span class="cm">        pending until the scheduler is resumed. */</span>
<span class="w">        </span><span class="n">vListInsertEnd</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">xPendingReadyList</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxUnblockedTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxUnblockedTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Return true if the task removed from the event list has a higher</span>
<span class="cm">        priority than the calling task.  This allows the calling task to know if</span>
<span class="cm">        it should force a context switch now. */</span>
<span class="w">        </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* Mark that a yield is pending in case the user is not using the</span>
<span class="cm">        &quot;xHigherPriorityTaskWoken&quot; parameter to an ISR safe FreeRTOS function. */</span>
<span class="w">        </span><span class="n">xYieldPending</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vTaskRemoveFromUnorderedEventList</span><span class="p">(</span><span class="w"> </span><span class="n">ListItem_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pxEventListItem</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xItemValue</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxUnblockedTCB</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by</span>
<span class="cm">    the event flags implementation. */</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">uxSchedulerSuspended</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Store the new item value in the event list. */</span>
<span class="w">    </span><span class="n">listSET_LIST_ITEM_VALUE</span><span class="p">(</span><span class="w"> </span><span class="n">pxEventListItem</span><span class="p">,</span><span class="w"> </span><span class="n">xItemValue</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">taskEVENT_LIST_ITEM_VALUE_IN_USE</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Remove the event list form the event flag.  Interrupts do not access</span>
<span class="cm">    event flags. */</span>
<span class="w">    </span><span class="n">pxUnblockedTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">listGET_LIST_ITEM_OWNER</span><span class="p">(</span><span class="w"> </span><span class="n">pxEventListItem</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxUnblockedTCB</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">uxListRemove</span><span class="p">(</span><span class="w"> </span><span class="n">pxEventListItem</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cp">#if( configUSE_TICKLESS_IDLE != 0 )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* If a task is blocked on a kernel object then xNextTaskUnblockTime</span>
<span class="cm">        might be set to the blocked task&#39;s time out time.  If the task is</span>
<span class="cm">        unblocked for a reason other than a timeout xNextTaskUnblockTime is</span>
<span class="cm">        normally left unchanged, because it is automatically reset to a new</span>
<span class="cm">        value when the tick count equals xNextTaskUnblockTime.  However if</span>
<span class="cm">        tickless idling is used it might be more important to enter sleep mode</span>
<span class="cm">        at the earliest possible time - so reset xNextTaskUnblockTime here to</span>
<span class="cm">        ensure it is updated at the earliest possible time. */</span>
<span class="w">        </span><span class="n">prvResetNextTaskUnblockTime</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="w">    </span><span class="cm">/* Remove the task from the delayed list and add it to the ready list.  The</span>
<span class="cm">    scheduler is suspended so interrupts will not be accessing the ready</span>
<span class="cm">    lists. */</span>
<span class="w">    </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">uxListRemove</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxUnblockedTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">prvAddTaskToReadyList</span><span class="p">(</span><span class="w"> </span><span class="n">pxUnblockedTCB</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxUnblockedTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* The unblocked task has a priority above that of the calling task, so</span>
<span class="cm">        a context switch is required.  This function is called with the</span>
<span class="cm">        scheduler suspended so xYieldPending is set so the context switch</span>
<span class="cm">        occurs immediately that the scheduler is resumed (unsuspended). */</span>
<span class="w">        </span><span class="n">xYieldPending</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vTaskSetTimeOutState</span><span class="p">(</span><span class="w"> </span><span class="n">TimeOut_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxTimeOut</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxTimeOut</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">pxTimeOut</span><span class="o">-&gt;</span><span class="n">xOverflowCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xNumOfOverflows</span><span class="p">;</span>
<span class="w">        </span><span class="n">pxTimeOut</span><span class="o">-&gt;</span><span class="n">xTimeOnEntering</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTickCount</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vTaskInternalSetTimeOutState</span><span class="p">(</span><span class="w"> </span><span class="n">TimeOut_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxTimeOut</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* For internal use only as it does not use a critical section. */</span>
<span class="w">    </span><span class="n">pxTimeOut</span><span class="o">-&gt;</span><span class="n">xOverflowCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xNumOfOverflows</span><span class="p">;</span>
<span class="w">    </span><span class="n">pxTimeOut</span><span class="o">-&gt;</span><span class="n">xTimeOnEntering</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTickCount</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xTaskCheckForTimeOut</span><span class="p">(</span><span class="w"> </span><span class="n">TimeOut_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxTimeOut</span><span class="p">,</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxTicksToWait</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>

<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxTimeOut</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxTicksToWait</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Minor optimisation.  The tick count cannot change in this block. */</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xConstTickCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTickCount</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xElapsedTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xConstTickCount</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">pxTimeOut</span><span class="o">-&gt;</span><span class="n">xTimeOnEntering</span><span class="p">;</span>

<span class="w">        </span><span class="cp">#if( INCLUDE_xTaskAbortDelay == 1 )</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">ucDelayAborted</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* The delay was aborted, which is not the same as a time out,</span>
<span class="cm">                but has the same result. */</span>
<span class="w">                </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">ucDelayAborted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="w">                </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">        </span><span class="cp">#endif</span>

<span class="w">        </span><span class="cp">#if ( INCLUDE_vTaskSuspend == 1 )</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="o">*</span><span class="n">pxTicksToWait</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">portMAX_DELAY</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* If INCLUDE_vTaskSuspend is set to 1 and the block time</span>
<span class="cm">                specified is the maximum block time then the task should block</span>
<span class="cm">                indefinitely, and therefore never time out. */</span>
<span class="w">                </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">        </span><span class="cp">#endif</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xNumOfOverflows</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pxTimeOut</span><span class="o">-&gt;</span><span class="n">xOverflowCount</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xConstTickCount</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">pxTimeOut</span><span class="o">-&gt;</span><span class="n">xTimeOnEntering</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="cm">/*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* The tick count is greater than the time at which</span>
<span class="cm">            vTaskSetTimeout() was called, but has also overflowed since</span>
<span class="cm">            vTaskSetTimeOut() was called.  It must have wrapped all the way</span>
<span class="cm">            around and gone past again. This passed since vTaskSetTimeout()</span>
<span class="cm">            was called. */</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xElapsedTime</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">pxTicksToWait</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="cm">/*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Not a genuine timeout. Adjust parameters for time remaining. */</span>
<span class="w">            </span><span class="o">*</span><span class="n">pxTicksToWait</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">xElapsedTime</span><span class="p">;</span>
<span class="w">            </span><span class="n">vTaskInternalSetTimeOutState</span><span class="p">(</span><span class="w"> </span><span class="n">pxTimeOut</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="o">*</span><span class="n">pxTicksToWait</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vTaskMissedYield</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">xYieldPending</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_TRACE_FACILITY == 1 )</span>

<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="nf">uxTaskGetTaskNumber</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxReturn</span><span class="p">;</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="n">pxTCB</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTask</span><span class="p">;</span>
<span class="w">            </span><span class="n">uxReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxTaskNumber</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">uxReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0U</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">uxReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_TRACE_FACILITY */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_TRACE_FACILITY == 1 )</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">vTaskSetTaskNumber</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTask</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxHandle</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pxTCB</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTask</span><span class="p">;</span>
<span class="w">            </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxTaskNumber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uxHandle</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_TRACE_FACILITY */</span>

<span class="cm">/*</span>
<span class="cm"> * -----------------------------------------------------------</span>
<span class="cm"> * The Idle task.</span>
<span class="cm"> * ----------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * The portTASK_FUNCTION() macro is used to allow port/compiler specific</span>
<span class="cm"> * language extensions.  The equivalent prototype for this function is:</span>
<span class="cm"> *</span>
<span class="cm"> * void prvIdleTask( void *pvParameters );</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span><span class="w"> </span><span class="n">portTASK_FUNCTION</span><span class="p">(</span><span class="w"> </span><span class="n">prvIdleTask</span><span class="p">,</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* Stop warnings. */</span>
<span class="w">    </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pvParameters</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* In case a task that has a secure context deletes itself, in which case</span>
<span class="cm">    the idle task is responsible for deleting the task&#39;s secure context, if</span>
<span class="cm">    any. */</span>
<span class="w">    </span><span class="n">portALLOCATE_SECURE_CONTEXT</span><span class="p">(</span><span class="w"> </span><span class="n">configMINIMAL_SECURE_STACK_SIZE</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="p">;;</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* See if any tasks have deleted themselves - if so then the idle task</span>
<span class="cm">        is responsible for freeing the deleted task&#39;s TCB and stack. */</span>
<span class="w">        </span><span class="n">prvCheckTasksWaitingTermination</span><span class="p">();</span>

<span class="w">        </span><span class="cp">#if ( configUSE_PREEMPTION == 0 )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* If we are not using preemption we keep forcing a task switch to</span>
<span class="cm">            see if any other task has become available.  If we are using</span>
<span class="cm">            preemption we don&#39;t need to do this as any task becoming available</span>
<span class="cm">            will automatically get the processor anyway. */</span>
<span class="w">            </span><span class="n">taskYIELD</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif </span><span class="cm">/* configUSE_PREEMPTION */</span>

<span class="w">        </span><span class="cp">#if ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configIDLE_SHOULD_YIELD == 1 ) )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* When using preemption tasks of equal priority will be</span>
<span class="cm">            timesliced.  If a task that is sharing the idle priority is ready</span>
<span class="cm">            to run then the idle task should yield before the end of the</span>
<span class="cm">            timeslice.</span>

<span class="cm">            A critical region is not required here as we are just reading from</span>
<span class="cm">            the list, and an occasional incorrect value will not matter.  If</span>
<span class="cm">            the ready list at the idle priority contains more than one task</span>
<span class="cm">            then a task other than the idle task is ready to execute. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listCURRENT_LIST_LENGTH</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxReadyTasksLists</span><span class="p">[</span><span class="w"> </span><span class="n">tskIDLE_PRIORITY</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">taskYIELD</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif </span><span class="cm">/* ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configIDLE_SHOULD_YIELD == 1 ) ) */</span>

<span class="w">        </span><span class="cp">#if ( configUSE_IDLE_HOOK == 1 )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">vApplicationIdleHook</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="cm">/* Call the user defined function from within the idle task.  This</span>
<span class="cm">            allows the application designer to add background functionality</span>
<span class="cm">            without the overhead of a separate task.</span>
<span class="cm">            NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,</span>
<span class="cm">            CALL A FUNCTION THAT MIGHT BLOCK. */</span>
<span class="w">            </span><span class="n">vApplicationIdleHook</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif </span><span class="cm">/* configUSE_IDLE_HOOK */</span>

<span class="w">        </span><span class="cm">/* This conditional compilation should use inequality to 0, not equality</span>
<span class="cm">        to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when</span>
<span class="cm">        user defined low power mode implementations require</span>
<span class="cm">        configUSE_TICKLESS_IDLE to be set to a value other than 1. */</span>
<span class="w">        </span><span class="cp">#if ( configUSE_TICKLESS_IDLE != 0 )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">        </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xExpectedIdleTime</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/* It is not desirable to suspend then resume the scheduler on</span>
<span class="cm">            each iteration of the idle task.  Therefore, a preliminary</span>
<span class="cm">            test of the expected idle time is performed without the</span>
<span class="cm">            scheduler suspended.  The result here is not necessarily</span>
<span class="cm">            valid. */</span>
<span class="w">            </span><span class="n">xExpectedIdleTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvGetExpectedIdleTime</span><span class="p">();</span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xExpectedIdleTime</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">configEXPECTED_IDLE_TIME_BEFORE_SLEEP</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">vTaskSuspendAll</span><span class="p">();</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* Now the scheduler is suspended, the expected idle</span>
<span class="cm">                    time can be sampled again, and this time its value can</span>
<span class="cm">                    be used. */</span>
<span class="w">                    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">xNextTaskUnblockTime</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">xTickCount</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="n">xExpectedIdleTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvGetExpectedIdleTime</span><span class="p">();</span>

<span class="w">                    </span><span class="cm">/* Define the following macro to set xExpectedIdleTime to 0</span>
<span class="cm">                    if the application does not want</span>
<span class="cm">                    portSUPPRESS_TICKS_AND_SLEEP() to be called. */</span>
<span class="w">                    </span><span class="n">configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING</span><span class="p">(</span><span class="w"> </span><span class="n">xExpectedIdleTime</span><span class="w"> </span><span class="p">);</span>

<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xExpectedIdleTime</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">configEXPECTED_IDLE_TIME_BEFORE_SLEEP</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">traceLOW_POWER_IDLE_BEGIN</span><span class="p">();</span>
<span class="w">                        </span><span class="n">portSUPPRESS_TICKS_AND_SLEEP</span><span class="p">(</span><span class="w"> </span><span class="n">xExpectedIdleTime</span><span class="w"> </span><span class="p">);</span>
<span class="w">                        </span><span class="n">traceLOW_POWER_IDLE_END</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xTaskResumeAll</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif </span><span class="cm">/* configUSE_TICKLESS_IDLE */</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if( configUSE_TICKLESS_IDLE != 0 )</span>

<span class="w">    </span><span class="n">eSleepModeStatus</span><span class="w"> </span><span class="n">eTaskConfirmSleepModeStatus</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* The idle task exists in addition to the application tasks. */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxNonApplicationTasks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">eSleepModeStatus</span><span class="w"> </span><span class="n">eReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eStandardSleep</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* This function must be called from a critical section. */</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listCURRENT_LIST_LENGTH</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xPendingReadyList</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* A task was made ready while the scheduler was suspended. */</span>
<span class="w">            </span><span class="n">eReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eAbortSleep</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xYieldPending</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* A yield was pended while the scheduler was suspended. */</span>
<span class="w">            </span><span class="n">eReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eAbortSleep</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* If all the tasks are in the suspended list (which might mean they</span>
<span class="cm">            have an infinite block time rather than actually being suspended)</span>
<span class="cm">            then it is safe to turn all clocks off and just wait for external</span>
<span class="cm">            interrupts. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listCURRENT_LIST_LENGTH</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xSuspendedTaskList</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">uxCurrentNumberOfTasks</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">uxNonApplicationTasks</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">eReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eNoTasksWaitingTimeout</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">eReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_TICKLESS_IDLE */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">vTaskSetThreadLocalStoragePointer</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTaskToSet</span><span class="p">,</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvValue</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTCB</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xIndex</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">configNUM_THREAD_LOCAL_STORAGE_POINTERS</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvGetTCBFromHandle</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskToSet</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">pvThreadLocalStoragePointers</span><span class="p">[</span><span class="w"> </span><span class="n">xIndex</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pvValue</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configNUM_THREAD_LOCAL_STORAGE_POINTERS */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvTaskGetThreadLocalStoragePointer</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTaskToQuery</span><span class="p">,</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xIndex</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTCB</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xIndex</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">configNUM_THREAD_LOCAL_STORAGE_POINTERS</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvGetTCBFromHandle</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskToQuery</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="n">pvReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">pvThreadLocalStoragePointers</span><span class="p">[</span><span class="w"> </span><span class="n">xIndex</span><span class="w"> </span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pvReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">pvReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configNUM_THREAD_LOCAL_STORAGE_POINTERS */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( portUSING_MPU_WRAPPERS == 1 )</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">vTaskAllocateMPURegions</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTaskToModify</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">MemoryRegion_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">xRegions</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTCB</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* If null is passed in here then we are modifying the MPU settings of</span>
<span class="cm">        the calling task. */</span>
<span class="w">        </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvGetTCBFromHandle</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskToModify</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="n">vPortStoreTaskMPUSettings</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xMPUSettings</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="n">xRegions</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* portUSING_MPU_WRAPPERS */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">prvInitialiseTaskLists</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxPriority</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="n">uxPriority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0U</span><span class="p">;</span><span class="w"> </span><span class="n">uxPriority</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">configMAX_PRIORITIES</span><span class="p">;</span><span class="w"> </span><span class="n">uxPriority</span><span class="o">++</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">vListInitialise</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxReadyTasksLists</span><span class="p">[</span><span class="w"> </span><span class="n">uxPriority</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">vListInitialise</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xDelayedTaskList1</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">vListInitialise</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xDelayedTaskList2</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">vListInitialise</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xPendingReadyList</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cp">#if ( INCLUDE_vTaskDelete == 1 )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">vListInitialise</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xTasksWaitingTermination</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif </span><span class="cm">/* INCLUDE_vTaskDelete */</span>

<span class="w">    </span><span class="cp">#if ( INCLUDE_vTaskSuspend == 1 )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">vListInitialise</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xSuspendedTaskList</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif </span><span class="cm">/* INCLUDE_vTaskSuspend */</span>

<span class="w">    </span><span class="cm">/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList</span>
<span class="cm">    using list2. */</span>
<span class="w">    </span><span class="n">pxDelayedTaskList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xDelayedTaskList1</span><span class="p">;</span>
<span class="w">    </span><span class="n">pxOverflowDelayedTaskList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xDelayedTaskList2</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">prvCheckTasksWaitingTermination</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>

<span class="w">    </span><span class="cp">#if ( INCLUDE_vTaskDelete == 1 )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTCB</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()</span>
<span class="cm">        being called too often in the idle task. */</span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="n">uxDeletedTasksWaitingCleanUp</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0U</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">listGET_OWNER_OF_HEAD_ENTRY</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xTasksWaitingTermination</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */</span>
<span class="w">                </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">uxListRemove</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="o">--</span><span class="n">uxCurrentNumberOfTasks</span><span class="p">;</span>
<span class="w">                </span><span class="o">--</span><span class="n">uxDeletedTasksWaitingCleanUp</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">            </span><span class="n">prvDeleteTCB</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif </span><span class="cm">/* INCLUDE_vTaskDelete */</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if( configUSE_TRACE_FACILITY == 1 )</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">vTaskGetInfo</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTask</span><span class="p">,</span><span class="w"> </span><span class="n">TaskStatus_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTaskStatus</span><span class="p">,</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xGetFreeStackSpace</span><span class="p">,</span><span class="w"> </span><span class="n">eTaskState</span><span class="w"> </span><span class="n">eState</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTCB</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* xTask is NULL then get the state of the calling task. */</span>
<span class="w">        </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvGetTCBFromHandle</span><span class="p">(</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="n">pxTaskStatus</span><span class="o">-&gt;</span><span class="n">xHandle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxTCB</span><span class="p">;</span>
<span class="w">        </span><span class="n">pxTaskStatus</span><span class="o">-&gt;</span><span class="n">pcTaskName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">pcTaskName</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="n">pxTaskStatus</span><span class="o">-&gt;</span><span class="n">uxCurrentPriority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="p">;</span>
<span class="w">        </span><span class="n">pxTaskStatus</span><span class="o">-&gt;</span><span class="n">pxStackBase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">pxStack</span><span class="p">;</span>
<span class="w">        </span><span class="n">pxTaskStatus</span><span class="o">-&gt;</span><span class="n">xTaskNumber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxTCBNumber</span><span class="p">;</span>

<span class="w">        </span><span class="cp">#if ( configUSE_MUTEXES == 1 )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pxTaskStatus</span><span class="o">-&gt;</span><span class="n">uxBasePriority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxBasePriority</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pxTaskStatus</span><span class="o">-&gt;</span><span class="n">uxBasePriority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif</span>

<span class="w">        </span><span class="cp">#if ( configGENERATE_RUN_TIME_STATS == 1 )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pxTaskStatus</span><span class="o">-&gt;</span><span class="n">ulRunTimeCounter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ulRunTimeCounter</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pxTaskStatus</span><span class="o">-&gt;</span><span class="n">ulRunTimeCounter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif</span>

<span class="w">        </span><span class="cm">/* Obtaining the task state is a little fiddly, so is only done if the</span>
<span class="cm">        value of eState passed into this function is eInvalid - otherwise the</span>
<span class="cm">        state is just set to whatever is passed in. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">eState</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">eInvalid</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">pxTaskStatus</span><span class="o">-&gt;</span><span class="n">eCurrentState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eRunning</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">pxTaskStatus</span><span class="o">-&gt;</span><span class="n">eCurrentState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eState</span><span class="p">;</span>

<span class="w">                </span><span class="cp">#if ( INCLUDE_vTaskSuspend == 1 )</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* If the task is in the suspended list then there is a</span>
<span class="cm">                    chance it is actually just blocked indefinitely - so really</span>
<span class="cm">                    it should be reported as being in the Blocked state. */</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">eState</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">eSuspended</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">vTaskSuspendAll</span><span class="p">();</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_ITEM_CONTAINER</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                            </span><span class="p">{</span>
<span class="w">                                </span><span class="n">pxTaskStatus</span><span class="o">-&gt;</span><span class="n">eCurrentState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eBlocked</span><span class="p">;</span>
<span class="w">                            </span><span class="p">}</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xTaskResumeAll</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="cp">#endif </span><span class="cm">/* INCLUDE_vTaskSuspend */</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pxTaskStatus</span><span class="o">-&gt;</span><span class="n">eCurrentState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eTaskGetState</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/* Obtaining the stack space takes some time, so the xGetFreeStackSpace</span>
<span class="cm">        parameter is provided to allow it to be skipped. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xGetFreeStackSpace</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cp">#if ( portSTACK_GROWTH &gt; 0 )</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">pxTaskStatus</span><span class="o">-&gt;</span><span class="n">usStackHighWaterMark</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvTaskCheckFreeStackSpace</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">pxEndOfStack</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="cp">#else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">pxTaskStatus</span><span class="o">-&gt;</span><span class="n">usStackHighWaterMark</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvTaskCheckFreeStackSpace</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">pxStack</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="cp">#endif</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pxTaskStatus</span><span class="o">-&gt;</span><span class="n">usStackHighWaterMark</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_TRACE_FACILITY */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_TRACE_FACILITY == 1 )</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">prvListTasksWithinSingleList</span><span class="p">(</span><span class="w"> </span><span class="n">TaskStatus_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTaskStatusArray</span><span class="p">,</span><span class="w"> </span><span class="n">List_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxList</span><span class="p">,</span><span class="w"> </span><span class="n">eTaskState</span><span class="w"> </span><span class="n">eState</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">configLIST_VOLATILE</span><span class="w"> </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxNextTCB</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">pxFirstTCB</span><span class="p">;</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxTask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listCURRENT_LIST_LENGTH</span><span class="p">(</span><span class="w"> </span><span class="n">pxList</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">listGET_OWNER_OF_NEXT_ENTRY</span><span class="p">(</span><span class="w"> </span><span class="n">pxFirstTCB</span><span class="p">,</span><span class="w"> </span><span class="n">pxList</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */</span>

<span class="w">            </span><span class="cm">/* Populate an TaskStatus_t structure within the</span>
<span class="cm">            pxTaskStatusArray array for each task that is referenced from</span>
<span class="cm">            pxList.  See the definition of TaskStatus_t in task.h for the</span>
<span class="cm">            meaning of each TaskStatus_t structure member. */</span>
<span class="w">            </span><span class="k">do</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">listGET_OWNER_OF_NEXT_ENTRY</span><span class="p">(</span><span class="w"> </span><span class="n">pxNextTCB</span><span class="p">,</span><span class="w"> </span><span class="n">pxList</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */</span>
<span class="w">                </span><span class="n">vTaskGetInfo</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxNextTCB</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">[</span><span class="w"> </span><span class="n">uxTask</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">,</span><span class="w"> </span><span class="n">eState</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="n">uxTask</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="n">pxNextTCB</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pxFirstTCB</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">uxTask</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_TRACE_FACILITY */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">configSTACK_DEPTH_TYPE</span><span class="w"> </span><span class="n">prvTaskCheckFreeStackSpace</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pucStackByte</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ulCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0U</span><span class="p">;</span>

<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="o">*</span><span class="n">pucStackByte</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">tskSTACK_FILL_BYTE</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pucStackByte</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">portSTACK_GROWTH</span><span class="p">;</span>
<span class="w">            </span><span class="n">ulCount</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">ulCount</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">StackType_t</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e961 Casting is not redundant on smaller architectures. */</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">configSTACK_DEPTH_TYPE</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">ulCount</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) ) */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 )</span>

<span class="w">    </span><span class="cm">/* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the</span>
<span class="cm">    same except for their return type.  Using configSTACK_DEPTH_TYPE allows the</span>
<span class="cm">    user to determine the return type.  It gets around the problem of the value</span>
<span class="cm">    overflowing on 8-bit types without breaking backward compatibility for</span>
<span class="cm">    applications that expect an 8-bit return type. */</span>
<span class="w">    </span><span class="n">configSTACK_DEPTH_TYPE</span><span class="w"> </span><span class="n">uxTaskGetStackHighWaterMark2</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTCB</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">pucEndOfStack</span><span class="p">;</span>
<span class="w">    </span><span class="n">configSTACK_DEPTH_TYPE</span><span class="w"> </span><span class="n">uxReturn</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are</span>
<span class="cm">        the same except for their return type.  Using configSTACK_DEPTH_TYPE</span>
<span class="cm">        allows the user to determine the return type.  It gets around the</span>
<span class="cm">        problem of the value overflowing on 8-bit types without breaking</span>
<span class="cm">        backward compatibility for applications that expect an 8-bit return</span>
<span class="cm">        type. */</span>

<span class="w">        </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvGetTCBFromHandle</span><span class="p">(</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cp">#if portSTACK_GROWTH &lt; 0</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pucEndOfStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">pxStack</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pucEndOfStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">pxEndOfStack</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif</span>

<span class="w">        </span><span class="n">uxReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvTaskCheckFreeStackSpace</span><span class="p">(</span><span class="w"> </span><span class="n">pucEndOfStack</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">uxReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* INCLUDE_uxTaskGetStackHighWaterMark2 */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )</span>

<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxTaskGetStackHighWaterMark</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTCB</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">pucEndOfStack</span><span class="p">;</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxReturn</span><span class="p">;</span>

<span class="w">        </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvGetTCBFromHandle</span><span class="p">(</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cp">#if portSTACK_GROWTH &lt; 0</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pucEndOfStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">pxStack</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pucEndOfStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">pxEndOfStack</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif</span>

<span class="w">        </span><span class="n">uxReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">prvTaskCheckFreeStackSpace</span><span class="p">(</span><span class="w"> </span><span class="n">pucEndOfStack</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">uxReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* INCLUDE_uxTaskGetStackHighWaterMark */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( INCLUDE_vTaskDelete == 1 )</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">prvDeleteTCB</span><span class="p">(</span><span class="w"> </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTCB</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* This call is required specifically for the TriCore port.  It must be</span>
<span class="cm">        above the vPortFree() calls.  The call is also used by ports/demos that</span>
<span class="cm">        want to allocate and clean RAM statically. */</span>
<span class="w">        </span><span class="n">portCLEAN_UP_TCB</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* Free up the memory allocated by the scheduler for the task.  It is up</span>
<span class="cm">        to the task to free any memory allocated at the application level.</span>
<span class="cm">        See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html</span>
<span class="cm">        for additional information. */</span>
<span class="w">        </span><span class="cp">#if ( configUSE_NEWLIB_REENTRANT == 1 )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">_reclaim_reent</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xNewLib_reent</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif </span><span class="cm">/* configUSE_NEWLIB_REENTRANT */</span>

<span class="w">        </span><span class="cp">#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 0 ) &amp;&amp; ( portUSING_MPU_WRAPPERS == 0 ) )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* The task can only have been allocated dynamically - free both</span>
<span class="cm">            the stack and TCB. */</span>
<span class="w">            </span><span class="n">vPortFree</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">pxStack</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="n">vPortFree</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) </span><span class="cm">/*lint !e731 !e9029 Macro has been consolidated for readability reasons. */</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* The task could have been allocated statically or dynamically, so</span>
<span class="cm">            check what was statically allocated before trying to free the</span>
<span class="cm">            memory. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ucStaticallyAllocated</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Both the stack and TCB were allocated dynamically, so both</span>
<span class="cm">                must be freed. */</span>
<span class="w">                </span><span class="n">vPortFree</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">pxStack</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="n">vPortFree</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ucStaticallyAllocated</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tskSTATICALLY_ALLOCATED_STACK_ONLY</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Only the stack was statically allocated, so the TCB is the</span>
<span class="cm">                only memory that must be freed. */</span>
<span class="w">                </span><span class="n">vPortFree</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Neither the stack nor the TCB were allocated dynamically, so</span>
<span class="cm">                nothing needs to be freed. */</span>
<span class="w">                </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ucStaticallyAllocated</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tskSTATICALLY_ALLOCATED_STACK_AND_TCB</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif </span><span class="cm">/* configSUPPORT_DYNAMIC_ALLOCATION */</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* INCLUDE_vTaskDelete */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">prvResetNextTaskUnblockTime</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTCB</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_IS_EMPTY</span><span class="p">(</span><span class="w"> </span><span class="n">pxDelayedTaskList</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* The new current delayed list is empty.  Set xNextTaskUnblockTime to</span>
<span class="cm">        the maximum possible value so it is extremely unlikely that the</span>
<span class="cm">        if( xTickCount &gt;= xNextTaskUnblockTime ) test will pass until</span>
<span class="cm">        there is an item in the delayed list. */</span>
<span class="w">        </span><span class="n">xNextTaskUnblockTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">portMAX_DELAY</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* The new current delayed list is not empty, get the value of</span>
<span class="cm">        the item at the head of the delayed list.  This is the time at</span>
<span class="cm">        which the task at the head of the delayed list should be removed</span>
<span class="cm">        from the Blocked state. */</span>
<span class="w">        </span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">listGET_OWNER_OF_HEAD_ENTRY</span><span class="p">(</span><span class="w"> </span><span class="n">pxDelayedTaskList</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */</span>
<span class="w">        </span><span class="n">xNextTaskUnblockTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">listGET_LIST_ITEM_VALUE</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">)</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )</span>

<span class="w">    </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTaskGetCurrentTaskHandle</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* A critical section is not required as this is not called from</span>
<span class="cm">        an interrupt and the current TCB will always be the same for any</span>
<span class="cm">        individual execution thread. */</span>
<span class="w">        </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="p">;</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )</span>

<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xTaskGetSchedulerState</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xSchedulerRunning</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskSCHEDULER_NOT_STARTED</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxSchedulerSuspended</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskSCHEDULER_RUNNING</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskSCHEDULER_SUSPENDED</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_MUTEXES == 1 )</span>

<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xTaskPriorityInherit</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxMutexHolder</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxMutexHolderTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxMutexHolder</span><span class="p">;</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* If the mutex was given back by an interrupt while the queue was</span>
<span class="cm">        locked then the mutex holder might now be NULL.  _RB_ Is this still</span>
<span class="cm">        needed as interrupts can no longer use mutexes? */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxMutexHolder</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* If the holder of the mutex has a priority below the priority of</span>
<span class="cm">            the task attempting to obtain the mutex then it will temporarily</span>
<span class="cm">            inherit the priority of the task attempting to obtain the mutex. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxMutexHolderTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Adjust the mutex holder state to account for its new</span>
<span class="cm">                priority.  Only reset the event list item value if the value is</span>
<span class="cm">                not being used for anything else. */</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">listGET_LIST_ITEM_VALUE</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxMutexHolderTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">taskEVENT_LIST_ITEM_VALUE_IN_USE</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0UL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">listSET_LIST_ITEM_VALUE</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxMutexHolderTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">configMAX_PRIORITIES</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e961 MISRA exception as the casts are only redundant for some ports. */</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="cm">/* If the task being modified is in the ready state it will need</span>
<span class="cm">                to be moved into a new list. */</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listIS_CONTAINED_WITHIN</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxReadyTasksLists</span><span class="p">[</span><span class="w"> </span><span class="n">pxMutexHolderTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxMutexHolderTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxListRemove</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxMutexHolderTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="cm">/* It is known that the task is in its ready list so</span>
<span class="cm">                        there is no need to check again and the port level</span>
<span class="cm">                        reset macro can be called directly. */</span>
<span class="w">                        </span><span class="n">portRESET_READY_PRIORITY</span><span class="p">(</span><span class="w"> </span><span class="n">pxMutexHolderTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="p">,</span><span class="w"> </span><span class="n">uxTopReadyPriority</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>

<span class="w">                    </span><span class="cm">/* Inherit the priority before being moved into the new list. */</span>
<span class="w">                    </span><span class="n">pxMutexHolderTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="p">;</span>
<span class="w">                    </span><span class="n">prvAddTaskToReadyList</span><span class="p">(</span><span class="w"> </span><span class="n">pxMutexHolderTCB</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* Just inherit the priority. */</span>
<span class="w">                    </span><span class="n">pxMutexHolderTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="n">traceTASK_PRIORITY_INHERIT</span><span class="p">(</span><span class="w"> </span><span class="n">pxMutexHolderTCB</span><span class="p">,</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="p">);</span>

<span class="w">                </span><span class="cm">/* Inheritance occurred. */</span>
<span class="w">                </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxMutexHolderTCB</span><span class="o">-&gt;</span><span class="n">uxBasePriority</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* The base priority of the mutex holder is lower than the</span>
<span class="cm">                    priority of the task attempting to take the mutex, but the</span>
<span class="cm">                    current priority of the mutex holder is not lower than the</span>
<span class="cm">                    priority of the task attempting to take the mutex.</span>
<span class="cm">                    Therefore the mutex holder must have already inherited a</span>
<span class="cm">                    priority, but inheritance would have occurred if that had</span>
<span class="cm">                    not been the case. */</span>
<span class="w">                    </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_MUTEXES */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_MUTEXES == 1 )</span>

<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xTaskPriorityDisinherit</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxMutexHolder</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxMutexHolder</span><span class="p">;</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxMutexHolder</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* A task can only have an inherited priority if it holds the mutex.</span>
<span class="cm">            If the mutex is held by a task then it cannot be given from an</span>
<span class="cm">            interrupt, and if a mutex is given by the holding task then it must</span>
<span class="cm">            be the running state task. */</span>
<span class="w">            </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxMutexesHeld</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxMutexesHeld</span><span class="w"> </span><span class="p">)</span><span class="o">--</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/* Has the holder of the mutex inherited the priority of another</span>
<span class="cm">            task? */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxBasePriority</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Only disinherit if no other mutexes are held. */</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxMutexesHeld</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* A task can only have an inherited priority if it holds</span>
<span class="cm">                    the mutex.  If the mutex is held by a task then it cannot be</span>
<span class="cm">                    given from an interrupt, and if a mutex is given by the</span>
<span class="cm">                    holding task then it must be the running state task.  Remove</span>
<span class="cm">                    the holding task from the ready/delayed list. */</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxListRemove</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">taskRESET_READY_PRIORITY</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>

<span class="w">                    </span><span class="cm">/* Disinherit the priority before adding the task into the</span>
<span class="cm">                    new ready list. */</span>
<span class="w">                    </span><span class="n">traceTASK_PRIORITY_DISINHERIT</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="p">,</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxBasePriority</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxBasePriority</span><span class="p">;</span>

<span class="w">                    </span><span class="cm">/* Reset the event list item value.  It cannot be in use for</span>
<span class="cm">                    any other purpose if this task is running, and it must be</span>
<span class="cm">                    running to give back the mutex. */</span>
<span class="w">                    </span><span class="n">listSET_LIST_ITEM_VALUE</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">configMAX_PRIORITIES</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e961 MISRA exception as the casts are only redundant for some ports. */</span>
<span class="w">                    </span><span class="n">prvAddTaskToReadyList</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>

<span class="w">                    </span><span class="cm">/* Return true to indicate that a context switch is required.</span>
<span class="cm">                    This is only actually required in the corner case whereby</span>
<span class="cm">                    multiple mutexes were held and the mutexes were given back</span>
<span class="cm">                    in an order different to that in which they were taken.</span>
<span class="cm">                    If a context switch did not occur when the first mutex was</span>
<span class="cm">                    returned, even if a task was waiting on it, then a context</span>
<span class="cm">                    switch should occur when the last mutex is returned whether</span>
<span class="cm">                    a task is waiting on it or not. */</span>
<span class="w">                    </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_MUTEXES */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_MUTEXES == 1 )</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">vTaskPriorityDisinheritAfterTimeout</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxMutexHolder</span><span class="p">,</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxHighestPriorityWaitingTask</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxMutexHolder</span><span class="p">;</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxPriorityUsedOnEntry</span><span class="p">,</span><span class="w"> </span><span class="n">uxPriorityToUse</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxOnlyOneMutexHeld</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxMutexHolder</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* If pxMutexHolder is not NULL then the holder must hold at least</span>
<span class="cm">            one mutex. */</span>
<span class="w">            </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxMutexesHeld</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="cm">/* Determine the priority to which the priority of the task that</span>
<span class="cm">            holds the mutex should be set.  This will be the greater of the</span>
<span class="cm">            holding task&#39;s base priority and the priority of the highest</span>
<span class="cm">            priority task that is waiting to obtain the mutex. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxBasePriority</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">uxHighestPriorityWaitingTask</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">uxPriorityToUse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uxHighestPriorityWaitingTask</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">uxPriorityToUse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxBasePriority</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="cm">/* Does the priority need to change? */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">uxPriorityToUse</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Only disinherit if no other mutexes are held.  This is a</span>
<span class="cm">                simplification in the priority inheritance implementation.  If</span>
<span class="cm">                the task that holds the mutex is also holding other mutexes then</span>
<span class="cm">                the other mutexes may have caused the priority inheritance. */</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxMutexesHeld</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">uxOnlyOneMutexHeld</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* If a task has timed out because it already holds the</span>
<span class="cm">                    mutex it was trying to obtain then it cannot of inherited</span>
<span class="cm">                    its own priority. */</span>
<span class="w">                    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="w"> </span><span class="p">);</span>

<span class="w">                    </span><span class="cm">/* Disinherit the priority, remembering the previous</span>
<span class="cm">                    priority to facilitate determining the subject task&#39;s</span>
<span class="cm">                    state. */</span>
<span class="w">                    </span><span class="n">traceTASK_PRIORITY_DISINHERIT</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="p">,</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxBasePriority</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="n">uxPriorityUsedOnEntry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="p">;</span>
<span class="w">                    </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uxPriorityToUse</span><span class="p">;</span>

<span class="w">                    </span><span class="cm">/* Only reset the event list item value if the value is not</span>
<span class="cm">                    being used for anything else. */</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">listGET_LIST_ITEM_VALUE</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">taskEVENT_LIST_ITEM_VALUE_IN_USE</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0UL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">listSET_LIST_ITEM_VALUE</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">configMAX_PRIORITIES</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">uxPriorityToUse</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e961 MISRA exception as the casts are only redundant for some ports. */</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>

<span class="w">                    </span><span class="cm">/* If the running task is not the task that holds the mutex</span>
<span class="cm">                    then the task that holds the mutex could be in either the</span>
<span class="cm">                    Ready, Blocked or Suspended states.  Only remove the task</span>
<span class="cm">                    from its current state list if it is in the Ready state as</span>
<span class="cm">                    the task&#39;s priority is going to change and there is one</span>
<span class="cm">                    Ready list per priority. */</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listIS_CONTAINED_WITHIN</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxReadyTasksLists</span><span class="p">[</span><span class="w"> </span><span class="n">uxPriorityUsedOnEntry</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxListRemove</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="cm">/* It is known that the task is in its ready list so</span>
<span class="cm">                            there is no need to check again and the port level</span>
<span class="cm">                            reset macro can be called directly. */</span>
<span class="w">                            </span><span class="n">portRESET_READY_PRIORITY</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="p">,</span><span class="w"> </span><span class="n">uxTopReadyPriority</span><span class="w"> </span><span class="p">);</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="k">else</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                        </span><span class="p">}</span>

<span class="w">                        </span><span class="n">prvAddTaskToReadyList</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_MUTEXES */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( portCRITICAL_NESTING_IN_TCB == 1 )</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">vTaskEnterCritical</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">portDISABLE_INTERRUPTS</span><span class="p">();</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xSchedulerRunning</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxCriticalNesting</span><span class="w"> </span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/* This is not the interrupt safe version of the enter critical</span>
<span class="cm">            function so assert() if it is being called from an interrupt</span>
<span class="cm">            context.  Only API functions that end in &quot;FromISR&quot; can be used in an</span>
<span class="cm">            interrupt.  Only assert if the critical nesting count is 1 to</span>
<span class="cm">            protect against recursive calls if the assert function also uses a</span>
<span class="cm">            critical section. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxCriticalNesting</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">portASSERT_IF_IN_ISR</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* portCRITICAL_NESTING_IN_TCB */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( portCRITICAL_NESTING_IN_TCB == 1 )</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">vTaskExitCritical</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xSchedulerRunning</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxCriticalNesting</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0U</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxCriticalNesting</span><span class="w"> </span><span class="p">)</span><span class="o">--</span><span class="p">;</span>

<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxCriticalNesting</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0U</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">portENABLE_INTERRUPTS</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* portCRITICAL_NESTING_IN_TCB */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( ( configUSE_TRACE_FACILITY == 1 ) &amp;&amp; ( configUSE_STATS_FORMATTING_FUNCTIONS &gt; 0 ) )</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">prvWriteNameToBuffer</span><span class="p">(</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">pcBuffer</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">pcTaskName</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* Start by copying the entire string. */</span>
<span class="w">        </span><span class="n">strcpy</span><span class="p">(</span><span class="w"> </span><span class="n">pcBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">pcTaskName</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* Pad the end of the string with spaces to ensure columns line up when</span>
<span class="cm">        printed out. */</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="w"> </span><span class="n">pcBuffer</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">configMAX_TASK_NAME_LEN</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pcBuffer</span><span class="p">[</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/* Terminate. */</span>
<span class="w">        </span><span class="n">pcBuffer</span><span class="p">[</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mh">0x00</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* Return the new end of string. */</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pcBuffer</span><span class="p">[</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* ( configUSE_TRACE_FACILITY == 1 ) &amp;&amp; ( configUSE_STATS_FORMATTING_FUNCTIONS &gt; 0 ) */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( ( configUSE_TRACE_FACILITY == 1 ) &amp;&amp; ( configUSE_STATS_FORMATTING_FUNCTIONS &gt; 0 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">vTaskList</span><span class="p">(</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pcWriteBuffer</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TaskStatus_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTaskStatusArray</span><span class="p">;</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxArraySize</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">cStatus</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * PLEASE NOTE:</span>
<span class="cm">         *</span>
<span class="cm">         * This function is provided for convenience only, and is used by many</span>
<span class="cm">         * of the demo applications.  Do not consider it to be part of the</span>
<span class="cm">         * scheduler.</span>
<span class="cm">         *</span>
<span class="cm">         * vTaskList() calls uxTaskGetSystemState(), then formats part of the</span>
<span class="cm">         * uxTaskGetSystemState() output into a human readable table that</span>
<span class="cm">         * displays task names, states and stack usage.</span>
<span class="cm">         *</span>
<span class="cm">         * vTaskList() has a dependency on the sprintf() C library function that</span>
<span class="cm">         * might bloat the code size, use a lot of stack, and provide different</span>
<span class="cm">         * results on different platforms.  An alternative, tiny, third party,</span>
<span class="cm">         * and limited functionality implementation of sprintf() is provided in</span>
<span class="cm">         * many of the FreeRTOS/Demo sub-directories in a file called</span>
<span class="cm">         * printf-stdarg.c (note printf-stdarg.c does not provide a full</span>
<span class="cm">         * snprintf() implementation!).</span>
<span class="cm">         *</span>
<span class="cm">         * It is recommended that production systems call uxTaskGetSystemState()</span>
<span class="cm">         * directly to get access to raw stats data, rather than indirectly</span>
<span class="cm">         * through a call to vTaskList().</span>
<span class="cm">         */</span>


<span class="w">        </span><span class="cm">/* Make sure the write buffer does not contain a string. */</span>
<span class="w">        </span><span class="o">*</span><span class="n">pcWriteBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mh">0x00</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* Take a snapshot of the number of tasks in case it changes while this</span>
<span class="cm">        function is executing. */</span>
<span class="w">        </span><span class="n">uxArraySize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uxCurrentNumberOfTasks</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* Allocate an array index for each task.  NOTE!  if</span>
<span class="cm">        configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will</span>
<span class="cm">        equate to NULL. */</span>
<span class="w">        </span><span class="n">pxTaskStatusArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pvPortMalloc</span><span class="p">(</span><span class="w"> </span><span class="n">uxCurrentNumberOfTasks</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">TaskStatus_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU&#39;s stack and this allocation allocates a struct that has the alignment requirements of a pointer. */</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Generate the (binary) data. */</span>
<span class="w">            </span><span class="n">uxArraySize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uxTaskGetSystemState</span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">,</span><span class="w"> </span><span class="n">uxArraySize</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="cm">/* Create a human readable table from the binary data. */</span>
<span class="w">            </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">uxArraySize</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">switch</span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">[</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">].</span><span class="n">eCurrentState</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">case</span><span class="w"> </span><span class="no">eRunning</span><span class="p">:</span><span class="w">      </span><span class="n">cStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tskRUNNING_CHAR</span><span class="p">;</span>
<span class="w">                                        </span><span class="k">break</span><span class="p">;</span>

<span class="w">                    </span><span class="k">case</span><span class="w"> </span><span class="no">eReady</span><span class="p">:</span><span class="w">        </span><span class="n">cStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tskREADY_CHAR</span><span class="p">;</span>
<span class="w">                                        </span><span class="k">break</span><span class="p">;</span>

<span class="w">                    </span><span class="k">case</span><span class="w"> </span><span class="no">eBlocked</span><span class="p">:</span><span class="w">      </span><span class="n">cStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tskBLOCKED_CHAR</span><span class="p">;</span>
<span class="w">                                        </span><span class="k">break</span><span class="p">;</span>

<span class="w">                    </span><span class="k">case</span><span class="w"> </span><span class="no">eSuspended</span><span class="p">:</span><span class="w">    </span><span class="n">cStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tskSUSPENDED_CHAR</span><span class="p">;</span>
<span class="w">                                        </span><span class="k">break</span><span class="p">;</span>

<span class="w">                    </span><span class="k">case</span><span class="w"> </span><span class="no">eDeleted</span><span class="p">:</span><span class="w">      </span><span class="n">cStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tskDELETED_CHAR</span><span class="p">;</span>
<span class="w">                                        </span><span class="k">break</span><span class="p">;</span>

<span class="w">                    </span><span class="k">case</span><span class="w"> </span><span class="no">eInvalid</span><span class="p">:</span><span class="w">      </span><span class="cm">/* Fall through. */</span>
<span class="w">                    </span><span class="k">default</span><span class="o">:</span><span class="w">            </span><span class="cm">/* Should not get here, but it is included</span>
<span class="cm">                                        to prevent static checking errors. */</span>
<span class="w">                                        </span><span class="n">cStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mh">0x00</span><span class="p">;</span>
<span class="w">                                        </span><span class="k">break</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="cm">/* Write the task name to the string, padding with spaces so it</span>
<span class="cm">                can be printed in tabular form more easily. */</span>
<span class="w">                </span><span class="n">pcWriteBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvWriteNameToBuffer</span><span class="p">(</span><span class="w"> </span><span class="n">pcWriteBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">[</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">].</span><span class="n">pcTaskName</span><span class="w"> </span><span class="p">);</span>

<span class="w">                </span><span class="cm">/* Write the rest of the string. */</span>
<span class="w">                </span><span class="n">sprintf</span><span class="p">(</span><span class="w"> </span><span class="n">pcWriteBuffer</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">%c</span><span class="se">\t</span><span class="s">%u</span><span class="se">\t</span><span class="s">%u</span><span class="se">\t</span><span class="s">%u</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cStatus</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">[</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">].</span><span class="n">uxCurrentPriority</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">[</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">].</span><span class="n">usStackHighWaterMark</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">[</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">].</span><span class="n">xTaskNumber</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */</span>
<span class="w">                </span><span class="n">pcWriteBuffer</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="w"> </span><span class="n">pcWriteBuffer</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="cm">/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION</span>
<span class="cm">            is 0 then vPortFree() will be #defined to nothing. */</span>
<span class="w">            </span><span class="n">vPortFree</span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* ( ( configUSE_TRACE_FACILITY == 1 ) &amp;&amp; ( configUSE_STATS_FORMATTING_FUNCTIONS &gt; 0 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */</span>
<span class="cm">/*----------------------------------------------------------*/</span>

<span class="cp">#if ( ( configGENERATE_RUN_TIME_STATS == 1 ) &amp;&amp; ( configUSE_STATS_FORMATTING_FUNCTIONS &gt; 0 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">vTaskGetRunTimeStats</span><span class="p">(</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">pcWriteBuffer</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TaskStatus_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTaskStatusArray</span><span class="p">;</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxArraySize</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ulTotalTime</span><span class="p">,</span><span class="w"> </span><span class="n">ulStatsAsPercentage</span><span class="p">;</span>

<span class="w">        </span><span class="cp">#if( configUSE_TRACE_FACILITY != 1 )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cp">#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif</span>

<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * PLEASE NOTE:</span>
<span class="cm">         *</span>
<span class="cm">         * This function is provided for convenience only, and is used by many</span>
<span class="cm">         * of the demo applications.  Do not consider it to be part of the</span>
<span class="cm">         * scheduler.</span>
<span class="cm">         *</span>
<span class="cm">         * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part</span>
<span class="cm">         * of the uxTaskGetSystemState() output into a human readable table that</span>
<span class="cm">         * displays the amount of time each task has spent in the Running state</span>
<span class="cm">         * in both absolute and percentage terms.</span>
<span class="cm">         *</span>
<span class="cm">         * vTaskGetRunTimeStats() has a dependency on the sprintf() C library</span>
<span class="cm">         * function that might bloat the code size, use a lot of stack, and</span>
<span class="cm">         * provide different results on different platforms.  An alternative,</span>
<span class="cm">         * tiny, third party, and limited functionality implementation of</span>
<span class="cm">         * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in</span>
<span class="cm">         * a file called printf-stdarg.c (note printf-stdarg.c does not provide</span>
<span class="cm">         * a full snprintf() implementation!).</span>
<span class="cm">         *</span>
<span class="cm">         * It is recommended that production systems call uxTaskGetSystemState()</span>
<span class="cm">         * directly to get access to raw stats data, rather than indirectly</span>
<span class="cm">         * through a call to vTaskGetRunTimeStats().</span>
<span class="cm">         */</span>

<span class="w">        </span><span class="cm">/* Make sure the write buffer does not contain a string. */</span>
<span class="w">        </span><span class="o">*</span><span class="n">pcWriteBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mh">0x00</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* Take a snapshot of the number of tasks in case it changes while this</span>
<span class="cm">        function is executing. */</span>
<span class="w">        </span><span class="n">uxArraySize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uxCurrentNumberOfTasks</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* Allocate an array index for each task.  NOTE!  If</span>
<span class="cm">        configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will</span>
<span class="cm">        equate to NULL. */</span>
<span class="w">        </span><span class="n">pxTaskStatusArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pvPortMalloc</span><span class="p">(</span><span class="w"> </span><span class="n">uxCurrentNumberOfTasks</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">TaskStatus_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU&#39;s stack and this allocation allocates a struct that has the alignment requirements of a pointer. */</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Generate the (binary) data. */</span>
<span class="w">            </span><span class="n">uxArraySize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uxTaskGetSystemState</span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">,</span><span class="w"> </span><span class="n">uxArraySize</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ulTotalTime</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="cm">/* For percentage calculations. */</span>
<span class="w">            </span><span class="n">ulTotalTime</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">100UL</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/* Avoid divide by zero errors. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">ulTotalTime</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0UL</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Create a human readable table from the binary data. */</span>
<span class="w">                </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">uxArraySize</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* What percentage of the total run time has the task used?</span>
<span class="cm">                    This will always be rounded down to the nearest integer.</span>
<span class="cm">                    ulTotalRunTimeDiv100 has already been divided by 100. */</span>
<span class="w">                    </span><span class="n">ulStatsAsPercentage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">[</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">].</span><span class="n">ulRunTimeCounter</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">ulTotalTime</span><span class="p">;</span>

<span class="w">                    </span><span class="cm">/* Write the task name to the string, padding with</span>
<span class="cm">                    spaces so it can be printed in tabular form more</span>
<span class="cm">                    easily. */</span>
<span class="w">                    </span><span class="n">pcWriteBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvWriteNameToBuffer</span><span class="p">(</span><span class="w"> </span><span class="n">pcWriteBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">[</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">].</span><span class="n">pcTaskName</span><span class="w"> </span><span class="p">);</span>

<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">ulStatsAsPercentage</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0UL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="cp">#ifdef portLU_PRINTF_SPECIFIER_REQUIRED</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="n">sprintf</span><span class="p">(</span><span class="w"> </span><span class="n">pcWriteBuffer</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">%lu</span><span class="se">\t\t</span><span class="s">%lu%%</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">[</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">].</span><span class="n">ulRunTimeCounter</span><span class="p">,</span><span class="w"> </span><span class="n">ulStatsAsPercentage</span><span class="w"> </span><span class="p">);</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="cp">#else</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="cm">/* sizeof( int ) == sizeof( long ) so a smaller</span>
<span class="cm">                            printf() library can be used. */</span>
<span class="w">                            </span><span class="n">sprintf</span><span class="p">(</span><span class="w"> </span><span class="n">pcWriteBuffer</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">%u</span><span class="se">\t\t</span><span class="s">%u%%</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">[</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">].</span><span class="n">ulRunTimeCounter</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">ulStatsAsPercentage</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="cp">#endif</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="cm">/* If the percentage is zero here then the task has</span>
<span class="cm">                        consumed less than 1% of the total run time. */</span>
<span class="w">                        </span><span class="cp">#ifdef portLU_PRINTF_SPECIFIER_REQUIRED</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="n">sprintf</span><span class="p">(</span><span class="w"> </span><span class="n">pcWriteBuffer</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">%lu</span><span class="se">\t\t</span><span class="s">&lt;1%%</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">[</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">].</span><span class="n">ulRunTimeCounter</span><span class="w"> </span><span class="p">);</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="cp">#else</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="cm">/* sizeof( int ) == sizeof( long ) so a smaller</span>
<span class="cm">                            printf() library can be used. */</span>
<span class="w">                            </span><span class="n">sprintf</span><span class="p">(</span><span class="w"> </span><span class="n">pcWriteBuffer</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">%u</span><span class="se">\t\t</span><span class="s">&lt;1%%</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">[</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">].</span><span class="n">ulRunTimeCounter</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="cp">#endif</span>
<span class="w">                    </span><span class="p">}</span>

<span class="w">                    </span><span class="n">pcWriteBuffer</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="w"> </span><span class="n">pcWriteBuffer</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="cm">/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION</span>
<span class="cm">            is 0 then vPortFree() will be #defined to nothing. */</span>
<span class="w">            </span><span class="n">vPortFree</span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* ( ( configGENERATE_RUN_TIME_STATS == 1 ) &amp;&amp; ( configUSE_STATS_FORMATTING_FUNCTIONS &gt; 0 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="n">TickType_t</span><span class="w"> </span><span class="n">uxTaskResetEventItemValue</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">TickType_t</span><span class="w"> </span><span class="n">uxReturn</span><span class="p">;</span>

<span class="w">    </span><span class="n">uxReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">listGET_LIST_ITEM_VALUE</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Reset the event list item to its normal value - so it can be used with</span>
<span class="cm">    queues and semaphores. */</span>
<span class="w">    </span><span class="n">listSET_LIST_ITEM_VALUE</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">configMAX_PRIORITIES</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e961 MISRA exception as the casts are only redundant for some ports. */</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">uxReturn</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_MUTEXES == 1 )</span>

<span class="w">    </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">pvTaskIncrementMutexHeldCount</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* If xSemaphoreCreateMutex() is called before any tasks have been created</span>
<span class="cm">        then pxCurrentTCB will be NULL. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxMutexesHeld</span><span class="w"> </span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_MUTEXES */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if( configUSE_TASK_NOTIFICATIONS == 1 )</span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ulTaskNotifyTake</span><span class="p">(</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xClearCountOnExit</span><span class="p">,</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ulReturn</span><span class="p">;</span>

<span class="w">        </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Only block if the notification count is not already non-zero. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">ulNotifiedValue</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0UL</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Mark this task as waiting for a notification. */</span>
<span class="w">                </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">ucNotifyState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskWAITING_NOTIFICATION</span><span class="p">;</span>

<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">prvAddCurrentTaskToDelayedList</span><span class="p">(</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="p">,</span><span class="w"> </span><span class="n">pdTRUE</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="n">traceTASK_NOTIFY_TAKE_BLOCK</span><span class="p">();</span>

<span class="w">                    </span><span class="cm">/* All ports are written to allow a yield in a critical</span>
<span class="cm">                    section (some will yield immediately, others wait until the</span>
<span class="cm">                    critical section exits) - but it is not something that</span>
<span class="cm">                    application code should ever do. */</span>
<span class="w">                    </span><span class="n">portYIELD_WITHIN_API</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">        </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">traceTASK_NOTIFY_TAKE</span><span class="p">();</span>
<span class="w">            </span><span class="n">ulReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">ulNotifiedValue</span><span class="p">;</span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">ulReturn</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0UL</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xClearCountOnExit</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">ulNotifiedValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0UL</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">ulNotifiedValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ulReturn</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">ucNotifyState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskNOT_WAITING_NOTIFICATION</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ulReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_TASK_NOTIFICATIONS */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if( configUSE_TASK_NOTIFICATIONS == 1 )</span>

<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xTaskNotifyWait</span><span class="p">(</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ulBitsToClearOnEntry</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ulBitsToClearOnExit</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">pulNotificationValue</span><span class="p">,</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>

<span class="w">        </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Only block if a notification is not already pending. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">ucNotifyState</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">taskNOTIFICATION_RECEIVED</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Clear bits in the task&#39;s notification value as bits may get</span>
<span class="cm">                set by the notifying task or interrupt.  This can be used to</span>
<span class="cm">                clear the value to zero. */</span>
<span class="w">                </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">ulNotifiedValue</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">ulBitsToClearOnEntry</span><span class="p">;</span>

<span class="w">                </span><span class="cm">/* Mark this task as waiting for a notification. */</span>
<span class="w">                </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">ucNotifyState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskWAITING_NOTIFICATION</span><span class="p">;</span>

<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">prvAddCurrentTaskToDelayedList</span><span class="p">(</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="p">,</span><span class="w"> </span><span class="n">pdTRUE</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="n">traceTASK_NOTIFY_WAIT_BLOCK</span><span class="p">();</span>

<span class="w">                    </span><span class="cm">/* All ports are written to allow a yield in a critical</span>
<span class="cm">                    section (some will yield immediately, others wait until the</span>
<span class="cm">                    critical section exits) - but it is not something that</span>
<span class="cm">                    application code should ever do. */</span>
<span class="w">                    </span><span class="n">portYIELD_WITHIN_API</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">        </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">traceTASK_NOTIFY_WAIT</span><span class="p">();</span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pulNotificationValue</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Output the current notification value, which may or may not</span>
<span class="cm">                have changed. */</span>
<span class="w">                </span><span class="o">*</span><span class="n">pulNotificationValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">ulNotifiedValue</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="cm">/* If ucNotifyValue is set then either the task never entered the</span>
<span class="cm">            blocked state (because a notification was already pending) or the</span>
<span class="cm">            task unblocked because of a notification.  Otherwise the task</span>
<span class="cm">            unblocked because of a timeout. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">ucNotifyState</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">taskNOTIFICATION_RECEIVED</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* A notification was not received. */</span>
<span class="w">                </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* A notification was already pending or a notification was</span>
<span class="cm">                received while the task was waiting. */</span>
<span class="w">                </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">ulNotifiedValue</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">ulBitsToClearOnExit</span><span class="p">;</span>
<span class="w">                </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">ucNotifyState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskNOT_WAITING_NOTIFICATION</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_TASK_NOTIFICATIONS */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if( configUSE_TASK_NOTIFICATIONS == 1 )</span>

<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xTaskGenericNotify</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTaskToNotify</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ulValue</span><span class="p">,</span><span class="w"> </span><span class="n">eNotifyAction</span><span class="w"> </span><span class="n">eAction</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">pulPreviousNotificationValue</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pxTCB</span><span class="p">;</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdPASS</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ucOriginalNotifyState</span><span class="p">;</span>

<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskToNotify</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTaskToNotify</span><span class="p">;</span>

<span class="w">        </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pulPreviousNotificationValue</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="o">*</span><span class="n">pulPreviousNotificationValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ulNotifiedValue</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="n">ucOriginalNotifyState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ucNotifyState</span><span class="p">;</span>

<span class="w">            </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ucNotifyState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskNOTIFICATION_RECEIVED</span><span class="p">;</span>

<span class="w">            </span><span class="k">switch</span><span class="p">(</span><span class="w"> </span><span class="n">eAction</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">case</span><span class="w"> </span><span class="no">eSetBits</span><span class="w">   </span><span class="p">:</span>
<span class="w">                    </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ulNotifiedValue</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">ulValue</span><span class="p">;</span>
<span class="w">                    </span><span class="k">break</span><span class="p">;</span>

<span class="w">                </span><span class="k">case</span><span class="w"> </span><span class="no">eIncrement</span><span class="w"> </span><span class="p">:</span>
<span class="w">                    </span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ulNotifiedValue</span><span class="w"> </span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
<span class="w">                    </span><span class="k">break</span><span class="p">;</span>

<span class="w">                </span><span class="k">case</span><span class="w"> </span><span class="no">eSetValueWithOverwrite</span><span class="w"> </span><span class="p">:</span>
<span class="w">                    </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ulNotifiedValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ulValue</span><span class="p">;</span>
<span class="w">                    </span><span class="k">break</span><span class="p">;</span>

<span class="w">                </span><span class="k">case</span><span class="w"> </span><span class="no">eSetValueWithoutOverwrite</span><span class="w"> </span><span class="p">:</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">ucOriginalNotifyState</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">taskNOTIFICATION_RECEIVED</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ulNotifiedValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ulValue</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="cm">/* The value could not be written to the task. */</span>
<span class="w">                        </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFAIL</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">break</span><span class="p">;</span>

<span class="w">                </span><span class="k">case</span><span class="w"> </span><span class="no">eNoAction</span><span class="p">:</span>
<span class="w">                    </span><span class="cm">/* The task is being notified without its notify value being</span>
<span class="cm">                    updated. */</span>
<span class="w">                    </span><span class="k">break</span><span class="p">;</span>

<span class="w">                </span><span class="k">default</span><span class="o">:</span>
<span class="w">                    </span><span class="cm">/* Should not get here if all enums are handled.</span>
<span class="cm">                    Artificially force an assert by testing a value the</span>
<span class="cm">                    compiler can&#39;t assume is const. */</span>
<span class="w">                    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ulNotifiedValue</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">~</span><span class="mi">0UL</span><span class="w"> </span><span class="p">);</span>

<span class="w">                    </span><span class="k">break</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="n">traceTASK_NOTIFY</span><span class="p">();</span>

<span class="w">            </span><span class="cm">/* If the task is in the blocked state specifically to wait for a</span>
<span class="cm">            notification then unblock it now. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">ucOriginalNotifyState</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">taskWAITING_NOTIFICATION</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">uxListRemove</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="n">prvAddTaskToReadyList</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>

<span class="w">                </span><span class="cm">/* The task should not have been on an event list. */</span>
<span class="w">                </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_ITEM_CONTAINER</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">);</span>

<span class="w">                </span><span class="cp">#if( configUSE_TICKLESS_IDLE != 0 )</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* If a task is blocked waiting for a notification then</span>
<span class="cm">                    xNextTaskUnblockTime might be set to the blocked task&#39;s time</span>
<span class="cm">                    out time.  If the task is unblocked for a reason other than</span>
<span class="cm">                    a timeout xNextTaskUnblockTime is normally left unchanged,</span>
<span class="cm">                    because it will automatically get reset to a new value when</span>
<span class="cm">                    the tick count equals xNextTaskUnblockTime.  However if</span>
<span class="cm">                    tickless idling is used it might be more important to enter</span>
<span class="cm">                    sleep mode at the earliest possible time - so reset</span>
<span class="cm">                    xNextTaskUnblockTime here to ensure it is updated at the</span>
<span class="cm">                    earliest possible time. */</span>
<span class="w">                    </span><span class="n">prvResetNextTaskUnblockTime</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="cp">#endif</span>

<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* The notified task has a priority above the currently</span>
<span class="cm">                    executing task so a yield is required. */</span>
<span class="w">                    </span><span class="n">taskYIELD_IF_USING_PREEMPTION</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_TASK_NOTIFICATIONS */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if( configUSE_TASK_NOTIFICATIONS == 1 )</span>

<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xTaskGenericNotifyFromISR</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTaskToNotify</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ulValue</span><span class="p">,</span><span class="w"> </span><span class="n">eNotifyAction</span><span class="w"> </span><span class="n">eAction</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">pulPreviousNotificationValue</span><span class="p">,</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxHigherPriorityTaskWoken</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pxTCB</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ucOriginalNotifyState</span><span class="p">;</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdPASS</span><span class="p">;</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxSavedInterruptStatus</span><span class="p">;</span>

<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskToNotify</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* RTOS ports that support interrupt nesting have the concept of a</span>
<span class="cm">        maximum system call (or maximum API call) interrupt priority.</span>
<span class="cm">        Interrupts that are above the maximum system call priority are keep</span>
<span class="cm">        permanently enabled, even when the RTOS kernel is in a critical section,</span>
<span class="cm">        but cannot make any calls to FreeRTOS API functions.  If configASSERT()</span>
<span class="cm">        is defined in FreeRTOSConfig.h then</span>
<span class="cm">        portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion</span>
<span class="cm">        failure if a FreeRTOS API function is called from an interrupt that has</span>
<span class="cm">        been assigned a priority above the configured maximum system call</span>
<span class="cm">        priority.  Only FreeRTOS functions that end in FromISR can be called</span>
<span class="cm">        from interrupts that have been assigned a priority at or (logically)</span>
<span class="cm">        below the maximum system call interrupt priority.  FreeRTOS maintains a</span>
<span class="cm">        separate interrupt safe API to ensure interrupt entry is as fast and as</span>
<span class="cm">        simple as possible.  More information (albeit Cortex-M specific) is</span>
<span class="cm">        provided on the following link:</span>
<span class="cm">        http://www.freertos.org/RTOS-Cortex-M3-M4.html */</span>
<span class="w">        </span><span class="n">portASSERT_IF_INTERRUPT_PRIORITY_INVALID</span><span class="p">();</span>

<span class="w">        </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTaskToNotify</span><span class="p">;</span>

<span class="w">        </span><span class="n">uxSavedInterruptStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">portSET_INTERRUPT_MASK_FROM_ISR</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pulPreviousNotificationValue</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="o">*</span><span class="n">pulPreviousNotificationValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ulNotifiedValue</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="n">ucOriginalNotifyState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ucNotifyState</span><span class="p">;</span>
<span class="w">            </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ucNotifyState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskNOTIFICATION_RECEIVED</span><span class="p">;</span>

<span class="w">            </span><span class="k">switch</span><span class="p">(</span><span class="w"> </span><span class="n">eAction</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">case</span><span class="w"> </span><span class="no">eSetBits</span><span class="w">   </span><span class="p">:</span>
<span class="w">                    </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ulNotifiedValue</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">ulValue</span><span class="p">;</span>
<span class="w">                    </span><span class="k">break</span><span class="p">;</span>

<span class="w">                </span><span class="k">case</span><span class="w"> </span><span class="no">eIncrement</span><span class="w"> </span><span class="p">:</span>
<span class="w">                    </span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ulNotifiedValue</span><span class="w"> </span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
<span class="w">                    </span><span class="k">break</span><span class="p">;</span>

<span class="w">                </span><span class="k">case</span><span class="w"> </span><span class="no">eSetValueWithOverwrite</span><span class="w"> </span><span class="p">:</span>
<span class="w">                    </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ulNotifiedValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ulValue</span><span class="p">;</span>
<span class="w">                    </span><span class="k">break</span><span class="p">;</span>

<span class="w">                </span><span class="k">case</span><span class="w"> </span><span class="no">eSetValueWithoutOverwrite</span><span class="w"> </span><span class="p">:</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">ucOriginalNotifyState</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">taskNOTIFICATION_RECEIVED</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ulNotifiedValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ulValue</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="cm">/* The value could not be written to the task. */</span>
<span class="w">                        </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFAIL</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">break</span><span class="p">;</span>

<span class="w">                </span><span class="k">case</span><span class="w"> </span><span class="no">eNoAction</span><span class="w"> </span><span class="p">:</span>
<span class="w">                    </span><span class="cm">/* The task is being notified without its notify value being</span>
<span class="cm">                    updated. */</span>
<span class="w">                    </span><span class="k">break</span><span class="p">;</span>

<span class="w">                </span><span class="k">default</span><span class="o">:</span>
<span class="w">                    </span><span class="cm">/* Should not get here if all enums are handled.</span>
<span class="cm">                    Artificially force an assert by testing a value the</span>
<span class="cm">                    compiler can&#39;t assume is const. */</span>
<span class="w">                    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ulNotifiedValue</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">~</span><span class="mi">0UL</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="k">break</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="n">traceTASK_NOTIFY_FROM_ISR</span><span class="p">();</span>

<span class="w">            </span><span class="cm">/* If the task is in the blocked state specifically to wait for a</span>
<span class="cm">            notification then unblock it now. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">ucOriginalNotifyState</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">taskWAITING_NOTIFICATION</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* The task should not have been on an event list. */</span>
<span class="w">                </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_ITEM_CONTAINER</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">);</span>

<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxSchedulerSuspended</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">uxListRemove</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="n">prvAddTaskToReadyList</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* The delayed and ready lists cannot be accessed, so hold</span>
<span class="cm">                    this task pending until the scheduler is resumed. */</span>
<span class="w">                    </span><span class="n">vListInsertEnd</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">xPendingReadyList</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* The notified task has a priority above the currently</span>
<span class="cm">                    executing task so a yield is required. */</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="o">*</span><span class="n">pxHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>

<span class="w">                    </span><span class="cm">/* Mark that a yield is pending in case the user is not</span>
<span class="cm">                    using the &quot;xHigherPriorityTaskWoken&quot; parameter to an ISR</span>
<span class="cm">                    safe FreeRTOS function. */</span>
<span class="w">                    </span><span class="n">xYieldPending</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">portCLEAR_INTERRUPT_MASK_FROM_ISR</span><span class="p">(</span><span class="w"> </span><span class="n">uxSavedInterruptStatus</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_TASK_NOTIFICATIONS */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if( configUSE_TASK_NOTIFICATIONS == 1 )</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">vTaskNotifyGiveFromISR</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTaskToNotify</span><span class="p">,</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxHigherPriorityTaskWoken</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pxTCB</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ucOriginalNotifyState</span><span class="p">;</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxSavedInterruptStatus</span><span class="p">;</span>

<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskToNotify</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* RTOS ports that support interrupt nesting have the concept of a</span>
<span class="cm">        maximum system call (or maximum API call) interrupt priority.</span>
<span class="cm">        Interrupts that are above the maximum system call priority are keep</span>
<span class="cm">        permanently enabled, even when the RTOS kernel is in a critical section,</span>
<span class="cm">        but cannot make any calls to FreeRTOS API functions.  If configASSERT()</span>
<span class="cm">        is defined in FreeRTOSConfig.h then</span>
<span class="cm">        portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion</span>
<span class="cm">        failure if a FreeRTOS API function is called from an interrupt that has</span>
<span class="cm">        been assigned a priority above the configured maximum system call</span>
<span class="cm">        priority.  Only FreeRTOS functions that end in FromISR can be called</span>
<span class="cm">        from interrupts that have been assigned a priority at or (logically)</span>
<span class="cm">        below the maximum system call interrupt priority.  FreeRTOS maintains a</span>
<span class="cm">        separate interrupt safe API to ensure interrupt entry is as fast and as</span>
<span class="cm">        simple as possible.  More information (albeit Cortex-M specific) is</span>
<span class="cm">        provided on the following link:</span>
<span class="cm">        http://www.freertos.org/RTOS-Cortex-M3-M4.html */</span>
<span class="w">        </span><span class="n">portASSERT_IF_INTERRUPT_PRIORITY_INVALID</span><span class="p">();</span>

<span class="w">        </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTaskToNotify</span><span class="p">;</span>

<span class="w">        </span><span class="n">uxSavedInterruptStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">portSET_INTERRUPT_MASK_FROM_ISR</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">ucOriginalNotifyState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ucNotifyState</span><span class="p">;</span>
<span class="w">            </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ucNotifyState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskNOTIFICATION_RECEIVED</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/* &#39;Giving&#39; is equivalent to incrementing a count in a counting</span>
<span class="cm">            semaphore. */</span>
<span class="w">            </span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ulNotifiedValue</span><span class="w"> </span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

<span class="w">            </span><span class="n">traceTASK_NOTIFY_GIVE_FROM_ISR</span><span class="p">();</span>

<span class="w">            </span><span class="cm">/* If the task is in the blocked state specifically to wait for a</span>
<span class="cm">            notification then unblock it now. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">ucOriginalNotifyState</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">taskWAITING_NOTIFICATION</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* The task should not have been on an event list. */</span>
<span class="w">                </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_ITEM_CONTAINER</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">);</span>

<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxSchedulerSuspended</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">uxListRemove</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="n">prvAddTaskToReadyList</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* The delayed and ready lists cannot be accessed, so hold</span>
<span class="cm">                    this task pending until the scheduler is resumed. */</span>
<span class="w">                    </span><span class="n">vListInsertEnd</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">xPendingReadyList</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">xEventListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* The notified task has a priority above the currently</span>
<span class="cm">                    executing task so a yield is required. */</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="o">*</span><span class="n">pxHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>

<span class="w">                    </span><span class="cm">/* Mark that a yield is pending in case the user is not</span>
<span class="cm">                    using the &quot;xHigherPriorityTaskWoken&quot; parameter in an ISR</span>
<span class="cm">                    safe FreeRTOS function. */</span>
<span class="w">                    </span><span class="n">xYieldPending</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">portCLEAR_INTERRUPT_MASK_FROM_ISR</span><span class="p">(</span><span class="w"> </span><span class="n">uxSavedInterruptStatus</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_TASK_NOTIFICATIONS */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if( configUSE_TASK_NOTIFICATIONS == 1 )</span>

<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xTaskNotifyStateClear</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTCB</span><span class="p">;</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* If null is passed in here then it is the calling task that is having</span>
<span class="cm">        its notification state cleared. */</span>
<span class="w">        </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvGetTCBFromHandle</span><span class="p">(</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ucNotifyState</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">taskNOTIFICATION_RECEIVED</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ucNotifyState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskNOT_WAITING_NOTIFICATION</span><span class="p">;</span>
<span class="w">                </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdPASS</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFAIL</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_TASK_NOTIFICATIONS */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if( configUSE_TASK_NOTIFICATIONS == 1 )</span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ulTaskNotifyValueClear</span><span class="p">(</span><span class="w"> </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xTask</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ulBitsToClear</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TCB_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTCB</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ulReturn</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* If null is passed in here then it is the calling task that is having</span>
<span class="cm">        its notification state cleared. */</span>
<span class="w">        </span><span class="n">pxTCB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvGetTCBFromHandle</span><span class="p">(</span><span class="w"> </span><span class="n">xTask</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Return the notification as it was before the bits were cleared,</span>
<span class="cm">            then clear the bit mask. */</span>
<span class="w">            </span><span class="n">ulReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">ulNotifiedValue</span><span class="p">;</span>
<span class="w">            </span><span class="n">pxTCB</span><span class="o">-&gt;</span><span class="n">ulNotifiedValue</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">ulBitsToClear</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ulReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_TASK_NOTIFICATIONS */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if( ( configGENERATE_RUN_TIME_STATS == 1 ) &amp;&amp; ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) )</span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ulTaskGetIdleRunTimeCounter</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xIdleTaskHandle</span><span class="o">-&gt;</span><span class="n">ulRunTimeCounter</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">prvAddCurrentTaskToDelayedList</span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xCanBlockIndefinitely</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">TickType_t</span><span class="w"> </span><span class="n">xTimeToWake</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xConstTickCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTickCount</span><span class="p">;</span>

<span class="w">    </span><span class="cp">#if( INCLUDE_xTaskAbortDelay == 1 )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* About to enter a delayed list, so ensure the ucDelayAborted flag is</span>
<span class="cm">        reset to pdFALSE so it can be detected as having been set to pdTRUE</span>
<span class="cm">        when the task leaves the Blocked state. */</span>
<span class="w">        </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">ucDelayAborted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="w">    </span><span class="cm">/* Remove the task from the ready list before adding it to the blocked list</span>
<span class="cm">    as the same list item is used for both lists. */</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxListRemove</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* The current task must be in a ready list, so there is no need to</span>
<span class="cm">        check, and the port reset macro can be called directly. */</span>
<span class="w">        </span><span class="n">portRESET_READY_PRIORITY</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">uxPriority</span><span class="p">,</span><span class="w"> </span><span class="n">uxTopReadyPriority</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB-&gt;uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cp">#if ( INCLUDE_vTaskSuspend == 1 )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">portMAX_DELAY</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xCanBlockIndefinitely</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Add the task to the suspended task list instead of a delayed task</span>
<span class="cm">            list to ensure it is not woken by a timing event.  It will block</span>
<span class="cm">            indefinitely. */</span>
<span class="w">            </span><span class="n">vListInsertEnd</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xSuspendedTaskList</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Calculate the time at which the task should be woken if the event</span>
<span class="cm">            does not occur.  This may overflow but this doesn&#39;t matter, the</span>
<span class="cm">            kernel will manage it correctly. */</span>
<span class="w">            </span><span class="n">xTimeToWake</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xConstTickCount</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/* The list item will be inserted in wake time order. */</span>
<span class="w">            </span><span class="n">listSET_LIST_ITEM_VALUE</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="n">xTimeToWake</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTimeToWake</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">xConstTickCount</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Wake time has overflowed.  Place this item in the overflow</span>
<span class="cm">                list. */</span>
<span class="w">                </span><span class="n">vListInsert</span><span class="p">(</span><span class="w"> </span><span class="n">pxOverflowDelayedTaskList</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* The wake time has not overflowed, so the current block list</span>
<span class="cm">                is used. */</span>
<span class="w">                </span><span class="n">vListInsert</span><span class="p">(</span><span class="w"> </span><span class="n">pxDelayedTaskList</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">                </span><span class="cm">/* If the task entering the blocked state was placed at the</span>
<span class="cm">                head of the list of blocked tasks then xNextTaskUnblockTime</span>
<span class="cm">                needs to be updated too. */</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTimeToWake</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">xNextTaskUnblockTime</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">xNextTaskUnblockTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTimeToWake</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#else </span><span class="cm">/* INCLUDE_vTaskSuspend */</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Calculate the time at which the task should be woken if the event</span>
<span class="cm">        does not occur.  This may overflow but this doesn&#39;t matter, the kernel</span>
<span class="cm">        will manage it correctly. */</span>
<span class="w">        </span><span class="n">xTimeToWake</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xConstTickCount</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* The list item will be inserted in wake time order. */</span>
<span class="w">        </span><span class="n">listSET_LIST_ITEM_VALUE</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="n">xTimeToWake</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTimeToWake</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">xConstTickCount</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Wake time has overflowed.  Place this item in the overflow list. */</span>
<span class="w">            </span><span class="n">vListInsert</span><span class="p">(</span><span class="w"> </span><span class="n">pxOverflowDelayedTaskList</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* The wake time has not overflowed, so the current block list is used. */</span>
<span class="w">            </span><span class="n">vListInsert</span><span class="p">(</span><span class="w"> </span><span class="n">pxDelayedTaskList</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxCurrentTCB</span><span class="o">-&gt;</span><span class="n">xStateListItem</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="cm">/* If the task entering the blocked state was placed at the head of the</span>
<span class="cm">            list of blocked tasks then xNextTaskUnblockTime needs to be updated</span>
<span class="cm">            too. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTimeToWake</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">xNextTaskUnblockTime</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">xNextTaskUnblockTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTimeToWake</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */</span>
<span class="w">        </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xCanBlockIndefinitely</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif </span><span class="cm">/* INCLUDE_vTaskSuspend */</span>
<span class="p">}</span>

<span class="cm">/* Code below here allows additional code to be inserted into this source file,</span>
<span class="cm">especially where access to file scope functions and data is needed (for example</span>
<span class="cm">when performing module tests). */</span>

<span class="cp">#ifdef FREERTOS_MODULE_TEST</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;tasks_test_access_functions.h&quot;</span>
<span class="cp">#endif</span>


<span class="cp">#if( configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1 )</span>

<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;freertos_tasks_c_additions.h&quot;</span>

<span class="w">    </span><span class="cp">#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">freertos_tasks_c_additions_init</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">FREERTOS_TASKS_C_ADDITIONS_INIT</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="cp">#endif</span>
</code></pre></div>





                
              </article>
            </div>
          
          
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
            Back to top
          </button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright © 2023 RoboticsBrno
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        <div class="md-social">
  
    
    
    
    
      
      
    
    <a href="https://github.com/RoboticsBrno" target="_blank" rel="noopener" title="github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
    </a>
  
    
    
    
    
      
      
    
    <a href="https://twitter.com/RobotikaBrno" target="_blank" rel="noopener" title="twitter.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg>
    </a>
  
    
    
    
    
      
      
    
    <a href="https://www.facebook.com/robotarna" target="_blank" rel="noopener" title="www.facebook.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M504 256C504 119 393 8 256 8S8 119 8 256c0 123.78 90.69 226.38 209.25 245V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.28c-30.8 0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.31 482.38 504 379.78 504 256z"/></svg>
    </a>
  
    
    
    
    
      
      
    
    <a href="https://www.youtube.com/@robotikabrno-robotarnaasps2392" target="_blank" rel="noopener" title="www.youtube.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M549.655 124.083c-6.281-23.65-24.787-42.276-48.284-48.597C458.781 64 288 64 288 64S117.22 64 74.629 75.486c-23.497 6.322-42.003 24.947-48.284 48.597-11.412 42.867-11.412 132.305-11.412 132.305s0 89.438 11.412 132.305c6.281 23.65 24.787 41.5 48.284 47.821C117.22 448 288 448 288 448s170.78 0 213.371-11.486c23.497-6.321 42.003-24.171 48.284-47.821 11.412-42.867 11.412-132.305 11.412-132.305s0-89.438-11.412-132.305zm-317.51 213.508V175.185l142.739 81.205-142.739 81.201z"/></svg>
    </a>
  
    
    
    
    
      
      
    
    <a href="https://www.instagram.com/_robotarna_" target="_blank" rel="noopener" title="www.instagram.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.tabs", "navigation.indexes", "navigation.top"], "search": "../../assets/javascripts/workers/search.208ed371.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.b4d07000.min.js"></script>
      
        <script src="../../assets/js/open_in_new_tab.js"></script>
      
    
  <script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>