
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Documentation for the RBCX robot controller board designed by the RoboticsBrno team. It is based on the STM32F446RE microcontroller and ESP32 microcontroller. Features: 4 motors with encoders, 4 servos, buttons with the gamepad, LEDs, ultra-sonic sensor, ...">
      
      
        <meta name="author" content="RoboticsBrno">
      
      
        <link rel="canonical" href="https://rbcx.robotikabrno.cz/apiStm/queue_8c_source/">
      
      
      
      <link rel="icon" href="../../assets/logo.png">
      <meta name="generator" content="mkdocs-1.4.3, mkdocs-material-9.1.15">
    
    
      
        <title>File queue.c - RB3204-RBCX</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.26e3688c.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.ecc896b0.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
        html.glightbox-open { overflow: initial; height: 100%; }
        .gslide-title { margin-top: 0px; user-select: text; }
        .gslide-desc { color: #666; user-select: text; }
        .gslide-image img { background: white; }
        
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}
            </style> <script src="../../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="green" data-md-color-accent="green">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#file-queuec" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="RB3204-RBCX" class="md-header__button md-logo" aria-label="RB3204-RBCX" data-md-component="logo">
      
  <img src="../../assets/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            RB3204-RBCX
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              File queue.c
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
          
            
            
            
            <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="green" data-md-color-accent="green"  aria-hidden="true"  type="radio" name="__palette" id="__palette_1">
            
          
        </form>
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/RoboticsBrno/RB3204-RBCX" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    RoboticsBrno/RB3204-RBCX
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  


  <li class="md-tabs__item">
    <a href="../.." class="md-tabs__link">
      Home
    </a>
  </li>

      
        
  
  


  <li class="md-tabs__item">
    <a href="../../SW-development/" class="md-tabs__link">
      Software development
    </a>
  </li>

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../api/" class="md-tabs__link">
        API Reference
      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="RB3204-RBCX" class="md-nav__button md-logo" aria-label="RB3204-RBCX" data-md-component="logo">
      
  <img src="../../assets/logo.png" alt="logo">

    </a>
    RB3204-RBCX
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/RoboticsBrno/RB3204-RBCX" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    RoboticsBrno/RB3204-RBCX
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../SW-development/" class="md-nav__link">
        Software development
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
      
      
        
          
            
          
        
          
        
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../../api/">API Reference</a>
          
            <label for="__nav_3">
              <span class="md-nav__icon md-icon"></span>
            </label>
          
        </div>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          API Reference
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2" >
      
      
        
          
            
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../">API STM Coprocessor</a>
          
            <label for="__nav_3_2">
              <span class="md-nav__icon md-icon"></span>
            </label>
          
        </div>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_2_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_2">
          <span class="md-nav__icon md-icon"></span>
          API STM Coprocessor
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../links/" class="md-nav__link">
        Links
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2_3" >
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_3_2_3" id="__nav_3_2_3_label" tabindex="0">
          Classes
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_2_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_2_3">
          <span class="md-nav__icon md-icon"></span>
          Classes
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../annotated/" class="md-nav__link">
        Class List
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../classes/" class="md-nav__link">
        Class Index
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../hierarchy/" class="md-nav__link">
        Class Hierarchy
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../class_members/" class="md-nav__link">
        Class Members
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../class_member_functions/" class="md-nav__link">
        Class Member Functions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../class_member_variables/" class="md-nav__link">
        Class Member Variables
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../class_member_typedefs/" class="md-nav__link">
        Class Member Typedefs
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../class_member_enums/" class="md-nav__link">
        Class Member Enumerations
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2_4" >
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_3_2_4" id="__nav_3_2_4_label" tabindex="0">
          Namespaces
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_2_4_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_2_4">
          <span class="md-nav__icon md-icon"></span>
          Namespaces
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../namespaces/" class="md-nav__link">
        Namespace List
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../namespace_members/" class="md-nav__link">
        Namespace Members
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../namespace_member_functions/" class="md-nav__link">
        Namespace Member Functions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../namespace_member_variables/" class="md-nav__link">
        Namespace Member Variables
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../namespace_member_typedefs/" class="md-nav__link">
        Namespace Member Typedefs
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../namespace_member_enums/" class="md-nav__link">
        Namespace Member Enumerations
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../functions/" class="md-nav__link">
        Functions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../variables/" class="md-nav__link">
        Variables
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../macros/" class="md-nav__link">
        Macros
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../files/" class="md-nav__link">
        Files
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3" >
      
      
        
          
            
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../../apiEsp32/">API ESP32 library</a>
          
            <label for="__nav_3_3">
              <span class="md-nav__icon md-icon"></span>
            </label>
          
        </div>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_3">
          <span class="md-nav__icon md-icon"></span>
          API ESP32 library
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/links/" class="md-nav__link">
        Links
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3_3" >
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_3_3_3" id="__nav_3_3_3_label" tabindex="0">
          Classes
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_3_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_3_3">
          <span class="md-nav__icon md-icon"></span>
          Classes
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/annotated/" class="md-nav__link">
        Class List
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/classes/" class="md-nav__link">
        Class Index
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/hierarchy/" class="md-nav__link">
        Class Hierarchy
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/class_members/" class="md-nav__link">
        Class Members
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/class_member_functions/" class="md-nav__link">
        Class Member Functions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/class_member_variables/" class="md-nav__link">
        Class Member Variables
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/class_member_typedefs/" class="md-nav__link">
        Class Member Typedefs
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/class_member_enums/" class="md-nav__link">
        Class Member Enumerations
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3_4" >
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_3_3_4" id="__nav_3_3_4_label" tabindex="0">
          Namespaces
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_3_4_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_3_4">
          <span class="md-nav__icon md-icon"></span>
          Namespaces
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/namespaces/" class="md-nav__link">
        Namespace List
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/namespace_members/" class="md-nav__link">
        Namespace Members
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/namespace_member_functions/" class="md-nav__link">
        Namespace Member Functions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/namespace_member_variables/" class="md-nav__link">
        Namespace Member Variables
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/namespace_member_typedefs/" class="md-nav__link">
        Namespace Member Typedefs
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/namespace_member_enums/" class="md-nav__link">
        Namespace Member Enumerations
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/functions/" class="md-nav__link">
        Functions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/variables/" class="md-nav__link">
        Variables
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/macros/" class="md-nav__link">
        Macros
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../apiEsp32/files/" class="md-nav__link">
        Files
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="file-queuec">File queue.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_6728f3a9088eeb382ccd8bff3a2a4804/"><strong>FreeRTOS</strong></a> <strong>&gt;</strong> <a href="../dir_3e946fa640f7764a34038834221bbde8/"><strong>src</strong></a> <strong>&gt;</strong> <a href="../queue_8c/"><strong>queue.c</strong></a></p>
<p><a href="../queue_8c/">Go to the documentation of this file.</a> </p>
<div class="highlight"><pre><span></span><code><span class="cm">/*</span>
<span class="cm"> * FreeRTOS Kernel V10.3.1</span>
<span class="cm"> * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining a copy of</span>
<span class="cm"> * this software and associated documentation files (the &quot;Software&quot;), to deal in</span>
<span class="cm"> * the Software without restriction, including without limitation the rights to</span>
<span class="cm"> * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of</span>
<span class="cm"> * the Software, and to permit persons to whom the Software is furnished to do so,</span>
<span class="cm"> * subject to the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice shall be included in all</span>
<span class="cm"> * copies or substantial portions of the Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="cm"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS</span>
<span class="cm"> * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR</span>
<span class="cm"> * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER</span>
<span class="cm"> * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<span class="cm"> * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="cm"> *</span>
<span class="cm"> * http://www.FreeRTOS.org</span>
<span class="cm"> * http://aws.amazon.com/freertos</span>
<span class="cm"> *</span>
<span class="cm"> * 1 tab == 4 spaces!</span>
<span class="cm"> */</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>

<span class="cm">/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining</span>
<span class="cm">all the API functions to use the MPU wrappers.  That should only be done when</span>
<span class="cm">task.h is included from an application file. */</span>
<span class="cp">#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;FreeRTOS.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;task.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;queue.h&quot;</span>

<span class="cp">#if ( configUSE_CO_ROUTINES == 1 )</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;croutine.h&quot;</span>
<span class="cp">#endif</span>

<span class="cm">/* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified</span>
<span class="cm">because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined</span>
<span class="cm">for the header files above, but not in this file, in order to generate the</span>
<span class="cm">correct privileged Vs unprivileged linkage and placement. */</span>
<span class="cp">#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE </span><span class="cm">/*lint !e961 !e750 !e9021. */</span>


<span class="cm">/* Constants used with the cRxLock and cTxLock structure members. */</span>
<span class="cp">#define queueUNLOCKED                   ( ( int8_t ) -1 )</span>
<span class="cp">#define queueLOCKED_UNMODIFIED          ( ( int8_t ) 0 )</span>

<span class="cm">/* When the Queue_t structure is used to represent a base queue its pcHead and</span>
<span class="cm">pcTail members are used as pointers into the queue storage area.  When the</span>
<span class="cm">Queue_t structure is used to represent a mutex pcHead and pcTail pointers are</span>
<span class="cm">not necessary, and the pcHead pointer is set to NULL to indicate that the</span>
<span class="cm">structure instead holds a pointer to the mutex holder (if any).  Map alternative</span>
<span class="cm">names to the pcHead and structure member to ensure the readability of the code</span>
<span class="cm">is maintained.  The QueuePointers_t and SemaphoreData_t types are used to form</span>
<span class="cm">a union as their usage is mutually exclusive dependent on what the queue is</span>
<span class="cm">being used for. */</span>
<span class="cp">#define uxQueueType                     pcHead</span>
<span class="cp">#define queueQUEUE_IS_MUTEX             NULL</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">QueuePointers</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int8_t</span><span class="w"> </span><span class="o">*</span><span class="n">pcTail</span><span class="p">;</span><span class="w">                 </span><span class="cm">/*&lt; Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */</span>
<span class="w">    </span><span class="kt">int8_t</span><span class="w"> </span><span class="o">*</span><span class="n">pcReadFrom</span><span class="p">;</span><span class="w">             </span><span class="cm">/*&lt; Points to the last place that a queued item was read from when the structure is used as a queue. */</span>
<span class="p">}</span><span class="w"> </span><span class="n">QueuePointers_t</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">SemaphoreData</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xMutexHolder</span><span class="p">;</span><span class="w">       </span><span class="cm">/*&lt; The handle of the task that holds the mutex. */</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxRecursiveCallCount</span><span class="p">;</span><span class="cm">/*&lt; Maintains a count of the number of times a recursive mutex has been recursively &#39;taken&#39; when the structure is used as a mutex. */</span>
<span class="p">}</span><span class="w"> </span><span class="n">SemaphoreData_t</span><span class="p">;</span>

<span class="cm">/* Semaphores do not actually store or copy data, so have an item size of</span>
<span class="cm">zero. */</span>
<span class="cp">#define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )</span>
<span class="cp">#define queueMUTEX_GIVE_BLOCK_TIME       ( ( TickType_t ) 0U )</span>

<span class="cp">#if( configUSE_PREEMPTION == 0 )</span>
<span class="w">    </span><span class="cm">/* If the cooperative scheduler is being used then a yield should not be</span>
<span class="cm">    performed just because a higher priority task has been woken. */</span>
<span class="w">    </span><span class="cp">#define queueYIELD_IF_USING_PREEMPTION()</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="cp">#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Definition of the queue used by the scheduler.</span>
<span class="cm"> * Items are queued by copy, not reference.  See the following link for the</span>
<span class="cm"> * rationale: https://www.freertos.org/Embedded-RTOS-Queues.html</span>
<span class="cm"> */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">QueueDefinition</span><span class="w">      </span><span class="cm">/* The old naming convention is used to prevent breaking kernel aware debuggers. */</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int8_t</span><span class="w"> </span><span class="o">*</span><span class="n">pcHead</span><span class="p">;</span><span class="w">                 </span><span class="cm">/*&lt; Points to the beginning of the queue storage area. */</span>
<span class="w">    </span><span class="kt">int8_t</span><span class="w"> </span><span class="o">*</span><span class="n">pcWriteTo</span><span class="p">;</span><span class="w">              </span><span class="cm">/*&lt; Points to the free next place in the storage area. */</span>

<span class="w">    </span><span class="k">union</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">QueuePointers_t</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span><span class="w">     </span><span class="cm">/*&lt; Data required exclusively when this structure is used as a queue. */</span>
<span class="w">        </span><span class="n">SemaphoreData_t</span><span class="w"> </span><span class="n">xSemaphore</span><span class="p">;</span><span class="w"> </span><span class="cm">/*&lt; Data required exclusively when this structure is used as a semaphore. */</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">u</span><span class="p">;</span>

<span class="w">    </span><span class="n">List_t</span><span class="w"> </span><span class="n">xTasksWaitingToSend</span><span class="p">;</span><span class="w">     </span><span class="cm">/*&lt; List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */</span>
<span class="w">    </span><span class="n">List_t</span><span class="w"> </span><span class="n">xTasksWaitingToReceive</span><span class="p">;</span><span class="w">  </span><span class="cm">/*&lt; List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */</span>

<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxMessagesWaiting</span><span class="p">;</span><span class="cm">/*&lt; The number of items currently in the queue. */</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxLength</span><span class="p">;</span><span class="w">           </span><span class="cm">/*&lt; The length of the queue defined as the number of items it will hold, not the number of bytes. */</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxItemSize</span><span class="p">;</span><span class="w">         </span><span class="cm">/*&lt; The size of each items that the queue will hold. */</span>

<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="kt">int8_t</span><span class="w"> </span><span class="n">cRxLock</span><span class="p">;</span><span class="w">        </span><span class="cm">/*&lt; Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */</span>
<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="kt">int8_t</span><span class="w"> </span><span class="n">cTxLock</span><span class="p">;</span><span class="w">        </span><span class="cm">/*&lt; Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */</span>

<span class="w">    </span><span class="cp">#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )</span>
<span class="w">        </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ucStaticallyAllocated</span><span class="p">;</span><span class="w">  </span><span class="cm">/*&lt; Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. */</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="w">    </span><span class="cp">#if ( configUSE_QUEUE_SETS == 1 )</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">QueueDefinition</span><span class="w"> </span><span class="o">*</span><span class="n">pxQueueSetContainer</span><span class="p">;</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="w">    </span><span class="cp">#if ( configUSE_TRACE_FACILITY == 1 )</span>
<span class="w">        </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxQueueNumber</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ucQueueType</span><span class="p">;</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="p">}</span><span class="w"> </span><span class="n">xQUEUE</span><span class="p">;</span>

<span class="cm">/* The old xQUEUE name is maintained above then typedefed to the new Queue_t</span>
<span class="cm">name below to enable the use of older kernel aware debuggers. */</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">xQUEUE</span><span class="w"> </span><span class="n">Queue_t</span><span class="p">;</span>

<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * The queue registry is just a means for kernel aware debuggers to locate</span>
<span class="cm"> * queue structures.  It has no other purpose so is an optional component.</span>
<span class="cm"> */</span>
<span class="cp">#if ( configQUEUE_REGISTRY_SIZE &gt; 0 )</span>

<span class="w">    </span><span class="cm">/* The type stored within the queue registry array.  This allows a name</span>
<span class="cm">    to be assigned to each queue making kernel aware debugging a little</span>
<span class="cm">    more user friendly. */</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">QUEUE_REGISTRY_ITEM</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">pcQueueName</span><span class="p">;</span><span class="w"> </span><span class="cm">/*lint !e971 Unqualified char types are allowed for strings and single characters only. */</span>
<span class="w">        </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xHandle</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">xQueueRegistryItem</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* The old xQueueRegistryItem name is maintained above then typedefed to the</span>
<span class="cm">    new xQueueRegistryItem name below to enable the use of older kernel aware</span>
<span class="cm">    debuggers. */</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="n">xQueueRegistryItem</span><span class="w"> </span><span class="n">QueueRegistryItem_t</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* The queue registry is simply an array of QueueRegistryItem_t structures.</span>
<span class="cm">    The pcQueueName member of a structure being NULL is indicative of the</span>
<span class="cm">    array position being vacant. */</span>
<span class="w">    </span><span class="n">PRIVILEGED_DATA</span><span class="w"> </span><span class="n">QueueRegistryItem_t</span><span class="w"> </span><span class="n">xQueueRegistry</span><span class="p">[</span><span class="w"> </span><span class="n">configQUEUE_REGISTRY_SIZE</span><span class="w"> </span><span class="p">];</span>

<span class="cp">#endif </span><span class="cm">/* configQUEUE_REGISTRY_SIZE */</span>

<span class="cm">/*</span>
<span class="cm"> * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not</span>
<span class="cm"> * prevent an ISR from adding or removing items to the queue, but does prevent</span>
<span class="cm"> * an ISR from removing tasks from the queue event lists.  If an ISR finds a</span>
<span class="cm"> * queue is locked it will instead increment the appropriate queue lock count</span>
<span class="cm"> * to indicate that a task may require unblocking.  When the queue in unlocked</span>
<span class="cm"> * these lock counts are inspected, and the appropriate action taken.</span>
<span class="cm"> */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">prvUnlockQueue</span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">PRIVILEGED_FUNCTION</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Uses a critical section to determine if there is any data in a queue.</span>
<span class="cm"> *</span>
<span class="cm"> * @return pdTRUE if the queue contains no items, otherwise pdFALSE.</span>
<span class="cm"> */</span>
<span class="k">static</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="nf">prvIsQueueEmpty</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">PRIVILEGED_FUNCTION</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Uses a critical section to determine if there is any space in a queue.</span>
<span class="cm"> *</span>
<span class="cm"> * @return pdTRUE if there is no space, otherwise pdFALSE;</span>
<span class="cm"> */</span>
<span class="k">static</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="nf">prvIsQueueFull</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">PRIVILEGED_FUNCTION</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Copies an item into the queue, either at the front of the queue or the</span>
<span class="cm"> * back of the queue.</span>
<span class="cm"> */</span>
<span class="k">static</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="nf">prvCopyDataToQueue</span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvItemToQueue</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xPosition</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">PRIVILEGED_FUNCTION</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Copies an item out of a queue.</span>
<span class="cm"> */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">prvCopyDataFromQueue</span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pvBuffer</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">PRIVILEGED_FUNCTION</span><span class="p">;</span>

<span class="cp">#if ( configUSE_QUEUE_SETS == 1 )</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Checks to see if a queue is a member of a queue set, and if so, notifies</span>
<span class="cm">     * the queue set that the queue contains data.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="nf">prvNotifyQueueSetContainer</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">PRIVILEGED_FUNCTION</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Called after a Queue_t structure has been allocated either statically or</span>
<span class="cm"> * dynamically to fill in the structure&#39;s members.</span>
<span class="cm"> */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">prvInitialiseNewQueue</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxQueueLength</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxItemSize</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">pucQueueStorage</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ucQueueType</span><span class="p">,</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxNewQueue</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">PRIVILEGED_FUNCTION</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Mutexes are a special type of queue.  When a mutex is created, first the</span>
<span class="cm"> * queue is created, then prvInitialiseMutex() is called to configure the queue</span>
<span class="cm"> * as a mutex.</span>
<span class="cm"> */</span>
<span class="cp">#if( configUSE_MUTEXES == 1 )</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">prvInitialiseMutex</span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxNewQueue</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">PRIVILEGED_FUNCTION</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#if( configUSE_MUTEXES == 1 )</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * If a task waiting for a mutex causes the mutex holder to inherit a</span>
<span class="cm">     * priority, but the waiting task times out, then the holder should</span>
<span class="cm">     * disinherit the priority - but only down to the highest priority of any</span>
<span class="cm">     * other tasks that are waiting for the same mutex.  This function returns</span>
<span class="cm">     * that priority.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="nf">prvGetDisinheritPriorityAfterTimeout</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">PRIVILEGED_FUNCTION</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * Macro to mark a queue as locked.  Locking a queue prevents an ISR from</span>
<span class="cm"> * accessing the queue event lists.</span>
<span class="cm"> */</span>
<span class="cp">#define prvLockQueue( pxQueue )                             \</span>
<span class="cp">    taskENTER_CRITICAL();                                   \</span>
<span class="cp">    {                                                       \</span>
<span class="cp">        if( ( pxQueue )-&gt;cRxLock == queueUNLOCKED )         \</span>
<span class="cp">        {                                                   \</span>
<span class="cp">            ( pxQueue )-&gt;cRxLock = queueLOCKED_UNMODIFIED;  \</span>
<span class="cp">        }                                                   \</span>
<span class="cp">        if( ( pxQueue )-&gt;cTxLock == queueUNLOCKED )         \</span>
<span class="cp">        {                                                   \</span>
<span class="cp">            ( pxQueue )-&gt;cTxLock = queueLOCKED_UNMODIFIED;  \</span>
<span class="cp">        }                                                   \</span>
<span class="cp">    }                                                       \</span>
<span class="cp">    taskEXIT_CRITICAL()</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xQueueGenericReset</span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xNewQueue</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span>

<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcTail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">pcHead</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxLength</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxItemSize</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */</span>
<span class="w">        </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0U</span><span class="p">;</span>
<span class="w">        </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">pcWriteTo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">pcHead</span><span class="p">;</span>
<span class="w">        </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcReadFrom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">pcHead</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxLength</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1U</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxItemSize</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */</span>
<span class="w">        </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">cRxLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">queueUNLOCKED</span><span class="p">;</span>
<span class="w">        </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">cTxLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">queueUNLOCKED</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xNewQueue</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* If there are tasks blocked waiting to read from the queue, then</span>
<span class="cm">            the tasks will remain blocked as after this function exits the queue</span>
<span class="cm">            will still be empty.  If there are tasks blocked waiting to write to</span>
<span class="cm">            the queue, then one should be unblocked as after this function exits</span>
<span class="cm">            it will be possible to write to it. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_IS_EMPTY</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToSend</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskRemoveFromEventList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToSend</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">queueYIELD_IF_USING_PREEMPTION</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Ensure the event queues start in the correct state. */</span>
<span class="w">            </span><span class="n">vListInitialise</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToSend</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="n">vListInitialise</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">    </span><span class="cm">/* A value is returned for calling semantic consistency with previous</span>
<span class="cm">    versions. */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">pdPASS</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if( configSUPPORT_STATIC_ALLOCATION == 1 )</span>

<span class="w">    </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="nf">xQueueGenericCreateStatic</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxQueueLength</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxItemSize</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">pucQueueStorage</span><span class="p">,</span><span class="w"> </span><span class="n">StaticQueue_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxStaticQueue</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ucQueueType</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxNewQueue</span><span class="p">;</span>

<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">uxQueueLength</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* The StaticQueue_t structure and the queue storage area must be</span>
<span class="cm">        supplied. */</span>
<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxStaticQueue</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* A queue storage area should be provided if the item size is not 0, and</span>
<span class="cm">        should not be provided if the item size is 0. */</span>
<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pucQueueStorage</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">uxItemSize</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pucQueueStorage</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">uxItemSize</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cp">#if( configASSERT_DEFINED == 1 )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Sanity check that the size of the structure used to declare a</span>
<span class="cm">            variable of type StaticQueue_t or StaticSemaphore_t equals the size of</span>
<span class="cm">            the real queue and semaphore structures. */</span>
<span class="w">            </span><span class="k">volatile</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">xSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">StaticQueue_t</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">xSize</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xSize</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Keeps lint quiet when configASSERT() is not defined. */</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif </span><span class="cm">/* configASSERT_DEFINED */</span>

<span class="w">        </span><span class="cm">/* The address of a statically allocated queue was passed in, use it.</span>
<span class="cm">        The address of a statically allocated storage area was also passed in</span>
<span class="cm">        but is already set. */</span>
<span class="w">        </span><span class="n">pxNewQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxStaticQueue</span><span class="p">;</span><span class="w"> </span><span class="cm">/*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewQueue</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cp">#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Queues can be allocated wither statically or dynamically, so</span>
<span class="cm">                note this queue was allocated statically in case the queue is</span>
<span class="cm">                later deleted. */</span>
<span class="w">                </span><span class="n">pxNewQueue</span><span class="o">-&gt;</span><span class="n">ucStaticallyAllocated</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="cp">#endif </span><span class="cm">/* configSUPPORT_DYNAMIC_ALLOCATION */</span>

<span class="w">            </span><span class="n">prvInitialiseNewQueue</span><span class="p">(</span><span class="w"> </span><span class="n">uxQueueLength</span><span class="p">,</span><span class="w"> </span><span class="n">uxItemSize</span><span class="p">,</span><span class="w"> </span><span class="n">pucQueueStorage</span><span class="p">,</span><span class="w"> </span><span class="n">ucQueueType</span><span class="p">,</span><span class="w"> </span><span class="n">pxNewQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">traceQUEUE_CREATE_FAILED</span><span class="p">(</span><span class="w"> </span><span class="n">ucQueueType</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">pxNewQueue</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configSUPPORT_STATIC_ALLOCATION */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )</span>

<span class="w">    </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="nf">xQueueGenericCreate</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxQueueLength</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxItemSize</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ucQueueType</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxNewQueue</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">xQueueSizeInBytes</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">pucQueueStorage</span><span class="p">;</span>

<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">uxQueueLength</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* Allocate enough space to hold the maximum number of items that</span>
<span class="cm">        can be in the queue at any time.  It is valid for uxItemSize to be</span>
<span class="cm">        zero in the case the queue is used as a semaphore. */</span>
<span class="w">        </span><span class="n">xQueueSizeInBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">uxQueueLength</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">uxItemSize</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e961 MISRA exception as the casts are only redundant for some ports. */</span>

<span class="w">        </span><span class="cm">/* Allocate the queue and storage area.  Justification for MISRA</span>
<span class="cm">        deviation as follows:  pvPortMalloc() always ensures returned memory</span>
<span class="cm">        blocks are aligned per the requirements of the MCU stack.  In this case</span>
<span class="cm">        pvPortMalloc() must return a pointer that is guaranteed to meet the</span>
<span class="cm">        alignment requirements of the Queue_t structure - which in this case</span>
<span class="cm">        is an int8_t *.  Therefore, whenever the stack alignment requirements</span>
<span class="cm">        are greater than or equal to the pointer to char requirements the cast</span>
<span class="cm">        is safe.  In other cases alignment requirements are not strict (one or</span>
<span class="cm">        two bytes). */</span>
<span class="w">        </span><span class="n">pxNewQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pvPortMalloc</span><span class="p">(</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">xQueueSizeInBytes</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e9087 !e9079 see comment above. */</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewQueue</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Jump past the queue structure to find the location of the queue</span>
<span class="cm">            storage area. */</span>
<span class="w">            </span><span class="n">pucQueueStorage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxNewQueue</span><span class="p">;</span>
<span class="w">            </span><span class="n">pucQueueStorage</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */</span>

<span class="w">            </span><span class="cp">#if( configSUPPORT_STATIC_ALLOCATION == 1 )</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Queues can be created either statically or dynamically, so</span>
<span class="cm">                note this task was created dynamically in case it is later</span>
<span class="cm">                deleted. */</span>
<span class="w">                </span><span class="n">pxNewQueue</span><span class="o">-&gt;</span><span class="n">ucStaticallyAllocated</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="cp">#endif </span><span class="cm">/* configSUPPORT_STATIC_ALLOCATION */</span>

<span class="w">            </span><span class="n">prvInitialiseNewQueue</span><span class="p">(</span><span class="w"> </span><span class="n">uxQueueLength</span><span class="p">,</span><span class="w"> </span><span class="n">uxItemSize</span><span class="p">,</span><span class="w"> </span><span class="n">pucQueueStorage</span><span class="p">,</span><span class="w"> </span><span class="n">ucQueueType</span><span class="p">,</span><span class="w"> </span><span class="n">pxNewQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">traceQUEUE_CREATE_FAILED</span><span class="p">(</span><span class="w"> </span><span class="n">ucQueueType</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">pxNewQueue</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configSUPPORT_STATIC_ALLOCATION */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">prvInitialiseNewQueue</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxQueueLength</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxItemSize</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">pucQueueStorage</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ucQueueType</span><span class="p">,</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxNewQueue</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* Remove compiler warnings about unused parameters should</span>
<span class="cm">    configUSE_TRACE_FACILITY not be set to 1. */</span>
<span class="w">    </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">ucQueueType</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxItemSize</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* No RAM was allocated for the queue storage area, but PC head cannot</span>
<span class="cm">        be set to NULL because NULL is used as a key to say the queue is used as</span>
<span class="cm">        a mutex.  Therefore just set pcHead to point to the queue as a benign</span>
<span class="cm">        value that is known to be within the memory map. */</span>
<span class="w">        </span><span class="n">pxNewQueue</span><span class="o">-&gt;</span><span class="n">pcHead</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">int8_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxNewQueue</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Set the head to the start of the queue storage area. */</span>
<span class="w">        </span><span class="n">pxNewQueue</span><span class="o">-&gt;</span><span class="n">pcHead</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">int8_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pucQueueStorage</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* Initialise the queue members as described where the queue type is</span>
<span class="cm">    defined. */</span>
<span class="w">    </span><span class="n">pxNewQueue</span><span class="o">-&gt;</span><span class="n">uxLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uxQueueLength</span><span class="p">;</span>
<span class="w">    </span><span class="n">pxNewQueue</span><span class="o">-&gt;</span><span class="n">uxItemSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uxItemSize</span><span class="p">;</span>
<span class="w">    </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xQueueGenericReset</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewQueue</span><span class="p">,</span><span class="w"> </span><span class="n">pdTRUE</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cp">#if ( configUSE_TRACE_FACILITY == 1 )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">pxNewQueue</span><span class="o">-&gt;</span><span class="n">ucQueueType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ucQueueType</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif </span><span class="cm">/* configUSE_TRACE_FACILITY */</span>

<span class="w">    </span><span class="cp">#if( configUSE_QUEUE_SETS == 1 )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">pxNewQueue</span><span class="o">-&gt;</span><span class="n">pxQueueSetContainer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif </span><span class="cm">/* configUSE_QUEUE_SETS */</span>

<span class="w">    </span><span class="n">traceQUEUE_CREATE</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewQueue</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if( configUSE_MUTEXES == 1 )</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">prvInitialiseMutex</span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxNewQueue</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewQueue</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* The queue create function will set all the queue structure members</span>
<span class="cm">            correctly for a generic queue, but this function is creating a</span>
<span class="cm">            mutex.  Overwrite those members that need to be set differently -</span>
<span class="cm">            in particular the information required for priority inheritance. */</span>
<span class="w">            </span><span class="n">pxNewQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xSemaphore</span><span class="p">.</span><span class="n">xMutexHolder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">            </span><span class="n">pxNewQueue</span><span class="o">-&gt;</span><span class="n">uxQueueType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">queueQUEUE_IS_MUTEX</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/* In case this is a recursive mutex. */</span>
<span class="w">            </span><span class="n">pxNewQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xSemaphore</span><span class="p">.</span><span class="n">uxRecursiveCallCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">            </span><span class="n">traceCREATE_MUTEX</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewQueue</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="cm">/* Start with the semaphore in the expected state. */</span>
<span class="w">            </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xQueueGenericSend</span><span class="p">(</span><span class="w"> </span><span class="n">pxNewQueue</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0U</span><span class="p">,</span><span class="w"> </span><span class="n">queueSEND_TO_BACK</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">traceCREATE_MUTEX_FAILED</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_MUTEXES */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if( ( configUSE_MUTEXES == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )</span>

<span class="w">    </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="nf">xQueueCreateMutex</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ucQueueType</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xNewQueue</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxMutexLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">uxMutexSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">        </span><span class="n">xNewQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueGenericCreate</span><span class="p">(</span><span class="w"> </span><span class="n">uxMutexLength</span><span class="p">,</span><span class="w"> </span><span class="n">uxMutexSize</span><span class="p">,</span><span class="w"> </span><span class="n">ucQueueType</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="n">prvInitialiseMutex</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xNewQueue</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xNewQueue</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_MUTEXES */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if( ( configUSE_MUTEXES == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) )</span>

<span class="w">    </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="nf">xQueueCreateMutexStatic</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ucQueueType</span><span class="p">,</span><span class="w"> </span><span class="n">StaticQueue_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxStaticQueue</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xNewQueue</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxMutexLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">uxMutexSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* Prevent compiler warnings about unused parameters if</span>
<span class="cm">        configUSE_TRACE_FACILITY does not equal 1. */</span>
<span class="w">        </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">ucQueueType</span><span class="p">;</span>

<span class="w">        </span><span class="n">xNewQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueGenericCreateStatic</span><span class="p">(</span><span class="w"> </span><span class="n">uxMutexLength</span><span class="p">,</span><span class="w"> </span><span class="n">uxMutexSize</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">pxStaticQueue</span><span class="p">,</span><span class="w"> </span><span class="n">ucQueueType</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="n">prvInitialiseMutex</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xNewQueue</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xNewQueue</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_MUTEXES */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( ( configUSE_MUTEXES == 1 ) &amp;&amp; ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )</span>

<span class="w">    </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="nf">xQueueGetMutexHolder</span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">pxReturn</span><span class="p">;</span>
<span class="w">    </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxSemaphore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xSemaphore</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* This function is called by xSemaphoreGetMutexHolder(), and should not</span>
<span class="cm">        be called directly.  Note:  This is a good way of determining if the</span>
<span class="cm">        calling task is the mutex holder, but not a good way of determining the</span>
<span class="cm">        identity of the mutex holder, as the holder may change between the</span>
<span class="cm">        following critical section exiting and the function returning. */</span>
<span class="w">        </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxSemaphore</span><span class="o">-&gt;</span><span class="n">uxQueueType</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">queueQUEUE_IS_MUTEX</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">pxReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxSemaphore</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xSemaphore</span><span class="p">.</span><span class="n">xMutexHolder</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">pxReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">pxReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="cm">/*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */</span>

<span class="cp">#endif</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( ( configUSE_MUTEXES == 1 ) &amp;&amp; ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )</span>

<span class="w">    </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="nf">xQueueGetMutexHolderFromISR</span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">pxReturn</span><span class="p">;</span>

<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* Mutexes cannot be used in interrupt service routines, so the mutex</span>
<span class="cm">        holder should not change in an ISR, and therefore a critical section is</span>
<span class="cm">        not required here. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="p">)</span><span class="o">-&gt;</span><span class="n">uxQueueType</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">queueQUEUE_IS_MUTEX</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pxReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="p">)</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xSemaphore</span><span class="p">.</span><span class="n">xMutexHolder</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pxReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">pxReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="cm">/*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */</span>

<span class="cp">#endif</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_RECURSIVE_MUTEXES == 1 )</span>

<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xQueueGiveMutexRecursive</span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xMutex</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxMutex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xMutex</span><span class="p">;</span>

<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxMutex</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* If this is the task that holds the mutex then xMutexHolder will not</span>
<span class="cm">        change outside of this task.  If this task does not hold the mutex then</span>
<span class="cm">        pxMutexHolder can never coincidentally equal the tasks handle, and as</span>
<span class="cm">        this is the only condition we are interested in it does not matter if</span>
<span class="cm">        pxMutexHolder is accessed simultaneously by another task.  Therefore no</span>
<span class="cm">        mutual exclusion is required to test the pxMutexHolder variable. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxMutex</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xSemaphore</span><span class="p">.</span><span class="n">xMutexHolder</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">xTaskGetCurrentTaskHandle</span><span class="p">()</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">traceGIVE_MUTEX_RECURSIVE</span><span class="p">(</span><span class="w"> </span><span class="n">pxMutex</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="cm">/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to</span>
<span class="cm">            the task handle, therefore no underflow check is required.  Also,</span>
<span class="cm">            uxRecursiveCallCount is only modified by the mutex holder, and as</span>
<span class="cm">            there can only be one, no mutual exclusion is required to modify the</span>
<span class="cm">            uxRecursiveCallCount member. */</span>
<span class="w">            </span><span class="p">(</span><span class="w"> </span><span class="n">pxMutex</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xSemaphore</span><span class="p">.</span><span class="n">uxRecursiveCallCount</span><span class="w"> </span><span class="p">)</span><span class="o">--</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/* Has the recursive call count unwound to 0? */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxMutex</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xSemaphore</span><span class="p">.</span><span class="n">uxRecursiveCallCount</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Return the mutex.  This will automatically unblock any other</span>
<span class="cm">                task that might be waiting to access the mutex. */</span>
<span class="w">                </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xQueueGenericSend</span><span class="p">(</span><span class="w"> </span><span class="n">pxMutex</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">queueMUTEX_GIVE_BLOCK_TIME</span><span class="p">,</span><span class="w"> </span><span class="n">queueSEND_TO_BACK</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdPASS</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* The mutex cannot be given because the calling task is not the</span>
<span class="cm">            holder. */</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFAIL</span><span class="p">;</span>

<span class="w">            </span><span class="n">traceGIVE_MUTEX_RECURSIVE_FAILED</span><span class="p">(</span><span class="w"> </span><span class="n">pxMutex</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_RECURSIVE_MUTEXES */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_RECURSIVE_MUTEXES == 1 )</span>

<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xQueueTakeMutexRecursive</span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xMutex</span><span class="p">,</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxMutex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xMutex</span><span class="p">;</span>

<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxMutex</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* Comments regarding mutual exclusion as per those within</span>
<span class="cm">        xQueueGiveMutexRecursive(). */</span>

<span class="w">        </span><span class="n">traceTAKE_MUTEX_RECURSIVE</span><span class="p">(</span><span class="w"> </span><span class="n">pxMutex</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxMutex</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xSemaphore</span><span class="p">.</span><span class="n">xMutexHolder</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">xTaskGetCurrentTaskHandle</span><span class="p">()</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="p">(</span><span class="w"> </span><span class="n">pxMutex</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xSemaphore</span><span class="p">.</span><span class="n">uxRecursiveCallCount</span><span class="w"> </span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdPASS</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueSemaphoreTake</span><span class="p">(</span><span class="w"> </span><span class="n">pxMutex</span><span class="p">,</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="cm">/* pdPASS will only be returned if the mutex was successfully</span>
<span class="cm">            obtained.  The calling task may have entered the Blocked state</span>
<span class="cm">            before reaching here. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xReturn</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFAIL</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="p">(</span><span class="w"> </span><span class="n">pxMutex</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xSemaphore</span><span class="p">.</span><span class="n">uxRecursiveCallCount</span><span class="w"> </span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">traceTAKE_MUTEX_RECURSIVE_FAILED</span><span class="p">(</span><span class="w"> </span><span class="n">pxMutex</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_RECURSIVE_MUTEXES */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) )</span>

<span class="w">    </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="nf">xQueueCreateCountingSemaphoreStatic</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxMaxCount</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxInitialCount</span><span class="p">,</span><span class="w"> </span><span class="n">StaticQueue_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxStaticQueue</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xHandle</span><span class="p">;</span>

<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">uxMaxCount</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">uxInitialCount</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">uxMaxCount</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="n">xHandle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueGenericCreateStatic</span><span class="p">(</span><span class="w"> </span><span class="n">uxMaxCount</span><span class="p">,</span><span class="w"> </span><span class="n">queueSEMAPHORE_QUEUE_ITEM_LENGTH</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">pxStaticQueue</span><span class="p">,</span><span class="w"> </span><span class="n">queueQUEUE_TYPE_COUNTING_SEMAPHORE</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xHandle</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xHandle</span><span class="w"> </span><span class="p">)</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uxInitialCount</span><span class="p">;</span>

<span class="w">            </span><span class="n">traceCREATE_COUNTING_SEMAPHORE</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">traceCREATE_COUNTING_SEMAPHORE_FAILED</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xHandle</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )</span>

<span class="w">    </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="nf">xQueueCreateCountingSemaphore</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxMaxCount</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxInitialCount</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xHandle</span><span class="p">;</span>

<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">uxMaxCount</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">uxInitialCount</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">uxMaxCount</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="n">xHandle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueGenericCreate</span><span class="p">(</span><span class="w"> </span><span class="n">uxMaxCount</span><span class="p">,</span><span class="w"> </span><span class="n">queueSEMAPHORE_QUEUE_ITEM_LENGTH</span><span class="p">,</span><span class="w"> </span><span class="n">queueQUEUE_TYPE_COUNTING_SEMAPHORE</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xHandle</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xHandle</span><span class="w"> </span><span class="p">)</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uxInitialCount</span><span class="p">;</span>

<span class="w">            </span><span class="n">traceCREATE_COUNTING_SEMAPHORE</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">traceCREATE_COUNTING_SEMAPHORE_FAILED</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xHandle</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xQueueGenericSend</span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pvItemToQueue</span><span class="p">,</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xCopyPosition</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xEntryTimeSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">,</span><span class="w"> </span><span class="n">xYieldRequired</span><span class="p">;</span>
<span class="n">TimeOut_t</span><span class="w"> </span><span class="n">xTimeOut</span><span class="p">;</span>
<span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span>

<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pvItemToQueue</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxItemSize</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0U</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xCopyPosition</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">queueOVERWRITE</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxLength</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="cp">#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xTaskGetSchedulerState</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">taskSCHEDULER_SUSPENDED</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif</span>


<span class="w">    </span><span class="cm">/*lint -save -e904 This function relaxes the coding standard somewhat to</span>
<span class="cm">    allow return statements within the function itself.  This is done in the</span>
<span class="cm">    interest of execution time efficiency. */</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="p">;;</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Is there room on the queue now?  The running task must be the</span>
<span class="cm">            highest priority task wanting to access the queue.  If the head item</span>
<span class="cm">            in the queue is to be overwritten then it does not matter if the</span>
<span class="cm">            queue is full. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxLength</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xCopyPosition</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">queueOVERWRITE</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">traceQUEUE_SEND</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>

<span class="w">                </span><span class="cp">#if ( configUSE_QUEUE_SETS == 1 )</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxPreviousMessagesWaiting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="p">;</span>

<span class="w">                    </span><span class="n">xYieldRequired</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvCopyDataToQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="p">,</span><span class="w"> </span><span class="n">pvItemToQueue</span><span class="p">,</span><span class="w"> </span><span class="n">xCopyPosition</span><span class="w"> </span><span class="p">);</span>

<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">pxQueueSetContainer</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xCopyPosition</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">queueOVERWRITE</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">uxPreviousMessagesWaiting</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="cm">/* Do not notify the queue set as an existing item</span>
<span class="cm">                            was overwritten in the queue so the number of items</span>
<span class="cm">                            in the queue has not changed. */</span>
<span class="w">                            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">prvNotifyQueueSetContainer</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="cm">/* The queue is a member of a queue set, and posting</span>
<span class="cm">                            to the queue set caused a higher priority task to</span>
<span class="cm">                            unblock. A context switch is required. */</span>
<span class="w">                            </span><span class="n">queueYIELD_IF_USING_PREEMPTION</span><span class="p">();</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="k">else</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="cm">/* If there was a task waiting for data to arrive on the</span>
<span class="cm">                        queue then unblock it now. */</span>
<span class="w">                        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_IS_EMPTY</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskRemoveFromEventList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                            </span><span class="p">{</span>
<span class="w">                                </span><span class="cm">/* The unblocked task has a priority higher than</span>
<span class="cm">                                our own so yield immediately.  Yes it is ok to</span>
<span class="cm">                                do this from within the critical section - the</span>
<span class="cm">                                kernel takes care of that. */</span>
<span class="w">                                </span><span class="n">queueYIELD_IF_USING_PREEMPTION</span><span class="p">();</span>
<span class="w">                            </span><span class="p">}</span>
<span class="w">                            </span><span class="k">else</span>
<span class="w">                            </span><span class="p">{</span>
<span class="w">                                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                            </span><span class="p">}</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xYieldRequired</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="cm">/* This path is a special case that will only get</span>
<span class="cm">                            executed if the task was holding multiple mutexes</span>
<span class="cm">                            and the mutexes were given back in an order that is</span>
<span class="cm">                            different to that in which they were taken. */</span>
<span class="w">                            </span><span class="n">queueYIELD_IF_USING_PREEMPTION</span><span class="p">();</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="k">else</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="cp">#else </span><span class="cm">/* configUSE_QUEUE_SETS */</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">xYieldRequired</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvCopyDataToQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="p">,</span><span class="w"> </span><span class="n">pvItemToQueue</span><span class="p">,</span><span class="w"> </span><span class="n">xCopyPosition</span><span class="w"> </span><span class="p">);</span>

<span class="w">                    </span><span class="cm">/* If there was a task waiting for data to arrive on the</span>
<span class="cm">                    queue then unblock it now. */</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_IS_EMPTY</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskRemoveFromEventList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="cm">/* The unblocked task has a priority higher than</span>
<span class="cm">                            our own so yield immediately.  Yes it is ok to do</span>
<span class="cm">                            this from within the critical section - the kernel</span>
<span class="cm">                            takes care of that. */</span>
<span class="w">                            </span><span class="n">queueYIELD_IF_USING_PREEMPTION</span><span class="p">();</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="k">else</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xYieldRequired</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="cm">/* This path is a special case that will only get</span>
<span class="cm">                        executed if the task was holding multiple mutexes and</span>
<span class="cm">                        the mutexes were given back in an order that is</span>
<span class="cm">                        different to that in which they were taken. */</span>
<span class="w">                        </span><span class="n">queueYIELD_IF_USING_PREEMPTION</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="cp">#endif </span><span class="cm">/* configUSE_QUEUE_SETS */</span>

<span class="w">                </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">pdPASS</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* The queue was full and no block time is specified (or</span>
<span class="cm">                    the block time has expired) so leave now. */</span>
<span class="w">                    </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">                    </span><span class="cm">/* Return to the original privilege level before exiting</span>
<span class="cm">                    the function. */</span>
<span class="w">                    </span><span class="n">traceQUEUE_SEND_FAILED</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="n">errQUEUE_FULL</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xEntryTimeSet</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* The queue was full and a block time was specified so</span>
<span class="cm">                    configure the timeout structure. */</span>
<span class="w">                    </span><span class="n">vTaskInternalSetTimeOutState</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xTimeOut</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="n">xEntryTimeSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* Entry time was already set. */</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">        </span><span class="cm">/* Interrupts and other tasks can send to and receive from the queue</span>
<span class="cm">        now the critical section has been exited. */</span>

<span class="w">        </span><span class="n">vTaskSuspendAll</span><span class="p">();</span>
<span class="w">        </span><span class="n">prvLockQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* Update the timeout state to see if it has expired yet. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskCheckForTimeOut</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xTimeOut</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">prvIsQueueFull</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">traceBLOCKING_ON_QUEUE_SEND</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="n">vTaskPlaceOnEventList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToSend</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">);</span>

<span class="w">                </span><span class="cm">/* Unlocking the queue means queue events can effect the</span>
<span class="cm">                event list.  It is possible that interrupts occurring now</span>
<span class="cm">                remove this task from the event list again - but as the</span>
<span class="cm">                scheduler is suspended the task will go onto the pending</span>
<span class="cm">                ready last instead of the actual ready list. */</span>
<span class="w">                </span><span class="n">prvUnlockQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>

<span class="w">                </span><span class="cm">/* Resuming the scheduler will move tasks from the pending</span>
<span class="cm">                ready list into the ready list - so it is feasible that this</span>
<span class="cm">                task is already in a ready list before it yields - in which</span>
<span class="cm">                case the yield will not cause a context switch unless there</span>
<span class="cm">                is also a higher priority task in the pending ready list. */</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskResumeAll</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">portYIELD_WITHIN_API</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Try again. */</span>
<span class="w">                </span><span class="n">prvUnlockQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xTaskResumeAll</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* The timeout has expired. */</span>
<span class="w">            </span><span class="n">prvUnlockQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xTaskResumeAll</span><span class="p">();</span>

<span class="w">            </span><span class="n">traceQUEUE_SEND_FAILED</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">errQUEUE_FULL</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="cm">/*lint -restore */</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xQueueGenericSendFromISR</span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pvItemToQueue</span><span class="p">,</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxHigherPriorityTaskWoken</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xCopyPosition</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxSavedInterruptStatus</span><span class="p">;</span>
<span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span>

<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pvItemToQueue</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxItemSize</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0U</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xCopyPosition</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">queueOVERWRITE</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxLength</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* RTOS ports that support interrupt nesting have the concept of a maximum</span>
<span class="cm">    system call (or maximum API call) interrupt priority.  Interrupts that are</span>
<span class="cm">    above the maximum system call priority are kept permanently enabled, even</span>
<span class="cm">    when the RTOS kernel is in a critical section, but cannot make any calls to</span>
<span class="cm">    FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h</span>
<span class="cm">    then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion</span>
<span class="cm">    failure if a FreeRTOS API function is called from an interrupt that has been</span>
<span class="cm">    assigned a priority above the configured maximum system call priority.</span>
<span class="cm">    Only FreeRTOS functions that end in FromISR can be called from interrupts</span>
<span class="cm">    that have been assigned a priority at or (logically) below the maximum</span>
<span class="cm">    system call interrupt priority.  FreeRTOS maintains a separate interrupt</span>
<span class="cm">    safe API to ensure interrupt entry is as fast and as simple as possible.</span>
<span class="cm">    More information (albeit Cortex-M specific) is provided on the following</span>
<span class="cm">    link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */</span>
<span class="w">    </span><span class="n">portASSERT_IF_INTERRUPT_PRIORITY_INVALID</span><span class="p">();</span>

<span class="w">    </span><span class="cm">/* Similar to xQueueGenericSend, except without blocking if there is no room</span>
<span class="cm">    in the queue.  Also don&#39;t directly wake a task that was blocked on a queue</span>
<span class="cm">    read, instead return a flag to say whether a context switch is required or</span>
<span class="cm">    not (i.e. has a task with a higher priority than us been woken by this</span>
<span class="cm">    post). */</span>
<span class="w">    </span><span class="n">uxSavedInterruptStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">portSET_INTERRUPT_MASK_FROM_ISR</span><span class="p">();</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxLength</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xCopyPosition</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">queueOVERWRITE</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="kt">int8_t</span><span class="w"> </span><span class="n">cTxLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">cTxLock</span><span class="p">;</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxPreviousMessagesWaiting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="p">;</span>

<span class="w">            </span><span class="n">traceQUEUE_SEND_FROM_ISR</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="cm">/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a</span>
<span class="cm">            semaphore or mutex.  That means prvCopyDataToQueue() cannot result</span>
<span class="cm">            in a task disinheriting a priority and prvCopyDataToQueue() can be</span>
<span class="cm">            called here even though the disinherit function does not check if</span>
<span class="cm">            the scheduler is suspended before accessing the ready lists. */</span>
<span class="w">            </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">prvCopyDataToQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="p">,</span><span class="w"> </span><span class="n">pvItemToQueue</span><span class="p">,</span><span class="w"> </span><span class="n">xCopyPosition</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="cm">/* The event list is not altered if the queue is locked.  This will</span>
<span class="cm">            be done when the queue is unlocked later. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">cTxLock</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">queueUNLOCKED</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cp">#if ( configUSE_QUEUE_SETS == 1 )</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">pxQueueSetContainer</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xCopyPosition</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">queueOVERWRITE</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">uxPreviousMessagesWaiting</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="cm">/* Do not notify the queue set as an existing item</span>
<span class="cm">                            was overwritten in the queue so the number of items</span>
<span class="cm">                            in the queue has not changed. */</span>
<span class="w">                            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">prvNotifyQueueSetContainer</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="cm">/* The queue is a member of a queue set, and posting</span>
<span class="cm">                            to the queue set caused a higher priority task to</span>
<span class="cm">                            unblock.  A context switch is required. */</span>
<span class="w">                            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                            </span><span class="p">{</span>
<span class="w">                                </span><span class="o">*</span><span class="n">pxHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                            </span><span class="p">}</span>
<span class="w">                            </span><span class="k">else</span>
<span class="w">                            </span><span class="p">{</span>
<span class="w">                                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                            </span><span class="p">}</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="k">else</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_IS_EMPTY</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskRemoveFromEventList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                            </span><span class="p">{</span>
<span class="w">                                </span><span class="cm">/* The task waiting has a higher priority so</span>
<span class="cm">                                record that a context switch is required. */</span>
<span class="w">                                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                                </span><span class="p">{</span>
<span class="w">                                    </span><span class="o">*</span><span class="n">pxHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                                </span><span class="p">}</span>
<span class="w">                                </span><span class="k">else</span>
<span class="w">                                </span><span class="p">{</span>
<span class="w">                                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                                </span><span class="p">}</span>
<span class="w">                            </span><span class="p">}</span>
<span class="w">                            </span><span class="k">else</span>
<span class="w">                            </span><span class="p">{</span>
<span class="w">                                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                            </span><span class="p">}</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="k">else</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="cp">#else </span><span class="cm">/* configUSE_QUEUE_SETS */</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_IS_EMPTY</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskRemoveFromEventList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="cm">/* The task waiting has a higher priority so record that a</span>
<span class="cm">                            context switch is required. */</span>
<span class="w">                            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                            </span><span class="p">{</span>
<span class="w">                                </span><span class="o">*</span><span class="n">pxHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                            </span><span class="p">}</span>
<span class="w">                            </span><span class="k">else</span>
<span class="w">                            </span><span class="p">{</span>
<span class="w">                                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                            </span><span class="p">}</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="k">else</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>

<span class="w">                    </span><span class="cm">/* Not used in this path. */</span>
<span class="w">                    </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">uxPreviousMessagesWaiting</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="cp">#endif </span><span class="cm">/* configUSE_QUEUE_SETS */</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Increment the lock count so the task that unlocks the queue</span>
<span class="cm">                knows that data was posted while it was locked. */</span>
<span class="w">                </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">cTxLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">int8_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">cTxLock</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdPASS</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">traceQUEUE_SEND_FROM_ISR_FAILED</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">errQUEUE_FULL</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">portCLEAR_INTERRUPT_MASK_FROM_ISR</span><span class="p">(</span><span class="w"> </span><span class="n">uxSavedInterruptStatus</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xQueueGiveFromISR</span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxHigherPriorityTaskWoken</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxSavedInterruptStatus</span><span class="p">;</span>
<span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Similar to xQueueGenericSendFromISR() but used with semaphores where the</span>
<span class="cm">    item size is 0.  Don&#39;t directly wake a task that was blocked on a queue</span>
<span class="cm">    read, instead return a flag to say whether a context switch is required or</span>
<span class="cm">    not (i.e. has a task with a higher priority than us been woken by this</span>
<span class="cm">    post). */</span>

<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()</span>
<span class="cm">    if the item size is not 0. */</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxItemSize</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Normally a mutex would not be given from an interrupt, especially if</span>
<span class="cm">    there is a mutex holder, as priority inheritance makes no sense for an</span>
<span class="cm">    interrupts, only tasks. */</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxQueueType</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">queueQUEUE_IS_MUTEX</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xSemaphore</span><span class="p">.</span><span class="n">xMutexHolder</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* RTOS ports that support interrupt nesting have the concept of a maximum</span>
<span class="cm">    system call (or maximum API call) interrupt priority.  Interrupts that are</span>
<span class="cm">    above the maximum system call priority are kept permanently enabled, even</span>
<span class="cm">    when the RTOS kernel is in a critical section, but cannot make any calls to</span>
<span class="cm">    FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h</span>
<span class="cm">    then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion</span>
<span class="cm">    failure if a FreeRTOS API function is called from an interrupt that has been</span>
<span class="cm">    assigned a priority above the configured maximum system call priority.</span>
<span class="cm">    Only FreeRTOS functions that end in FromISR can be called from interrupts</span>
<span class="cm">    that have been assigned a priority at or (logically) below the maximum</span>
<span class="cm">    system call interrupt priority.  FreeRTOS maintains a separate interrupt</span>
<span class="cm">    safe API to ensure interrupt entry is as fast and as simple as possible.</span>
<span class="cm">    More information (albeit Cortex-M specific) is provided on the following</span>
<span class="cm">    link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */</span>
<span class="w">    </span><span class="n">portASSERT_IF_INTERRUPT_PRIORITY_INVALID</span><span class="p">();</span>

<span class="w">    </span><span class="n">uxSavedInterruptStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">portSET_INTERRUPT_MASK_FROM_ISR</span><span class="p">();</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* When the queue is used to implement a semaphore no data is ever</span>
<span class="cm">        moved through the queue but it is still valid to see if the queue &#39;has</span>
<span class="cm">        space&#39;. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxLength</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="kt">int8_t</span><span class="w"> </span><span class="n">cTxLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">cTxLock</span><span class="p">;</span>

<span class="w">            </span><span class="n">traceQUEUE_SEND_FROM_ISR</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="cm">/* A task can only have an inherited priority if it is a mutex</span>
<span class="cm">            holder - and if there is a mutex holder then the mutex cannot be</span>
<span class="cm">            given from an ISR.  As this is the ISR version of the function it</span>
<span class="cm">            can be assumed there is no mutex holder and no need to determine if</span>
<span class="cm">            priority disinheritance is needed.  Simply increase the count of</span>
<span class="cm">            messages (semaphores) available. */</span>
<span class="w">            </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/* The event list is not altered if the queue is locked.  This will</span>
<span class="cm">            be done when the queue is unlocked later. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">cTxLock</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">queueUNLOCKED</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cp">#if ( configUSE_QUEUE_SETS == 1 )</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">pxQueueSetContainer</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">prvNotifyQueueSetContainer</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="cm">/* The semaphore is a member of a queue set, and</span>
<span class="cm">                            posting to the queue set caused a higher priority</span>
<span class="cm">                            task to unblock.  A context switch is required. */</span>
<span class="w">                            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                            </span><span class="p">{</span>
<span class="w">                                </span><span class="o">*</span><span class="n">pxHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                            </span><span class="p">}</span>
<span class="w">                            </span><span class="k">else</span>
<span class="w">                            </span><span class="p">{</span>
<span class="w">                                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                            </span><span class="p">}</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="k">else</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_IS_EMPTY</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskRemoveFromEventList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                            </span><span class="p">{</span>
<span class="w">                                </span><span class="cm">/* The task waiting has a higher priority so</span>
<span class="cm">                                record that a context switch is required. */</span>
<span class="w">                                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                                </span><span class="p">{</span>
<span class="w">                                    </span><span class="o">*</span><span class="n">pxHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                                </span><span class="p">}</span>
<span class="w">                                </span><span class="k">else</span>
<span class="w">                                </span><span class="p">{</span>
<span class="w">                                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                                </span><span class="p">}</span>
<span class="w">                            </span><span class="p">}</span>
<span class="w">                            </span><span class="k">else</span>
<span class="w">                            </span><span class="p">{</span>
<span class="w">                                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                            </span><span class="p">}</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="k">else</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="cp">#else </span><span class="cm">/* configUSE_QUEUE_SETS */</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_IS_EMPTY</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskRemoveFromEventList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="cm">/* The task waiting has a higher priority so record that a</span>
<span class="cm">                            context switch is required. */</span>
<span class="w">                            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                            </span><span class="p">{</span>
<span class="w">                                </span><span class="o">*</span><span class="n">pxHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                            </span><span class="p">}</span>
<span class="w">                            </span><span class="k">else</span>
<span class="w">                            </span><span class="p">{</span>
<span class="w">                                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                            </span><span class="p">}</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="k">else</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="cp">#endif </span><span class="cm">/* configUSE_QUEUE_SETS */</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Increment the lock count so the task that unlocks the queue</span>
<span class="cm">                knows that data was posted while it was locked. */</span>
<span class="w">                </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">cTxLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">int8_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">cTxLock</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdPASS</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">traceQUEUE_SEND_FROM_ISR_FAILED</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">errQUEUE_FULL</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">portCLEAR_INTERRUPT_MASK_FROM_ISR</span><span class="p">(</span><span class="w"> </span><span class="n">uxSavedInterruptStatus</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xQueueReceive</span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pvBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xEntryTimeSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="n">TimeOut_t</span><span class="w"> </span><span class="n">xTimeOut</span><span class="p">;</span>
<span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Check the pointer is not NULL. */</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* The buffer into which data is received can only be NULL if the data size</span>
<span class="cm">    is zero (so no data is copied into the buffer. */</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pvBuffer</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span><span class="o">-&gt;</span><span class="n">uxItemSize</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0U</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Cannot block if the scheduler is suspended. */</span>
<span class="w">    </span><span class="cp">#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xTaskGetSchedulerState</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">taskSCHEDULER_SUSPENDED</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif</span>


<span class="w">    </span><span class="cm">/*lint -save -e904  This function relaxes the coding standard somewhat to</span>
<span class="cm">    allow return statements within the function itself.  This is done in the</span>
<span class="cm">    interest of execution time efficiency. */</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="p">;;</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/* Is there data in the queue now?  To be running the calling task</span>
<span class="cm">            must be the highest priority task wanting to access the queue. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Data available, remove one item. */</span>
<span class="w">                </span><span class="n">prvCopyDataFromQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="p">,</span><span class="w"> </span><span class="n">pvBuffer</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="n">traceQUEUE_RECEIVE</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">                </span><span class="cm">/* There is now space in the queue, were any tasks waiting to</span>
<span class="cm">                post to the queue?  If so, unblock the highest priority waiting</span>
<span class="cm">                task. */</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_IS_EMPTY</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToSend</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskRemoveFromEventList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToSend</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">queueYIELD_IF_USING_PREEMPTION</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">pdPASS</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* The queue was empty and no block time is specified (or</span>
<span class="cm">                    the block time has expired) so leave now. */</span>
<span class="w">                    </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>
<span class="w">                    </span><span class="n">traceQUEUE_RECEIVE_FAILED</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="n">errQUEUE_EMPTY</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xEntryTimeSet</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* The queue was empty and a block time was specified so</span>
<span class="cm">                    configure the timeout structure. */</span>
<span class="w">                    </span><span class="n">vTaskInternalSetTimeOutState</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xTimeOut</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="n">xEntryTimeSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* Entry time was already set. */</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">        </span><span class="cm">/* Interrupts and other tasks can send to and receive from the queue</span>
<span class="cm">        now the critical section has been exited. */</span>

<span class="w">        </span><span class="n">vTaskSuspendAll</span><span class="p">();</span>
<span class="w">        </span><span class="n">prvLockQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* Update the timeout state to see if it has expired yet. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskCheckForTimeOut</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xTimeOut</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* The timeout has not expired.  If the queue is still empty place</span>
<span class="cm">            the task on the list of tasks waiting to receive from the queue. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">prvIsQueueEmpty</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">traceBLOCKING_ON_QUEUE_RECEIVE</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="n">vTaskPlaceOnEventList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="n">prvUnlockQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskResumeAll</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">portYIELD_WITHIN_API</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* The queue contains data again.  Loop back to try and read the</span>
<span class="cm">                data. */</span>
<span class="w">                </span><span class="n">prvUnlockQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xTaskResumeAll</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Timed out.  If there is no data in the queue exit, otherwise loop</span>
<span class="cm">            back and attempt to read the data. */</span>
<span class="w">            </span><span class="n">prvUnlockQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xTaskResumeAll</span><span class="p">();</span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">prvIsQueueEmpty</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">traceQUEUE_RECEIVE_FAILED</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">errQUEUE_EMPTY</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="cm">/*lint -restore */</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xQueueSemaphoreTake</span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xEntryTimeSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="n">TimeOut_t</span><span class="w"> </span><span class="n">xTimeOut</span><span class="p">;</span>
<span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span>

<span class="cp">#if( configUSE_MUTEXES == 1 )</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xInheritanceOccurred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="w">    </span><span class="cm">/* Check the queue pointer is not NULL. */</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Check this really is a semaphore, in which case the item size will be</span>
<span class="cm">    0. */</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxItemSize</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Cannot block if the scheduler is suspended. */</span>
<span class="w">    </span><span class="cp">#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xTaskGetSchedulerState</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">taskSCHEDULER_SUSPENDED</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif</span>


<span class="w">    </span><span class="cm">/*lint -save -e904 This function relaxes the coding standard somewhat to allow return</span>
<span class="cm">    statements within the function itself.  This is done in the interest</span>
<span class="cm">    of execution time efficiency. */</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="p">;;</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Semaphores are queues with an item size of 0, and where the</span>
<span class="cm">            number of messages in the queue is the semaphore&#39;s count value. */</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxSemaphoreCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/* Is there data in the queue now?  To be running the calling task</span>
<span class="cm">            must be the highest priority task wanting to access the queue. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxSemaphoreCount</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">traceQUEUE_RECEIVE</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>

<span class="w">                </span><span class="cm">/* Semaphores are queues with a data size of zero and where the</span>
<span class="cm">                messages waiting is the semaphore&#39;s count.  Reduce the count. */</span>
<span class="w">                </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uxSemaphoreCount</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">                </span><span class="cp">#if ( configUSE_MUTEXES == 1 )</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxQueueType</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">queueQUEUE_IS_MUTEX</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="cm">/* Record the information required to implement</span>
<span class="cm">                        priority inheritance should it become necessary. */</span>
<span class="w">                        </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xSemaphore</span><span class="p">.</span><span class="n">xMutexHolder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pvTaskIncrementMutexHeldCount</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="cp">#endif </span><span class="cm">/* configUSE_MUTEXES */</span>

<span class="w">                </span><span class="cm">/* Check to see if other tasks are blocked waiting to give the</span>
<span class="cm">                semaphore, and if so, unblock the highest priority such task. */</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_IS_EMPTY</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToSend</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskRemoveFromEventList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToSend</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">queueYIELD_IF_USING_PREEMPTION</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">pdPASS</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* For inheritance to have occurred there must have been an</span>
<span class="cm">                    initial timeout, and an adjusted timeout cannot become 0, as</span>
<span class="cm">                    if it were 0 the function would have exited. */</span>
<span class="w">                    </span><span class="cp">#if( configUSE_MUTEXES == 1 )</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">xInheritanceOccurred</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="cp">#endif </span><span class="cm">/* configUSE_MUTEXES */</span>

<span class="w">                    </span><span class="cm">/* The semaphore count was 0 and no block time is specified</span>
<span class="cm">                    (or the block time has expired) so exit now. */</span>
<span class="w">                    </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>
<span class="w">                    </span><span class="n">traceQUEUE_RECEIVE_FAILED</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="n">errQUEUE_EMPTY</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xEntryTimeSet</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* The semaphore count was 0 and a block time was specified</span>
<span class="cm">                    so configure the timeout structure ready to block. */</span>
<span class="w">                    </span><span class="n">vTaskInternalSetTimeOutState</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xTimeOut</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="n">xEntryTimeSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* Entry time was already set. */</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">        </span><span class="cm">/* Interrupts and other tasks can give to and take from the semaphore</span>
<span class="cm">        now the critical section has been exited. */</span>

<span class="w">        </span><span class="n">vTaskSuspendAll</span><span class="p">();</span>
<span class="w">        </span><span class="n">prvLockQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* Update the timeout state to see if it has expired yet. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskCheckForTimeOut</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xTimeOut</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* A block time is specified and not expired.  If the semaphore</span>
<span class="cm">            count is 0 then enter the Blocked state to wait for a semaphore to</span>
<span class="cm">            become available.  As semaphores are implemented with queues the</span>
<span class="cm">            queue being empty is equivalent to the semaphore count being 0. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">prvIsQueueEmpty</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">traceBLOCKING_ON_QUEUE_RECEIVE</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>

<span class="w">                </span><span class="cp">#if ( configUSE_MUTEXES == 1 )</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxQueueType</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">queueQUEUE_IS_MUTEX</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="n">xInheritanceOccurred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTaskPriorityInherit</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xSemaphore</span><span class="p">.</span><span class="n">xMutexHolder</span><span class="w"> </span><span class="p">);</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="cp">#endif</span>

<span class="w">                </span><span class="n">vTaskPlaceOnEventList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="n">prvUnlockQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskResumeAll</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">portYIELD_WITHIN_API</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* There was no timeout and the semaphore count was not 0, so</span>
<span class="cm">                attempt to take the semaphore again. */</span>
<span class="w">                </span><span class="n">prvUnlockQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xTaskResumeAll</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Timed out. */</span>
<span class="w">            </span><span class="n">prvUnlockQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xTaskResumeAll</span><span class="p">();</span>

<span class="w">            </span><span class="cm">/* If the semaphore count is 0 exit now as the timeout has</span>
<span class="cm">            expired.  Otherwise return to attempt to take the semaphore that is</span>
<span class="cm">            known to be available.  As semaphores are implemented by queues the</span>
<span class="cm">            queue being empty is equivalent to the semaphore count being 0. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">prvIsQueueEmpty</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cp">#if ( configUSE_MUTEXES == 1 )</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* xInheritanceOccurred could only have be set if</span>
<span class="cm">                    pxQueue-&gt;uxQueueType == queueQUEUE_IS_MUTEX so no need to</span>
<span class="cm">                    test the mutex type again to check it is actually a mutex. */</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xInheritanceOccurred</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxHighestWaitingPriority</span><span class="p">;</span>

<span class="w">                            </span><span class="cm">/* This task blocking on the mutex caused another</span>
<span class="cm">                            task to inherit this task&#39;s priority.  Now this task</span>
<span class="cm">                            has timed out the priority should be disinherited</span>
<span class="cm">                            again, but only as low as the next highest priority</span>
<span class="cm">                            task that is waiting for the same mutex. */</span>
<span class="w">                            </span><span class="n">uxHighestWaitingPriority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvGetDisinheritPriorityAfterTimeout</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">                            </span><span class="n">vTaskPriorityDisinheritAfterTimeout</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xSemaphore</span><span class="p">.</span><span class="n">xMutexHolder</span><span class="p">,</span><span class="w"> </span><span class="n">uxHighestWaitingPriority</span><span class="w"> </span><span class="p">);</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="cp">#endif </span><span class="cm">/* configUSE_MUTEXES */</span>

<span class="w">                </span><span class="n">traceQUEUE_RECEIVE_FAILED</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">errQUEUE_EMPTY</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="cm">/*lint -restore */</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xQueuePeek</span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pvBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xEntryTimeSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="n">TimeOut_t</span><span class="w"> </span><span class="n">xTimeOut</span><span class="p">;</span>
<span class="kt">int8_t</span><span class="w"> </span><span class="o">*</span><span class="n">pcOriginalReadPosition</span><span class="p">;</span>
<span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Check the pointer is not NULL. */</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* The buffer into which data is received can only be NULL if the data size</span>
<span class="cm">    is zero (so no data is copied into the buffer. */</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pvBuffer</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span><span class="o">-&gt;</span><span class="n">uxItemSize</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0U</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Cannot block if the scheduler is suspended. */</span>
<span class="w">    </span><span class="cp">#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xTaskGetSchedulerState</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">taskSCHEDULER_SUSPENDED</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif</span>


<span class="w">    </span><span class="cm">/*lint -save -e904  This function relaxes the coding standard somewhat to</span>
<span class="cm">    allow return statements within the function itself.  This is done in the</span>
<span class="cm">    interest of execution time efficiency. */</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="p">;;</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/* Is there data in the queue now?  To be running the calling task</span>
<span class="cm">            must be the highest priority task wanting to access the queue. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Remember the read position so it can be reset after the data</span>
<span class="cm">                is read from the queue as this function is only peeking the</span>
<span class="cm">                data, not removing it. */</span>
<span class="w">                </span><span class="n">pcOriginalReadPosition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcReadFrom</span><span class="p">;</span>

<span class="w">                </span><span class="n">prvCopyDataFromQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="p">,</span><span class="w"> </span><span class="n">pvBuffer</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="n">traceQUEUE_PEEK</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>

<span class="w">                </span><span class="cm">/* The data is not being removed, so reset the read pointer. */</span>
<span class="w">                </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcReadFrom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pcOriginalReadPosition</span><span class="p">;</span>

<span class="w">                </span><span class="cm">/* The data is being left in the queue, so see if there are</span>
<span class="cm">                any other tasks waiting for the data. */</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_IS_EMPTY</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskRemoveFromEventList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="cm">/* The task waiting has a higher priority than this task. */</span>
<span class="w">                        </span><span class="n">queueYIELD_IF_USING_PREEMPTION</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">pdPASS</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* The queue was empty and no block time is specified (or</span>
<span class="cm">                    the block time has expired) so leave now. */</span>
<span class="w">                    </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>
<span class="w">                    </span><span class="n">traceQUEUE_PEEK_FAILED</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="n">errQUEUE_EMPTY</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xEntryTimeSet</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* The queue was empty and a block time was specified so</span>
<span class="cm">                    configure the timeout structure ready to enter the blocked</span>
<span class="cm">                    state. */</span>
<span class="w">                    </span><span class="n">vTaskInternalSetTimeOutState</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xTimeOut</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="n">xEntryTimeSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* Entry time was already set. */</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">        </span><span class="cm">/* Interrupts and other tasks can send to and receive from the queue</span>
<span class="cm">        now the critical section has been exited. */</span>

<span class="w">        </span><span class="n">vTaskSuspendAll</span><span class="p">();</span>
<span class="w">        </span><span class="n">prvLockQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* Update the timeout state to see if it has expired yet. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskCheckForTimeOut</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xTimeOut</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Timeout has not expired yet, check to see if there is data in the</span>
<span class="cm">            queue now, and if not enter the Blocked state to wait for data. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">prvIsQueueEmpty</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">traceBLOCKING_ON_QUEUE_PEEK</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="n">vTaskPlaceOnEventList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="n">prvUnlockQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskResumeAll</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">portYIELD_WITHIN_API</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* There is data in the queue now, so don&#39;t enter the blocked</span>
<span class="cm">                state, instead return to try and obtain the data. */</span>
<span class="w">                </span><span class="n">prvUnlockQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xTaskResumeAll</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* The timeout has expired.  If there is still no data in the queue</span>
<span class="cm">            exit, otherwise go back and try to read the data again. */</span>
<span class="w">            </span><span class="n">prvUnlockQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xTaskResumeAll</span><span class="p">();</span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">prvIsQueueEmpty</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">traceQUEUE_PEEK_FAILED</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">errQUEUE_EMPTY</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="cm">/*lint -restore */</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xQueueReceiveFromISR</span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pvBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxHigherPriorityTaskWoken</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxSavedInterruptStatus</span><span class="p">;</span>
<span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span>

<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pvBuffer</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxItemSize</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0U</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* RTOS ports that support interrupt nesting have the concept of a maximum</span>
<span class="cm">    system call (or maximum API call) interrupt priority.  Interrupts that are</span>
<span class="cm">    above the maximum system call priority are kept permanently enabled, even</span>
<span class="cm">    when the RTOS kernel is in a critical section, but cannot make any calls to</span>
<span class="cm">    FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h</span>
<span class="cm">    then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion</span>
<span class="cm">    failure if a FreeRTOS API function is called from an interrupt that has been</span>
<span class="cm">    assigned a priority above the configured maximum system call priority.</span>
<span class="cm">    Only FreeRTOS functions that end in FromISR can be called from interrupts</span>
<span class="cm">    that have been assigned a priority at or (logically) below the maximum</span>
<span class="cm">    system call interrupt priority.  FreeRTOS maintains a separate interrupt</span>
<span class="cm">    safe API to ensure interrupt entry is as fast and as simple as possible.</span>
<span class="cm">    More information (albeit Cortex-M specific) is provided on the following</span>
<span class="cm">    link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */</span>
<span class="w">    </span><span class="n">portASSERT_IF_INTERRUPT_PRIORITY_INVALID</span><span class="p">();</span>

<span class="w">    </span><span class="n">uxSavedInterruptStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">portSET_INTERRUPT_MASK_FROM_ISR</span><span class="p">();</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* Cannot block in an ISR, so check there is data available. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="kt">int8_t</span><span class="w"> </span><span class="n">cRxLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">cRxLock</span><span class="p">;</span>

<span class="w">            </span><span class="n">traceQUEUE_RECEIVE_FROM_ISR</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="n">prvCopyDataFromQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="p">,</span><span class="w"> </span><span class="n">pvBuffer</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/* If the queue is locked the event list will not be modified.</span>
<span class="cm">            Instead update the lock count so the task that unlocks the queue</span>
<span class="cm">            will know that an ISR has removed data while the queue was</span>
<span class="cm">            locked. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">cRxLock</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">queueUNLOCKED</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_IS_EMPTY</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToSend</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskRemoveFromEventList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToSend</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="cm">/* The task waiting has a higher priority than us so</span>
<span class="cm">                        force a context switch. */</span>
<span class="w">                        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="o">*</span><span class="n">pxHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="k">else</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Increment the lock count so the task that unlocks the queue</span>
<span class="cm">                knows that data was removed while it was locked. */</span>
<span class="w">                </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">cRxLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">int8_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">cRxLock</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdPASS</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFAIL</span><span class="p">;</span>
<span class="w">            </span><span class="n">traceQUEUE_RECEIVE_FROM_ISR_FAILED</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">portCLEAR_INTERRUPT_MASK_FROM_ISR</span><span class="p">(</span><span class="w"> </span><span class="n">uxSavedInterruptStatus</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xQueuePeekFromISR</span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pvBuffer</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxSavedInterruptStatus</span><span class="p">;</span>
<span class="kt">int8_t</span><span class="w"> </span><span class="o">*</span><span class="n">pcOriginalReadPosition</span><span class="p">;</span>
<span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span>

<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pvBuffer</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxItemSize</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0U</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxItemSize</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/* Can&#39;t peek a semaphore. */</span>

<span class="w">    </span><span class="cm">/* RTOS ports that support interrupt nesting have the concept of a maximum</span>
<span class="cm">    system call (or maximum API call) interrupt priority.  Interrupts that are</span>
<span class="cm">    above the maximum system call priority are kept permanently enabled, even</span>
<span class="cm">    when the RTOS kernel is in a critical section, but cannot make any calls to</span>
<span class="cm">    FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h</span>
<span class="cm">    then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion</span>
<span class="cm">    failure if a FreeRTOS API function is called from an interrupt that has been</span>
<span class="cm">    assigned a priority above the configured maximum system call priority.</span>
<span class="cm">    Only FreeRTOS functions that end in FromISR can be called from interrupts</span>
<span class="cm">    that have been assigned a priority at or (logically) below the maximum</span>
<span class="cm">    system call interrupt priority.  FreeRTOS maintains a separate interrupt</span>
<span class="cm">    safe API to ensure interrupt entry is as fast and as simple as possible.</span>
<span class="cm">    More information (albeit Cortex-M specific) is provided on the following</span>
<span class="cm">    link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */</span>
<span class="w">    </span><span class="n">portASSERT_IF_INTERRUPT_PRIORITY_INVALID</span><span class="p">();</span>

<span class="w">    </span><span class="n">uxSavedInterruptStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">portSET_INTERRUPT_MASK_FROM_ISR</span><span class="p">();</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Cannot block in an ISR, so check there is data available. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">traceQUEUE_PEEK_FROM_ISR</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="cm">/* Remember the read position so it can be reset as nothing is</span>
<span class="cm">            actually being removed from the queue. */</span>
<span class="w">            </span><span class="n">pcOriginalReadPosition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcReadFrom</span><span class="p">;</span>
<span class="w">            </span><span class="n">prvCopyDataFromQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="p">,</span><span class="w"> </span><span class="n">pvBuffer</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcReadFrom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pcOriginalReadPosition</span><span class="p">;</span>

<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdPASS</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFAIL</span><span class="p">;</span>
<span class="w">            </span><span class="n">traceQUEUE_PEEK_FROM_ISR_FAILED</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">portCLEAR_INTERRUPT_MASK_FROM_ISR</span><span class="p">(</span><span class="w"> </span><span class="n">uxSavedInterruptStatus</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="n">UBaseType_t</span><span class="w"> </span><span class="nf">uxQueueMessagesWaiting</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxReturn</span><span class="p">;</span>

<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">uxReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="p">)</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">uxReturn</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="cm">/*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="n">UBaseType_t</span><span class="w"> </span><span class="nf">uxQueueSpacesAvailable</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxReturn</span><span class="p">;</span>
<span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span>

<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">uxReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxLength</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">uxReturn</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="cm">/*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="n">UBaseType_t</span><span class="w"> </span><span class="nf">uxQueueMessagesWaitingFromISR</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxReturn</span><span class="p">;</span>
<span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span>

<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">uxReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">uxReturn</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="cm">/*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vQueueDelete</span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span>

<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">traceQUEUE_DELETE</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="cp">#if ( configQUEUE_REGISTRY_SIZE &gt; 0 )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">vQueueUnregisterQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="w">    </span><span class="cp">#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 0 ) )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* The queue can only have been allocated dynamically - free it</span>
<span class="cm">        again. */</span>
<span class="w">        </span><span class="n">vPortFree</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) )</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* The queue could have been allocated statically or dynamically, so</span>
<span class="cm">        check before attempting to free the memory. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">ucStaticallyAllocated</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">vPortFree</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* The queue must have been statically allocated, so is not going to be</span>
<span class="cm">        deleted.  Avoid compiler warnings about the unused parameter. */</span>
<span class="w">        </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxQueue</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif </span><span class="cm">/* configSUPPORT_DYNAMIC_ALLOCATION */</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_TRACE_FACILITY == 1 )</span>

<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="nf">uxQueueGetQueueNumber</span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="p">)</span><span class="o">-&gt;</span><span class="n">uxQueueNumber</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_TRACE_FACILITY */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_TRACE_FACILITY == 1 )</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">vQueueSetQueueNumber</span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxQueueNumber</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="p">)</span><span class="o">-&gt;</span><span class="n">uxQueueNumber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uxQueueNumber</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_TRACE_FACILITY */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_TRACE_FACILITY == 1 )</span>

<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="nf">ucQueueGetQueueType</span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ucQueueType</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_TRACE_FACILITY */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if( configUSE_MUTEXES == 1 )</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="nf">prvGetDisinheritPriorityAfterTimeout</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxHighestPriorityOfWaitingTasks</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* If a task waiting for a mutex causes the mutex holder to inherit a</span>
<span class="cm">        priority, but the waiting task times out, then the holder should</span>
<span class="cm">        disinherit the priority - but only down to the highest priority of any</span>
<span class="cm">        other tasks that are waiting for the same mutex.  For this purpose,</span>
<span class="cm">        return the priority of the highest priority task that is waiting for the</span>
<span class="cm">        mutex. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listCURRENT_LIST_LENGTH</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0U</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">uxHighestPriorityOfWaitingTasks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">configMAX_PRIORITIES</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">listGET_ITEM_VALUE_OF_HEAD_ENTRY</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">uxHighestPriorityOfWaitingTasks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tskIDLE_PRIORITY</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">uxHighestPriorityOfWaitingTasks</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_MUTEXES */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="k">static</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="nf">prvCopyDataToQueue</span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvItemToQueue</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xPosition</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxMessagesWaiting</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* This function is called from a critical section. */</span>

<span class="w">    </span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxItemSize</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cp">#if ( configUSE_MUTEXES == 1 )</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxQueueType</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">queueQUEUE_IS_MUTEX</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* The mutex is no longer being held. */</span>
<span class="w">                </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTaskPriorityDisinherit</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xSemaphore</span><span class="p">.</span><span class="n">xMutexHolder</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xSemaphore</span><span class="p">.</span><span class="n">xMutexHolder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cp">#endif </span><span class="cm">/* configUSE_MUTEXES */</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xPosition</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">queueSEND_TO_BACK</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">memcpy</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">pcWriteTo</span><span class="p">,</span><span class="w"> </span><span class="n">pvItemToQueue</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxItemSize</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */</span>
<span class="w">        </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">pcWriteTo</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxItemSize</span><span class="p">;</span><span class="w"> </span><span class="cm">/*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">pcWriteTo</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcTail</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="cm">/*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">pcWriteTo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">pcHead</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">memcpy</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcReadFrom</span><span class="p">,</span><span class="w"> </span><span class="n">pvItemToQueue</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxItemSize</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */</span>
<span class="w">        </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcReadFrom</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxItemSize</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcReadFrom</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">pcHead</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="cm">/*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcReadFrom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcTail</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxItemSize</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xPosition</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">queueOVERWRITE</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* An item is not being added but overwritten, so subtract</span>
<span class="cm">                one from the recorded number of items in the queue so when</span>
<span class="cm">                one is added again below the number of recorded items remains</span>
<span class="cm">                correct. */</span>
<span class="w">                </span><span class="o">--</span><span class="n">uxMessagesWaiting</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">prvCopyDataFromQueue</span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pvBuffer</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxItemSize</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcReadFrom</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxItemSize</span><span class="p">;</span><span class="w"> </span><span class="cm">/*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcReadFrom</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcTail</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="cm">/*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcReadFrom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">pcHead</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">memcpy</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pvBuffer</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcReadFrom</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxItemSize</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">prvUnlockQueue</span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */</span>

<span class="w">    </span><span class="cm">/* The lock counts contains the number of extra data items placed or</span>
<span class="cm">    removed from the queue while the queue was locked.  When a queue is</span>
<span class="cm">    locked items can be added or removed, but the event lists cannot be</span>
<span class="cm">    updated. */</span>
<span class="w">    </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int8_t</span><span class="w"> </span><span class="n">cTxLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">cTxLock</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* See if data was added to the queue while it was locked. */</span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="n">cTxLock</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">queueLOCKED_UNMODIFIED</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Data was posted while the queue was locked.  Are any tasks</span>
<span class="cm">            blocked waiting for data to become available? */</span>
<span class="w">            </span><span class="cp">#if ( configUSE_QUEUE_SETS == 1 )</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">pxQueueSetContainer</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">prvNotifyQueueSetContainer</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="cm">/* The queue is a member of a queue set, and posting to</span>
<span class="cm">                        the queue set caused a higher priority task to unblock.</span>
<span class="cm">                        A context switch is required. */</span>
<span class="w">                        </span><span class="n">vTaskMissedYield</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* Tasks that are removed from the event list will get</span>
<span class="cm">                    added to the pending ready list as the scheduler is still</span>
<span class="cm">                    suspended. */</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_IS_EMPTY</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskRemoveFromEventList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="cm">/* The task waiting has a higher priority so record that a</span>
<span class="cm">                            context switch is required. */</span>
<span class="w">                            </span><span class="n">vTaskMissedYield</span><span class="p">();</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="k">else</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="k">break</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="cp">#else </span><span class="cm">/* configUSE_QUEUE_SETS */</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Tasks that are removed from the event list will get added to</span>
<span class="cm">                the pending ready list as the scheduler is still suspended. */</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_IS_EMPTY</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskRemoveFromEventList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="cm">/* The task waiting has a higher priority so record that</span>
<span class="cm">                        a context switch is required. */</span>
<span class="w">                        </span><span class="n">vTaskMissedYield</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">break</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="cp">#endif </span><span class="cm">/* configUSE_QUEUE_SETS */</span>

<span class="w">            </span><span class="o">--</span><span class="n">cTxLock</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">cTxLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">queueUNLOCKED</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">    </span><span class="cm">/* Do the same for the Rx lock. */</span>
<span class="w">    </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int8_t</span><span class="w"> </span><span class="n">cRxLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">cRxLock</span><span class="p">;</span>

<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="n">cRxLock</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">queueLOCKED_UNMODIFIED</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_IS_EMPTY</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToSend</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskRemoveFromEventList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToSend</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">vTaskMissedYield</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="o">--</span><span class="n">cRxLock</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">cRxLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">queueUNLOCKED</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="k">static</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="nf">prvIsQueueEmpty</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>

<span class="w">    </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w">  </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xQueueIsQueueEmptyFromISR</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span>

<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="cm">/*lint !e818 xQueue could not be pointer to const because it is a typedef. */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="k">static</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="nf">prvIsQueueFull</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>

<span class="w">    </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxLength</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xQueueIsQueueFullFromISR</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span>

<span class="w">    </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxLength</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="cm">/*lint !e818 xQueue could not be pointer to const because it is a typedef. */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_CO_ROUTINES == 1 )</span>

<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xQueueCRSend</span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvItemToQueue</span><span class="p">,</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* If the queue is already full we may have to block.  A critical section</span>
<span class="cm">        is required to prevent an interrupt removing something from the queue</span>
<span class="cm">        between the check to see if the queue is full and blocking on the queue. */</span>
<span class="w">        </span><span class="n">portDISABLE_INTERRUPTS</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">prvIsQueueFull</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* The queue is full - do we want to block or just leave without</span>
<span class="cm">                posting? */</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* As this is called from a coroutine we cannot block directly, but</span>
<span class="cm">                    return indicating that we need to block. */</span>
<span class="w">                    </span><span class="n">vCoRoutineAddToDelayedList</span><span class="p">(</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToSend</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="n">portENABLE_INTERRUPTS</span><span class="p">();</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="n">errQUEUE_BLOCKED</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">portENABLE_INTERRUPTS</span><span class="p">();</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="n">errQUEUE_FULL</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">portENABLE_INTERRUPTS</span><span class="p">();</span>

<span class="w">        </span><span class="n">portDISABLE_INTERRUPTS</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxLength</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* There is room in the queue, copy the data into the queue. */</span>
<span class="w">                </span><span class="n">prvCopyDataToQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="p">,</span><span class="w"> </span><span class="n">pvItemToQueue</span><span class="p">,</span><span class="w"> </span><span class="n">queueSEND_TO_BACK</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdPASS</span><span class="p">;</span>

<span class="w">                </span><span class="cm">/* Were any co-routines waiting for data to become available? */</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_IS_EMPTY</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* In this instance the co-routine could be placed directly</span>
<span class="cm">                    into the ready list as we are within a critical section.</span>
<span class="cm">                    Instead the same pending ready list mechanism is used as if</span>
<span class="cm">                    the event were caused from within an interrupt. */</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xCoRoutineRemoveFromEventList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="cm">/* The co-routine waiting has a higher priority so record</span>
<span class="cm">                        that a yield might be appropriate. */</span>
<span class="w">                        </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">errQUEUE_YIELD</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">errQUEUE_FULL</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">portENABLE_INTERRUPTS</span><span class="p">();</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_CO_ROUTINES */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_CO_ROUTINES == 1 )</span>

<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xQueueCRReceive</span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* If the queue is already empty we may have to block.  A critical section</span>
<span class="cm">        is required to prevent an interrupt adding something to the queue</span>
<span class="cm">        between the check to see if the queue is empty and blocking on the queue. */</span>
<span class="w">        </span><span class="n">portDISABLE_INTERRUPTS</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* There are no messages in the queue, do we want to block or just</span>
<span class="cm">                leave with nothing? */</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* As this is a co-routine we cannot block directly, but return</span>
<span class="cm">                    indicating that we need to block. */</span>
<span class="w">                    </span><span class="n">vCoRoutineAddToDelayedList</span><span class="p">(</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">                    </span><span class="n">portENABLE_INTERRUPTS</span><span class="p">();</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="n">errQUEUE_BLOCKED</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">portENABLE_INTERRUPTS</span><span class="p">();</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="n">errQUEUE_FULL</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">portENABLE_INTERRUPTS</span><span class="p">();</span>

<span class="w">        </span><span class="n">portDISABLE_INTERRUPTS</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Data is available from the queue. */</span>
<span class="w">                </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcReadFrom</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxItemSize</span><span class="p">;</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcReadFrom</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcTail</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcReadFrom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">pcHead</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="o">--</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">memcpy</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pvBuffer</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcReadFrom</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxItemSize</span><span class="w"> </span><span class="p">);</span>

<span class="w">                </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdPASS</span><span class="p">;</span>

<span class="w">                </span><span class="cm">/* Were any co-routines waiting for space to become available? */</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_IS_EMPTY</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToSend</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="cm">/* In this instance the co-routine could be placed directly</span>
<span class="cm">                    into the ready list as we are within a critical section.</span>
<span class="cm">                    Instead the same pending ready list mechanism is used as if</span>
<span class="cm">                    the event were caused from within an interrupt. */</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xCoRoutineRemoveFromEventList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToSend</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">errQUEUE_YIELD</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFAIL</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">portENABLE_INTERRUPTS</span><span class="p">();</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_CO_ROUTINES */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_CO_ROUTINES == 1 )</span>

<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xQueueCRSendFromISR</span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvItemToQueue</span><span class="p">,</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xCoRoutinePreviouslyWoken</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* Cannot block within an ISR so if there is no space on the queue then</span>
<span class="cm">        exit without doing anything. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxLength</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">prvCopyDataToQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="p">,</span><span class="w"> </span><span class="n">pvItemToQueue</span><span class="p">,</span><span class="w"> </span><span class="n">queueSEND_TO_BACK</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="cm">/* We only want to wake one co-routine per ISR, so check that a</span>
<span class="cm">            co-routine has not already been woken. */</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xCoRoutinePreviouslyWoken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_IS_EMPTY</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xCoRoutineRemoveFromEventList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="k">return</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xCoRoutinePreviouslyWoken</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_CO_ROUTINES */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_CO_ROUTINES == 1 )</span>

<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xQueueCRReceiveFromISR</span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxCoRoutineWoken</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* We cannot block from an ISR, so check there is data available. If</span>
<span class="cm">        not then just leave without doing anything. */</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Copy the data from the queue. */</span>
<span class="w">            </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcReadFrom</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxItemSize</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcReadFrom</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcTail</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcReadFrom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">pcHead</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="o">--</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">memcpy</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pvBuffer</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">xQueue</span><span class="p">.</span><span class="n">pcReadFrom</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxItemSize</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="o">*</span><span class="n">pxCoRoutineWoken</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_IS_EMPTY</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToSend</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xCoRoutineRemoveFromEventList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToSend</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="o">*</span><span class="n">pxCoRoutineWoken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdPASS</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFAIL</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_CO_ROUTINES */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configQUEUE_REGISTRY_SIZE &gt; 0 )</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">vQueueAddToRegistry</span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">pcQueueName</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="cm">/*lint !e971 Unqualified char types are allowed for strings and single characters only. */</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">ux</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* See if there is an empty space in the registry.  A NULL name denotes</span>
<span class="cm">        a free slot. */</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="n">ux</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0U</span><span class="p">;</span><span class="w"> </span><span class="n">ux</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">configQUEUE_REGISTRY_SIZE</span><span class="p">;</span><span class="w"> </span><span class="n">ux</span><span class="o">++</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xQueueRegistry</span><span class="p">[</span><span class="w"> </span><span class="n">ux</span><span class="w"> </span><span class="p">].</span><span class="n">pcQueueName</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Store the information on this queue. */</span>
<span class="w">                </span><span class="n">xQueueRegistry</span><span class="p">[</span><span class="w"> </span><span class="n">ux</span><span class="w"> </span><span class="p">].</span><span class="n">pcQueueName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pcQueueName</span><span class="p">;</span>
<span class="w">                </span><span class="n">xQueueRegistry</span><span class="p">[</span><span class="w"> </span><span class="n">ux</span><span class="w"> </span><span class="p">].</span><span class="n">xHandle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span>

<span class="w">                </span><span class="n">traceQUEUE_REGISTRY_ADD</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="n">pcQueueName</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configQUEUE_REGISTRY_SIZE */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configQUEUE_REGISTRY_SIZE &gt; 0 )</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">pcQueueGetName</span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="cm">/*lint !e971 Unqualified char types are allowed for strings and single characters only. */</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">ux</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">pcReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"> </span><span class="cm">/*lint !e971 Unqualified char types are allowed for strings and single characters only. */</span>

<span class="w">        </span><span class="cm">/* Note there is nothing here to protect against another task adding or</span>
<span class="cm">        removing entries from the registry while it is being searched. */</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="n">ux</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0U</span><span class="p">;</span><span class="w"> </span><span class="n">ux</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">configQUEUE_REGISTRY_SIZE</span><span class="p">;</span><span class="w"> </span><span class="n">ux</span><span class="o">++</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xQueueRegistry</span><span class="p">[</span><span class="w"> </span><span class="n">ux</span><span class="w"> </span><span class="p">].</span><span class="n">xHandle</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">pcReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueRegistry</span><span class="p">[</span><span class="w"> </span><span class="n">ux</span><span class="w"> </span><span class="p">].</span><span class="n">pcQueueName</span><span class="p">;</span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">pcReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="cm">/*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */</span>

<span class="cp">#endif </span><span class="cm">/* configQUEUE_REGISTRY_SIZE */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configQUEUE_REGISTRY_SIZE &gt; 0 )</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">vQueueUnregisterQueue</span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">ux</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* See if the handle of the queue being unregistered in actually in the</span>
<span class="cm">        registry. */</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="n">ux</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0U</span><span class="p">;</span><span class="w"> </span><span class="n">ux</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">configQUEUE_REGISTRY_SIZE</span><span class="p">;</span><span class="w"> </span><span class="n">ux</span><span class="o">++</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xQueueRegistry</span><span class="p">[</span><span class="w"> </span><span class="n">ux</span><span class="w"> </span><span class="p">].</span><span class="n">xHandle</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Set the name to NULL to show that this slot if free again. */</span>
<span class="w">                </span><span class="n">xQueueRegistry</span><span class="p">[</span><span class="w"> </span><span class="n">ux</span><span class="w"> </span><span class="p">].</span><span class="n">pcQueueName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">                </span><span class="cm">/* Set the handle to NULL to ensure the same queue handle cannot</span>
<span class="cm">                appear in the registry twice if it is added, removed, then</span>
<span class="cm">                added again. */</span>
<span class="w">                </span><span class="n">xQueueRegistry</span><span class="p">[</span><span class="w"> </span><span class="n">ux</span><span class="w"> </span><span class="p">].</span><span class="n">xHandle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="cm">/*lint !e818 xQueue could not be pointer to const because it is a typedef. */</span>

<span class="cp">#endif </span><span class="cm">/* configQUEUE_REGISTRY_SIZE */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_TIMERS == 1 )</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">vQueueWaitForMessageRestricted</span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xWaitIndefinitely</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* This function should not be called by application code hence the</span>
<span class="cm">        &#39;Restricted&#39; in its name.  It is not part of the public API.  It is</span>
<span class="cm">        designed for use by kernel code, and has special calling requirements.</span>
<span class="cm">        It can result in vListInsert() being called on a list that can only</span>
<span class="cm">        possibly ever have one item in it, so the list will be fast, but even</span>
<span class="cm">        so it should be called with the scheduler locked and not from a critical</span>
<span class="cm">        section. */</span>

<span class="w">        </span><span class="cm">/* Only do anything if there are no messages in the queue.  This function</span>
<span class="cm">        will not actually cause the task to block, just place it on a blocked</span>
<span class="cm">        list.  It will not block until the scheduler is unlocked - at which</span>
<span class="cm">        time a yield will be performed.  If an item is added to the queue while</span>
<span class="cm">        the queue is locked, and the calling task blocks on the queue, then the</span>
<span class="cm">        calling task will be immediately unblocked when the queue is unlocked. */</span>
<span class="w">        </span><span class="n">prvLockQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0U</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* There is nothing in the queue, block for the specified period. */</span>
<span class="w">            </span><span class="n">vTaskPlaceOnEventListRestricted</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="p">,</span><span class="w"> </span><span class="n">xWaitIndefinitely</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">prvUnlockQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_TIMERS */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if( ( configUSE_QUEUE_SETS == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )</span>

<span class="w">    </span><span class="n">QueueSetHandle_t</span><span class="w"> </span><span class="nf">xQueueCreateSet</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxEventQueueLength</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">QueueSetHandle_t</span><span class="w"> </span><span class="n">pxQueue</span><span class="p">;</span>

<span class="w">        </span><span class="n">pxQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueGenericCreate</span><span class="p">(</span><span class="w"> </span><span class="n">uxEventQueueLength</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="n">queueQUEUE_TYPE_SET</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">pxQueue</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_QUEUE_SETS */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_QUEUE_SETS == 1 )</span>

<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xQueueAddToSet</span><span class="p">(</span><span class="w"> </span><span class="n">QueueSetMemberHandle_t</span><span class="w"> </span><span class="n">xQueueOrSemaphore</span><span class="p">,</span><span class="w"> </span><span class="n">QueueSetHandle_t</span><span class="w"> </span><span class="n">xQueueSet</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>

<span class="w">        </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xQueueOrSemaphore</span><span class="w"> </span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pxQueueSetContainer</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Cannot add a queue/semaphore to more than one queue set. */</span>
<span class="w">                </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFAIL</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xQueueOrSemaphore</span><span class="w"> </span><span class="p">)</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Cannot add a queue/semaphore to a queue set if there are already</span>
<span class="cm">                items in the queue/semaphore. */</span>
<span class="w">                </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFAIL</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xQueueOrSemaphore</span><span class="w"> </span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pxQueueSetContainer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueSet</span><span class="p">;</span>
<span class="w">                </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdPASS</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_QUEUE_SETS */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_QUEUE_SETS == 1 )</span>

<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="nf">xQueueRemoveFromSet</span><span class="p">(</span><span class="w"> </span><span class="n">QueueSetMemberHandle_t</span><span class="w"> </span><span class="n">xQueueOrSemaphore</span><span class="p">,</span><span class="w"> </span><span class="n">QueueSetHandle_t</span><span class="w"> </span><span class="n">xQueueSet</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueueOrSemaphore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xQueueOrSemaphore</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueueOrSemaphore</span><span class="o">-&gt;</span><span class="n">pxQueueSetContainer</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">xQueueSet</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* The queue was not a member of the set. */</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFAIL</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueueOrSemaphore</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* It is dangerous to remove a queue from a set when the queue is</span>
<span class="cm">            not empty because the queue set will still hold pending events for</span>
<span class="cm">            the queue. */</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFAIL</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">taskENTER_CRITICAL</span><span class="p">();</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* The queue is no longer contained in the set. */</span>
<span class="w">                </span><span class="n">pxQueueOrSemaphore</span><span class="o">-&gt;</span><span class="n">pxQueueSetContainer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">taskEXIT_CRITICAL</span><span class="p">();</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdPASS</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="cm">/*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_QUEUE_SETS */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_QUEUE_SETS == 1 )</span>

<span class="w">    </span><span class="n">QueueSetMemberHandle_t</span><span class="w"> </span><span class="nf">xQueueSelectFromSet</span><span class="p">(</span><span class="w"> </span><span class="n">QueueSetHandle_t</span><span class="w"> </span><span class="n">xQueueSet</span><span class="p">,</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">QueueSetMemberHandle_t</span><span class="w"> </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">        </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xQueueReceive</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xQueueSet</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xReturn</span><span class="p">,</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e961 Casting from one typedef to another is not redundant. */</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_QUEUE_SETS */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_QUEUE_SETS == 1 )</span>

<span class="w">    </span><span class="n">QueueSetMemberHandle_t</span><span class="w"> </span><span class="nf">xQueueSelectFromSetFromISR</span><span class="p">(</span><span class="w"> </span><span class="n">QueueSetHandle_t</span><span class="w"> </span><span class="n">xQueueSet</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">QueueSetMemberHandle_t</span><span class="w"> </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">        </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xQueueReceiveFromISR</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">xQueueSet</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xReturn</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="cm">/*lint !e961 Casting from one typedef to another is not redundant. */</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_QUEUE_SETS */</span>
<span class="cm">/*-----------------------------------------------------------*/</span>

<span class="cp">#if ( configUSE_QUEUE_SETS == 1 )</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="nf">prvNotifyQueueSetContainer</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pxQueue</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">Queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxQueueSetContainer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueue</span><span class="o">-&gt;</span><span class="n">pxQueueSetContainer</span><span class="p">;</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* This function must be called form a critical section. */</span>

<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueueSetContainer</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueueSetContainer</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">pxQueueSetContainer</span><span class="o">-&gt;</span><span class="n">uxLength</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueueSetContainer</span><span class="o">-&gt;</span><span class="n">uxMessagesWaiting</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">pxQueueSetContainer</span><span class="o">-&gt;</span><span class="n">uxLength</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="kt">int8_t</span><span class="w"> </span><span class="n">cTxLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxQueueSetContainer</span><span class="o">-&gt;</span><span class="n">cTxLock</span><span class="p">;</span>

<span class="w">            </span><span class="n">traceQUEUE_SEND</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueueSetContainer</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="cm">/* The data copied is the handle of the queue that contains data. */</span>
<span class="w">            </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prvCopyDataToQueue</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueueSetContainer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pxQueue</span><span class="p">,</span><span class="w"> </span><span class="n">queueSEND_TO_BACK</span><span class="w"> </span><span class="p">);</span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">cTxLock</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">queueUNLOCKED</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">listLIST_IS_EMPTY</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueueSetContainer</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskRemoveFromEventList</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxQueueSetContainer</span><span class="o">-&gt;</span><span class="n">xTasksWaitingToReceive</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="cm">/* The task waiting has a higher priority. */</span>
<span class="w">                        </span><span class="n">xReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="k">else</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">pxQueueSetContainer</span><span class="o">-&gt;</span><span class="n">cTxLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">int8_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">cTxLock</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">mtCOVERAGE_TEST_MARKER</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">xReturn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* configUSE_QUEUE_SETS */</span>
</code></pre></div>





                
              </article>
            </div>
          
          
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
            Back to top
          </button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright © 2023 RoboticsBrno
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        <div class="md-social">
  
    
    
    
    
      
      
    
    <a href="https://github.com/RoboticsBrno" target="_blank" rel="noopener" title="github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
    </a>
  
    
    
    
    
      
      
    
    <a href="https://twitter.com/RobotikaBrno" target="_blank" rel="noopener" title="twitter.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg>
    </a>
  
    
    
    
    
      
      
    
    <a href="https://www.facebook.com/robotarna" target="_blank" rel="noopener" title="www.facebook.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M504 256C504 119 393 8 256 8S8 119 8 256c0 123.78 90.69 226.38 209.25 245V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.28c-30.8 0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.31 482.38 504 379.78 504 256z"/></svg>
    </a>
  
    
    
    
    
      
      
    
    <a href="https://www.youtube.com/@robotikabrno-robotarnaasps2392" target="_blank" rel="noopener" title="www.youtube.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M549.655 124.083c-6.281-23.65-24.787-42.276-48.284-48.597C458.781 64 288 64 288 64S117.22 64 74.629 75.486c-23.497 6.322-42.003 24.947-48.284 48.597-11.412 42.867-11.412 132.305-11.412 132.305s0 89.438 11.412 132.305c6.281 23.65 24.787 41.5 48.284 47.821C117.22 448 288 448 288 448s170.78 0 213.371-11.486c23.497-6.321 42.003-24.171 48.284-47.821 11.412-42.867 11.412-132.305 11.412-132.305s0-89.438-11.412-132.305zm-317.51 213.508V175.185l142.739 81.205-142.739 81.201z"/></svg>
    </a>
  
    
    
    
    
      
      
    
    <a href="https://www.instagram.com/_robotarna_" target="_blank" rel="noopener" title="www.instagram.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.tabs", "navigation.indexes", "navigation.top"], "search": "../../assets/javascripts/workers/search.208ed371.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.b4d07000.min.js"></script>
      
        <script src="../../assets/js/open_in_new_tab.js"></script>
      
    
  <script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>